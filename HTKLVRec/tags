!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALIGN8	kenlm/lm/binary_format.hh	39;"	d
ALL	kenlm/lm/config.hh	/^  enum ARPALoadComplain {ALL, EXPENSIVE, NONE};$/;"	e	enum:lm::ngram::Config::ARPALoadComplain
ALLOW_HEX	kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_HEX = 1,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALLOW_LEADING_SPACES	kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_LEADING_SPACES = 8,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALLOW_OCTALS	kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_OCTALS = 2,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALLOW_SPACES_AFTER_SIGN	kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_SPACES_AFTER_SIGN = 32$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALLOW_TRAILING_JUNK	kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_TRAILING_JUNK = 4,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALLOW_TRAILING_SPACES	kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_TRAILING_SPACES = 16,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ARPAFormat	kenlm/lm/filter/format.hh	/^struct ARPAFormat {$/;"	s	namespace:lm
ARPAInputException	kenlm/lm/filter/arpa_io.cc	/^ARPAInputException::ARPAInputException(const StringPiece &message) throw() {$/;"	f	class:lm::ARPAInputException
ARPAInputException	kenlm/lm/filter/arpa_io.cc	/^ARPAInputException::ARPAInputException(const StringPiece &message, const StringPiece &line) throw() {$/;"	f	class:lm::ARPAInputException
ARPAInputException	kenlm/lm/filter/arpa_io.hh	/^class ARPAInputException : public util::Exception {$/;"	c	namespace:lm
ARPALoadComplain	kenlm/lm/config.hh	/^  enum ARPALoadComplain {ALL, EXPENSIVE, NONE};$/;"	g	struct:lm::ngram::Config
ARPAOutput	kenlm/lm/filter/arpa_io.cc	/^ARPAOutput::ARPAOutput(const char *name, size_t buffer_size) : file_name_(name), buffer_(new char[buffer_size]) {$/;"	f	class:lm::ARPAOutput
ARPAOutput	kenlm/lm/filter/arpa_io.hh	/^class ARPAOutput : boost::noncopyable {$/;"	c	namespace:lm
ARPAOutputException	kenlm/lm/filter/arpa_io.cc	/^ARPAOutputException::ARPAOutputException(const char *message, const std::string &file_name) throw() {$/;"	f	class:lm::ARPAOutputException
ARPAOutputException	kenlm/lm/filter/arpa_io.hh	/^class ARPAOutputException : public util::ErrnoException {$/;"	c	namespace:lm
ARPAToStream	kenlm/lm/interpolate/arpa_to_stream.cc	/^ARPAToStream::ARPAToStream(int fd, ngram::GrowableVocab<ngram::WriteUniqueWords> &vocab)$/;"	f	class:lm::interpolate::ARPAToStream
ARPAToStream	kenlm/lm/interpolate/arpa_to_stream.hh	/^class ARPAToStream {$/;"	c	namespace:lm::interpolate
ARRAY_ALLOCATED	kenlm/util/mmap.hh	/^    typedef enum {MMAP_ALLOCATED, ARRAY_ALLOCATED, MALLOC_ALLOCATED, NONE_ALLOCATED} Alloc;$/;"	e	enum:util::scoped_memory::__anon41
ARRAY_SIZE	kenlm/util/double-conversion/utils.h	104;"	d
ARRAY_TRIE	kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon20
ARRAY_TRIE_SORTED	kenlm/lm/model_type.hh	/^const ModelType ARRAY_TRIE_SORTED = ARRAY_TRIE;$/;"	m	namespace:lm::ngram
ASSERT	kenlm/util/double-conversion/utils.h	36;"	d
ATTEMPTS_MIN	kenlm/util/file.cc	384;"	d	file:
AccumulateStats	HLVRec-misc.c	/^void AccumulateStats (DecoderInst *dec)$/;"	f
Activate	kenlm/util/stream/multi_progress.cc	/^void MultiProgress::Activate() {$/;"	f	class:util::stream::MultiProgress
ActivateLowerMiddle	kenlm/lm/search_hashed.cc	/^    explicit ActivateLowerMiddle(Middle &middle) : modify_(middle) {}$/;"	f	class:lm::ngram::__anon23::ActivateLowerMiddle
ActivateLowerMiddle	kenlm/lm/search_hashed.cc	/^template <class Middle> class ActivateLowerMiddle {$/;"	c	namespace:lm::ngram::__anon23	file:
ActivateNode	HLVRec.c	/^static LexNodeInst *ActivateNode (DecoderInst *dec, LexNode *ln)$/;"	f	file:
ActivateProgress	kenlm/util/stream/chain.hh	/^    void ActivateProgress() {$/;"	f	class:util::stream::Chain
ActivateUnigram	kenlm/lm/search_hashed.cc	/^    explicit ActivateUnigram(Weights *unigram) : modify_(unigram) {}$/;"	f	class:lm::ngram::__anon23::ActivateUnigram
ActivateUnigram	kenlm/lm/search_hashed.cc	/^template <class Weights> class ActivateUnigram {$/;"	c	namespace:lm::ngram::__anon23	file:
Add	kenlm/lm/builder/adjust_counts.cc	/^    void Add(std::size_t order_minus_1, uint64_t count, bool pruned = false) {$/;"	f	class:lm::builder::__anon8::StatCollector
Add	kenlm/lm/builder/output.hh	/^    void Add(OutputHook *hook) {$/;"	f	class:lm::builder::Output
Add	kenlm/lm/search_trie.cc	/^    void Add(const WordIndex *to, ProbPointer index) {$/;"	f	class:lm::ngram::trie::__anon24::BackoffMessages
Add	kenlm/lm/vocab.cc	/^void WriteWordsWrapper::Add(WordIndex index, const StringPiece &str) {$/;"	f	class:lm::ngram::WriteWordsWrapper
Add	kenlm/util/stream/chain.cc	/^ChainPosition Chain::Add() {$/;"	f	class:util::stream::Chain
Add	kenlm/util/stream/multi_progress.cc	/^WorkerProgress MultiProgress::Add() {$/;"	f	class:util::stream::MultiProgress
AddBignum	kenlm/util/double-conversion/bignum.cc	/^void Bignum::AddBignum(const Bignum& other) {$/;"	f	class:double_conversion::Bignum
AddCharacter	kenlm/util/double-conversion/utils.h	/^  void AddCharacter(char c) {$/;"	f	class:double_conversion::StringBuilder
AddCombiner	kenlm/lm/builder/sort.hh	/^struct AddCombiner {$/;"	s	namespace:lm::builder
AddFull	kenlm/lm/builder/adjust_counts.cc	/^    void AddFull(uint64_t count, bool pruned = false) {$/;"	f	class:lm::builder::__anon8::StatCollector
AddIncoming	kenlm/lm/filter/phrase.cc	/^    void AddIncoming(Arc *arc) {$/;"	f	class:lm::phrase::detail::Vertex	file:
AddLink	HLVNet.c	/^void AddLink (MemHeap *heap, TLexNode *start, TLexNode *end)$/;"	f
AddMonoPron_S	HLVNet.c	/^STLexNode *AddMonoPron_S (MemHeap *heap, STLexNode *root, int n, LabId *p)$/;"	f
AddNGram	kenlm/lm/filter/arpa_io.hh	/^    template <class Iterator> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line) {$/;"	f	class:lm::ARPAOutput
AddNGram	kenlm/lm/filter/arpa_io.hh	/^    void AddNGram(const StringPiece &line) {$/;"	f	class:lm::ARPAOutput
AddNGram	kenlm/lm/filter/arpa_io.hh	/^    void AddNGram(const StringPiece &ngram, const StringPiece &line) {$/;"	f	class:lm::ARPAOutput
AddNGram	kenlm/lm/filter/count_io.hh	/^    template <class Iterator> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line) {$/;"	f	class:lm::CountOutput
AddNGram	kenlm/lm/filter/count_io.hh	/^    void AddNGram(const StringPiece &line) {$/;"	f	class:lm::CountOutput
AddNGram	kenlm/lm/filter/count_io.hh	/^    void AddNGram(const StringPiece &ngram, const StringPiece &line) {$/;"	f	class:lm::CountOutput
AddNGram	kenlm/lm/filter/format.hh	/^    template <class Iterator> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line) {$/;"	f	class:lm::MultipleOutput
AddNGram	kenlm/lm/filter/format.hh	/^    template <class Output> void AddNGram(const StringPiece &ngram, const StringPiece &line, Output &output) {$/;"	f	class:lm::InputBuffer
AddNGram	kenlm/lm/filter/format.hh	/^    void AddNGram(const StringPiece &line) {$/;"	f	class:lm::BinaryOutputBuffer
AddNGram	kenlm/lm/filter/format.hh	/^    void AddNGram(const StringPiece &line) {$/;"	f	class:lm::MultipleOutput
AddNGram	kenlm/lm/filter/format.hh	/^    void AddNGram(const StringPiece &line) {$/;"	f	class:lm::MultipleOutputBuffer
AddNGram	kenlm/lm/filter/format.hh	/^    void AddNGram(const StringPiece &ngram, const StringPiece &line) {$/;"	f	class:lm::DispatchInput
AddNGram	kenlm/lm/filter/phrase.hh	/^    template <class Iterator, class Output> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line, Output &output) {$/;"	f	class:lm::phrase::Multiple
AddNGram	kenlm/lm/filter/phrase.hh	/^    template <class Output> void AddNGram(const StringPiece &ngram, const StringPiece &line, Output &output) {$/;"	f	class:lm::phrase::Multiple
AddNGram	kenlm/lm/filter/thread.hh	/^    void AddNGram(const StringPiece &ngram, const StringPiece &line, RealOutput &output) {$/;"	f	class:lm::Controller
AddNGram	kenlm/lm/filter/vocab.hh	/^    template <class Iterator, class Output> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line, Output &output) {$/;"	f	class:lm::vocab::Multiple
AddNGram	kenlm/lm/filter/vocab.hh	/^    template <class Output> void AddNGram(const StringPiece &ngram, const StringPiece &line, Output &output) {$/;"	f	class:lm::vocab::Multiple
AddNGram	kenlm/lm/filter/wrapper.hh	/^    template <class Iterator, class Output> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line, Output &output) {$/;"	f	class:lm::BinaryFilter
AddNGram	kenlm/lm/filter/wrapper.hh	/^    template <class Output> void AddNGram(const StringPiece &ngram, const StringPiece &line, Output &output) {$/;"	f	class:lm::BinaryFilter
AddNGram	kenlm/lm/filter/wrapper.hh	/^    template <class Output> void AddNGram(const StringPiece &ngram, const StringPiece &line, Output &output) {$/;"	f	class:lm::ContextFilter
AddPadding	kenlm/util/double-conversion/utils.h	/^  void AddPadding(char c, int count) {$/;"	f	class:double_conversion::StringBuilder
AddPhrase	kenlm/lm/filter/phrase.hh	/^    template <class Iterator> void AddPhrase(unsigned int sentence_id, const Iterator &begin, const Iterator &end) {$/;"	f	class:lm::phrase::Substrings
AddPronProbs	HLVRec-propagate.c	/^static void AddPronProbs (DecoderInst *dec, TokenSet *ts, int var)$/;"	f	file:
AddRight	kenlm/lm/builder/initial_probabilities.cc	/^    AddRight(const Discount &discount, const util::stream::ChainPosition &input, bool pruning)$/;"	f	class:lm::builder::__anon11::AddRight
AddRight	kenlm/lm/builder/initial_probabilities.cc	/^class AddRight {$/;"	c	namespace:lm::builder::__anon11	file:
AddSTLexLink	HLVNet.c	/^STLexLink *AddSTLexLink (MemHeap *heap, STLexNode *start, STLexNode *end)$/;"	f
AddString	kenlm/util/double-conversion/utils.h	/^  void AddString(const char* s) {$/;"	f	class:double_conversion::StringBuilder
AddSubstring	kenlm/util/double-conversion/utils.h	/^  void AddSubstring(const char* s, int n) {$/;"	f	class:double_conversion::StringBuilder
AddUInt64	kenlm/util/double-conversion/bignum.cc	/^void Bignum::AddUInt64(uint64_t operand) {$/;"	f	class:double_conversion::Bignum
AddUnigramWord	kenlm/lm/builder/corpus_count.cc	/^    void AddUnigramWord(WordIndex index) {$/;"	f	class:lm::builder::__anon9::Writer	file:
AdjustCounts	kenlm/lm/builder/adjust_counts.hh	/^    AdjustCounts($/;"	f	class:lm::builder::AdjustCounts
AdjustCounts	kenlm/lm/builder/adjust_counts.hh	/^class AdjustCounts {$/;"	c	namespace:lm::builder
AdjustLower	kenlm/lm/search_hashed.cc	/^template <class Added, class Build> void AdjustLower($/;"	f	namespace:lm::ngram::__anon23
AdjustmentPowerOfTen	kenlm/util/double-conversion/strtod.cc	/^static DiyFp AdjustmentPowerOfTen(int exponent) {$/;"	f	namespace:double_conversion
AdvanceOrThrow	kenlm/util/file.cc	/^void AdvanceOrThrow(int fd, int64_t off) {$/;"	f	namespace:util
AdvanceToNonspace	kenlm/util/double-conversion/double-conversion.cc	/^static inline bool AdvanceToNonspace(const char** current, const char* end) {$/;"	f	namespace:double_conversion
Align	kenlm/util/double-conversion/bignum.cc	/^void Bignum::Align(const Bignum& other) {$/;"	f	class:double_conversion::Bignum
AlignTo8	kenlm/lm/bhiksha.cc	/^void *AlignTo8(void *from) {$/;"	f	namespace:lm::ngram::trie::__anon6
AllIntersection	kenlm/util/multi_intersection.hh	/^template <class Iterator, class Output, class Less> void AllIntersection(std::vector<boost::iterator_range<Iterator> > &sets, Output &out, const Less less) {$/;"	f	namespace:util
AllIntersection	kenlm/util/multi_intersection.hh	/^template <class Iterator, class Output> void AllIntersection(std::vector<boost::iterator_range<Iterator> > &sets, Output &out) {$/;"	f	namespace:util
Alloc	kenlm/util/mmap.hh	/^    typedef enum {MMAP_ALLOCATED, ARRAY_ALLOCATED, MALLOC_ALLOCATED, NONE_ALLOCATED} Alloc;$/;"	t	class:util::scoped_memory	typeref:enum:util::scoped_memory::__anon41
AllocLMNodeCache	HLVRec-LM.c	/^LMNodeCache* AllocLMNodeCache (LMCache *cache, int lmlaIdx)$/;"	f
Allocate	kenlm/util/pool.hh	/^    void *Allocate(std::size_t size) {$/;"	f	class:util::Pool
AltPathList2Path	HLVRec-traceback.c	/^WordendHyp *AltPathList2Path (DecoderInst *dec, AltWordendHyp *alt, PronId pron)$/;"	f
AltWordendHyp	HLVRec.h	/^typedef struct _AltWordendHyp AltWordendHyp;\/* records alternatives for lattice tracback *\/$/;"	t	typeref:struct:_AltWordendHyp
AnalyseSearchSpace	HDecode.c	/^void AnalyseSearchSpace (DecoderInst *dec, BestInfo *bestInfo)$/;"	f
AnalyseSearchSpace	HDecode.mod.c	/^void AnalyseSearchSpace (DecoderInst *dec, BestInfo *bestInfo)$/;"	f
Annotated	kenlm/lm/filter/format.hh	/^    struct Annotated {$/;"	s	class:lm::MultipleOutputBuffer
AnyCharacter	kenlm/util/tokenize_piece.hh	/^    AnyCharacter() {}$/;"	f	class:util::AnyCharacter
AnyCharacter	kenlm/util/tokenize_piece.hh	/^    explicit AnyCharacter(const StringPiece &chars) : chars_(chars) {}$/;"	f	class:util::AnyCharacter
AnyCharacter	kenlm/util/tokenize_piece.hh	/^class AnyCharacter {$/;"	c	namespace:util
AnyCharacterLast	kenlm/util/tokenize_piece.hh	/^    AnyCharacterLast() {}$/;"	f	class:util::AnyCharacterLast
AnyCharacterLast	kenlm/util/tokenize_piece.hh	/^    explicit AnyCharacterLast(const StringPiece &chars) : chars_(chars) {}$/;"	f	class:util::AnyCharacterLast
AnyCharacterLast	kenlm/util/tokenize_piece.hh	/^class AnyCharacterLast {$/;"	c	namespace:util
Append	kenlm/lm/builder/corpus_count.cc	/^    void Append(WordIndex word) {$/;"	f	class:lm::builder::__anon9::Writer
Append	kenlm/util/stream/sort.hh	/^    void Append(uint64_t length) {$/;"	f	class:util::stream::Offsets
AppendSentence	kenlm/lm/filter/phrase.hh	/^    void AppendSentence(std::vector<unsigned int> &vec, unsigned int sentence_id) {$/;"	f	class:lm::phrase::Substrings
Apply	kenlm/lm/builder/discount.hh	/^  float Apply(uint64_t count) const {$/;"	f	struct:lm::builder::Discount
Apply	kenlm/lm/builder/output.cc	/^void OutputHook::Apply(util::stream::Chains &chains) {$/;"	f	class:lm::builder::OutputHook
Apply	kenlm/lm/builder/output.hh	/^    void Apply(HookType hook_type, util::stream::Chains &chains) {$/;"	f	class:lm::builder::Output
Apply	kenlm/lm/search_trie.cc	/^    void Apply(float *const *const base, FILE *unigrams) {$/;"	f	class:lm::ngram::trie::__anon24::BackoffMessages
Apply	kenlm/lm/search_trie.cc	/^    void Apply(float *const *const base, RecordReader &reader) {$/;"	f	class:lm::ngram::trie::__anon24::BackoffMessages
ApplyBuild	kenlm/lm/search_hashed.cc	/^template <class Value> template <class Build> void HashedSearch<Value>::ApplyBuild(util::FilePiece &f, const std::vector<uint64_t> &counts, const ProbingVocabulary &vocab, PositiveProbWarn &warn, const Build &build) {$/;"	f	class:lm::ngram::detail::HashedSearch
Arc	kenlm/lm/filter/phrase.cc	/^    Arc() {}$/;"	f	class:lm::phrase::detail::Arc
Arc	kenlm/lm/filter/phrase.cc	/^class Arc {$/;"	c	namespace:lm::phrase::detail	file:
ArcGreater	kenlm/lm/filter/phrase.cc	/^struct ArcGreater : public std::binary_function<const Arc *, const Arc *, bool> {$/;"	s	namespace:lm::phrase::detail	file:
ArrayBhiksha	kenlm/lm/bhiksha.cc	/^ArrayBhiksha::ArrayBhiksha(void *base, uint64_t max_offset, uint64_t max_next, const Config &config)$/;"	f	class:lm::ngram::trie::ArrayBhiksha
ArrayBhiksha	kenlm/lm/bhiksha.hh	/^class ArrayBhiksha {$/;"	c	namespace:lm::ngram::trie
ArrayCount	kenlm/lm/bhiksha.cc	/^std::size_t ArrayCount(uint64_t max_offset, uint64_t max_next, const Config &config) {$/;"	f	namespace:lm::ngram::trie::__anon5
AsDiyFp	kenlm/util/double-conversion/ieee.h	/^  DiyFp AsDiyFp() const {$/;"	f	class:double_conversion::Double
AsDiyFp	kenlm/util/double-conversion/ieee.h	/^  DiyFp AsDiyFp() const {$/;"	f	class:double_conversion::Single
AsNormalizedDiyFp	kenlm/util/double-conversion/ieee.h	/^  DiyFp AsNormalizedDiyFp() const {$/;"	f	class:double_conversion::Double
AsUint32	kenlm/util/double-conversion/ieee.h	/^  uint32_t AsUint32() const {$/;"	f	class:double_conversion::Single
AsUint64	kenlm/util/double-conversion/ieee.h	/^  uint64_t AsUint64() const {$/;"	f	class:double_conversion::Double
AssignBignum	kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignBignum(const Bignum& other) {$/;"	f	class:double_conversion::Bignum
AssignDecimalString	kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignDecimalString(Vector<const char> value) {$/;"	f	class:double_conversion::Bignum
AssignHexString	kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignHexString(Vector<const char> value) {$/;"	f	class:double_conversion::Bignum
AssignPowerUInt16	kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignPowerUInt16(uint16_t base, int power_exponent) {$/;"	f	class:double_conversion::Bignum
AssignUInt16	kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignUInt16(uint16_t value) {$/;"	f	class:double_conversion::Bignum
AssignUInt64	kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignUInt64(uint64_t value) {$/;"	f	class:double_conversion::Bignum
AssignWEIds	HLVNet.c	/^void AssignWEIds(TLexNet *tnet)$/;"	f
AutoProbing	kenlm/util/probing_hash_table.hh	/^    AutoProbing(std::size_t initial_size = 10, const Key &invalid = Key(), const Hash &hash_func = Hash(), const Equal &equal_func = Equal()) :$/;"	f	class:util::AutoProbing
AutoProbing	kenlm/util/probing_hash_table.hh	/^template <class EntryT, class HashT, class EqualT = std::equal_to<typename EntryT::Key> > class AutoProbing {$/;"	c	namespace:util
B	kenlm/lm/filter/format.hh	/^    typedef DispatchInput<Filter, Output> B;$/;"	t	class:lm::DispatchARPAInput
BAddSearch	HLVNet.c	/^static int BAddSearch (Ptr elem, int *np, Ptr **ap)$/;"	f	file:
BIGNUM_DTOA_FIXED	kenlm/util/double-conversion/bignum-dtoa.h	/^  BIGNUM_DTOA_FIXED,$/;"	e	enum:double_conversion::BignumDtoaMode
BIGNUM_DTOA_PRECISION	kenlm/util/double-conversion/bignum-dtoa.h	/^  BIGNUM_DTOA_PRECISION$/;"	e	enum:double_conversion::BignumDtoaMode
BIGNUM_DTOA_SHORTEST	kenlm/util/double-conversion/bignum-dtoa.h	/^  BIGNUM_DTOA_SHORTEST,$/;"	e	enum:double_conversion::BignumDtoaMode
BIGNUM_DTOA_SHORTEST_SINGLE	kenlm/util/double-conversion/bignum-dtoa.h	/^  BIGNUM_DTOA_SHORTEST_SINGLE,$/;"	e	enum:double_conversion::BignumDtoaMode
BIN_ARPA_HAS_BOWT	HLVLM.h	172;"	d
BIN_ARPA_INT_LMID	HLVLM.h	173;"	d
BOOST_LEXICAL_CAST_ASSUME_C_LOCALE	kenlm/util/fake_ofstream.hh	14;"	d
BSearch	HLVNet.c	/^static int BSearch (Ptr elem, int n, Ptr *array)$/;"	f	file:
BUFLEN	HLVNet.c	274;"	d	file:
BZException	kenlm/util/read_compressed.cc	/^BZException::BZException() throw() {}$/;"	f	class:util::BZException
BZException	kenlm/util/read_compressed.hh	/^class BZException : public CompressedException {$/;"	c	namespace:util
BZip	kenlm/util/read_compressed.cc	/^    BZip(const void *base, std::size_t amount) {$/;"	f	class:util::__anon45::BZip
BZip	kenlm/util/read_compressed.cc	/^class BZip {$/;"	c	namespace:util::__anon45	file:
Backend	kenlm/util/probing_hash_table.hh	/^    typedef ProbingHashTable<EntryT, HashT, EqualT> Backend;$/;"	t	class:util::AutoProbing
Backoff	kenlm/lm/quantize.hh	/^        float Backoff() const {$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
Backoff	kenlm/lm/quantize.hh	/^        float Backoff() const {$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
Backoff	kenlm/lm/trie.hh	/^    float Backoff() const { return to_->backoff; }$/;"	f	class:lm::ngram::trie::UnigramPointer
Backoff	kenlm/lm/value.hh	/^    float Backoff() const { return to_->backoff; }$/;"	f	class:lm::ngram::GenericProbingProxy
Backoff	kenlm/lm/value.hh	/^    float Backoff() const { return to_->backoff; }$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
BackoffBins	kenlm/lm/quantize.hh	/^        const Bins &BackoffBins() const { return bins_[1]; }$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
BackoffMessages	kenlm/lm/search_trie.cc	/^class BackoffMessages {$/;"	c	namespace:lm::ngram::trie::__anon24	file:
BackoffValue	kenlm/lm/value.hh	/^struct BackoffValue {$/;"	s	namespace:lm::ngram
BadDiscountException	kenlm/lm/builder/adjust_counts.cc	/^BadDiscountException::BadDiscountException() throw() {}$/;"	f	class:lm::builder::BadDiscountException
BadDiscountException	kenlm/lm/builder/adjust_counts.hh	/^class BadDiscountException : public util::Exception {$/;"	c	namespace:lm::builder
BadSortConfig	kenlm/util/stream/sort.hh	/^    BadSortConfig() throw() {}$/;"	f	class:util::stream::BadSortConfig
BadSortConfig	kenlm/util/stream/sort.hh	/^class BadSortConfig : public Exception {$/;"	c	namespace:util::stream
Base	kenlm/lm/builder/ngram.hh	/^    const uint8_t *Base() const { return reinterpret_cast<const uint8_t*>(begin_); }$/;"	f	class:lm::builder::NGram
Base	kenlm/lm/builder/ngram.hh	/^    uint8_t *Base() { return reinterpret_cast<uint8_t*>(begin_); }$/;"	f	class:lm::builder::NGram
BaseFullScore	kenlm/lm/facade.hh	/^    FullScoreReturn BaseFullScore(const void *in_state, const WordIndex new_word, void *out_state) const {$/;"	f	class:lm::base::ModelFacade
BaseFullScoreForgotState	kenlm/lm/facade.hh	/^    FullScoreReturn BaseFullScoreForgotState(const WordIndex *context_rbegin, const WordIndex *context_rend, const WordIndex new_word, void *out_state) const {$/;"	f	class:lm::base::ModelFacade
BaseInit	kenlm/lm/trie.cc	/^void BitPacked::BaseInit(void *base, uint64_t max_vocab, uint8_t remaining_bits) {$/;"	f	class:lm::ngram::trie::BitPacked
BaseScore	kenlm/lm/facade.hh	/^    float BaseScore(const void *in_state, const WordIndex new_word, void *out_state) const {$/;"	f	class:lm::base::ModelFacade
BaseSize	kenlm/lm/trie.cc	/^uint64_t BitPacked::BaseSize(uint64_t entries, uint64_t max_vocab, uint8_t remaining_bits) {$/;"	f	class:lm::ngram::trie::BitPacked
BaseVocabulary	kenlm/lm/virtual_interface.hh	/^    const Vocabulary &BaseVocabulary() const { return *base_vocab_; }$/;"	f	class:lm::base::Model
BaseVocabulary_pointer	kenlm/lm/virtual_interface.hh	/^    const Vocabulary* BaseVocabulary_pointer() const { return  base_vocab_; }$/;"	f	class:lm::base::Model
BasicPrint	kenlm/lm/ngram_query.hh	/^struct BasicPrint {$/;"	s	namespace:lm::ngram
Batch	kenlm/lm/filter/thread.hh	/^    typedef ThreadBatch<OutputBuffer> Batch;$/;"	t	class:lm::Controller
BeginLength	kenlm/lm/filter/arpa_io.cc	/^void ARPAOutput::BeginLength(unsigned int length) {$/;"	f	class:lm::ARPAOutput
BeginLength	kenlm/lm/filter/format.hh	/^    void BeginLength(unsigned int length) { B::output_.BeginLength(length); }$/;"	f	class:lm::DispatchARPAInput
BeginLength	kenlm/lm/filter/format.hh	/^    void BeginLength(unsigned int length) {$/;"	f	class:lm::MultipleARPAOutput
BeginNonTerminal	kenlm/lm/left.hh	/^    void BeginNonTerminal(const ChartState &in, float prob = 0.0) {$/;"	f	class:lm::ngram::RuleScore
BeginSentence	kenlm/lm/left.hh	/^    void BeginSentence() {$/;"	f	class:lm::ngram::RuleScore
BeginSentence	kenlm/lm/virtual_interface.hh	/^    WordIndex BeginSentence() const { return begin_sentence_; }$/;"	f	class:lm::base::Vocabulary
BeginSentenceMemory	kenlm/lm/virtual_interface.hh	/^    const void *BeginSentenceMemory() const { return begin_sentence_memory_; }$/;"	f	class:lm::base::Model
BeginSentenceState	kenlm/lm/facade.hh	/^    const State &BeginSentenceState() const { return begin_sentence_; }$/;"	f	class:lm::base::ModelFacade
BeginSentenceWrite	kenlm/lm/virtual_interface.hh	/^    void BeginSentenceWrite(void *to) const { memcpy(to, begin_sentence_memory_, StateSize()); }$/;"	f	class:lm::base::Model
BestInfo	HDecode.c	/^typedef struct _BestInfo BestInfo;$/;"	t	typeref:struct:_BestInfo	file:
BestInfo	HDecode.mod.c	/^typedef struct _BestInfo BestInfo;$/;"	t	typeref:struct:_BestInfo	file:
BestTokSet	HLVRec-traceback.c	/^TokenSet *BestTokSet (DecoderInst *dec)$/;"	f
BiggestPowerTen	kenlm/util/double-conversion/fast-dtoa.cc	/^static void BiggestPowerTen(uint32_t number,$/;"	f	namespace:double_conversion
BigitAt	kenlm/util/double-conversion/bignum.cc	/^Bignum::Chunk Bignum::BigitAt(int index) const {$/;"	f	class:double_conversion::Bignum
BigitLength	kenlm/util/double-conversion/bignum.h	/^  int BigitLength() const { return used_digits_ + exponent_; }$/;"	f	class:double_conversion::Bignum
BigitsShiftLeft	kenlm/util/double-conversion/bignum.cc	/^void Bignum::BigitsShiftLeft(int shift_amount) {$/;"	f	class:double_conversion::Bignum
Bignum	kenlm/util/double-conversion/bignum.cc	/^Bignum::Bignum()$/;"	f	class:double_conversion::Bignum
Bignum	kenlm/util/double-conversion/bignum.h	/^class Bignum {$/;"	c	namespace:double_conversion
BignumDtoa	kenlm/util/double-conversion/bignum-dtoa.cc	/^void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,$/;"	f	namespace:double_conversion
BignumDtoaMode	kenlm/util/double-conversion/bignum-dtoa.h	/^enum BignumDtoaMode {$/;"	g	namespace:double_conversion
BignumToFixed	kenlm/util/double-conversion/bignum-dtoa.cc	/^static void BignumToFixed(int requested_digits, int* decimal_point,$/;"	f	namespace:double_conversion
BinaryFilter	kenlm/lm/filter/wrapper.hh	/^    explicit BinaryFilter(Binary binary) : binary_(binary) {}$/;"	f	class:lm::BinaryFilter
BinaryFilter	kenlm/lm/filter/wrapper.hh	/^template <class Binary> class BinaryFilter {$/;"	c	namespace:lm
BinaryFind	kenlm/util/sorted_uniform.hh	/^template <class Iterator, class Accessor> bool BinaryFind($/;"	f	namespace:util
BinaryFormat	kenlm/lm/binary_format.cc	/^BinaryFormat::BinaryFormat(const Config &config) $/;"	f	class:lm::ngram::BinaryFormat
BinaryFormat	kenlm/lm/binary_format.hh	/^class BinaryFormat {$/;"	c	namespace:lm::ngram
BinaryOutputBuffer	kenlm/lm/filter/format.hh	/^    BinaryOutputBuffer() {}$/;"	f	class:lm::BinaryOutputBuffer
BinaryOutputBuffer	kenlm/lm/filter/format.hh	/^class BinaryOutputBuffer {$/;"	c	namespace:lm
Bins	kenlm/lm/quantize.hh	/^        Bins() {}$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
Bins	kenlm/lm/quantize.hh	/^        Bins(uint8_t bits, float *begin) : begin_(begin), end_(begin_ + (1ULL << bits)), bits_(bits), mask_((1ULL << bits) - 1) {}$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
Bins	kenlm/lm/quantize.hh	/^    class Bins {$/;"	c	class:lm::ngram::SeparatelyQuantize
BitAddress	kenlm/util/bit_packing.hh	/^  BitAddress(void *in_base, uint64_t in_offset) : base(in_base), offset(in_offset) {}$/;"	f	struct:util::BitAddress
BitAddress	kenlm/util/bit_packing.hh	/^struct BitAddress {$/;"	s	namespace:util
BitAt	kenlm/util/double-conversion/fixed-dtoa.cc	/^  int BitAt(int position) {$/;"	f	class:double_conversion::UInt128
BitCast	kenlm/util/double-conversion/utils.h	/^inline Dest BitCast(Source* source) {$/;"	f	namespace:double_conversion
BitCast	kenlm/util/double-conversion/utils.h	/^inline Dest BitCast(const Source& source) {$/;"	f	namespace:double_conversion
BitPackShift	kenlm/util/bit_packing.hh	/^inline uint8_t BitPackShift(uint8_t bit, uint8_t \/*length*\/) {$/;"	f	namespace:util
BitPacked	kenlm/lm/trie.hh	/^    BitPacked() {}$/;"	f	class:lm::ngram::trie::BitPacked
BitPacked	kenlm/lm/trie.hh	/^class BitPacked {$/;"	c	namespace:lm::ngram::trie
BitPackedLongest	kenlm/lm/trie.hh	/^    BitPackedLongest() {}$/;"	f	class:lm::ngram::trie::BitPackedLongest
BitPackedLongest	kenlm/lm/trie.hh	/^class BitPackedLongest : public BitPacked {$/;"	c	namespace:lm::ngram::trie
BitPackedMiddle	kenlm/lm/trie.cc	/^template <class Bhiksha> BitPackedMiddle<Bhiksha>::BitPackedMiddle(void *base, uint8_t quant_bits, uint64_t entries, uint64_t max_vocab, uint64_t max_next, const BitPacked &next_source, const Config &config) :$/;"	f	class:lm::ngram::trie::BitPackedMiddle
BitPackedMiddle	kenlm/lm/trie.hh	/^template <class Bhiksha> class BitPackedMiddle : public BitPacked {$/;"	c	namespace:lm::ngram::trie
BitPackingSanity	kenlm/util/bit_packing.cc	/^void BitPackingSanity() {$/;"	f	namespace:util
BitSize	kenlm/util/double-conversion/bignum.cc	/^static int BitSize(S value) {$/;"	f	namespace:double_conversion
Bits	kenlm/lm/quantize.hh	/^        uint8_t Bits() const { return bits_; }$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
BitsMask	kenlm/util/bit_packing.hh	/^struct BitsMask {$/;"	s	namespace:util
BlankManager	kenlm/lm/search_trie.cc	/^    BlankManager(unsigned char total_order, Doing &doing) : total_order_(total_order), been_length_(0), doing_(doing) {$/;"	f	class:lm::ngram::trie::__anon24::BlankManager
BlankManager	kenlm/lm/search_trie.cc	/^template <class Doing> class BlankManager {$/;"	c	namespace:lm::ngram::trie::__anon24	file:
Block	kenlm/util/stream/block.hh	/^    Block() : mem_(NULL), valid_size_(0) {}$/;"	f	class:util::stream::Block
Block	kenlm/util/stream/block.hh	/^    Block(void *mem, std::size_t size) : mem_(mem), valid_size_(size) {}$/;"	f	class:util::stream::Block
Block	kenlm/util/stream/block.hh	/^class Block {$/;"	c	namespace:util::stream
BlockSize	kenlm/util/stream/chain.hh	/^    std::size_t BlockSize() const {$/;"	f	class:util::stream::Chain
BlockSorter	kenlm/util/stream/sort.hh	/^    BlockSorter(Offsets &offsets, const Compare &compare) :$/;"	f	class:util::stream::BlockSorter
BlockSorter	kenlm/util/stream/sort.hh	/^template <class Compare> class BlockSorter {$/;"	c	namespace:util::stream
BlockingSort	kenlm/util/stream/sort.hh	/^template <class Compare, class Combine> uint64_t BlockingSort(Chain &chain, const SortConfig &config, const Compare &compare = Compare(), const Combine &combine = NeverCombine()) {$/;"	f	namespace:util::stream
BoolCharacter	kenlm/util/tokenize_piece.hh	/^    BoolCharacter() {}$/;"	f	class:util::BoolCharacter
BoolCharacter	kenlm/util/tokenize_piece.hh	/^    explicit BoolCharacter(const bool *delimiter) { delimiter_ = delimiter; }$/;"	f	class:util::BoolCharacter
BoolCharacter	kenlm/util/tokenize_piece.hh	/^class BoolCharacter {$/;"	c	namespace:util
Bound	kenlm/lm/vocab.hh	/^    WordIndex Bound() const { return bound_; }$/;"	f	class:lm::ngram::ProbingVocabulary
Bound	kenlm/lm/vocab.hh	/^    WordIndex Bound() const { return bound_; }$/;"	f	class:lm::ngram::SortedVocabulary
BoundedSortedUniformFind	kenlm/util/sorted_uniform.hh	/^template <class Iterator, class Accessor, class Pivot> bool BoundedSortedUniformFind($/;"	f	namespace:util
Buffer	kenlm/lm/vocab.hh	/^    const std::string &Buffer() const { return buffer_; }$/;"	f	class:lm::ngram::WriteWordsWrapper
BufferEntry	kenlm/lm/builder/initial_probabilities.cc	/^struct BufferEntry {$/;"	s	namespace:lm::builder::__anon11	file:
BufferFinal	kenlm/lm/builder/pipeline.cc	/^    void BufferFinal(const std::vector<uint64_t> &counts) {$/;"	f	class:lm::builder::__anon13::Master
Build	kenlm/util/tokenize_piece.hh	/^    template <unsigned Length> static void Build(const char (&characters)[Length], bool (&out)[256]) {$/;"	f	class:util::BoolCharacter
BuildForceLat	HLVRec-traceback.c	/^WordendHyp *BuildForceLat (DecoderInst *dec)$/;"	f
BuildGraph	kenlm/lm/filter/phrase.cc	/^void BuildGraph(const Substrings &phrase, const std::vector<Hash> &hashes, detail::Vertex *const vertices, detail::Arc *free_arc) {$/;"	f	namespace:lm::phrase::__anon15
BuildLatAltList	HLVRec-traceback.c	/^AltWordendHyp *BuildLatAltList (DecoderInst *dec, TokenSet *ts, Boolean useLM)$/;"	f
BuildLattice	HLVRec-traceback.c	/^WordendHyp *BuildLattice (DecoderInst *dec)$/;"	f
BuildLookupTable	kenlm/util/string_piece.cc	/^static inline void BuildLookupTable(const StringPiece& characters_wanted,$/;"	f	file:
BuildTrie	kenlm/lm/search_trie.cc	/^template <class Quant, class Bhiksha> void BuildTrie(SortedFiles &files, std::vector<uint64_t> &counts, const Config &config, TrieSearch<Quant, Bhiksha> &out, Quant &quant, SortedVocabulary &vocab, BinaryFormat &backing) {$/;"	f	namespace:lm::ngram::trie
ByBits	kenlm/util/bit_packing.hh	/^  static BitsMask ByBits(uint8_t bits) {$/;"	f	struct:util::BitsMask
ByMax	kenlm/util/bit_packing.hh	/^  static BitsMask ByMax(uint64_t max_value) {$/;"	f	struct:util::BitsMask
CC	Makefile	/^CC      = 	g++$/;"	m
CFLAGS	Makefile	/^CFLAGS  := 	-DKENLM_MAX_ORDER=6 -D__cplusplus -DNO_LAT_LM -lrt -m32 -ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH="x86_64"' -Wall -Wno-switch -g -O2  -I.\/kenlm -I$(inc)$/;"	m
COLLECT_STATS	config.h	31;"	d
COLLECT_STATS_ACTIVATION	config.h	32;"	d
COMPLAIN	kenlm/lm/lm_exception.hh	/^typedef enum {THROW_UP, COMPLAIN, SILENT} WarningAction;$/;"	e	enum:lm::__anon17
COUNT_HOOK	kenlm/lm/builder/output.hh	/^  COUNT_HOOK, \/\/ Raw N-gram counts, highest order only.$/;"	e	enum:lm::builder::HookType
CachedPower	kenlm/util/double-conversion/cached-powers.cc	/^struct CachedPower {$/;"	s	namespace:double_conversion	file:
Calc	kenlm/util/sorted_uniform.hh	/^  static inline std::size_t Calc(uint64_t off, uint64_t range, std::size_t width) {$/;"	f	struct:util::Pivot64
Calc	kenlm/util/sorted_uniform.hh	/^  static inline std::size_t Calc(uint64_t off, uint64_t range, uint64_t width) {$/;"	f	struct:util::Pivot32
CalcPhonePost	HLVRec-misc.c	/^void CalcPhonePost (DecoderInst *dec)$/;"	f
CalculateDiscounts	kenlm/lm/builder/adjust_counts.cc	/^    void CalculateDiscounts(const DiscountConfig &config) {$/;"	f	class:lm::builder::__anon8::StatCollector
CallFilter	kenlm/lm/filter/format.hh	/^    template <class Filter, class Output> void CallFilter(Filter &filter, Output &output) const {$/;"	f	class:lm::InputBuffer
CallFilter	kenlm/lm/filter/thread.hh	/^    template <class Filter> void CallFilter(Filter &filter) {$/;"	f	class:lm::ThreadBatch
Callback	kenlm/lm/builder/interpolate.cc	/^    Callback(float uniform_prob, const util::stream::ChainPositions &backoffs, const std::vector<uint64_t> &prune_thresholds, bool prune_vocab)$/;"	f	class:lm::builder::__anon12::Callback
Callback	kenlm/lm/builder/interpolate.cc	/^template <class Output> class Callback {$/;"	c	namespace:lm::builder::__anon12	file:
Callback	kenlm/lm/filter/vocab.hh	/^        Callback(Output &out, const StringPiece &line) : out_(out), line_(line) {}$/;"	f	class:lm::vocab::Multiple::Callback
Callback	kenlm/lm/filter/vocab.hh	/^    template <class Output> class Callback {$/;"	c	class:lm::vocab::Multiple
Callback	kenlm/lm/value.hh	/^  template <class Model, class C> void Callback(const Config &, unsigned int, typename Model::Vocabulary &, C &callback) {$/;"	f	struct:lm::ngram::BackoffValue
Callback	kenlm/lm/value.hh	/^  template <class Model, class C> void Callback(const Config &config, unsigned int order, typename Model::Vocabulary &vocab, C &callback) {$/;"	f	struct:lm::ngram::RestValue
CallocOrThrow	kenlm/util/scoped.cc	/^void *CallocOrThrow(std::size_t requested) {$/;"	f	namespace:util
Chain	kenlm/util/stream/chain.cc	/^Chain::Chain(const ChainConfig &config) : config_(config), complete_called_(false) {$/;"	f	class:util::stream::Chain
Chain	kenlm/util/stream/chain.hh	/^class Chain {$/;"	c	namespace:util::stream
ChainConfig	kenlm/util/stream/config.hh	/^  ChainConfig() {}$/;"	f	struct:util::stream::ChainConfig
ChainConfig	kenlm/util/stream/config.hh	/^  ChainConfig(std::size_t in_entry_size, std::size_t in_block_count, std::size_t in_total_memory)$/;"	f	struct:util::stream::ChainConfig
ChainConfig	kenlm/util/stream/config.hh	/^struct ChainConfig {$/;"	s	namespace:util::stream
ChainConfigException	kenlm/util/stream/chain.cc	/^ChainConfigException::ChainConfigException() throw() { *this << "Chain configured with "; }$/;"	f	class:util::stream::ChainConfigException
ChainConfigException	kenlm/util/stream/chain.hh	/^class ChainConfigException : public Exception {$/;"	c	namespace:util::stream
ChainPosition	kenlm/util/stream/chain.hh	/^    ChainPosition(PCQueue<Block> &in, PCQueue<Block> &out, Chain *chain, MultiProgress &progress) $/;"	f	class:util::stream::ChainPosition
ChainPosition	kenlm/util/stream/chain.hh	/^class ChainPosition {$/;"	c	namespace:util::stream
ChainPositions	kenlm/util/stream/multi_stream.hh	/^    ChainPositions() {}$/;"	f	class:util::stream::ChainPositions
ChainPositions	kenlm/util/stream/multi_stream.hh	/^    explicit ChainPositions(Chains &chains) {$/;"	f	class:util::stream::ChainPositions
ChainPositions	kenlm/util/stream/multi_stream.hh	/^class ChainPositions : public util::FixedArray<util::stream::ChainPosition> {$/;"	c	namespace:util::stream
Chains	kenlm/util/stream/multi_stream.hh	/^    Chains() {}$/;"	f	class:util::stream::Chains
Chains	kenlm/util/stream/multi_stream.hh	/^    explicit Chains(std::size_t limit) : util::FixedArray<util::stream::Chain>(limit) {}$/;"	f	class:util::stream::Chains
Chains	kenlm/util/stream/multi_stream.hh	/^class Chains : public util::FixedArray<util::stream::Chain> {$/;"	c	namespace:util::stream
ChartState	kenlm/lm/state.hh	/^struct ChartState {$/;"	s	namespace:lm::ngram
CheckConsistency	kenlm/util/probing_hash_table.hh	/^    void CheckConsistency() {$/;"	f	class:util::ProbingHashTable
CheckCounts	kenlm/lm/model.cc	/^void CheckCounts(const std::vector<uint64_t> &counts) {$/;"	f	namespace:lm::ngram::detail::__anon18
CheckForRun	kenlm/util/stream/chain.hh	/^    template <class T, void (T::*ptr)(const ChainPosition &) = &T::Run> struct CheckForRun {$/;"	s	class:util::stream::Chain
CheckForRun	kenlm/util/stream/multi_stream.hh	/^    template <class T, void (T::*ptr)(const ChainPositions &) = &T::Run> struct CheckForRun {$/;"	s	class:util::stream::Chains
CheckLAlign	HLVRec-traceback.c	/^void CheckLAlign (DecoderInst *dec, Lattice *lat)$/;"	f
CheckLRTransP	HLVRec.c	/^static Boolean CheckLRTransP (SMatrix transP)$/;"	f	file:
CheckOffT	kenlm/util/file.cc	/^template <> struct CheckOffT<8> {$/;"	s	namespace:util::__anon36	file:
CheckOverflow	kenlm/util/exception.hh	/^inline std::size_t CheckOverflow(uint64_t value) {$/;"	f	namespace:util
CheckOverflowInternal	kenlm/util/exception.hh	/^template <> inline std::size_t CheckOverflowInternal<8>(uint64_t value) {$/;"	f	namespace:util
CheckOverflowInternal	kenlm/util/exception.hh	/^template <unsigned len> inline std::size_t CheckOverflowInternal(uint64_t value) {$/;"	f	namespace:util
CheckSpecials	kenlm/lm/vocab.hh	/^template <class Vocab> void CheckSpecials(const Config &config, const Vocab &vocab) throw(SpecialWordMissingException) {$/;"	f	namespace:lm::ngram
CheckTokenSetId	HLVRec-misc.c	/^static void CheckTokenSetId (DecoderInst *dec, TokenSet *ts1, TokenSet *ts2)$/;"	f	file:
CheckTokenSetOrder	HLVRec-misc.c	/^void CheckTokenSetOrder (DecoderInst *dec, TokenSet *ts)$/;"	f
CheckedBase	kenlm/util/mmap.hh	/^    void *CheckedBase(uint64_t index) {$/;"	f	class:util::Rolling
CheckedIndex	kenlm/util/mmap.hh	/^    void *CheckedIndex(uint64_t index) {$/;"	f	class:util::Rolling
ChopBits	kenlm/lm/bhiksha.cc	/^uint8_t ChopBits(uint64_t max_offset, uint64_t max_next, const Config &config) {$/;"	f	namespace:lm::ngram::trie::__anon5
Chunk	kenlm/util/double-conversion/bignum.h	/^  typedef uint32_t Chunk;$/;"	t	class:double_conversion::Bignum
Clamp	kenlm/util/double-conversion/bignum.cc	/^void Bignum::Clamp() {$/;"	f	class:double_conversion::Bignum
CleanDecoderInst	HLVRec.c	/^void CleanDecoderInst (DecoderInst *dec)$/;"	f
Clear	kenlm/lm/filter/format.hh	/^    void Clear() { actual_ = 0; }$/;"	f	class:lm::InputBuffer
Clear	kenlm/util/probing_hash_table.hh	/^    void Clear() {$/;"	f	class:util::AutoProbing
Clear	kenlm/util/probing_hash_table.hh	/^    void Clear() {$/;"	f	class:util::ProbingHashTable
Close	kenlm/util/file.cc	/^void scoped_FILE_closer::Close(std::FILE *file) {$/;"	f	class:util::scoped_FILE_closer
Close	kenlm/util/scoped.hh	/^  static void Close(T *p) { clean(p); }$/;"	f	struct:util::scoped_c_forward
Close	kenlm/util/scoped.hh	/^  template <class T> static void Close(T *p) { delete [] p; }$/;"	f	struct:util::scoped_delete_array_forward
Close	kenlm/util/scoped.hh	/^  template <class T> static void Close(T *p) { delete p; }$/;"	f	struct:util::scoped_delete_forward
Closer	kenlm/lm/trie_sort.cc	/^    explicit Closer(std::deque<FILE*> &files) : files_(files) {}$/;"	f	class:lm::ngram::trie::__anon27::Closer
Closer	kenlm/lm/trie_sort.cc	/^class Closer {$/;"	c	namespace:lm::ngram::trie::__anon27	file:
CollapseStream	kenlm/lm/builder/adjust_counts.cc	/^    CollapseStream(const util::stream::ChainPosition &position, uint64_t prune_threshold, const std::vector<bool>& prune_words) :$/;"	f	class:lm::builder::__anon8::CollapseStream
CollapseStream	kenlm/lm/builder/adjust_counts.cc	/^class CollapseStream {$/;"	c	namespace:lm::builder::__anon8	file:
CollectPhoneStats	HLVNet.c	/^void CollectPhoneStats (MemHeap *heap, TLexNet *net)$/;"	f
CombinePaths	HLVRec-misc.c	/^static WordendHyp *CombinePaths (DecoderInst *dec, RelToken *winner, RelToken *loser, LogFloat diff)$/;"	f	file:
CombineWordHash	kenlm/lm/search_hashed.hh	/^inline uint64_t CombineWordHash(uint64_t current, const WordIndex next) {$/;"	f	namespace:lm::ngram::detail
CompLMlaNode	HLVNet.h	/^} CompLMlaNode;$/;"	t	typeref:struct:_CompLMlaNode
Comparator	kenlm/lm/builder/sort.hh	/^    explicit Comparator(std::size_t order) : order_(order) {}$/;"	f	class:lm::builder::Comparator
Comparator	kenlm/lm/builder/sort.hh	/^template <class Child> class Comparator : public std::binary_function<const void *, const void *, bool> {$/;"	c	namespace:lm::builder
Compare	kenlm/lm/builder/sort.hh	/^    inline bool Compare(const WordIndex *lhs, const WordIndex *rhs) const {$/;"	f	class:lm::builder::ContextOrder
Compare	kenlm/lm/builder/sort.hh	/^    inline bool Compare(const WordIndex *lhs, const WordIndex *rhs) const {$/;"	f	class:lm::builder::PrefixOrder
Compare	kenlm/lm/builder/sort.hh	/^    inline bool Compare(const WordIndex *lhs, const WordIndex *rhs) const {$/;"	f	class:lm::builder::SuffixOrder
Compare	kenlm/lm/search_trie.cc	/^int Compare(unsigned char order, const void *first_void, const void *second_void) {$/;"	f	namespace:lm::ngram::trie::__anon24
Compare	kenlm/lm/state.hh	/^    int Compare(const State &other) const {$/;"	f	class:lm::ngram::State
Compare	kenlm/lm/state.hh	/^  int Compare(const ChartState &other) const {$/;"	f	struct:lm::ngram::ChartState
Compare	kenlm/lm/state.hh	/^  int Compare(const Left &other) const {$/;"	f	struct:lm::ngram::Left
Compare	kenlm/util/double-conversion/bignum.cc	/^int Bignum::Compare(const Bignum& a, const Bignum& b) {$/;"	f	class:double_conversion::Bignum
CompareBasePron	HLVNet.c	/^Boolean CompareBasePron (Pron b, Pron p)$/;"	f
CompareBufferWithDiyFp	kenlm/util/double-conversion/strtod.cc	/^static int CompareBufferWithDiyFp(Vector<const char> buffer,$/;"	f	namespace:double_conversion
ComplainAboutARPA	kenlm/lm/model.cc	/^void ComplainAboutARPA(const Config &config, ModelType model_type) {$/;"	f	namespace:lm::ngram::detail::__anon18
ComplainDisallowed	kenlm/lm/builder/corpus_count.cc	/^  void ComplainDisallowed(StringPiece word, WarningAction &action) {$/;"	f	namespace:lm::builder::__anon10
Complete	kenlm/util/read_compressed.cc	/^class Complete : public ReadBase {$/;"	c	namespace:util::__anon45	file:
Complete	kenlm/util/stream/chain.cc	/^ChainPosition Chain::Complete() {$/;"	f	class:util::stream::Chain
CompleteLoop	kenlm/util/stream/chain.hh	/^    void CompleteLoop() {$/;"	f	class:util::stream::Chain
CompressedException	kenlm/util/read_compressed.cc	/^CompressedException::CompressedException() throw() {}$/;"	f	class:util::CompressedException
CompressedException	kenlm/util/read_compressed.hh	/^class CompressedException : public Exception {$/;"	c	namespace:util
ComputeGuess	kenlm/util/double-conversion/strtod.cc	/^static bool ComputeGuess(Vector<const char> trimmed, int exponent,$/;"	f	namespace:double_conversion
ConditionCommon	kenlm/lm/filter/phrase.cc	/^ConditionCommon::ConditionCommon(const ConditionCommon &from) : substrings_(from.substrings_) {}$/;"	f	class:lm::phrase::detail::ConditionCommon
ConditionCommon	kenlm/lm/filter/phrase.cc	/^ConditionCommon::ConditionCommon(const Substrings &substrings) : substrings_(substrings) {}$/;"	f	class:lm::phrase::detail::ConditionCommon
ConditionCommon	kenlm/lm/filter/phrase.hh	/^class ConditionCommon {$/;"	c	namespace:lm::phrase::detail
Config	kenlm/lm/builder/pipeline.cc	/^    const PipelineConfig &Config() const { return config_; }$/;"	f	class:lm::builder::__anon13::Master
Config	kenlm/lm/config.cc	/^Config::Config() :$/;"	f	class:lm::ngram::Config
Config	kenlm/lm/config.hh	/^struct Config {$/;"	s	namespace:lm::ngram
ConfigException	kenlm/lm/lm_exception.cc	/^ConfigException::ConfigException() throw() {}$/;"	f	class:lm::ConfigException
ConfigException	kenlm/lm/lm_exception.hh	/^class ConfigException : public util::Exception {$/;"	c	namespace:lm
ConfigureEnumerate	kenlm/lm/vocab.cc	/^void ProbingVocabulary::ConfigureEnumerate(EnumerateVocab *to, std::size_t \/*max_entries*\/) {$/;"	f	class:lm::ngram::ProbingVocabulary
ConfigureEnumerate	kenlm/lm/vocab.cc	/^void SortedVocabulary::ConfigureEnumerate(EnumerateVocab *to, std::size_t max_entries) {$/;"	f	class:lm::ngram::SortedVocabulary
ConstIterator	kenlm/util/probing_hash_table.hh	/^    typedef const Entry *ConstIterator;$/;"	t	class:util::AutoProbing
ConstIterator	kenlm/util/probing_hash_table.hh	/^    typedef const Entry *ConstIterator;$/;"	t	class:util::ProbingHashTable
Construct	kenlm/lm/builder/corpus_count.cc	/^  static DedupeEntry Construct(WordIndex *at) {$/;"	f	struct:lm::builder::__anon9::DedupeEntry
Constructed	kenlm/util/fixed_array.hh	/^    void Constructed() {$/;"	f	class:util::FixedArray
Consume	kenlm/util/file_piece.hh	/^    StringPiece Consume(const char *to) {$/;"	f	class:util::FilePiece
Consume	kenlm/util/pcqueue.hh	/^  T Consume() {$/;"	f	class:util::PCQueue
Consume	kenlm/util/pcqueue.hh	/^  T& Consume(T &out) {$/;"	f	class:util::PCQueue
ConsumeSubString	kenlm/util/double-conversion/double-conversion.cc	/^static bool ConsumeSubString(const char** current,$/;"	f	namespace:double_conversion
Context	kenlm/lm/trie_sort.hh	/^    FILE *Context(unsigned char of_order) {$/;"	f	class:lm::ngram::trie::SortedFiles
ContextFilter	kenlm/lm/filter/wrapper.hh	/^    explicit ContextFilter(Filter &backend) : backend_(backend) {}$/;"	f	class:lm::ContextFilter
ContextFilter	kenlm/lm/filter/wrapper.hh	/^template <class FilterT> class ContextFilter {$/;"	c	namespace:lm
ContextOrder	kenlm/lm/builder/sort.hh	/^    explicit ContextOrder(std::size_t order) : Comparator<ContextOrder>(order) {}$/;"	f	class:lm::builder::ContextOrder
ContextOrder	kenlm/lm/builder/sort.hh	/^class ContextOrder : public Comparator<ContextOrder> {$/;"	c	namespace:lm::builder
Controller	kenlm/lm/filter/thread.hh	/^    Controller(size_t batch_size, size_t queue, size_t workers, const Filter &filter, RealOutput &output) $/;"	f	class:lm::Controller
Controller	kenlm/lm/filter/thread.hh	/^template <class Filter, class OutputBuffer, class RealOutput> class Controller : boost::noncopyable {$/;"	c	namespace:lm
ConvertHSet	HLVModel.c	/^StateInfo_lv *ConvertHSet(MemHeap *heap, HMMSet *hset, Boolean useHModel)$/;"	f
ConvertSilDict	HLVNet.c	/^void ConvertSilDict (Vocab *voc, LabId spLab, LabId silLab, $/;"	f
ConvertTLex2Lex	HLVNet.c	/^LexNet *ConvertTLex2Lex (MemHeap *heap, TLexNet *tnet)$/;"	f
ConvertToSorted	kenlm/lm/trie_sort.cc	/^void SortedFiles::ConvertToSorted(util::FilePiece &f, const SortedVocabulary &vocab, const std::vector<uint64_t> &counts, const std::string &file_prefix, unsigned char order, PositiveProbWarn &warn, void *mem, std::size_t mem_size) {$/;"	f	class:lm::ngram::trie::SortedFiles
Copy	kenlm/lm/filter/format.hh	/^  static void Copy(util::FilePiece &in, Output &out) {$/;"	f	struct:lm::ARPAFormat
Copy	kenlm/lm/filter/format.hh	/^  static void Copy(util::FilePiece &in, Output &out) {$/;"	f	struct:lm::CountFormat
CopyRemainingHistory	kenlm/lm/model.cc	/^void CopyRemainingHistory(const WordIndex *from, State &out_state) {$/;"	f	namespace:lm::ngram::detail::__anon19
CopyToString	kenlm/util/string_piece.cc	/^void StringPiece::CopyToString(std::string* target) const {$/;"	f	class:StringPiece
CorpusCount	kenlm/lm/builder/corpus_count.cc	/^CorpusCount::CorpusCount(util::FilePiece &from, int vocab_write, uint64_t &token_count, WordIndex &type_count, std::vector<bool> &prune_words, const std::string& prune_vocab_filename, std::size_t entries_per_block, WarningAction disallowed_symbol)$/;"	f	class:lm::builder::CorpusCount
CorpusCount	kenlm/lm/builder/corpus_count.hh	/^class CorpusCount {$/;"	c	namespace:lm::builder
Count	kenlm/lm/builder/ngram.hh	/^    uint64_t &Count() { return Value().count; }$/;"	f	class:lm::builder::NGram
Count	kenlm/lm/builder/ngram.hh	/^    uint64_t Count() const { return Value().count; }$/;"	f	class:lm::builder::NGram
CountBatch	kenlm/lm/filter/count_io.hh	/^    explicit CountBatch(std::streamsize initial_read) $/;"	f	class:lm::CountBatch
CountBatch	kenlm/lm/filter/count_io.hh	/^class CountBatch {$/;"	c	namespace:lm
CountFormat	kenlm/lm/filter/format.hh	/^struct CountFormat {$/;"	s	namespace:lm
CountOutput	kenlm/lm/filter/count_io.hh	/^    explicit CountOutput(const char *name) : file_(util::CreateOrThrow(name)) {}$/;"	f	class:lm::CountOutput
CountOutput	kenlm/lm/filter/count_io.hh	/^class CountOutput : boost::noncopyable {$/;"	c	namespace:lm
CountText	kenlm/lm/builder/pipeline.cc	/^void CountText(int text_file \/* input *\/, int vocab_file \/* output *\/, Master &master, uint64_t &token_count, std::string &text_file_name, std::vector<bool> &prune_words) {$/;"	f	namespace:lm::builder::__anon13
Counts	kenlm/lm/interpolate/arpa_to_stream.hh	/^    const std::vector<uint64_t> &Counts() const { return counts_; }$/;"	f	class:lm::interpolate::ARPAToStream
Counts	kenlm/lm/search_trie.cc	/^    const std::vector<uint64_t> &Counts() const {$/;"	f	class:lm::ngram::trie::__anon24::FindBlanks
CreateAnodes	HLVNet.c	/^void CreateAnodes (MemHeap *heap, TLexNet *net)$/;"	f
CreateBYnodes	HLVNet.c	/^void CreateBYnodes (MemHeap *heap, TLexNet *net)$/;"	f
CreateBestInfo	HDecode.c	/^BestInfo *CreateBestInfo (MemHeap *heap, char *fn, HTime frameDur)$/;"	f
CreateBestInfo	HDecode.mod.c	/^BestInfo *CreateBestInfo (MemHeap *heap, char *fn, HTime frameDur)$/;"	f
CreateBoNGram	HLVLM.c	/^FSLM_ngram *CreateBoNGram (MemHeap *heap, int vocSize, int counts[NSIZE])$/;"	f
CreateBoundary	HLVNet.c	/^TLexNode *CreateBoundary (MemHeap *heap, TLexNet *tnet, LabId labid, int modLayer, int weLayer)$/;"	f
CreateChains	kenlm/lm/builder/pipeline.cc	/^    void CreateChains(std::size_t remaining_mem, const std::vector<uint64_t> &count_bounds) {$/;"	f	class:lm::builder::__anon13::Master	file:
CreateCompLMLA	HLVNet.c	/^static void CreateCompLMLA (MemHeap *heap, LMlaTree *laTree, TLexNet *tnet)$/;"	f	file:
CreateDecimalRepresentation	kenlm/util/double-conversion/double-conversion.cc	/^void DoubleToStringConverter::CreateDecimalRepresentation($/;"	f	class:double_conversion::DoubleToStringConverter
CreateDecoderInst	HLVRec.c	/^DecoderInst *CreateDecoderInst(HMMSet *hset, lm::base::Model *lm_kenlm, int nTok, Boolean latgen, $/;"	f
CreateExponentialRepresentation	kenlm/util/double-conversion/double-conversion.cc	/^void DoubleToStringConverter::CreateExponentialRepresentation($/;"	f	class:double_conversion::DoubleToStringConverter
CreateLM	HLVLM.c	/^FSLM *CreateLM (MemHeap *heap, char *fn, char *startWord, char *endWord, Vocab *vocab)$/;"	f
CreateLMCache	HLVRec-LM.c	/^static LMCache *CreateLMCache (DecoderInst *dec, MemHeap *heap)$/;"	f	file:
CreateLMfromLat	HLVLM.c	/^FSLM *CreateLMfromLat (MemHeap *heap, char *latfn, Lattice *lat, Vocab *vocab)$/;"	f
CreateLexNet	HLVNet.c	/^LexNet *CreateLexNet (MemHeap *heap, Vocab *voc, HMMSet *hset, $/;"	f
CreateLexNet_S	HLVNet.c	/^LexNet *CreateLexNet_S (MemHeap *heap, Vocab *voc, HMMSet *hset, char *startWord, char *endWord)$/;"	f
CreateOrThrow	kenlm/util/file.cc	/^int CreateOrThrow(const char *name) {$/;"	f	namespace:util
CreateOutPCache	HLVRec-outP.c	/^static OutPCache *CreateOutPCache (MemHeap *heap, HMMSet *hset, int block)$/;"	f	file:
CreateSILnodes	HLVNet.c	/^void CreateSILnodes (MemHeap *heap, TLexNet *net)$/;"	f
CreateStartEnd	HLVNet.c	/^void CreateStartEnd (MemHeap *heap, TLexNet *tnet)$/;"	f
CreateZnodes	HLVNet.c	/^void CreateZnodes (MemHeap *heap, TLexNet *net)$/;"	f
Create_kenlm	HDecode.c	/^Model* Create_kenlm(const char* file){$/;"	f
Current	kenlm/lm/filter/phrase.cc	/^    Sentence Current() const {$/;"	f	class:lm::phrase::detail::Arc
Current	kenlm/lm/filter/phrase.cc	/^    Sentence Current() const {$/;"	f	class:lm::phrase::detail::Vertex
Current	kenlm/util/read_compressed.cc	/^    ReadBase *Current(ReadCompressed &thunk) { return thunk.internal_.get(); }$/;"	f	class:util::ReadBase
Current	kenlm/util/stream/sort.hh	/^        const void *Current() const { return current_; }$/;"	f	class:util::stream::MergeQueue::Entry
CutToMaxSignificantDigits	kenlm/util/double-conversion/strtod.cc	/^static void CutToMaxSignificantDigits(Vector<const char> buffer,$/;"	f	namespace:double_conversion
CutoffCount	kenlm/lm/builder/ngram.hh	/^    uint64_t CutoffCount() const {$/;"	f	class:lm::builder::NGram
DEBUG_LABEL_NET	HLVNet.c	57;"	d	file:
DIR_BACKW	HLVNet.c	1732;"	d	file:
DIR_FORW	HLVNet.c	1731;"	d	file:
DISALLOW_COPY_AND_ASSIGN	kenlm/util/double-conversion/utils.h	112;"	d
DISALLOW_IMPLICIT_CONSTRUCTORS	kenlm/util/double-conversion/utils.h	124;"	d
DOUBLE_CONVERSION_BIGNUM_DTOA_H_	kenlm/util/double-conversion/bignum-dtoa.h	29;"	d
DOUBLE_CONVERSION_BIGNUM_H_	kenlm/util/double-conversion/bignum.h	29;"	d
DOUBLE_CONVERSION_CACHED_POWERS_H_	kenlm/util/double-conversion/cached-powers.h	29;"	d
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS	kenlm/util/double-conversion/utils.h	62;"	d
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS	kenlm/util/double-conversion/utils.h	66;"	d
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS	kenlm/util/double-conversion/utils.h	68;"	d
DOUBLE_CONVERSION_DIY_FP_H_	kenlm/util/double-conversion/diy-fp.h	29;"	d
DOUBLE_CONVERSION_DOUBLE_CONVERSION_H_	kenlm/util/double-conversion/double-conversion.h	29;"	d
DOUBLE_CONVERSION_DOUBLE_H_	kenlm/util/double-conversion/ieee.h	29;"	d
DOUBLE_CONVERSION_FAST_DTOA_H_	kenlm/util/double-conversion/fast-dtoa.h	29;"	d
DOUBLE_CONVERSION_FIXED_DTOA_H_	kenlm/util/double-conversion/fixed-dtoa.h	29;"	d
DOUBLE_CONVERSION_STRTOD_H_	kenlm/util/double-conversion/strtod.h	29;"	d
DOUBLE_CONVERSION_UTILS_H_	kenlm/util/double-conversion/utils.h	29;"	d
Data	kenlm/lm/trie_sort.cc	/^    const void *Data() const { return inner_.Data(); }$/;"	f	class:lm::ngram::trie::__anon26::PartialViewProxy
Data	kenlm/lm/trie_sort.cc	/^    void *Data() { return inner_.Data(); }$/;"	f	class:lm::ngram::trie::__anon26::PartialViewProxy
Data	kenlm/lm/trie_sort.hh	/^    const void *Data() const { return data_.get(); }$/;"	f	class:lm::ngram::trie::RecordReader
Data	kenlm/lm/trie_sort.hh	/^    void *Data() { return data_.get(); }$/;"	f	class:lm::ngram::trie::RecordReader
Data	kenlm/util/sized_iterator.hh	/^    const void *Data() const { return inner_.Data(); }$/;"	f	class:util::SizedProxy
Data	kenlm/util/sized_iterator.hh	/^    const void *Data() const { return ptr_; }$/;"	f	class:util::SizedInnerIterator
Data	kenlm/util/sized_iterator.hh	/^    void *Data() { return inner_.Data(); }$/;"	f	class:util::SizedProxy
Data	kenlm/util/sized_iterator.hh	/^    void *Data() { return ptr_; }$/;"	f	class:util::SizedInnerIterator
DeactivateNode	HLVRec.c	/^static void DeactivateNode (DecoderInst *dec, LexNode *ln)$/;"	f	file:
Debug_Check_LMhashtab	HLVLM.c	/^void Debug_Check_LMhashtab(FSLM_ngram *nglm)$/;"	f
Debug_Check_Score	HLVRec-misc.c	/^void Debug_Check_Score (DecoderInst *dec)$/;"	f
Debug_DumpNet	HLVRec-misc.c	/^void Debug_DumpNet (LexNet *net)$/;"	f
Decode	kenlm/lm/quantize.hh	/^        float Decode(std::size_t off) const { return begin_[off]; }$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
DecoderInst	HLVRec.h	/^typedef struct _DecoderInst DecoderInst;  \/* contains all state information about one instance$/;"	t	typeref:struct:_DecoderInst
DecreaseBase	kenlm/util/mmap.hh	/^    void DecreaseBase(uint64_t by) {$/;"	f	class:util::Rolling
Dedupe	kenlm/lm/builder/corpus_count.cc	/^typedef util::ProbingHashTable<DedupeEntry, DedupeHash, DedupeEquals> Dedupe;$/;"	t	namespace:lm::builder::__anon9	file:
DedupeEntry	kenlm/lm/builder/corpus_count.cc	/^struct DedupeEntry {$/;"	s	namespace:lm::builder::__anon9	file:
DedupeEquals	kenlm/lm/builder/corpus_count.cc	/^    explicit DedupeEquals(std::size_t order) : size_(order * sizeof(WordIndex)) {}$/;"	f	class:lm::builder::__anon9::DedupeEquals
DedupeEquals	kenlm/lm/builder/corpus_count.cc	/^class DedupeEquals : public std::binary_function<const WordIndex *, const WordIndex *, bool> {$/;"	c	namespace:lm::builder::__anon9	file:
DedupeHash	kenlm/lm/builder/corpus_count.cc	/^    explicit DedupeHash(std::size_t order) : size_(order * sizeof(WordIndex)) {}$/;"	f	class:lm::builder::__anon9::DedupeHash
DedupeHash	kenlm/lm/builder/corpus_count.cc	/^class DedupeHash : public std::unary_function<const WordIndex *, bool> {$/;"	c	namespace:lm::builder::__anon9	file:
DedupeMultiplier	kenlm/lm/builder/corpus_count.cc	/^float CorpusCount::DedupeMultiplier(std::size_t order) {$/;"	f	class:lm::builder::CorpusCount
DeepSwap	kenlm/util/joint_sort.hh	/^    void DeepSwap(JointIter &other) {$/;"	f	class:util::detail::JointIter
DefaultLazy	kenlm/util/stream/sort.hh	/^    std::size_t DefaultLazy() {$/;"	f	class:util::stream::Sort
DetectCompressedMagic	kenlm/util/read_compressed.cc	/^bool ReadCompressed::DetectCompressedMagic(const void *from_void) {$/;"	f	class:util::ReadCompressed
DetectMagic	kenlm/util/read_compressed.cc	/^MagicResult DetectMagic(const void *from_void, std::size_t length) {$/;"	f	namespace:util::__anon45
DigitGen	kenlm/util/double-conversion/fast-dtoa.cc	/^static bool DigitGen(DiyFp low,$/;"	f	namespace:double_conversion
DigitGenCounted	kenlm/util/double-conversion/fast-dtoa.cc	/^static bool DigitGenCounted(DiyFp w,$/;"	f	namespace:double_conversion
Discount	kenlm/lm/builder/discount.hh	/^struct Discount {$/;"	s	namespace:lm::builder
DiscountConfig	kenlm/lm/builder/adjust_counts.hh	/^struct DiscountConfig {$/;"	s	namespace:lm::builder
DiskFlush	kenlm/lm/trie_sort.cc	/^FILE *DiskFlush(const void *mem_begin, const void *mem_end, const std::string &temp_prefix) {$/;"	f	namespace:lm::ngram::trie::__anon26
DispatchARPAInput	kenlm/lm/filter/format.hh	/^    DispatchARPAInput(Filter &filter, Output &output) : B(filter, output) {}$/;"	f	class:lm::DispatchARPAInput
DispatchARPAInput	kenlm/lm/filter/format.hh	/^template <class Filter, class Output> class DispatchARPAInput : public DispatchInput<Filter, Output> {$/;"	c	namespace:lm
DispatchBuild	kenlm/lm/search_hashed.cc	/^template <> void HashedSearch<BackoffValue>::DispatchBuild(util::FilePiece &f, const std::vector<uint64_t> &counts, const Config &config, const ProbingVocabulary &vocab, PositiveProbWarn &warn) {$/;"	f	class:lm::ngram::detail::HashedSearch
DispatchBuild	kenlm/lm/search_hashed.cc	/^template <> void HashedSearch<RestValue>::DispatchBuild(util::FilePiece &f, const std::vector<uint64_t> &counts, const Config &config, const ProbingVocabulary &vocab, PositiveProbWarn &warn) {$/;"	f	class:lm::ngram::detail::HashedSearch
DispatchInput	kenlm/lm/filter/format.hh	/^    DispatchInput(Filter &filter, Output &output) : filter_(filter), output_(output) {}$/;"	f	class:lm::DispatchInput
DispatchInput	kenlm/lm/filter/format.hh	/^template <class Filter, class Output> class DispatchInput {$/;"	c	namespace:lm
DivModPowerOf2	kenlm/util/double-conversion/fixed-dtoa.cc	/^  int DivModPowerOf2(int power) {$/;"	f	class:double_conversion::UInt128
DivideModuloIntBignum	kenlm/util/double-conversion/bignum.cc	/^uint16_t Bignum::DivideModuloIntBignum(const Bignum& other) {$/;"	f	class:double_conversion::Bignum
DiyFp	kenlm/util/double-conversion/diy-fp.h	/^  DiyFp() : f_(0), e_(0) {}$/;"	f	class:double_conversion::DiyFp
DiyFp	kenlm/util/double-conversion/diy-fp.h	/^  DiyFp(uint64_t f, int e) : f_(f), e_(e) {}$/;"	f	class:double_conversion::DiyFp
DiyFp	kenlm/util/double-conversion/diy-fp.h	/^class DiyFp {$/;"	c	namespace:double_conversion
DiyFpStrtod	kenlm/util/double-conversion/strtod.cc	/^static bool DiyFpStrtod(Vector<const char> buffer,$/;"	f	namespace:double_conversion
DiyFpToUint64	kenlm/util/double-conversion/ieee.h	/^  static uint64_t DiyFpToUint64(DiyFp diy_fp) {$/;"	f	class:double_conversion::Double
DoRecognition	HDecode.c	/^void DoRecognition (DecoderInst *dec, char *fn)$/;"	f
DoRecognition	HDecode.mod.c	/^void DoRecognition (DecoderInst *dec, char *fn)$/;"	f
DontBhiksha	kenlm/lm/bhiksha.cc	/^DontBhiksha::DontBhiksha(const void * \/*base*\/, uint64_t \/*max_offset*\/, uint64_t max_next, const Config &\/*config*\/) : $/;"	f	class:lm::ngram::trie::DontBhiksha
DontBhiksha	kenlm/lm/bhiksha.hh	/^class DontBhiksha {$/;"	c	namespace:lm::ngram::trie
DontQuantize	kenlm/lm/quantize.hh	/^    DontQuantize() {}$/;"	f	class:lm::ngram::DontQuantize
DontQuantize	kenlm/lm/quantize.hh	/^class DontQuantize {$/;"	c	namespace:lm::ngram
Double	kenlm/util/double-conversion/ieee.h	/^  Double() : d64_(0) {}$/;"	f	class:double_conversion::Double
Double	kenlm/util/double-conversion/ieee.h	/^  explicit Double(DiyFp diy_fp)$/;"	f	class:double_conversion::Double
Double	kenlm/util/double-conversion/ieee.h	/^  explicit Double(double d) : d64_(double_to_uint64(d)) {}$/;"	f	class:double_conversion::Double
Double	kenlm/util/double-conversion/ieee.h	/^  explicit Double(uint64_t d64) : d64_(d64) {}$/;"	f	class:double_conversion::Double
Double	kenlm/util/double-conversion/ieee.h	/^class Double {$/;"	c	namespace:double_conversion
Double	kenlm/util/probing_hash_table.hh	/^    void Double(void *new_base, bool clear_new = true) {$/;"	f	class:util::ProbingHashTable
DoubleChunk	kenlm/util/double-conversion/bignum.h	/^  typedef uint64_t DoubleChunk;$/;"	t	class:double_conversion::Bignum
DoubleIfNeeded	kenlm/util/probing_hash_table.hh	/^    void DoubleIfNeeded() {$/;"	f	class:util::AutoProbing
DoubleSec	kenlm/util/usage.cc	/^double DoubleSec(const struct timespec &tv) {$/;"	f	namespace:util::__anon49
DoubleSec	kenlm/util/usage.cc	/^double DoubleSec(const struct timeval &tv) {$/;"	f	namespace:util::__anon49
DoubleSec	kenlm/util/usage.cc	/^double DoubleSec(time_t tv) {$/;"	f	namespace:util::__anon49
DoubleStrtod	kenlm/util/double-conversion/strtod.cc	/^static bool DoubleStrtod(Vector<const char> trimmed,$/;"	f	namespace:double_conversion
DoubleTo	kenlm/util/probing_hash_table.hh	/^    std::size_t DoubleTo() const {$/;"	f	class:util::ProbingHashTable
DoubleToAscii	kenlm/util/double-conversion/double-conversion.cc	/^void DoubleToStringConverter::DoubleToAscii(double v,$/;"	f	class:double_conversion::DoubleToStringConverter
DoubleToStringConverter	kenlm/util/double-conversion/double-conversion.h	/^  DoubleToStringConverter(int flags,$/;"	f	class:double_conversion::DoubleToStringConverter
DoubleToStringConverter	kenlm/util/double-conversion/double-conversion.h	/^class DoubleToStringConverter {$/;"	c	namespace:double_conversion
DtoaMode	kenlm/util/double-conversion/double-conversion.h	/^  enum DtoaMode {$/;"	g	class:double_conversion::DoubleToStringConverter
DtoaToBignumDtoaMode	kenlm/util/double-conversion/double-conversion.cc	/^static BignumDtoaMode DtoaToBignumDtoaMode($/;"	f	namespace:double_conversion
DumpSeparateFiles	kenlm/lm/builder/print.hh	/^    static void DumpSeparateFiles(const VocabReconstitute &vocab, const std::string &file_base, util::stream::Chains &chains) {$/;"	f	class:lm::builder::Print
DumpStream	kenlm/lm/builder/print.hh	/^    void DumpStream(NGramStream &stream, util::FakeOFStream &to) {$/;"	f	class:lm::builder::Print
DupOrThrow	kenlm/util/file.cc	/^int DupOrThrow(int fd) {$/;"	f	namespace:util
EMIT_POSITIVE_EXPONENT_SIGN	kenlm/util/double-conversion/double-conversion.h	/^    EMIT_POSITIVE_EXPONENT_SIGN = 1,$/;"	e	enum:double_conversion::DoubleToStringConverter::Flags
EMIT_TRAILING_DECIMAL_POINT	kenlm/util/double-conversion/double-conversion.h	/^    EMIT_TRAILING_DECIMAL_POINT = 2,$/;"	e	enum:double_conversion::DoubleToStringConverter::Flags
EMIT_TRAILING_ZERO_AFTER_POINT	kenlm/util/double-conversion/double-conversion.h	/^    EMIT_TRAILING_ZERO_AFTER_POINT = 4,$/;"	e	enum:double_conversion::DoubleToStringConverter::Flags
EOF	kenlm/util/getopt.c	16;"	d	file:
ERR	kenlm/util/getopt.c	17;"	d	file:
EXPENSIVE	kenlm/lm/config.hh	/^  enum ARPALoadComplain {ALL, EXPENSIVE, NONE};$/;"	e	enum:lm::ngram::Config::ARPALoadComplain
EcmaScriptConverter	kenlm/util/double-conversion/double-conversion.cc	/^const DoubleToStringConverter& DoubleToStringConverter::EcmaScriptConverter() {$/;"	f	class:double_conversion::DoubleToStringConverter
Empty	kenlm/lm/filter/format.hh	/^    bool Empty() { return actual_ == 0; }$/;"	f	class:lm::InputBuffer
Empty	kenlm/lm/filter/phrase.cc	/^    bool Empty() const {$/;"	f	class:lm::phrase::detail::Arc
Empty	kenlm/lm/filter/phrase.cc	/^    bool Empty() const {$/;"	f	class:lm::phrase::detail::Vertex
Empty	kenlm/util/stream/sort.hh	/^    bool Empty() const {$/;"	f	class:util::stream::MergeQueue
Encode	kenlm/lm/quantize.hh	/^        uint64_t Encode(float value, size_t reserved) const {$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
EncodeBackoff	kenlm/lm/quantize.hh	/^        uint64_t EncodeBackoff(float value) const {$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
EncodeProb	kenlm/lm/quantize.hh	/^        uint64_t EncodeProb(float value) const {$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
EndLength	kenlm/lm/filter/arpa_io.cc	/^void ARPAOutput::EndLength(unsigned int length) {$/;"	f	class:lm::ARPAOutput
EndLength	kenlm/lm/filter/format.hh	/^    void EndLength(unsigned int length) {$/;"	f	class:lm::DispatchARPAInput
EndLength	kenlm/lm/filter/format.hh	/^    void EndLength(unsigned int length) {$/;"	f	class:lm::MultipleARPAOutput
EndOfFileException	kenlm/util/file.cc	/^EndOfFileException::EndOfFileException() throw() {$/;"	f	class:util::EndOfFileException
EndOfFileException	kenlm/util/file.hh	/^class EndOfFileException : public Exception {$/;"	c	namespace:util
EndSentence	kenlm/lm/virtual_interface.hh	/^    WordIndex EndSentence() const { return end_sentence_; }$/;"	f	class:lm::base::Vocabulary
EnsureCapacity	kenlm/util/double-conversion/bignum.h	/^  void EnsureCapacity(int size) {$/;"	f	class:double_conversion::Bignum
EnsureRemaining	kenlm/util/fake_ofstream.hh	/^    void EnsureRemaining(std::size_t amount) {$/;"	f	class:util::FakeOFStream
Enter	kenlm/lm/builder/interpolate.cc	/^    void Enter(unsigned order_minus_1, NGram &gram) {$/;"	f	class:lm::builder::__anon12::Callback
Entry	kenlm/util/probing_hash_table.hh	/^    typedef EntryT Entry;$/;"	t	class:util::AutoProbing
Entry	kenlm/util/probing_hash_table.hh	/^    typedef EntryT Entry;$/;"	t	class:util::ProbingHashTable
Entry	kenlm/util/stream/sort.hh	/^        Entry() {}$/;"	f	class:util::stream::MergeQueue::Entry
Entry	kenlm/util/stream/sort.hh	/^        Entry(void *base, int fd, uint64_t offset, uint64_t amount, std::size_t buf_size) {$/;"	f	class:util::stream::MergeQueue::Entry
Entry	kenlm/util/stream/sort.hh	/^    class Entry {$/;"	c	class:util::stream::MergeQueue
Entry	kenlm/util/stream/sort.hh	/^    struct Entry {$/;"	s	class:util::stream::Offsets
EntryCompare	kenlm/lm/trie_sort.hh	/^    explicit EntryCompare(unsigned char order) : order_(order) {}$/;"	f	class:lm::ngram::trie::EntryCompare
EntryCompare	kenlm/lm/trie_sort.hh	/^class EntryCompare : public std::binary_function<const void*, const void*, bool> {$/;"	c	namespace:lm::ngram::trie
EntrySize	kenlm/lm/trie_sort.hh	/^    std::size_t EntrySize() const { return entry_size_; }$/;"	f	class:lm::ngram::trie::RecordReader
EntrySize	kenlm/util/sized_iterator.hh	/^    std::size_t EntrySize() const { return size_; }$/;"	f	class:util::SizedInnerIterator
EntrySize	kenlm/util/stream/chain.hh	/^    std::size_t EntrySize() const {$/;"	f	class:util::stream::Chain
EnumerateVocab	kenlm/lm/enumerate_vocab.hh	/^    EnumerateVocab() {}$/;"	f	class:lm::EnumerateVocab
EnumerateVocab	kenlm/lm/enumerate_vocab.hh	/^class EnumerateVocab {$/;"	c	namespace:lm
Equal	kenlm/util/double-conversion/bignum.h	/^  static bool Equal(const Bignum& a, const Bignum& b) {$/;"	f	class:double_conversion::Bignum
Equal	kenlm/util/probing_hash_table.hh	/^    typedef EqualT Equal;$/;"	t	class:util::AutoProbing
Equal	kenlm/util/probing_hash_table.hh	/^    typedef EqualT Equal;$/;"	t	class:util::ProbingHashTable
ErrnoException	kenlm/util/exception.cc	/^ErrnoException::ErrnoException() throw() : errno_(errno) {$/;"	f	class:util::ErrnoException
ErrnoException	kenlm/util/exception.hh	/^class ErrnoException : public Exception {$/;"	c	namespace:util
Error	kenlm/util/exception.hh	/^    int Error() const throw() { return errno_; }$/;"	f	class:util::ErrnoException
ErsatzPRead	kenlm/util/file.cc	/^void ErsatzPRead(int fd, void *to_void, std::size_t size, uint64_t off) {$/;"	f	namespace:util
ErsatzPWrite	kenlm/util/file.cc	/^void ErsatzPWrite(int fd, const void *from_void, std::size_t size, uint64_t off) {$/;"	f	namespace:util
ErsatzProgress	kenlm/util/ersatz_progress.cc	/^ErsatzProgress::ErsatzProgress() : current_(0), next_(std::numeric_limits<uint64_t>::max()), complete_(next_), out_(NULL) {}$/;"	f	class:util::ErsatzProgress
ErsatzProgress	kenlm/util/ersatz_progress.cc	/^ErsatzProgress::ErsatzProgress(uint64_t complete, std::ostream *to, const std::string &message) $/;"	f	class:util::ErsatzProgress
ErsatzProgress	kenlm/util/ersatz_progress.hh	/^class ErsatzProgress {$/;"	c	namespace:util
EstimatePower	kenlm/util/double-conversion/bignum-dtoa.cc	/^static int EstimatePower(int exponent) {$/;"	f	namespace:double_conversion
Evaluate	kenlm/lm/filter/phrase.cc	/^bool Union::Evaluate() {$/;"	f	class:lm::phrase::Union
Evaluate	kenlm/lm/filter/phrase.cc	/^template <class Output> void Multiple::Evaluate(const StringPiece &line, Output &output) {$/;"	f	class:lm::phrase::Multiple
Exception	kenlm/util/exception.cc	/^Exception::Exception() throw() {}$/;"	f	class:util::Exception
Exception	kenlm/util/exception.cc	/^Exception::Exception(const Exception &from) : std::exception() {$/;"	f	class:util::Exception
Exception	kenlm/util/exception.hh	/^class Exception : public std::exception {$/;"	c	namespace:util
ExceptionTag	kenlm/util/exception.hh	/^    template <class T> struct ExceptionTag {$/;"	s	class:util::Exception
Exit	kenlm/lm/builder/interpolate.cc	/^    void Exit(unsigned, const NGram &) const {}$/;"	f	class:lm::builder::__anon12::Callback
Exponent	kenlm/util/double-conversion/ieee.h	/^  int Exponent() const {$/;"	f	class:double_conversion::Double
Exponent	kenlm/util/double-conversion/ieee.h	/^  int Exponent() const {$/;"	f	class:double_conversion::Single
ExtendLeft	kenlm/lm/left.hh	/^    bool ExtendLeft(const ChartState &in, unsigned char &next_use, unsigned char extend_length, const float *back_in, float *back_out) {$/;"	f	class:lm::ngram::RuleScore
ExtendLeft	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> FullScoreReturn GenericModel<Search, VocabularyT>::ExtendLeft($/;"	f	class:lm::ngram::detail::GenericModel
ExtendLoop	kenlm/lm/partial.hh	/^template <class Model> ExtendReturn ExtendLoop($/;"	f	namespace:lm::ngram
ExtendReturn	kenlm/lm/partial.hh	/^struct ExtendReturn {$/;"	s	namespace:lm::ngram
Extends	kenlm/lm/search_trie.cc	/^    bool Extends(unsigned char order, const WordIndex *words) {$/;"	f	class:lm::ngram::trie::__anon24::BackoffMessages
ExtractNonRolling	kenlm/util/mmap.cc	/^void *Rolling::ExtractNonRolling(scoped_memory &out, uint64_t index, std::size_t size) {$/;"	f	class:util::Rolling
FAST_DTOA_PRECISION	kenlm/util/double-conversion/fast-dtoa.h	/^  FAST_DTOA_PRECISION$/;"	e	enum:double_conversion::FastDtoaMode
FAST_DTOA_SHORTEST	kenlm/util/double-conversion/fast-dtoa.h	/^  FAST_DTOA_SHORTEST,$/;"	e	enum:double_conversion::FastDtoaMode
FAST_DTOA_SHORTEST_SINGLE	kenlm/util/double-conversion/fast-dtoa.h	/^  FAST_DTOA_SHORTEST_SINGLE,$/;"	e	enum:double_conversion::FastDtoaMode
FD	kenlm/util/file.hh	/^    int FD() const { return fd_; }$/;"	f	class:util::FDException
FDException	kenlm/util/file.cc	/^FDException::FDException(int fd) throw() : fd_(fd), name_guess_(NameFromFD(fd)) {$/;"	f	class:util::FDException
FDException	kenlm/util/file.hh	/^class FDException : public ErrnoException {$/;"	c	namespace:util
FDOpenOrThrow	kenlm/util/file.cc	/^std::FILE *FDOpenOrThrow(scoped_fd &file) {$/;"	f	namespace:util
FDOpenReadOrThrow	kenlm/util/file.cc	/^std::FILE *FDOpenReadOrThrow(scoped_fd &file) {$/;"	f	namespace:util
FIXED	kenlm/util/double-conversion/double-conversion.h	/^    FIXED,$/;"	e	enum:double_conversion::DoubleToStringConverter::DtoaMode
FLOAT_TO_NGLM_PROB	HLVLM.h	126;"	d
FLOAT_TO_NGLM_PROB	HLVLM.h	134;"	d
FMakeTemp	kenlm/util/file.cc	/^std::FILE *FMakeTemp(const StringPiece &base) {$/;"	f	namespace:util
FSLM	HLVLM.h	/^typedef struct _FSLM FSLM;$/;"	t	typeref:struct:_FSLM
FSLMType	HLVLM.h	/^typedef enum {fslm_ngram, fslm_latlm, kenlm} FSLMType;$/;"	t	typeref:enum:__anon1
FSLM_LatArc	HLVLM.h	/^} FSLM_LatArc;$/;"	t	typeref:struct:_FSLM_LatArc
FSLM_LatNode	HLVLM.h	/^typedef struct _FSLM_LatNode  FSLM_LatNode;$/;"	t	typeref:struct:_FSLM_LatNode
FSLM_latlm	HLVLM.h	/^typedef struct _FSLM_latlm FSLM_latlm;$/;"	t	typeref:struct:_FSLM_latlm
FSLM_ngram	HLVLM.h	/^typedef struct _FSLM_ngram FSLM_ngram;$/;"	t	typeref:struct:_FSLM_ngram
FSyncOrThrow	kenlm/util/file.cc	/^void FSyncOrThrow(int fd) {$/;"	f	namespace:util
FVTransModels	HDecode.c	/^void FVTransModels (HMMSet *hset, BlockMatrix transMat)$/;"	f
FVTransModels	HDecode.mod.c	/^void FVTransModels (HMMSet *hset, BlockMatrix transMat)$/;"	f
FakeOFStream	kenlm/util/fake_ofstream.hh	/^    explicit FakeOFStream(int out = -1, std::size_t buffer_size = 1048576)$/;"	f	class:util::FakeOFStream
FakeOFStream	kenlm/util/fake_ofstream.hh	/^class FakeOFStream {$/;"	c	namespace:util
FakeSEModelAlign	HLVRec-traceback.c	/^void FakeSEModelAlign(Lattice *lat, LArc *la)$/;"	f
FakeSEpath	HLVRec-traceback.c	/^AltWordendHyp *FakeSEpath (DecoderInst *dec, RelToken *tok, Boolean useLM)$/;"	f
FastDtoa	kenlm/util/double-conversion/fast-dtoa.cc	/^bool FastDtoa(double v,$/;"	f	namespace:double_conversion
FastDtoaMode	kenlm/util/double-conversion/fast-dtoa.h	/^enum FastDtoaMode {$/;"	g	namespace:double_conversion
FastFixedDtoa	kenlm/util/double-conversion/fixed-dtoa.cc	/^bool FastFixedDtoa(double v,$/;"	f	namespace:double_conversion
FastMakeNode	kenlm/lm/search_hashed.hh	/^    bool FastMakeNode(const WordIndex *begin, const WordIndex *end, Node &node) const {$/;"	f	class:lm::ngram::detail::HashedSearch
FastMakeNode	kenlm/lm/search_trie.hh	/^    bool FastMakeNode(const WordIndex *begin, const WordIndex *end, Node &node) const {$/;"	f	class:lm::ngram::trie::TrieSearch
Fast_LMLA_LMState	HLVLM.c	/^LMState Fast_LMLA_LMState (FSLM *lm, LMState src)$/;"	f
Fast_LMLA_LMState_kenlm	HLVLM.c	/^lm::ngram::State Fast_LMLA_LMState_kenlm (lm::base::Model *lm_kenlm, lm::ngram::State src)$/;"	f
File	kenlm/lm/filter/arpa_io.hh	/^    const std::string &File() const throw() { return file_name_; }$/;"	f	class:lm::ARPAOutputException
File	kenlm/util/stream/sort.hh	/^    int File() const { return log_; }$/;"	f	class:util::stream::Offsets
FileBuffer	kenlm/util/stream/io.hh	/^    explicit FileBuffer(int fd) : file_(fd) {}$/;"	f	class:util::stream::FileBuffer
FileBuffer	kenlm/util/stream/io.hh	/^class FileBuffer {$/;"	c	namespace:util::stream
FileName	kenlm/util/file_piece.hh	/^    const std::string &FileName() const { return file_name_; }$/;"	f	class:util::FilePiece
FileOpenException	kenlm/util/exception.hh	/^	FileOpenException() throw() {}$/;"	f	class:util::FileOpenException
FileOpenException	kenlm/util/exception.hh	/^class FileOpenException : public Exception {$/;"	c	namespace:util
FilePiece	kenlm/util/file_piece.cc	/^FilePiece::FilePiece(const char *name, std::ostream *show_progress, std::size_t min_buffer) : $/;"	f	class:util::FilePiece
FilePiece	kenlm/util/file_piece.cc	/^FilePiece::FilePiece(int fd, const char *name, std::ostream *show_progress, std::size_t min_buffer) : $/;"	f	class:util::FilePiece
FilePiece	kenlm/util/file_piece.cc	/^FilePiece::FilePiece(std::istream &stream, const char *name, std::size_t min_buffer) :$/;"	f	class:util::FilePiece
FilePiece	kenlm/util/file_piece.hh	/^class FilePiece {$/;"	c	namespace:util
Fill	kenlm/lm/filter/thread.hh	/^    InputBuffer &Fill(uint64_t sequence) {$/;"	f	class:lm::ThreadBatch
FillDigits32	kenlm/util/double-conversion/fixed-dtoa.cc	/^static void FillDigits32(uint32_t number, Vector<char> buffer, int* length) {$/;"	f	namespace:double_conversion
FillDigits32FixedLength	kenlm/util/double-conversion/fixed-dtoa.cc	/^static void FillDigits32FixedLength(uint32_t number, int requested_length,$/;"	f	namespace:double_conversion
FillDigits64	kenlm/util/double-conversion/fixed-dtoa.cc	/^static void FillDigits64(uint64_t number, Vector<char> buffer, int* length) {$/;"	f	namespace:double_conversion
FillDigits64FixedLength	kenlm/util/double-conversion/fixed-dtoa.cc	/^static void FillDigits64FixedLength(uint64_t number, int requested_length,$/;"	f	namespace:double_conversion
FillFractionals	kenlm/util/double-conversion/fixed-dtoa.cc	/^static void FillFractionals(uint64_t fractionals, int exponent,$/;"	f	namespace:double_conversion
Filter	kenlm/lm/filter/wrapper.hh	/^    typedef FilterT Filter;$/;"	t	class:lm::ContextFilter
FilterWorker	kenlm/lm/filter/thread.hh	/^    FilterWorker(const Filter &filter, util::PCQueue<Request> &done) : filter_(filter), done_(done) {}$/;"	f	class:lm::FilterWorker
FilterWorker	kenlm/lm/filter/thread.hh	/^template <class Batch, class Filter> class FilterWorker {$/;"	c	namespace:lm
Finalize	kenlm/util/double-conversion/utils.h	/^  char* Finalize() {$/;"	f	class:double_conversion::StringBuilder
Find	kenlm/lm/trie.cc	/^template <class Bhiksha> util::BitAddress BitPackedMiddle<Bhiksha>::Find(WordIndex word, NodeRange &range, uint64_t &pointer) const {$/;"	f	class:lm::ngram::trie::BitPackedMiddle
Find	kenlm/lm/trie.cc	/^util::BitAddress BitPackedLongest::Find(WordIndex word, const NodeRange &range) const {$/;"	f	class:lm::ngram::trie::BitPackedLongest
Find	kenlm/lm/trie.hh	/^    UnigramPointer Find(WordIndex word, NodeRange &next) const {$/;"	f	class:lm::ngram::trie::Unigram
Find	kenlm/util/probing_hash_table.hh	/^    template <class Key> bool Find(const Key key, ConstIterator &out) const {$/;"	f	class:util::AutoProbing
Find	kenlm/util/probing_hash_table.hh	/^    template <class Key> bool Find(const Key key, ConstIterator &out) const {$/;"	f	class:util::ProbingHashTable
Find	kenlm/util/tokenize_piece.hh	/^    StringPiece Find(const StringPiece &in) const {$/;"	f	class:util::AnyCharacter
Find	kenlm/util/tokenize_piece.hh	/^    StringPiece Find(const StringPiece &in) const {$/;"	f	class:util::AnyCharacterLast
Find	kenlm/util/tokenize_piece.hh	/^    StringPiece Find(const StringPiece &in) const {$/;"	f	class:util::BoolCharacter
Find	kenlm/util/tokenize_piece.hh	/^    StringPiece Find(const StringPiece &in) const {$/;"	f	class:util::MultiCharacter
Find	kenlm/util/tokenize_piece.hh	/^    StringPiece Find(const StringPiece &in) const {$/;"	f	class:util::SingleCharacter
FindAddTLCN	HLVNet.c	/^TLexConNode *FindAddTLCN (MemHeap *heap, TLexNet *net, int layerId, int *n, TLexConNode *lcnHashTab[], LabId lc, LabId rc)$/;"	f
FindAddTLexNode	HLVNet.c	/^TLexNode *FindAddTLexNode (MemHeap *heap, TLexNet *net, int layerId, int *n, TLexNode *lnHashTab[], LexNodeType type , HLink hmm)$/;"	f
FindBitPacked	kenlm/lm/trie.cc	/^bool FindBitPacked(const void *base, uint64_t key_mask, uint8_t key_bits, uint8_t total_bits, uint64_t begin_index, uint64_t end_index, const uint64_t max_vocab, const uint64_t key, uint64_t &at_index) {$/;"	f	namespace:lm::ngram::trie::__anon25
FindBlanks	kenlm/lm/search_trie.cc	/^    FindBlanks(unsigned char order, const ProbBackoff *unigrams, SRISucks &messages)$/;"	f	class:lm::ngram::trie::__anon24::FindBlanks
FindBlanks	kenlm/lm/search_trie.cc	/^class FindBlanks {$/;"	c	namespace:lm::ngram::trie::__anon24	file:
FindContexts_s	HLVNet.c	/^void FindContexts_s (HMMSet *hset, STLexNode *n)$/;"	f
FindDelimiterOrEOF	kenlm/util/file_piece.cc	/^const char *FilePiece::FindDelimiterOrEOF(const bool *delim)  {$/;"	f	class:util::FilePiece
FindDifference	kenlm/lm/builder/adjust_counts.cc	/^const WordIndex* FindDifference(const NGram &full, const NGram &lower_last) {$/;"	f	namespace:lm::builder::__anon8
FindHMM	HLVNet.c	/^HLink FindHMM (HMMSet *hset, LabId id)$/;"	f
FindHMMLink	HLVNet.c	/^TLexLink *FindHMMLink (TLexNode *ln, HLink hmm)$/;"	f
FindLatArc	HLVLM.c	/^FSLM_LatArc *FindLatArc (FSLM_LatArc *low, FSLM_LatArc *hi, PronId pronId)$/;"	f
FindLexNetLab	HDecode.c	/^BestInfo *FindLexNetLab (MemHeap *heap, LexNode *ln, LLink ll, HTime frameDur)$/;"	f
FindLexNetLab	HDecode.mod.c	/^BestInfo *FindLexNetLab (MemHeap *heap, LexNode *ln, LLink ll, HTime frameDur)$/;"	f
FindLower	kenlm/lm/search_hashed.cc	/^template <class Value> void FindLower($/;"	f	namespace:lm::ngram::__anon23
FindMinLatArc	HLVLM.c	/^FSLM_LatArc *FindMinLatArc (FSLM_LatArc *low, FSLM_LatArc *hi, PronId minPron)$/;"	f
FindMinSEntry	HLVLM.c	/^SEntry *FindMinSEntry (SEntry *se, int nse, PronId minPron)$/;"	f
FindMinSEntryP	HLVLM.c	/^static SEntry *FindMinSEntryP (SEntry *low, SEntry *hi, PronId minPron)$/;"	f	file:
FindOrInsert	kenlm/lm/vocab.hh	/^    WordIndex FindOrInsert(const StringPiece &word) {$/;"	f	class:lm::ngram::GrowableVocab
FindOrInsert	kenlm/util/probing_hash_table.hh	/^    template <class T> bool FindOrInsert(const T &t, MutableIterator &out) {$/;"	f	class:util::AutoProbing
FindOrInsert	kenlm/util/probing_hash_table.hh	/^    template <class T> bool FindOrInsert(const T &t, MutableIterator &out) {$/;"	f	class:util::ProbingHashTable
FindSEntry	HLVLM.c	/^static SEntry *FindSEntry (SEntry *se, PronId pronId, int l, int h)$/;"	f	file:
FindStringPiece	kenlm/util/string_piece_hash.hh	/^template <class T> typename T::const_iterator FindStringPiece(const T &t, const StringPiece &key) {$/;"	f
FindStringPiece	kenlm/util/string_piece_hash.hh	/^template <class T> typename T::iterator FindStringPiece(T &t, const StringPiece &key) {$/;"	f
FindTriphone	HLVNet.c	/^HLink FindTriphone (HMMSet *hset, LabId a, LabId b, LabId c)$/;"	f
Finish	kenlm/lm/filter/arpa_io.cc	/^void ARPAOutput::Finish() {$/;"	f	class:lm::ARPAOutput
Finish	kenlm/lm/filter/format.hh	/^    void Finish() { B::output_.Finish(); }$/;"	f	class:lm::DispatchARPAInput
Finish	kenlm/lm/filter/format.hh	/^    void Finish() {$/;"	f	class:lm::MultipleARPAOutput
Finish	kenlm/lm/left.hh	/^    float Finish() {$/;"	f	class:lm::ngram::RuleScore
Finish	kenlm/util/fake_ofstream.hh	/^    void Finish() {$/;"	f	class:util::FakeOFStream
FinishFile	kenlm/lm/binary_format.cc	/^void BinaryFormat::FinishFile(const Config &config, ModelType model_type, unsigned int search_version, const std::vector<uint64_t> &counts) {$/;"	f	class:lm::ngram::BinaryFormat
Finished	kenlm/util/ersatz_progress.hh	/^    void Finished() {$/;"	f	class:util::ErsatzProgress
Finished	kenlm/util/stream/multi_progress.cc	/^void MultiProgress::Finished() {$/;"	f	class:util::stream::MultiProgress
FinishedAdding	kenlm/lm/search_trie.cc	/^    void FinishedAdding() {$/;"	f	class:lm::ngram::trie::__anon24::BackoffMessages	file:
FinishedAppending	kenlm/util/stream/sort.hh	/^    void FinishedAppending() {$/;"	f	class:util::stream::Offsets
FinishedInserting	kenlm/util/probing_hash_table.hh	/^    void FinishedInserting() {}$/;"	f	class:util::ProbingHashTable
FinishedLoading	kenlm/lm/bhiksha.cc	/^void ArrayBhiksha::FinishedLoading(const Config &config) {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
FinishedLoading	kenlm/lm/bhiksha.hh	/^    void FinishedLoading(const Config &\/*config*\/) {}$/;"	f	class:lm::ngram::trie::DontBhiksha
FinishedLoading	kenlm/lm/quantize.cc	/^void SeparatelyQuantize::FinishedLoading(const Config &config) {$/;"	f	class:lm::ngram::SeparatelyQuantize
FinishedLoading	kenlm/lm/quantize.hh	/^    void FinishedLoading(const Config &) {}$/;"	f	class:lm::ngram::DontQuantize
FinishedLoading	kenlm/lm/trie.cc	/^template <class Bhiksha> void BitPackedMiddle<Bhiksha>::FinishedLoading(uint64_t next_end, const Config &config) {$/;"	f	class:lm::ngram::trie::BitPackedMiddle
FinishedLoading	kenlm/lm/vocab.cc	/^void ProbingVocabulary::FinishedLoading() {$/;"	f	class:lm::ngram::ProbingVocabulary
FinishedLoading	kenlm/lm/vocab.cc	/^void SortedVocabulary::FinishedLoading(ProbBackoff *reorder_vocab) {$/;"	f	class:lm::ngram::SortedVocabulary
FinishedLoading	kenlm/lm/vocab.hh	/^    template <class Weights> void FinishedLoading(Weights * \/*reorder_vocab*\/) {$/;"	f	class:lm::ngram::ProbingVocabulary
FirstCombine	kenlm/lm/trie_sort.cc	/^struct FirstCombine {$/;"	s	namespace:lm::ngram::trie::__anon26	file:
FirstIntersection	kenlm/util/multi_intersection.hh	/^template <class Iterator, class Less> boost::optional<typename std::iterator_traits<Iterator>::value_type> FirstIntersection(std::vector<boost::iterator_range<Iterator> > &sets, const Less less) {$/;"	f	namespace:util
FirstIntersection	kenlm/util/multi_intersection.hh	/^template <class Iterator> boost::optional<typename std::iterator_traits<Iterator>::value_type> FirstIntersection(std::vector<boost::iterator_range<Iterator> > &sets) {$/;"	f	namespace:util
FirstIntersectionSorted	kenlm/util/multi_intersection.hh	/^template <class Iterator, class Less> boost::optional<typename std::iterator_traits<Iterator>::value_type> FirstIntersectionSorted(std::vector<boost::iterator_range<Iterator> > &sets, const Less &less = std::less<typename std::iterator_traits<Iterator>::value_type>()) {$/;"	f	namespace:util::detail
FixedArray	kenlm/util/fixed_array.hh	/^    FixedArray() $/;"	f	class:util::FixedArray
FixedArray	kenlm/util/fixed_array.hh	/^    FixedArray(const FixedArray &from) {$/;"	f	class:util::FixedArray
FixedArray	kenlm/util/fixed_array.hh	/^    explicit FixedArray(std::size_t limit) {$/;"	f	class:util::FixedArray
FixedArray	kenlm/util/fixed_array.hh	/^template <class T> class FixedArray {$/;"	c	namespace:util
FixedWidthParameters	kenlm/lm/binary_format.hh	/^struct FixedWidthParameters {$/;"	s	namespace:lm::ngram
FixupMultiply10	kenlm/util/double-conversion/bignum-dtoa.cc	/^static void FixupMultiply10(int estimated_power, bool is_even,$/;"	f	namespace:double_conversion
Flags	kenlm/util/double-conversion/double-conversion.h	/^  enum Flags {$/;"	g	class:double_conversion::DoubleToStringConverter
Flags	kenlm/util/double-conversion/double-conversion.h	/^  enum Flags {$/;"	g	class:double_conversion::StringToDoubleConverter
FloatEnc	kenlm/util/bit_packing.hh	/^typedef union { float f; uint32_t i; } FloatEnc;$/;"	t	namespace:util	typeref:union:util::__anon31
FloatSize	kenlm/util/bit_packing.cc	/^typedef StaticCheck<sizeof(float) == 4>::StaticAssertionPassed FloatSize;$/;"	t	namespace:util::__anon30	file:
Flush	kenlm/lm/filter/format.hh	/^    template <class Output> void Flush(Output &output) {$/;"	f	class:lm::BinaryOutputBuffer
Flush	kenlm/lm/filter/format.hh	/^    template <class Output> void Flush(Output &output) {$/;"	f	class:lm::MultipleOutputBuffer
Flush	kenlm/lm/filter/phrase.hh	/^    void Flush() const {}$/;"	f	class:lm::phrase::Multiple
Flush	kenlm/lm/filter/thread.hh	/^    template <class RealOutput> void Flush(RealOutput &output) {$/;"	f	class:lm::ThreadBatch
Flush	kenlm/lm/filter/thread.hh	/^    void Flush() {$/;"	f	class:lm::Controller
Flush	kenlm/lm/filter/vocab.hh	/^    void Flush() const {}$/;"	f	class:lm::vocab::Multiple
Flush	kenlm/lm/filter/wrapper.hh	/^    void Flush() const {}$/;"	f	class:lm::BinaryFilter
Flush	kenlm/lm/filter/wrapper.hh	/^    void Flush() const {}$/;"	f	class:lm::ContextFilter
Flush	kenlm/util/fake_ofstream.hh	/^    void Flush() {$/;"	f	class:util::FakeOFStream
FlushInput	kenlm/lm/filter/thread.hh	/^    void FlushInput() {$/;"	f	class:lm::Controller
FormatLoadException	kenlm/lm/lm_exception.cc	/^FormatLoadException::FormatLoadException() throw() {}$/;"	f	class:lm::FormatLoadException
FormatLoadException	kenlm/lm/lm_exception.hh	/^class FormatLoadException : public LoadException {$/;"	c	namespace:lm
Found	kenlm/lm/quantize.hh	/^        bool Found() const { return address_.base != NULL; }$/;"	f	class:lm::ngram::SeparatelyQuantize::LongestPointer
Found	kenlm/lm/quantize.hh	/^        bool Found() const { return address_.base != NULL; }$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
Found	kenlm/lm/quantize.hh	/^        bool Found() const {$/;"	f	class:lm::ngram::DontQuantize::LongestPointer
Found	kenlm/lm/quantize.hh	/^        bool Found() const {$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
Found	kenlm/lm/search_hashed.hh	/^    bool Found() const {$/;"	f	class:lm::ngram::detail::LongestPointer
Found	kenlm/lm/trie.hh	/^    bool Found() const { return to_ != NULL; }$/;"	f	class:lm::ngram::trie::UnigramPointer
Found	kenlm/lm/value.hh	/^    bool Found() const { return to_ != 0; }$/;"	f	class:lm::ngram::GenericProbingProxy
Found	kenlm/lm/value.hh	/^    bool Found() const { return to_ != 0; }$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
FreeAll	kenlm/util/pool.cc	/^void Pool::FreeAll() {$/;"	f	class:util::Pool
FreeLMCache	HLVRec-LM.c	/^static void FreeLMCache (LMCache *cache)$/;"	f	file:
FreeMiddles	kenlm/lm/search_trie.hh	/^    void FreeMiddles() {$/;"	f	class:lm::ngram::trie::TrieSearch
FromMax	kenlm/util/bit_packing.hh	/^  void FromMax(uint64_t max_value) {$/;"	f	struct:util::BitsMask
Full	kenlm/lm/trie_sort.hh	/^    FILE *Full(unsigned char order) {$/;"	f	class:lm::ngram::trie::SortedFiles
FullPrint	kenlm/lm/ngram_query.hh	/^struct FullPrint : public BasicPrint {$/;"	s	namespace:lm::ngram
FullScore	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> FullScoreReturn GenericModel<Search, VocabularyT>::FullScore(const State &in_state, const WordIndex new_word, State &out_state) const {$/;"	f	class:lm::ngram::detail::GenericModel
FullScore	kenlm/lm/wrappers/nplm.cc	/^FullScoreReturn Model::FullScore(const State &from, const WordIndex new_word, State &out_state) const {$/;"	f	class:lm::np::Model
FullScoreForgotState	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> FullScoreReturn GenericModel<Search, VocabularyT>::FullScoreForgotState(const WordIndex *context_rbegin, const WordIndex *context_rend, const WordIndex new_word, State &out_state) const {$/;"	f	class:lm::ngram::detail::GenericModel
FullScoreForgotState	kenlm/lm/wrappers/nplm.cc	/^FullScoreReturn Model::FullScoreForgotState(const WordIndex *context_rbegin, const WordIndex *context_rend, const WordIndex new_word, State &out_state) const {$/;"	f	class:lm::np::Model
FullScoreReturn	kenlm/lm/return.hh	/^struct FullScoreReturn {$/;"	s	namespace:lm
GC_ALTPATH_PREV	HLVRec-GC.c	51;"	d	file:
GZException	kenlm/util/read_compressed.cc	/^GZException::GZException() throw() {}$/;"	f	class:util::GZException
GZException	kenlm/util/read_compressed.hh	/^class GZException : public CompressedException {$/;"	c	namespace:util
GZip	kenlm/util/read_compressed.cc	/^    GZip(const void *base, std::size_t amount) {$/;"	f	class:util::__anon45::GZip
GZip	kenlm/util/read_compressed.cc	/^class GZip {$/;"	c	namespace:util::__anon45	file:
GarbageCollectPaths	HLVRec-GC.c	/^static void GarbageCollectPaths (DecoderInst *dec)$/;"	f	file:
GenerateCountedDigits	kenlm/util/double-conversion/bignum-dtoa.cc	/^static void GenerateCountedDigits(int count, int* decimal_point,$/;"	f	namespace:double_conversion
GenerateShortestDigits	kenlm/util/double-conversion/bignum-dtoa.cc	/^static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,$/;"	f	namespace:double_conversion
GenericModel	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> GenericModel<Search, VocabularyT>::GenericModel(const char *file, const Config &init_config) : backing_(init_config) {$/;"	f	class:lm::ngram::detail::GenericModel
GenericModel	kenlm/lm/model.hh	/^template <class Search, class VocabularyT> class GenericModel : public base::ModelFacade<GenericModel<Search, VocabularyT>, State, VocabularyT> {$/;"	c	namespace:lm::ngram::detail
GenericProbingProxy	kenlm/lm/value.hh	/^    GenericProbingProxy() : to_(0) {}$/;"	f	class:lm::ngram::GenericProbingProxy
GenericProbingProxy	kenlm/lm/value.hh	/^    explicit GenericProbingProxy(const Weights &to) : to_(&to) {}$/;"	f	class:lm::ngram::GenericProbingProxy
GenericProbingProxy	kenlm/lm/value.hh	/^template <class Weights> class GenericProbingProxy {$/;"	c	namespace:lm::ngram
GenericStreams	kenlm/util/stream/multi_stream.hh	/^    GenericStreams() {}$/;"	f	class:util::stream::GenericStreams
GenericStreams	kenlm/util/stream/multi_stream.hh	/^    GenericStreams(const ChainPositions &positions) {$/;"	f	class:util::stream::GenericStreams
GenericStreams	kenlm/util/stream/multi_stream.hh	/^template <class T> class GenericStreams : public util::FixedArray<T> {$/;"	c	namespace:util::stream
GenericTrieUnigramProxy	kenlm/lm/value.hh	/^    GenericTrieUnigramProxy() : to_(0) {}$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
GenericTrieUnigramProxy	kenlm/lm/value.hh	/^    explicit GenericTrieUnigramProxy(const Weights &to) : to_(&to) {}$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
GenericTrieUnigramProxy	kenlm/lm/value.hh	/^template <class Weights> class GenericTrieUnigramProxy {$/;"	c	namespace:lm::ngram
Get	kenlm/lm/builder/discount.hh	/^  float Get(uint64_t count) const {$/;"	f	struct:lm::builder::Discount
Get	kenlm/lm/builder/ngram_stream.hh	/^    const void *Get() const { return stream_.Get(); }$/;"	f	class:lm::builder::NGramStream
Get	kenlm/lm/builder/ngram_stream.hh	/^    void *Get() { return stream_.Get(); }$/;"	f	class:lm::builder::NGramStream
Get	kenlm/util/stream/block.hh	/^    const void *Get() const { return mem_; }$/;"	f	class:util::stream::Block
Get	kenlm/util/stream/block.hh	/^    void *Get() { return mem_; }$/;"	f	class:util::stream::Block
Get	kenlm/util/stream/stream.hh	/^    const void *Get() const { return current_; }$/;"	f	class:util::stream::Stream
Get	kenlm/util/stream/stream.hh	/^    void *Get() { return current_; }$/;"	f	class:util::stream::Stream
GetBlank	kenlm/lm/search_trie.cc	/^    ProbBackoff GetBlank(unsigned char total_order, unsigned char order, const WordIndex *indices) {$/;"	f	class:lm::ngram::trie::__anon24::SRISucks
GetCachedPowerForBinaryExponentRange	kenlm/util/double-conversion/cached-powers.cc	/^void PowersOfTenCache::GetCachedPowerForBinaryExponentRange($/;"	f	class:double_conversion::PowersOfTenCache
GetCachedPowerForDecimalExponent	kenlm/util/double-conversion/cached-powers.cc	/^void PowersOfTenCache::GetCachedPowerForDecimalExponent(int requested_exponent,$/;"	f	class:double_conversion::PowersOfTenCache
GetChain	kenlm/util/stream/chain.hh	/^    const Chain &GetChain() const { return *chain_; }$/;"	f	class:util::stream::ChainPosition
GetDelegate	kenlm/util/sized_iterator.hh	/^    const Delegate &GetDelegate() const { return delegate_; }$/;"	f	class:util::SizedCompare
GetHeader	kenlm/lm/builder/output.hh	/^    const HeaderInfo &GetHeader() const { return header_; }$/;"	f	class:lm::builder::Output
GetHeader	kenlm/lm/builder/output.hh	/^inline const HeaderInfo &OutputHook::GetHeader() const {$/;"	f	class:lm::builder::OutputHook
GetKey	kenlm/lm/builder/corpus_count.cc	/^  Key GetKey() const { return key; }$/;"	f	struct:lm::builder::__anon9::DedupeEntry
GetKey	kenlm/lm/builder/corpus_count.cc	/^  uint64_t GetKey() const { return key; }$/;"	f	struct:lm::builder::__anon9::VocabEntry
GetKey	kenlm/lm/search_hashed.hh	/^  uint64_t GetKey() const {$/;"	f	struct:lm::ngram::detail::ProbEntry
GetKey	kenlm/lm/value.hh	/^    Key GetKey() const { return key; }$/;"	f	struct:lm::ngram::RestValue::ProbingEntry
GetKey	kenlm/lm/value.hh	/^    uint64_t GetKey() const { return key; }$/;"	f	struct:lm::ngram::BackoffValue::ProbingEntry
GetKey	kenlm/lm/vocab.hh	/^  uint64_t GetKey() const { return key; }$/;"	f	struct:lm::ngram::ProbingVocabularyEntry
GetKey	kenlm/util/joint_sort.hh	/^      const typename std::iterator_traits<KeyIter>::value_type &GetKey() const { return key; }$/;"	f	struct:util::detail::JointProxy::__anon40
GetKey	kenlm/util/joint_sort.hh	/^    typename std::iterator_traits<KeyIter>::reference GetKey() const {$/;"	f	class:util::detail::JointProxy
GetLMEntry	HLVLM.c	/^static void GetLMEntry (FSLM_ngram *nglm, Source *src, Boolean bin, int n, LMId *ndx, $/;"	f	file:
GetLMWord	HLVLM.c	/^static void GetLMWord (Source *src, char *buf, Boolean raw)$/;"	f	file:
GetNEntry	HLVLM.c	/^NEntry *GetNEntry (FSLM_ngram *nglm, LMId ndx[NSIZE], Boolean create)$/;"	f
GetProb	HLVLM.c	/^static LogFloat GetProb(Source *src, Boolean bin)$/;"	f	file:
GetState	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> void GenericModel<Search, VocabularyT>::GetState(const WordIndex *context_rbegin, const WordIndex *context_rend, State &out_state) const {$/;"	f	class:lm::ngram::detail::GenericModel
GetTables	kenlm/lm/quantize.hh	/^    const Bins *GetTables(unsigned char order_minus_2) const { return tables_[order_minus_2]; }$/;"	f	class:lm::ngram::SeparatelyQuantize
GetVocabFD	kenlm/lm/builder/output.hh	/^    int GetVocabFD() const { return vocab_fd_; }$/;"	f	class:lm::builder::Output
GetVocabFD	kenlm/lm/builder/output.hh	/^inline int OutputHook::GetVocabFD() const {$/;"	f	class:lm::builder::OutputHook
GetVocabulary	kenlm/lm/facade.hh	/^    const Vocabulary &GetVocabulary() const { return *static_cast<const Vocabulary*>(&BaseVocabulary()); }$/;"	f	class:lm::base::ModelFacade
GetWall	kenlm/util/usage.cc	/^Wall GetWall() {$/;"	f	namespace:util::__anon49
Gram	kenlm/lm/builder/interpolate.cc	/^    void Gram(unsigned \/*order_minus_1*\/, float full_backoff, ProbBackoff &out) const {$/;"	f	class:lm::builder::__anon12::OutputProbBackoff
Gram	kenlm/lm/builder/interpolate.cc	/^    void Gram(unsigned order_minus_1, float full_backoff, ProbBackoff &out) {$/;"	f	class:lm::builder::__anon12::OutputQ
Gram	kenlm/lm/search_trie.cc	/^  Gram(const WordIndex *in_begin, unsigned char order) : begin(in_begin), end(in_begin + order) {}$/;"	f	struct:lm::ngram::trie::__anon24::Gram
Gram	kenlm/lm/search_trie.cc	/^struct Gram {$/;"	s	namespace:lm::ngram::trie::__anon24	file:
Greater	kenlm/util/stream/sort.hh	/^        explicit Greater(const Compare &compare) : compare_(compare) {}$/;"	f	class:util::stream::MergeQueue::Greater
Greater	kenlm/util/stream/sort.hh	/^    class Greater : public std::binary_function<const Entry &, const Entry &, bool> {$/;"	c	class:util::stream::MergeQueue
Grisu3	kenlm/util/double-conversion/fast-dtoa.cc	/^static bool Grisu3(double v,$/;"	f	namespace:double_conversion
Grisu3Counted	kenlm/util/double-conversion/fast-dtoa.cc	/^static bool Grisu3Counted(double v,$/;"	f	namespace:double_conversion
GrowForSearch	kenlm/lm/binary_format.cc	/^void *BinaryFormat::GrowForSearch(std::size_t memory_size, std::size_t vocab_pad, void *&vocab_base) {$/;"	f	class:lm::ngram::BinaryFormat
GrowableVocab	kenlm/lm/vocab.hh	/^    template <class NewWordConstruct> GrowableVocab(WordIndex initial_size, const NewWordConstruct &new_word_construct = NewWordAction())$/;"	f	class:lm::ngram::GrowableVocab
GrowableVocab	kenlm/lm/vocab.hh	/^template <class NewWordAction = NoOpUniqueWords> class GrowableVocab {$/;"	c	namespace:lm::ngram
GuardLarge	kenlm/util/file.cc	/^std::size_t GuardLarge(std::size_t size) {$/;"	f	namespace:util::__anon34
GuessPhysicalMemory	kenlm/util/usage.cc	/^uint64_t GuessPhysicalMemory() {$/;"	f	namespace:util
HASH1	HLVNet.c	213;"	d	file:
HASH2	HLVNet.c	214;"	d	file:
HASH_PROBING	kenlm/lm/model_type.hh	/^const ModelType HASH_PROBING = PROBING;$/;"	m	namespace:lm::ngram
HEADER	Makefile	/^HEADER = HLVLM.h  HLVModel.h  HLVNet.h  HLVRec.h config.h$/;"	m
HLVMODEL_BLOCK_BASE	HLVModel.h	135;"	d
HLVMODEL_BLOCK_GCONST	HLVModel.h	138;"	d
HLVMODEL_BLOCK_GCONST_OFFSET	HLVModel.h	136;"	d
HLVMODEL_BLOCK_INVVAR_OFFSET	HLVModel.h	143;"	d
HLVMODEL_BLOCK_MEAN_OFFSET	HLVModel.h	142;"	d
HLVMODEL_BLOCK_MIXW	HLVModel.h	139;"	d
HLVMODEL_BLOCK_MIXW_OFFSET	HLVModel.h	137;"	d
HLVMODEL_BLOCK_MPDF	HLVModel.h	141;"	d
HLVMODEL_BLOCK_NMIX	HLVModel.h	140;"	d
HLVMODEL_VEC_ALIGN	HLVModel.h	95;"	d
HLVMODEL_VEC_PAD	HLVModel.h	96;"	d
HTKLIB	Makefile	/^HTKLIB  = 	$(inc)\/HTKLib.a $/;"	m
HTKLIB	Makefile	/^HTKLIB = $(inc)\/HTKLiblv.a$/;"	m
Handle1PhonePron	HLVNet.c	/^void Handle1PhonePron (MemHeap *heap, TLexNet *net, Pron pron)$/;"	f
HandleError	kenlm/util/read_compressed.cc	/^    void HandleError(int value) {$/;"	f	class:util::__anon45::BZip	file:
HandleError	kenlm/util/read_compressed.cc	/^    void HandleError(lzma_ret value) {$/;"	f	class:util::__anon45::XZip	file:
HandleSpSkipLayer	HLVRec-propagate.c	/^void HandleSpSkipLayer (DecoderInst *dec, LexNodeInst *inst)$/;"	f
HandleSpecialValues	kenlm/util/double-conversion/double-conversion.cc	/^bool DoubleToStringConverter::HandleSpecialValues($/;"	f	class:double_conversion::DoubleToStringConverter
HandleStrerror	kenlm/util/exception.cc	/^const char *HandleStrerror(const char *ret, const char * \/*buf*\/) {$/;"	f	namespace:util::__anon33
HandleStrerror	kenlm/util/exception.cc	/^const char *HandleStrerror(int ret, const char *buf) {$/;"	f	namespace:util::__anon33
HandleWordend	HLVRec-propagate.c	/^static void HandleWordend (DecoderInst *dec, LexNode *ln)$/;"	f	file:
Handler	kenlm/util/thread_pool.hh	/^    typedef HandlerT Handler;$/;"	t	class:util::ThreadPool
Handler	kenlm/util/thread_pool.hh	/^    typedef HandlerT Handler;$/;"	t	class:util::Worker
HasExtension	kenlm/lm/blank.hh	/^inline bool HasExtension(const float &backoff) {$/;"	f	namespace:lm::ngram
Hash	kenlm/lm/filter/phrase.hh	/^typedef uint64_t Hash;$/;"	t	namespace:lm::phrase
Hash	kenlm/util/probing_hash_table.hh	/^    typedef HashT Hash;$/;"	t	class:util::AutoProbing
Hash	kenlm/util/probing_hash_table.hh	/^    typedef HashT Hash;$/;"	t	class:util::ProbingHashTable
HashBufferEntry	kenlm/lm/builder/initial_probabilities.cc	/^struct HashBufferEntry : public BufferEntry {$/;"	s	namespace:lm::builder::__anon11	file:
HashForVocab	kenlm/lm/vocab.cc	/^uint64_t HashForVocab(const char *str, std::size_t len) {$/;"	f	namespace:lm::ngram::detail
HashForVocab	kenlm/lm/vocab.hh	/^inline uint64_t HashForVocab(const StringPiece &str) {$/;"	f	namespace:lm::ngram::detail
HashGamma	kenlm/lm/builder/hash_gamma.hh	/^struct HashGamma {$/;"	s	namespace:lm::builder
HashedSearch	kenlm/lm/search_hashed.hh	/^template <class Value> class HashedSearch {$/;"	c	namespace:lm::ngram::detail
Have	kenlm/lm/builder/output.hh	/^    bool Have(HookType hook_type) const {$/;"	f	class:lm::builder::Output
HeaderInfo	kenlm/lm/builder/header_info.hh	/^  HeaderInfo() {}$/;"	f	struct:HeaderInfo
HeaderInfo	kenlm/lm/builder/header_info.hh	/^  HeaderInfo(const std::string& input_file_in, uint64_t token_count_in, const std::vector<uint64_t> &counts_pruned_in)$/;"	f	struct:HeaderInfo
HeaderInfo	kenlm/lm/builder/header_info.hh	/^struct HeaderInfo {$/;"	s
HexCharOfValue	kenlm/util/double-conversion/bignum.cc	/^static char HexCharOfValue(int value) {$/;"	f	namespace:double_conversion
HexCharValue	kenlm/util/double-conversion/bignum.cc	/^static int HexCharValue(char c) {$/;"	f	namespace:double_conversion
HookType	kenlm/lm/builder/output.hh	/^enum HookType {$/;"	g	namespace:lm::builder
I	kenlm/util/proxy_iterator.hh	/^    InnerIterator &I() { return p_.Inner(); }$/;"	f	class:util::ProxyIterator
I	kenlm/util/proxy_iterator.hh	/^    const InnerIterator &I() const { return p_.Inner(); }$/;"	f	class:util::ProxyIterator
INSTALL	Makefile	/^INSTALL = 	\/usr\/bin\/install -c$/;"	m
IStreamReader	kenlm/util/read_compressed.cc	/^    explicit IStreamReader(std::istream &stream) : stream_(stream) {}$/;"	f	class:util::__anon45::IStreamReader
IStreamReader	kenlm/util/read_compressed.cc	/^class IStreamReader : public ReadBase {$/;"	c	namespace:util::__anon45	file:
Ideal	kenlm/util/probing_hash_table.hh	/^    template <class T> MutableIterator Ideal(const T &t) {$/;"	f	class:util::ProbingHashTable
Identity	kenlm/util/exception.hh	/^      typedef T Identity;$/;"	t	struct:util::Exception::ExceptionTag
IdentityAccessor	kenlm/util/sorted_uniform.hh	/^template <class T> class IdentityAccessor {$/;"	c	namespace:util
IdentityHash	kenlm/util/probing_hash_table.hh	/^struct IdentityHash {$/;"	s	namespace:util
IgnoredType	kenlm/util/file.cc	/^typedef CheckOffT<sizeof(off_t)>::True IgnoredType;$/;"	t	namespace:util::__anon36	file:
In	kenlm/util/thread_pool.hh	/^    PCQueue<Request> &In() { return in_; }$/;"	f	class:util::ThreadPool
IncreaseBase	kenlm/util/mmap.hh	/^    void IncreaseBase(uint64_t by) {$/;"	f	class:util::Rolling
Increment	kenlm/util/stream/sort.hh	/^        bool Increment(int fd, std::size_t buf_size, std::size_t entry_size) {$/;"	f	class:util::stream::MergeQueue::Entry
IndependentLeft	kenlm/lm/value.hh	/^    bool IndependentLeft() const {$/;"	f	class:lm::ngram::GenericProbingProxy
Index	kenlm/lm/neural/wordvecs.hh	/^    WordIndex Index(StringPiece str) const { return vocab_.Index(str); }$/;"	f	class:lm::neural::WordVecs
Index	kenlm/lm/virtual_interface.hh	/^    virtual WordIndex Index(const char *str) const {$/;"	f	class:lm::base::Vocabulary
Index	kenlm/lm/virtual_interface.hh	/^    virtual WordIndex Index(const std::string &str) const {$/;"	f	class:lm::base::Vocabulary
Index	kenlm/lm/vocab.hh	/^    WordIndex Index(const StringPiece &str) const {$/;"	f	class:lm::ngram::GrowableVocab
Index	kenlm/lm/vocab.hh	/^    WordIndex Index(const StringPiece &str) const {$/;"	f	class:lm::ngram::ProbingVocabulary
Index	kenlm/lm/vocab.hh	/^    WordIndex Index(const StringPiece &str) const {$/;"	f	class:lm::ngram::SortedVocabulary
Index	kenlm/lm/wrappers/nplm.cc	/^WordIndex Vocabulary::Index(const std::string &str) const {$/;"	f	class:lm::np::Vocabulary
Index	kenlm/lm/wrappers/nplm.hh	/^    WordIndex Index(const StringPiece &str) const {$/;"	f	class:lm::np::Vocabulary
Infinity	kenlm/util/double-conversion/ieee.h	/^  static double Infinity() {$/;"	f	class:double_conversion::Double
Infinity	kenlm/util/double-conversion/ieee.h	/^  static float Infinity() {$/;"	f	class:double_conversion::Single
Init	kenlm/lm/builder/ngram_stream.hh	/^    void Init(const util::stream::ChainPosition &position) {$/;"	f	class:lm::builder::NGramStream
Init	kenlm/lm/facade.hh	/^    void Init(const State &begin_sentence, const State &null_context, const Vocabulary &vocab, unsigned char order) {$/;"	f	class:lm::base::ModelFacade
Init	kenlm/lm/search_trie.cc	/^    void Init(std::size_t entry_size) {$/;"	f	class:lm::ngram::trie::__anon24::BackoffMessages
Init	kenlm/lm/trie.hh	/^    void Init(void *base, uint8_t quant_bits, uint64_t max_vocab) {$/;"	f	class:lm::ngram::trie::BitPackedLongest
Init	kenlm/lm/trie.hh	/^    void Init(void *start) {$/;"	f	class:lm::ngram::trie::Unigram
Init	kenlm/lm/trie_sort.cc	/^void RecordReader::Init(FILE *file, std::size_t entry_size) {$/;"	f	class:lm::ngram::trie::RecordReader
Init	kenlm/util/fixed_array.hh	/^    void Init(std::size_t count) {$/;"	f	class:util::FixedArray
Init	kenlm/util/mmap.hh	/^    void Init(void *data) {$/;"	f	class:util::Rolling
Init	kenlm/util/stream/chain.cc	/^void Link::Init(const ChainPosition &position) {$/;"	f	class:util::stream::Link
Init	kenlm/util/stream/multi_stream.hh	/^    void Init(const ChainPositions &positions) {$/;"	f	class:util::stream::GenericStreams
Init	kenlm/util/stream/multi_stream.hh	/^    void Init(const ChainPositions &positions, std::size_t limit) {$/;"	f	class:util::stream::GenericStreams
Init	kenlm/util/stream/multi_stream.hh	/^inline void ChainPositions::Init(Chains &chains) {$/;"	f	class:util::stream::ChainPositions
Init	kenlm/util/stream/stream.hh	/^    void Init(const ChainPosition &position) {$/;"	f	class:util::stream::Stream
InitDecoderInst	HLVRec.c	/^void InitDecoderInst (DecoderInst *dec, LexNet *net, HTime sampRate, LogFloat beamWidth, $/;"	f
InitForAdjust	kenlm/lm/builder/pipeline.cc	/^    void InitForAdjust(util::stream::Sort<SuffixOrder, AddCombiner> &ngrams, WordIndex types) {$/;"	f	class:lm::builder::__anon13::Master
InitLMlaTree	HLVNet.c	/^static void InitLMlaTree(LexNet *net, TLexNet *tnet)$/;"	f	file:
InitLVLM	HLVLM.c	/^void InitLVLM (void)$/;"	f
InitLVModel	HLVModel.c	/^void InitLVModel(void)$/;"	f
InitLVNet	HLVNet.c	/^void InitLVNet(void)$/;"	f
InitLVRec	HLVRec.c	/^void InitLVRec(void)$/;"	f
InitPhonePost	HLVRec-misc.c	/^void InitPhonePost (DecoderInst *dec)$/;"	f
InitWithDummy	kenlm/util/stream/multi_stream.hh	/^    void InitWithDummy(const ChainPositions &positions) {$/;"	f	class:util::stream::GenericStreams
InitialProbabilities	kenlm/lm/builder/initial_probabilities.cc	/^void InitialProbabilities($/;"	f	namespace:lm::builder
InitialProbabilities	kenlm/lm/builder/pipeline.cc	/^void InitialProbabilities(const std::vector<uint64_t> &counts, const std::vector<uint64_t> &counts_pruned, const std::vector<Discount> &discounts, Master &master, Sorts<SuffixOrder> &primary,$/;"	f	namespace:lm::builder::__anon13
InitialProbabilitiesConfig	kenlm/lm/builder/initial_probabilities.hh	/^struct InitialProbabilitiesConfig {$/;"	s	namespace:lm::builder
InitialScaledStartValues	kenlm/util/double-conversion/bignum-dtoa.cc	/^static void InitialScaledStartValues(uint64_t significand,$/;"	f	namespace:double_conversion
InitialScaledStartValuesNegativeExponentNegativePower	kenlm/util/double-conversion/bignum-dtoa.cc	/^static void InitialScaledStartValuesNegativeExponentNegativePower($/;"	f	namespace:double_conversion
InitialScaledStartValuesNegativeExponentPositivePower	kenlm/util/double-conversion/bignum-dtoa.cc	/^static void InitialScaledStartValuesNegativeExponentPositivePower($/;"	f	namespace:double_conversion
InitialScaledStartValuesPositiveExponent	kenlm/util/double-conversion/bignum-dtoa.cc	/^static void InitialScaledStartValuesPositiveExponent($/;"	f	namespace:double_conversion
Initialise	HDecode.c	/^DecoderInst *Initialise (void)$/;"	f
Initialise	HDecode.mod.c	/^DecoderInst *Initialise (void)$/;"	f
Initialize	kenlm/util/file_piece.cc	/^void FilePiece::Initialize(const char *name, std::ostream *show_progress, std::size_t min_buffer) {$/;"	f	class:util::FilePiece
InitializeBinary	kenlm/lm/binary_format.cc	/^void BinaryFormat::InitializeBinary(int fd, ModelType model_type, unsigned int search_version, Parameters &params) {$/;"	f	class:lm::ngram::BinaryFormat
InitializeFromARPA	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> void GenericModel<Search, VocabularyT>::InitializeFromARPA(int fd, const char *file, const Config &config) {$/;"	f	class:lm::ngram::detail::GenericModel
InitializeFromARPA	kenlm/lm/search_hashed.cc	/^template <class Value> void HashedSearch<Value>::InitializeFromARPA(const char * \/*file*\/, util::FilePiece &f, const std::vector<uint64_t> &counts, const Config &config, ProbingVocabulary &vocab, BinaryFormat &backing) {$/;"	f	class:lm::ngram::detail::HashedSearch
InitializeFromARPA	kenlm/lm/search_trie.cc	/^template <class Quant, class Bhiksha> void TrieSearch<Quant, Bhiksha>::InitializeFromARPA(const char *file, util::FilePiece &f, std::vector<uint64_t> &counts, const Config &config, SortedVocabulary &vocab, BinaryFormat &backing) {$/;"	f	class:lm::ngram::trie::TrieSearch
InitializeNoRead	kenlm/util/file_piece.cc	/^void FilePiece::InitializeNoRead(const char *name, std::size_t min_buffer) {$/;"	f	class:util::FilePiece
InlineBits	kenlm/lm/bhiksha.cc	/^uint8_t ArrayBhiksha::InlineBits(uint64_t max_offset, uint64_t max_next, const Config &config) {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
InlineBits	kenlm/lm/bhiksha.hh	/^    static uint8_t InlineBits(uint64_t \/*max_offset*\/, uint64_t max_next, const Config &\/*config*\/) {$/;"	f	class:lm::ngram::trie::DontBhiksha
InlineBits	kenlm/lm/bhiksha.hh	/^    uint8_t InlineBits() const { return next_.bits; }$/;"	f	class:lm::ngram::trie::DontBhiksha
InlineBits	kenlm/lm/bhiksha.hh	/^    uint8_t InlineBits() const { return next_inline_.bits; }$/;"	f	class:lm::ngram::trie::ArrayBhiksha
Inner	kenlm/lm/trie_sort.cc	/^    InnerIterator &Inner() { return inner_; }$/;"	f	class:lm::ngram::trie::__anon26::PartialViewProxy	file:
Inner	kenlm/lm/trie_sort.cc	/^    const InnerIterator &Inner() const { return inner_; } $/;"	f	class:lm::ngram::trie::__anon26::PartialViewProxy	file:
Inner	kenlm/util/joint_sort.hh	/^    InnerIterator &Inner() { return inner_; }$/;"	f	class:util::detail::JointProxy
Inner	kenlm/util/joint_sort.hh	/^    const InnerIterator &Inner() const { return inner_; }$/;"	f	class:util::detail::JointProxy
Inner	kenlm/util/proxy_iterator.hh	/^    const InnerIterator &Inner() { return p_.Inner(); }$/;"	f	class:util::ProxyIterator
Inner	kenlm/util/sized_iterator.hh	/^    InnerIterator &Inner() { return inner_; }$/;"	f	class:util::SizedProxy
Inner	kenlm/util/sized_iterator.hh	/^    const InnerIterator &Inner() const { return inner_; }$/;"	f	class:util::SizedProxy
InnerIterator	kenlm/lm/trie_sort.cc	/^    typedef util::SizedInnerIterator InnerIterator;$/;"	t	class:lm::ngram::trie::__anon26::PartialViewProxy	file:
InnerIterator	kenlm/util/joint_sort.hh	/^    typedef JointIter<KeyIter, ValueIter> InnerIterator;$/;"	t	class:util::detail::JointProxy
InnerIterator	kenlm/util/proxy_iterator.hh	/^    typedef typename Proxy::InnerIterator InnerIterator;$/;"	t	class:util::ProxyIterator
InnerIterator	kenlm/util/sized_iterator.hh	/^    typedef SizedInnerIterator InnerIterator;$/;"	t	class:util::SizedProxy
InputBuffer	kenlm/lm/filter/format.hh	/^    InputBuffer() : actual_(0) {}$/;"	f	class:lm::InputBuffer
InputBuffer	kenlm/lm/filter/format.hh	/^class InputBuffer {$/;"	c	namespace:lm
Insert	kenlm/lm/trie.cc	/^template <class Bhiksha> util::BitAddress BitPackedMiddle<Bhiksha>::Insert(WordIndex word) {$/;"	f	class:lm::ngram::trie::BitPackedMiddle
Insert	kenlm/lm/trie.cc	/^util::BitAddress BitPackedLongest::Insert(WordIndex index) {$/;"	f	class:lm::ngram::trie::BitPackedLongest
Insert	kenlm/lm/vocab.cc	/^WordIndex ProbingVocabulary::Insert(const StringPiece &str) {$/;"	f	class:lm::ngram::ProbingVocabulary
Insert	kenlm/lm/vocab.cc	/^WordIndex SortedVocabulary::Insert(const StringPiece &str) {$/;"	f	class:lm::ngram::SortedVocabulary
Insert	kenlm/util/probing_hash_table.hh	/^    template <class T> MutableIterator Insert(const T &t) {$/;"	f	class:util::AutoProbing
Insert	kenlm/util/probing_hash_table.hh	/^    template <class T> MutableIterator Insert(const T &t) {$/;"	f	class:util::ProbingHashTable
InsertIndex	kenlm/lm/trie.hh	/^    uint64_t InsertIndex() const {$/;"	f	class:lm::ngram::trie::BitPacked
InspectAddr	kenlm/util/scoped.cc	/^void *InspectAddr(void *addr, std::size_t requested, const char *func_name) {$/;"	f	namespace:util::__anon46
InternalSeek	kenlm/util/file.cc	/^void InternalSeek(int fd, int64_t off, int whence) {$/;"	f	namespace:util::__anon36
InternalUnRest	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> float GenericModel<Search, VocabularyT>::InternalUnRest(const uint64_t *pointers_begin, const uint64_t *pointers_end, unsigned char first_length) const {$/;"	f	class:lm::ngram::detail::GenericModel
Interpolate	kenlm/lm/builder/interpolate.cc	/^Interpolate::Interpolate(uint64_t vocab_size, const util::stream::ChainPositions &backoffs, const std::vector<uint64_t>& prune_thresholds, bool prune_vocab, bool output_q)$/;"	f	class:lm::builder::Interpolate
Interpolate	kenlm/lm/builder/interpolate.hh	/^class Interpolate {$/;"	c	namespace:lm::builder
InterpolateProbabilities	kenlm/lm/builder/pipeline.cc	/^void InterpolateProbabilities(const std::vector<uint64_t> &counts, Master &master, Sorts<SuffixOrder> &primary, util::FixedArray<util::stream::FileBuffer> &gammas) {$/;"	f	namespace:lm::builder::__anon13
IsBinaryFormat	kenlm/lm/binary_format.cc	/^bool IsBinaryFormat(int fd) {$/;"	f	namespace:lm::ngram
IsClamped	kenlm/util/double-conversion/bignum.cc	/^bool Bignum::IsClamped() const {$/;"	f	class:double_conversion::Bignum
IsDenormal	kenlm/util/double-conversion/ieee.h	/^  bool IsDenormal() const {$/;"	f	class:double_conversion::Double
IsDenormal	kenlm/util/double-conversion/ieee.h	/^  bool IsDenormal() const {$/;"	f	class:double_conversion::Single
IsEntirelyWhiteSpace	kenlm/lm/filter/arpa_io.cc	/^bool IsEntirelyWhiteSpace(const StringPiece &line) {$/;"	f	namespace:lm
IsEntirelyWhiteSpace	kenlm/lm/read_arpa.cc	/^bool IsEntirelyWhiteSpace(const StringPiece &line) {$/;"	f	namespace:lm::__anon22
IsInfinite	kenlm/util/double-conversion/ieee.h	/^  bool IsInfinite() const {$/;"	f	class:double_conversion::Double
IsInfinite	kenlm/util/double-conversion/ieee.h	/^  bool IsInfinite() const {$/;"	f	class:double_conversion::Single
IsLineEnd	kenlm/lm/filter/vocab.cc	/^bool IsLineEnd(std::istream &in) {$/;"	f	namespace:lm::vocab::__anon16
IsMarked	kenlm/lm/builder/ngram.hh	/^    bool IsMarked() const {$/;"	f	class:lm::builder::NGram
IsNan	kenlm/util/double-conversion/ieee.h	/^  bool IsNan() const {$/;"	f	class:double_conversion::Double
IsNan	kenlm/util/double-conversion/ieee.h	/^  bool IsNan() const {$/;"	f	class:double_conversion::Single
IsPassthrough	kenlm/util/mmap.hh	/^    bool IsPassthrough() const { return fd_ == -1; }$/;"	f	class:util::Rolling
IsSpecial	kenlm/util/double-conversion/ieee.h	/^  bool IsSpecial() const {$/;"	f	class:double_conversion::Double
IsSpecial	kenlm/util/double-conversion/ieee.h	/^  bool IsSpecial() const {$/;"	f	class:double_conversion::Single
IsTag	kenlm/lm/filter/vocab.hh	/^inline bool IsTag(const StringPiece &value) {$/;"	f	namespace:lm::vocab
IsZero	kenlm/util/double-conversion/fixed-dtoa.cc	/^  bool IsZero() const {$/;"	f	class:double_conversion::UInt128
Join	kenlm/util/thread_pool.hh	/^    void Join() {$/;"	f	class:util::Worker
JointIter	kenlm/util/joint_sort.hh	/^    JointIter() {}$/;"	f	class:util::detail::JointIter
JointIter	kenlm/util/joint_sort.hh	/^    JointIter(const KeyIter &key_iter, const ValueIter &value_iter) : key_(key_iter), value_(value_iter) {}$/;"	f	class:util::detail::JointIter
JointIter	kenlm/util/joint_sort.hh	/^template <class KeyIter, class ValueIter> class JointIter {$/;"	c	namespace:util::detail
JointOrder	kenlm/lm/builder/joint_order.hh	/^template <class Callback, class Compare> void JointOrder(const util::stream::ChainPositions &positions, Callback &callback) {$/;"	f	namespace:lm::builder
JointProxy	kenlm/util/joint_sort.hh	/^    JointProxy(const JointProxy<KeyIter, ValueIter> &other) : inner_(other.inner_) {}$/;"	f	class:util::detail::JointProxy
JointProxy	kenlm/util/joint_sort.hh	/^    JointProxy(const KeyIter &key_iter, const ValueIter &value_iter) : inner_(key_iter, value_iter) {}$/;"	f	class:util::detail::JointProxy
JointProxy	kenlm/util/joint_sort.hh	/^template <class KeyIter, class ValueIter> class JointProxy {$/;"	c	namespace:util::detail
JointSort	kenlm/util/joint_sort.hh	/^template <class KeyIter, class ValueIter, class Less> void JointSort(const KeyIter &key_begin, const KeyIter &key_end, const ValueIter &value_begin, const Less &less) {$/;"	f	namespace:util
JointSort	kenlm/util/joint_sort.hh	/^template <class KeyIter, class ValueIter> void JointSort(const KeyIter &key_begin, const KeyIter &key_end, const ValueIter &value_begin) {$/;"	f	namespace:util
KENLMLIB	Makefile	/^KENLMLIB = .\/kenlm\/lm\/*.cc .\/kenlm\/util\/*.cc kenlm\/util\/double-conversion\/*.cc$/;"	m
KENLM_ORDER_MESSAGE	kenlm/lm/max_order.hh	10;"	d
Key	kenlm/lm/builder/corpus_count.cc	/^  typedef WordIndex *Key;$/;"	t	struct:lm::builder::__anon9::DedupeEntry	file:
Key	kenlm/lm/builder/corpus_count.cc	/^  typedef uint64_t Key;$/;"	t	struct:lm::builder::__anon9::VocabEntry	file:
Key	kenlm/lm/search_hashed.hh	/^  typedef uint64_t Key;$/;"	t	struct:lm::ngram::detail::ProbEntry
Key	kenlm/lm/trie.cc	/^    typedef uint64_t Key;$/;"	t	class:lm::ngram::trie::__anon25::KeyAccessor	file:
Key	kenlm/lm/value.hh	/^    typedef uint64_t Key;$/;"	t	struct:lm::ngram::BackoffValue::ProbingEntry
Key	kenlm/lm/value.hh	/^    typedef uint64_t Key;$/;"	t	struct:lm::ngram::RestValue::ProbingEntry
Key	kenlm/lm/vocab.hh	/^  typedef uint64_t Key;$/;"	t	struct:lm::ngram::ProbingVocabularyEntry
Key	kenlm/util/probing_hash_table.hh	/^    typedef typename Entry::Key Key;$/;"	t	class:util::AutoProbing
Key	kenlm/util/probing_hash_table.hh	/^    typedef typename Entry::Key Key;$/;"	t	class:util::ProbingHashTable
Key	kenlm/util/sorted_uniform.hh	/^    typedef T Key;$/;"	t	class:util::IdentityAccessor
KeyAccessor	kenlm/lm/trie.cc	/^    KeyAccessor(const void *base, uint64_t key_mask, uint8_t key_bits, uint8_t total_bits) $/;"	f	class:lm::ngram::trie::__anon25::KeyAccessor
KeyAccessor	kenlm/lm/trie.cc	/^class KeyAccessor {$/;"	c	namespace:lm::ngram::trie::__anon25	file:
LAYER_A	HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAYER_AB	HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAYER_BY	HLVNet.h	/^   LAYER_BY=6, LAYER_WE=7, LAYER_YZ=8$/;"	e	enum:_LayerId
LAYER_SA	HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAYER_SIL	HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAYER_SIL_NTOK_SCALE	HLVRec.c	92;"	d	file:
LAYER_WE	HLVNet.h	/^   LAYER_BY=6, LAYER_WE=7, LAYER_YZ=8$/;"	e	enum:_LayerId
LAYER_YZ	HLVNet.h	/^   LAYER_BY=6, LAYER_WE=7, LAYER_YZ=8$/;"	e	enum:_LayerId
LAYER_Z	HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAYER_ZS	HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAZY	kenlm/util/mmap.hh	/^  LAZY,$/;"	e	enum:util::__anon42
LAlignFromAltModpath	HLVRec-traceback.c	/^LAlign *LAlignFromAltModpath (DecoderInst *dec, MemHeap *heap,$/;"	f
LAlignFromModpath	HLVRec-traceback.c	/^LAlign *LAlignFromModpath (DecoderInst *dec, MemHeap *heap,$/;"	f
LDFLAGS	Makefile	/^LDFLAGS = 	-L\/usr\/X11R6\/lib  -lm$/;"	m
LEGACY_CUHTK2_MLLR	config.h	68;"	d
LEX_CON_HASH_SIZE	HLVNet.h	128;"	d
LEX_MOD_HASH_SIZE	HLVNet.h	129;"	d
LIST_BLOCKSIZE	HLVNet.c	55;"	d	file:
LMCACHE_NLA	HLVRec.h	258;"	d
LMCache	HLVRec.h	/^typedef struct _LMCache LMCache;$/;"	t	typeref:struct:_LMCache
LMCacheLA	HLVRec.h	/^typedef struct _LMCacheLA LMCacheLA;$/;"	t	typeref:struct:_LMCacheLA
LMCacheLookaheadProb	HLVRec-LM.c	/^static LMTokScore LMCacheLookaheadProb (DecoderInst *dec, LMState lmState, $/;"	f	file:
LMCacheLookaheadProb_kenlm	HLVRec-LM.c	/^static LMTokScore LMCacheLookaheadProb_kenlm (DecoderInst *dec, lm::ngram::State& lmState, int lmlaIdx, Boolean fastlmla)$/;"	f	file:
LMCacheState_hash	HLVRec-LM.c	/^static int LMCacheState_hash (LMState lmstate)$/;"	f	file:
LMCacheTransProb	HLVRec-LM.c	/^static LMTokScore LMCacheTransProb (DecoderInst *dec, FSLM *lm, $/;"	f	file:
LMCacheTransProb_kenlm	HLVRec-LM.c	/^static LMTokScore LMCacheTransProb_kenlm (DecoderInst *dec, lm::base::Model *lm_kenlm, lm::base::Vocabulary* vocab_kenlm,$/;"	f	file:
LMId	config.h	/^typedef unsigned int LMId;$/;"	t
LMIdMapper	HLVLM.c	/^static LMId LMIdMapper(FSLM_ngram *nglm, char *w)$/;"	f	file:
LMInitial	HLVLM.c	/^LMState LMInitial (FSLM *lm)$/;"	f
LMLACacheEntry	HLVRec.h	/^typedef  struct _LMLACacheEntry LMLACacheEntry;$/;"	t	typeref:struct:_LMLACacheEntry
LMLA_CACHE_SIZE	HLVRec.h	190;"	d
LMLA_HASH	HLVRec.h	191;"	d
LMLA_nocache	HLVRec-LM.c	/^LMTokScore LMLA_nocache (DecoderInst *dec, LMState lmState, int lmlaIdx)$/;"	f
LMLookAhead	HLVLM.c	/^LogFloat LMLookAhead (FSLM *lm, LMState src, PronId minPron, PronId maxPron)$/;"	f
LMLookAhead_2gram	HLVLM.c	/^LogFloat LMLookAhead_2gram (FSLM *lm, LMState src, PronId minPron, PronId maxPron)$/;"	f
LMLookAhead_3gram	HLVLM.c	/^LogFloat LMLookAhead_3gram (FSLM *lm, LMState src, PronId minPron, PronId maxPron)$/;"	f
LMLookAhead_kenlm	HLVLM.c	/^LogFloat LMLookAhead_kenlm (lm::base::Model* lm_kenlm,lm::base::Vocabulary* vocab_kenlm, Vocab& vocab_htk, lm::ngram::State& src, PronId minPron, PronId maxPron)$/;"	f
LMLookAhead_latlm	HLVLM.c	/^LogFloat LMLookAhead_latlm (FSLM *lm, LMState src, $/;"	f
LMLookAhead_ngram	HLVLM.c	/^LogFloat LMLookAhead_ngram (FSLM *lm, LMState src, PronId minPron, PronId maxPron)$/;"	f
LMNodeCache	HLVRec.h	/^typedef struct _LMNodeCache LMNodeCache;$/;"	t	typeref:struct:_LMNodeCache
LMState	HLVLM.h	/^typedef Ptr LMState;$/;"	t
LMTokScore	config.h	/^typedef LogFloat LMTokScore;$/;"	t
LMTransProb	HLVLM.c	/^LogFloat LMTransProb (FSLM *lm, LMState src, PronId pronid, LMState *dest)$/;"	f
LMTransProb_kenlm	HLVLM.c	/^LogFloat LMTransProb_kenlm(lm::base::Model* lm_kenlm, lm::base::Vocabulary* vocab_kenlm, lm::ngram::State& src, char* pWord,lm::ngram::State& dest)$/;"	f
LMTransProb_latlm	HLVLM.c	/^LogFloat LMTransProb_latlm (FSLM *lm, LMState src,$/;"	f
LMTransProb_ngram	HLVLM.c	/^LogFloat LMTransProb_ngram (FSLM *lm, LMState src, PronId pronid, LMState *dest)$/;"	f
LMWordIndex	kenlm/lm/word_index.hh	/^typedef lm::WordIndex LMWordIndex;$/;"	t
LM_BHIKSHA_H	kenlm/lm/bhiksha.hh	14;"	d
LM_BINARY_FORMAT_H	kenlm/lm/binary_format.hh	2;"	d
LM_BLANK_H	kenlm/lm/blank.hh	2;"	d
LM_BUILDER_ADJUST_COUNTS_H	kenlm/lm/builder/adjust_counts.hh	2;"	d
LM_BUILDER_CORPUS_COUNT_H	kenlm/lm/builder/corpus_count.hh	2;"	d
LM_BUILDER_DISCOUNT_H	kenlm/lm/builder/discount.hh	2;"	d
LM_BUILDER_HASH_GAMMA__	kenlm/lm/builder/hash_gamma.hh	2;"	d
LM_BUILDER_HEADER_INFO_H	kenlm/lm/builder/header_info.hh	2;"	d
LM_BUILDER_INITIAL_PROBABILITIES_H	kenlm/lm/builder/initial_probabilities.hh	2;"	d
LM_BUILDER_INTERPOLATE_H	kenlm/lm/builder/interpolate.hh	2;"	d
LM_BUILDER_JOINT_ORDER_H	kenlm/lm/builder/joint_order.hh	2;"	d
LM_BUILDER_NGRAM_H	kenlm/lm/builder/ngram.hh	2;"	d
LM_BUILDER_NGRAM_STREAM_H	kenlm/lm/builder/ngram_stream.hh	2;"	d
LM_BUILDER_OUTPUT_H	kenlm/lm/builder/output.hh	2;"	d
LM_BUILDER_PIPELINE_H	kenlm/lm/builder/pipeline.hh	2;"	d
LM_BUILDER_PRINT_H	kenlm/lm/builder/print.hh	2;"	d
LM_BUILDER_SORT_H	kenlm/lm/builder/sort.hh	2;"	d
LM_COMMA	kenlm/lm/model.hh	130;"	d
LM_CONFIG_H	kenlm/lm/config.hh	2;"	d
LM_ENUMERATE_VOCAB_H	kenlm/lm/enumerate_vocab.hh	2;"	d
LM_FACADE_H	kenlm/lm/facade.hh	2;"	d
LM_FILTER_ARPA_IO_H	kenlm/lm/filter/arpa_io.hh	2;"	d
LM_FILTER_COUNT_IO_H	kenlm/lm/filter/count_io.hh	2;"	d
LM_FILTER_FORMAT_H	kenlm/lm/filter/format.hh	2;"	d
LM_FILTER_PHRASE_H	kenlm/lm/filter/phrase.hh	2;"	d
LM_FILTER_PHRASE_METHOD	kenlm/lm/filter/phrase.hh	13;"	d
LM_FILTER_THREAD_H	kenlm/lm/filter/thread.hh	2;"	d
LM_FILTER_VOCAB_H	kenlm/lm/filter/vocab.hh	2;"	d
LM_FILTER_WRAPPER_H	kenlm/lm/filter/wrapper.hh	2;"	d
LM_LEFT_H	kenlm/lm/left.hh	39;"	d
LM_LM_EXCEPTION_H	kenlm/lm/lm_exception.hh	2;"	d
LM_MAX_ORDER_H	kenlm/lm/max_order.hh	2;"	d
LM_MODEL_H	kenlm/lm/model.hh	2;"	d
LM_MODEL_TYPE_H	kenlm/lm/model_type.hh	2;"	d
LM_NAME_MODEL	kenlm/lm/model.hh	131;"	d
LM_NEURAL_WORDVECS_H	kenlm/lm/neural/wordvecs.hh	2;"	d
LM_NGRAM_INT	config.h	42;"	d
LM_NGRAM_QUERY_H	kenlm/lm/ngram_query.hh	2;"	d
LM_PARTIAL_H	kenlm/lm/partial.hh	2;"	d
LM_QUANTIZE_H	kenlm/lm/quantize.hh	2;"	d
LM_READ_ARPA_H	kenlm/lm/read_arpa.hh	2;"	d
LM_RETURN_H	kenlm/lm/return.hh	2;"	d
LM_SEARCH_HASHED_H	kenlm/lm/search_hashed.hh	2;"	d
LM_SEARCH_TRIE_H	kenlm/lm/search_trie.hh	2;"	d
LM_SIZES_H	kenlm/lm/sizes.hh	2;"	d
LM_STATE_H	kenlm/lm/state.hh	2;"	d
LM_TRIE_H	kenlm/lm/trie.hh	2;"	d
LM_TRIE_SORT_H	kenlm/lm/trie_sort.hh	4;"	d
LM_VALUE_BUILD_H	kenlm/lm/value_build.hh	2;"	d
LM_VALUE_H	kenlm/lm/value.hh	2;"	d
LM_VIRTUAL_INTERFACE_H	kenlm/lm/virtual_interface.hh	2;"	d
LM_VOCAB_H	kenlm/lm/vocab.hh	2;"	d
LM_WEIGHTS_H	kenlm/lm/weights.hh	2;"	d
LM_WORD_INDEX_H	kenlm/lm/word_index.hh	3;"	d
LM_WRAPPERS_NPLM_H	kenlm/lm/wrappers/nplm.hh	2;"	d
LMlaNode	HLVNet.h	/^} LMlaNode;$/;"	t	typeref:struct:_LMlaNode
LMlaTree	HLVNet.h	/^typedef struct _LMlaTree LMlaTree;$/;"	t	typeref:struct:_LMlaTree
LN10	HLVLM.c	/^const double LN10 = 2.30258509299404568;    \/* Defined to save recalculating it *\/$/;"	v
LN_CON	HLVNet.h	/^  LN_WORDEND, LN_CON, LN_MODEL$/;"	e	enum:_LexNodeType
LN_MODEL	HLVNet.h	/^  LN_WORDEND, LN_CON, LN_MODEL$/;"	e	enum:_LexNodeType
LN_WORDEND	HLVNet.h	/^  LN_WORDEND, LN_CON, LN_MODEL$/;"	e	enum:_LexNodeType
LatTraceBack	HLVRec-traceback.c	/^Lattice *LatTraceBack (MemHeap *heap, DecoderInst *dec)$/;"	f
LatTraceBackCount	HLVRec-traceback.c	/^static void LatTraceBackCount (DecoderInst *dec, WordendHyp *path, int *nnodes, int *nlinks)$/;"	f	file:
LayerId	HLVNet.h	/^} LayerId;$/;"	t	typeref:enum:_LayerId
LayerStats	HLVRec-misc.c	/^typedef struct _LayerStats LayerStats;$/;"	t	typeref:struct:_LayerStats	file:
Left	kenlm/lm/state.hh	/^struct Left {$/;"	s	namespace:lm::ngram
Length	kenlm/lm/state.hh	/^    unsigned char Length() const { return length; }$/;"	f	class:lm::ngram::State
Less	kenlm/util/double-conversion/bignum.h	/^  static bool Less(const Bignum& a, const Bignum& b) {$/;"	f	class:double_conversion::Bignum
LessEqual	kenlm/util/double-conversion/bignum.h	/^  static bool LessEqual(const Bignum& a, const Bignum& b) {$/;"	f	class:double_conversion::Bignum
LessWrapper	kenlm/util/joint_sort.hh	/^    explicit LessWrapper(const Less &less) : less_(less) {}$/;"	f	class:util::detail::LessWrapper
LessWrapper	kenlm/util/joint_sort.hh	/^template <class Proxy, class Less> class LessWrapper : public std::binary_function<const typename Proxy::value_type &, const typename Proxy::value_type &, bool> {$/;"	c	namespace:util::detail
LexNet	HLVNet.h	/^} LexNet;$/;"	t	typeref:struct:_LexNet
LexNode	HLVNet.h	/^typedef struct _LexNode LexNode;$/;"	t	typeref:struct:_LexNode
LexNodeInst	HLVNet.h	/^typedef struct _LexNodeInst LexNodeInst;        \/* structure defined in HLVRec *\/$/;"	t	typeref:struct:_LexNodeInst
LexNodeType	HLVNet.h	/^} LexNodeType;$/;"	t	typeref:enum:_LexNodeType
Line	kenlm/lm/filter/format.hh	/^    struct Line {$/;"	s	class:lm::InputBuffer
Line	kenlm/lm/ngram_query.hh	/^  void Line(uint64_t oov, float total) const {$/;"	f	struct:lm::ngram::BasicPrint
LineInput	kenlm/util/stream/line_input.hh	/^class LineInput {$/;"	c	namespace:util::stream
Link	kenlm/util/stream/chain.cc	/^Link::Link() : in_(NULL), out_(NULL), poisoned_(true) {}$/;"	f	class:util::stream::Link
Link	kenlm/util/stream/chain.cc	/^Link::Link(const ChainPosition &position) : in_(NULL) {$/;"	f	class:util::stream::Link
Link	kenlm/util/stream/chain.hh	/^class Link {$/;"	c	namespace:util::stream
LoadBinary	kenlm/lm/binary_format.cc	/^void *BinaryFormat::LoadBinary(std::size_t size) {$/;"	f	class:lm::ngram::BinaryFormat
LoadException	kenlm/lm/lm_exception.cc	/^LoadException::LoadException() throw() {}$/;"	f	class:lm::LoadException
LoadException	kenlm/lm/lm_exception.hh	/^class LoadException : public util::Exception {$/;"	c	namespace:lm
LoadFVTrans	HDecode.c	/^void LoadFVTrans (char *fn, BlockMatrix *transMat)$/;"	f
LoadFVTrans	HDecode.mod.c	/^void LoadFVTrans (char *fn, BlockMatrix *transMat)$/;"	f
LoadMethod	kenlm/util/mmap.hh	/^} LoadMethod;$/;"	t	namespace:util	typeref:enum:util::__anon42
LoadVirtual	kenlm/lm/model.cc	/^base::Model *LoadVirtual(const char *file_name, const Config &config, ModelType model_type) {$/;"	f	namespace:lm::ngram
LoadedBinary	kenlm/lm/vocab.cc	/^void ProbingVocabulary::LoadedBinary(bool have_words, int fd, EnumerateVocab *to, uint64_t offset) {$/;"	f	class:lm::ngram::ProbingVocabulary
LoadedBinary	kenlm/lm/vocab.cc	/^void SortedVocabulary::LoadedBinary(bool have_words, int fd, EnumerateVocab *to, uint64_t offset) {$/;"	f	class:lm::ngram::SortedVocabulary
Longest	kenlm/lm/search_hashed.hh	/^    typedef util::ProbingHashTable<ProbEntry, util::IdentityHash> Longest;$/;"	t	class:lm::ngram::detail::HashedSearch
Longest	kenlm/lm/search_trie.cc	/^    void Longest(const void * \/*data*\/) {$/;"	f	class:lm::ngram::trie::__anon24::FindBlanks
Longest	kenlm/lm/search_trie.cc	/^    void Longest(const void *data) {$/;"	f	class:lm::ngram::trie::__anon24::WriteEntries
Longest	kenlm/lm/search_trie.hh	/^    typedef trie::BitPackedLongest Longest;$/;"	t	class:lm::ngram::trie::TrieSearch
LongestBits	kenlm/lm/quantize.hh	/^    static uint8_t LongestBits(const Config &\/*config*\/) { return 31; }$/;"	f	class:lm::ngram::DontQuantize
LongestBits	kenlm/lm/quantize.hh	/^    static uint8_t LongestBits(const Config &config) { return config.prob_bits; }$/;"	f	class:lm::ngram::SeparatelyQuantize
LongestPointer	kenlm/lm/quantize.hh	/^        LongestPointer() : address_(NULL, 0) {}$/;"	f	class:lm::ngram::DontQuantize::LongestPointer
LongestPointer	kenlm/lm/quantize.hh	/^        LongestPointer() : address_(NULL, 0) {}$/;"	f	class:lm::ngram::SeparatelyQuantize::LongestPointer
LongestPointer	kenlm/lm/quantize.hh	/^        LongestPointer(const SeparatelyQuantize &quant, const util::BitAddress &address) : table_(&quant.LongestTable()), address_(address) {}$/;"	f	class:lm::ngram::SeparatelyQuantize::LongestPointer
LongestPointer	kenlm/lm/quantize.hh	/^        explicit LongestPointer(const DontQuantize &\/*quant*\/, util::BitAddress address) : address_(address) {}$/;"	f	class:lm::ngram::DontQuantize::LongestPointer
LongestPointer	kenlm/lm/quantize.hh	/^    class LongestPointer {$/;"	c	class:lm::ngram::DontQuantize
LongestPointer	kenlm/lm/quantize.hh	/^    class LongestPointer {$/;"	c	class:lm::ngram::SeparatelyQuantize
LongestPointer	kenlm/lm/search_hashed.hh	/^    LongestPointer() : to_(NULL) {}$/;"	f	class:lm::ngram::detail::LongestPointer
LongestPointer	kenlm/lm/search_hashed.hh	/^    explicit LongestPointer(const float &to) : to_(&to) {}$/;"	f	class:lm::ngram::detail::LongestPointer
LongestPointer	kenlm/lm/search_hashed.hh	/^    typedef ::lm::ngram::detail::LongestPointer LongestPointer;$/;"	t	class:lm::ngram::detail::HashedSearch
LongestPointer	kenlm/lm/search_hashed.hh	/^class LongestPointer {$/;"	c	namespace:lm::ngram::detail
LongestPointer	kenlm/lm/search_trie.hh	/^    typedef typename Quant::LongestPointer LongestPointer;$/;"	t	class:lm::ngram::trie::TrieSearch
LongestTable	kenlm/lm/quantize.hh	/^    const Bins &LongestTable() const { return longest_; }$/;"	f	class:lm::ngram::SeparatelyQuantize
Lookup	kenlm/lm/builder/print.hh	/^    const char *Lookup(WordIndex index) const {$/;"	f	class:lm::builder::VocabReconstitute
Lookup	kenlm/lm/search_hashed.hh	/^        const typename Value::Weights &Lookup(WordIndex index) const {$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Lookup	kenlm/lm/trie.hh	/^    const ProbBackoff &Lookup(WordIndex index) const { return unigram_[index].weights; }$/;"	f	class:lm::ngram::trie::Unigram
Lookup	kenlm/lm/vocab.hh	/^    typedef util::AutoProbing<ProbingVocabularyEntry, util::IdentityHash> Lookup;$/;"	t	class:lm::ngram::GrowableVocab
Lookup	kenlm/lm/vocab.hh	/^    typedef util::ProbingHashTable<ProbingVocabularyEntry, util::IdentityHash> Lookup;$/;"	t	class:lm::ngram::ProbingVocabulary
LookupLongest	kenlm/lm/search_hashed.hh	/^    LongestPointer LookupLongest(WordIndex word, const Node &node) const {$/;"	f	class:lm::ngram::detail::HashedSearch
LookupLongest	kenlm/lm/search_trie.hh	/^    LongestPointer LookupLongest(WordIndex word, const Node &node) const {$/;"	f	class:lm::ngram::trie::TrieSearch
LookupMiddle	kenlm/lm/search_hashed.hh	/^    MiddlePointer LookupMiddle(unsigned char order_minus_2, WordIndex word, Node &node, bool &independent_left, uint64_t &extend_pointer) const {$/;"	f	class:lm::ngram::detail::HashedSearch
LookupMiddle	kenlm/lm/search_trie.hh	/^    MiddlePointer LookupMiddle(unsigned char order_minus_2, WordIndex word, Node &node, bool &independent_left, uint64_t &extend_left) const {$/;"	f	class:lm::ngram::trie::TrieSearch
LookupPiece	kenlm/lm/builder/print.hh	/^    StringPiece LookupPiece(WordIndex index) const {$/;"	f	class:lm::builder::VocabReconstitute
LookupUnigram	kenlm/lm/search_hashed.hh	/^    UnigramPointer LookupUnigram(WordIndex word, Node &next, bool &independent_left, uint64_t &extend_left) const {$/;"	f	class:lm::ngram::detail::HashedSearch
LookupUnigram	kenlm/lm/search_trie.hh	/^    UnigramPointer LookupUnigram(WordIndex word, Node &next, bool &independent_left, uint64_t &extend_left) const {$/;"	f	class:lm::ngram::trie::TrieSearch
LowerBound	kenlm/lm/filter/phrase.cc	/^void Arc::LowerBound(const Sentence to) {$/;"	f	class:lm::phrase::detail::Arc
LowerBound	kenlm/lm/filter/phrase.cc	/^void Vertex::LowerBound(const Sentence to) {$/;"	f	class:lm::phrase::detail::Vertex
LowerBoundaryIsCloser	kenlm/util/double-conversion/ieee.h	/^  bool LowerBoundaryIsCloser() const {$/;"	f	class:double_conversion::Double
LowerBoundaryIsCloser	kenlm/util/double-conversion/ieee.h	/^  bool LowerBoundaryIsCloser() const {$/;"	f	class:double_conversion::Single
LowerRestBuild	kenlm/lm/value_build.cc	/^template <class Model> LowerRestBuild<Model>::LowerRestBuild(const Config &config, unsigned int order, const typename Model::Vocabulary &vocab) {$/;"	f	class:lm::ngram::LowerRestBuild
LowerRestBuild	kenlm/lm/value_build.hh	/^template <class Model> class LowerRestBuild {$/;"	c	namespace:lm::ngram
MACH_CALL	kenlm/util/pcqueue.hh	27;"	d
MALLOC_ALLOCATED	kenlm/util/mmap.hh	/^    typedef enum {MMAP_ALLOCATED, ARRAY_ALLOCATED, MALLOC_ALLOCATED, NONE_ALLOCATED} Alloc;$/;"	e	enum:util::scoped_memory::__anon41
MARKED_ALTPATH_P	HLVRec-GC.c	48;"	d	file:
MARKED_MODPATH_P	HLVRec-GC.c	56;"	d	file:
MARKED_PATH_P	HLVRec-GC.c	41;"	d	file:
MARK_ALTPATH	HLVRec-GC.c	47;"	d	file:
MARK_ALTPATH_MASK	HLVRec-GC.c	46;"	d	file:
MARK_MODPATH	HLVRec-GC.c	55;"	d	file:
MARK_MODPATH_MASK	HLVRec-GC.c	54;"	d	file:
MARK_PATH	HLVRec-GC.c	40;"	d	file:
MARK_PATH_MASK	HLVRec-GC.c	39;"	d	file:
MAXBLOCKOBS	config.h	63;"	d
MAX_LMID	HLVLM.h	97;"	d
MMAP_ALLOCATED	kenlm/util/mmap.hh	/^    typedef enum {MMAP_ALLOCATED, ARRAY_ALLOCATED, MALLOC_ALLOCATED, NONE_ALLOCATED} Alloc;$/;"	e	enum:util::scoped_memory::__anon41
MMP_NBINS	HLVRec-propagate.c	1447;"	d	file:
MMapShift	kenlm/util/file_piece.cc	/^void FilePiece::MMapShift(uint64_t desired_begin) {$/;"	f	class:util::FilePiece
MODALIGN	config.h	57;"	d
MODALIGN	config.h	60;"	d
MagicResult	kenlm/util/read_compressed.cc	/^enum MagicResult {$/;"	g	namespace:util::__anon45	file:
Make	kenlm/lm/vocab.hh	/^  static ProbingVocabularyEntry Make(uint64_t key, WordIndex value) {$/;"	f	struct:lm::ngram::ProbingVocabularyEntry
MakeBins	kenlm/lm/quantize.cc	/^void MakeBins(std::vector<float> &values, float *centers, uint32_t bins) {$/;"	f	namespace:lm::ngram::__anon21
MakeGraph	kenlm/lm/filter/phrase.cc	/^detail::Vertex &ConditionCommon::MakeGraph() {$/;"	f	class:lm::phrase::detail::ConditionCommon
MakeHashes	kenlm/lm/filter/phrase.hh	/^template <class Iterator> void MakeHashes(Iterator i, const Iterator &end, std::vector<Hash> &hashes) {$/;"	f	namespace:lm::phrase::detail
MakeTemp	kenlm/util/file.cc	/^int MakeTemp(const StringPiece &base) {$/;"	f	namespace:util
MallocException	kenlm/util/scoped.cc	/^MallocException::MallocException(std::size_t requested) throw() {$/;"	f	class:util::MallocException
MallocException	kenlm/util/scoped.hh	/^class MallocException : public ErrnoException {$/;"	c	namespace:util
MallocOrThrow	kenlm/util/scoped.cc	/^void *MallocOrThrow(std::size_t requested) {$/;"	f	namespace:util
MapAnonymous	kenlm/util/mmap.cc	/^void MapAnonymous(std::size_t size, util::scoped_memory &to) {$/;"	f	namespace:util
MapFile	kenlm/lm/binary_format.cc	/^void BinaryFormat::MapFile(void *&vocab_base, void *&search_base) {$/;"	f	class:lm::ngram::BinaryFormat
MapOrThrow	kenlm/util/mmap.cc	/^void *MapOrThrow(std::size_t size, bool for_write, int flags, bool prefault, int fd, uint64_t offset) {$/;"	f	namespace:util
MapRead	kenlm/util/mmap.cc	/^void MapRead(LoadMethod method, int fd, uint64_t offset, std::size_t size, scoped_memory &out) {$/;"	f	namespace:util
MapZeroedWrite	kenlm/util/mmap.cc	/^void *MapZeroedWrite(const char *name, std::size_t size, scoped_fd &file) {$/;"	f	namespace:util
MapZeroedWrite	kenlm/util/mmap.cc	/^void *MapZeroedWrite(int fd, std::size_t size) {$/;"	f	namespace:util
Mark	kenlm/lm/builder/ngram.hh	/^    void Mark() {$/;"	f	class:lm::builder::NGram
MarkAllProns	HLVNet.c	/^void MarkAllProns (Vocab *voc)$/;"	f
MarkAllWords	HLVNet.c	/^void MarkAllWords (Vocab *voc)$/;"	f
MarkAllWordsfromLat	HLVNet.c	/^void MarkAllWordsfromLat (Vocab *voc, Lattice *lat, Boolean silDict)$/;"	f
MarkExtends	kenlm/lm/value_build.hh	/^    bool MarkExtends(RestWeights &weights, const Prob &to) const {$/;"	f	class:lm::ngram::MaxRestBuild
MarkExtends	kenlm/lm/value_build.hh	/^    bool MarkExtends(RestWeights &weights, const RestWeights &to) const {$/;"	f	class:lm::ngram::MaxRestBuild
MarkExtends	kenlm/lm/value_build.hh	/^    template <class Second> bool MarkExtends(ProbBackoff &weights, const Second &) const {$/;"	f	class:lm::ngram::NoRestBuild
MarkExtends	kenlm/lm/value_build.hh	/^    template <class Second> bool MarkExtends(RestWeights &weights, const Second &) const {$/;"	f	class:lm::ngram::LowerRestBuild
MarkLower	kenlm/lm/search_hashed.cc	/^template <class Build> void MarkLower($/;"	f	namespace:lm::ngram::__anon23
MarkModPath	HLVRec-GC.c	/^static void MarkModPath (ModendHyp *m)$/;"	f	file:
MarkPath	HLVRec-GC.c	/^static void MarkPath (WordendHyp *path)$/;"	f	file:
MarkTokSet	HLVRec-GC.c	/^static void MarkTokSet (TokenSet *ts)$/;"	f	file:
Mask	kenlm/lm/quantize.hh	/^        uint64_t Mask() const { return mask_; }$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
Master	kenlm/lm/builder/pipeline.cc	/^    explicit Master(PipelineConfig &config) $/;"	f	class:lm::builder::__anon13::Master
Master	kenlm/lm/builder/pipeline.cc	/^class Master {$/;"	c	namespace:lm::builder::__anon13	file:
MatchCheck	kenlm/lm/binary_format.cc	/^void MatchCheck(ModelType model_type, unsigned int search_version, const Parameters &params) {$/;"	f	namespace:lm::ngram
Max	kenlm/util/double-conversion/utils.h	/^static T Max(T a, T b) {$/;"	f	namespace:double_conversion
MaxRestBuild	kenlm/lm/value_build.hh	/^    MaxRestBuild() {}$/;"	f	class:lm::ngram::MaxRestBuild
MaxRestBuild	kenlm/lm/value_build.hh	/^class MaxRestBuild {$/;"	c	namespace:lm::ngram
MaximumLazyInput	kenlm/lm/builder/pipeline.cc	/^    template <class Compare> void MaximumLazyInput(const std::vector<uint64_t> &counts, Sorts<Compare> &sorts) {$/;"	f	class:lm::builder::__anon13::Master
MemUsage	kenlm/lm/vocab.hh	/^    static std::size_t MemUsage(WordIndex content) {$/;"	f	class:lm::ngram::GrowableVocab
MemUsage	kenlm/util/probing_hash_table.hh	/^    static std::size_t MemUsage(std::size_t size, float multiplier = 1.5) {$/;"	f	class:util::AutoProbing
Merge	kenlm/util/stream/sort.hh	/^    std::size_t Merge(std::size_t lazy_memory) {$/;"	f	class:util::stream::Sort
MergeQueue	kenlm/util/stream/sort.hh	/^    MergeQueue(int fd, std::size_t buffer_size, std::size_t entry_size, const Compare &compare)$/;"	f	class:util::stream::MergeQueue
MergeQueue	kenlm/util/stream/sort.hh	/^template <class Compare> class MergeQueue {$/;"	c	namespace:util::stream
MergeRight	kenlm/lm/builder/initial_probabilities.cc	/^    MergeRight(bool interpolate_unigrams, const util::stream::ChainPosition &from_adder, const Discount &discount)$/;"	f	class:lm::builder::__anon11::MergeRight
MergeRight	kenlm/lm/builder/initial_probabilities.cc	/^class MergeRight {$/;"	c	namespace:lm::builder::__anon11	file:
MergeSortedFiles	kenlm/lm/trie_sort.cc	/^template <class Combine> FILE *MergeSortedFiles(FILE *first_file, FILE *second_file, const std::string &temp_prefix, std::size_t weights_size, unsigned char order, const Combine &combine) {$/;"	f	namespace:lm::ngram::trie::__anon26
MergeTokSet	HLVRec-propagate.c	/^static void MergeTokSet (DecoderInst *dec, TokenSet *src, TokenSet *dest, $/;"	f	file:
MergingReader	kenlm/util/stream/sort.hh	/^    MergingReader(int in, Offsets *in_offsets, Offsets *out_offsets, std::size_t buffer_size, std::size_t total_memory, const Compare &compare, const Combine &combine) :$/;"	f	class:util::stream::MergingReader
MergingReader	kenlm/util/stream/sort.hh	/^template <class Compare, class Combine> class MergingReader {$/;"	c	namespace:util::stream
Middle	kenlm/lm/search_hashed.hh	/^    typedef util::ProbingHashTable<typename Value::ProbingEntry, util::IdentityHash> Middle;$/;"	t	class:lm::ngram::detail::HashedSearch
Middle	kenlm/lm/search_trie.cc	/^    void Middle(const unsigned char order, const void * \/*data*\/) {$/;"	f	class:lm::ngram::trie::__anon24::FindBlanks
Middle	kenlm/lm/search_trie.cc	/^    void Middle(const unsigned char order, const void *data) {$/;"	f	class:lm::ngram::trie::__anon24::WriteEntries
Middle	kenlm/lm/search_trie.hh	/^    typedef trie::BitPackedMiddle<Bhiksha> Middle;$/;"	t	class:lm::ngram::trie::TrieSearch
MiddleBits	kenlm/lm/quantize.hh	/^    static uint8_t MiddleBits(const Config &\/*config*\/) { return 63; }$/;"	f	class:lm::ngram::DontQuantize
MiddleBits	kenlm/lm/quantize.hh	/^    static uint8_t MiddleBits(const Config &config) { return config.prob_bits + config.backoff_bits; }$/;"	f	class:lm::ngram::SeparatelyQuantize
MiddleBlank	kenlm/lm/search_trie.cc	/^    void MiddleBlank(const unsigned char order, const WordIndex *indices, unsigned char \/*lower*\/, float \/*prob_base*\/) {$/;"	f	class:lm::ngram::trie::__anon24::WriteEntries
MiddleBlank	kenlm/lm/search_trie.cc	/^    void MiddleBlank(const unsigned char order, const WordIndex *indices, unsigned char lower, float prob_basis) {$/;"	f	class:lm::ngram::trie::__anon24::FindBlanks
MiddlePointer	kenlm/lm/quantize.hh	/^        MiddlePointer() : address_(NULL, 0) {}$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
MiddlePointer	kenlm/lm/quantize.hh	/^        MiddlePointer() : address_(NULL, 0) {}$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
MiddlePointer	kenlm/lm/quantize.hh	/^        MiddlePointer(const DontQuantize & \/*quant*\/, unsigned char \/*order_minus_2*\/, util::BitAddress address) : address_(address) {}$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
MiddlePointer	kenlm/lm/quantize.hh	/^        MiddlePointer(const SeparatelyQuantize &quant, unsigned char order_minus_2, const util::BitAddress &address) : bins_(quant.GetTables(order_minus_2)), address_(address) {}$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
MiddlePointer	kenlm/lm/quantize.hh	/^    class MiddlePointer {$/;"	c	class:lm::ngram::DontQuantize
MiddlePointer	kenlm/lm/quantize.hh	/^    class MiddlePointer {$/;"	c	class:lm::ngram::SeparatelyQuantize
MiddlePointer	kenlm/lm/search_hashed.hh	/^    typedef typename Value::ProbingProxy MiddlePointer;$/;"	t	class:lm::ngram::detail::HashedSearch
MiddlePointer	kenlm/lm/search_trie.hh	/^    typedef typename Quant::MiddlePointer MiddlePointer;$/;"	t	class:lm::ngram::trie::TrieSearch
Milestone	kenlm/util/ersatz_progress.cc	/^void ErsatzProgress::Milestone() {$/;"	f	class:util::ErsatzProgress
Milestone	kenlm/util/stream/multi_progress.cc	/^void MultiProgress::Milestone(WorkerProgress &worker) {$/;"	f	class:util::stream::MultiProgress
Min	kenlm/util/double-conversion/utils.h	/^static T Min(T a, T b) {$/;"	f	namespace:double_conversion
Minus	kenlm/util/double-conversion/diy-fp.h	/^  static DiyFp Minus(const DiyFp& a, const DiyFp& b) {$/;"	f	class:double_conversion::DiyFp
MissingSentenceMarker	kenlm/lm/vocab.cc	/^void MissingSentenceMarker(const Config &config, const char *str) throw(SpecialWordMissingException) {$/;"	f	namespace:lm::ngram
MissingUnknown	kenlm/lm/vocab.cc	/^void MissingUnknown(const Config &config) throw(SpecialWordMissingException) {$/;"	f	namespace:lm::ngram
Model	kenlm/lm/model.hh	/^typedef ProbingModel Model;$/;"	t	namespace:lm::ngram
Model	kenlm/lm/virtual_interface.hh	/^    explicit Model(size_t state_size) : state_size_(state_size) {}$/;"	f	class:lm::base::Model
Model	kenlm/lm/virtual_interface.hh	/^class Model {$/;"	c	namespace:lm::base
Model	kenlm/lm/wrappers/nplm.cc	/^Model::Model(const std::string &file, std::size_t cache) $/;"	f	class:lm::np::Model
Model	kenlm/lm/wrappers/nplm.hh	/^class Model : public lm::base::ModelFacade<Model, State, Vocabulary> {$/;"	c	namespace:lm::np
ModelFacade	kenlm/lm/facade.hh	/^    ModelFacade() : Model(sizeof(State)) {}$/;"	f	class:lm::base::ModelFacade
ModelFacade	kenlm/lm/facade.hh	/^template <class Child, class StateT, class VocabularyT> class ModelFacade : public Model {$/;"	c	namespace:lm::base
ModelType	kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	t	namespace:lm::ngram	typeref:enum:lm::ngram::__anon20
ModendHyp	HLVRec.h	/^typedef struct _ModendHyp ModendHyp;    \/* records model level tracback *\/$/;"	t	typeref:struct:_ModendHyp
More	kenlm/util/pool.cc	/^void *Pool::More(std::size_t size) {$/;"	f	class:util::Pool
MoveRead	kenlm/lm/filter/thread.hh	/^    void MoveRead() {$/;"	f	class:lm::Controller
MultiCharacter	kenlm/util/tokenize_piece.hh	/^    MultiCharacter() {}$/;"	f	class:util::MultiCharacter
MultiCharacter	kenlm/util/tokenize_piece.hh	/^    explicit MultiCharacter(const StringPiece &delimiter) : delimiter_(delimiter) {}$/;"	f	class:util::MultiCharacter
MultiCharacter	kenlm/util/tokenize_piece.hh	/^class MultiCharacter {$/;"	c	namespace:util
MultiProgress	kenlm/util/stream/multi_progress.cc	/^MultiProgress::MultiProgress() : active_(false), complete_(std::numeric_limits<uint64_t>::max()), character_handout_(0) {}$/;"	f	class:util::stream::MultiProgress
MultiProgress	kenlm/util/stream/multi_progress.hh	/^class MultiProgress {$/;"	c	namespace:util::stream
Multiple	kenlm/lm/filter/format.hh	/^  typedef MultipleARPAOutput Multiple;$/;"	t	struct:lm::ARPAFormat
Multiple	kenlm/lm/filter/format.hh	/^  typedef MultipleOutput<Output> Multiple;$/;"	t	struct:lm::CountFormat
Multiple	kenlm/lm/filter/phrase.hh	/^    explicit Multiple(const Substrings &substrings) : detail::ConditionCommon(substrings) {}$/;"	f	class:lm::phrase::Multiple
Multiple	kenlm/lm/filter/phrase.hh	/^class Multiple : public detail::ConditionCommon {$/;"	c	namespace:lm::phrase
Multiple	kenlm/lm/filter/vocab.hh	/^    Multiple(const Words &vocabs) : vocabs_(vocabs) {}$/;"	f	class:lm::vocab::Multiple
Multiple	kenlm/lm/filter/vocab.hh	/^class Multiple {$/;"	c	namespace:lm::vocab
MultipleARPAOutput	kenlm/lm/filter/format.hh	/^    MultipleARPAOutput(const char *prefix, size_t number) : MultipleOutput<ARPAOutput>(prefix, number) {}$/;"	f	class:lm::MultipleARPAOutput
MultipleARPAOutput	kenlm/lm/filter/format.hh	/^class MultipleARPAOutput : public MultipleOutput<ARPAOutput> {$/;"	c	namespace:lm
MultipleOutput	kenlm/lm/filter/format.hh	/^    MultipleOutput(const char *prefix, size_t number) {$/;"	f	class:lm::MultipleOutput
MultipleOutput	kenlm/lm/filter/format.hh	/^template <class Single> class MultipleOutput {$/;"	c	namespace:lm
MultipleOutputBuffer	kenlm/lm/filter/format.hh	/^    MultipleOutputBuffer() : last_(NULL) {}$/;"	f	class:lm::MultipleOutputBuffer
MultipleOutputBuffer	kenlm/lm/filter/format.hh	/^class MultipleOutputBuffer {$/;"	c	namespace:lm
Multiply	kenlm/util/double-conversion/diy-fp.cc	/^void DiyFp::Multiply(const DiyFp& other) {$/;"	f	class:double_conversion::DiyFp
Multiply	kenlm/util/double-conversion/fixed-dtoa.cc	/^  void Multiply(uint32_t multiplicand) {$/;"	f	class:double_conversion::UInt128
MultiplyByPowerOfTen	kenlm/util/double-conversion/bignum.cc	/^void Bignum::MultiplyByPowerOfTen(int exponent) {$/;"	f	class:double_conversion::Bignum
MultiplyByUInt32	kenlm/util/double-conversion/bignum.cc	/^void Bignum::MultiplyByUInt32(uint32_t factor) {$/;"	f	class:double_conversion::Bignum
MultiplyByUInt64	kenlm/util/double-conversion/bignum.cc	/^void Bignum::MultiplyByUInt64(uint64_t factor) {$/;"	f	class:double_conversion::Bignum
MurmurHash64A	kenlm/util/murmur_hash.cc	/^uint64_t MurmurHash64A ( const void * key, std::size_t len, uint64_t seed )$/;"	f	namespace:util
MurmurHash64B	kenlm/util/murmur_hash.cc	/^uint64_t MurmurHash64B ( const void * key, std::size_t len, uint64_t seed )$/;"	f	namespace:util
MurmurHashNative	kenlm/util/murmur_hash.cc	/^uint64_t MurmurHashNative(const void * key, std::size_t len, uint64_t seed) {$/;"	f	namespace:util
MurmurHashNativeBackend	kenlm/util/murmur_hash.cc	/^template <> inline uint64_t MurmurHashNativeBackend<4>(const void * key, std::size_t len, uint64_t seed) {$/;"	f	namespace:util::__anon43
MurmurHashNativeBackend	kenlm/util/murmur_hash.cc	/^template <unsigned L> inline uint64_t MurmurHashNativeBackend(const void * key, std::size_t len, uint64_t seed) {$/;"	f	namespace:util::__anon43
MustFind	kenlm/util/probing_hash_table.hh	/^    template <class Key> ConstIterator MustFind(const Key key) const {$/;"	f	class:util::AutoProbing
MustFind	kenlm/util/probing_hash_table.hh	/^    template <class Key> ConstIterator MustFind(const Key key) const {$/;"	f	class:util::ProbingHashTable
MutableChains	kenlm/lm/builder/pipeline.cc	/^    util::stream::Chains &MutableChains() { return chains_; }$/;"	f	class:lm::builder::__anon13::Master
MutableIterator	kenlm/util/probing_hash_table.hh	/^    typedef Entry *MutableIterator;$/;"	t	class:util::AutoProbing
MutableIterator	kenlm/util/probing_hash_table.hh	/^    typedef Entry *MutableIterator;$/;"	t	class:util::ProbingHashTable
NBINS	HLVRec-propagate.c	236;"	d	file:
NDEBUG	config.h	30;"	d
NEntry	HLVLM.h	/^} NEntry;$/;"	t	typeref:struct:nentry
NGHSIZE1	HLVLM.c	1497;"	d	file:
NGHSIZE2	HLVLM.c	1498;"	d	file:
NGHSIZE3	HLVLM.c	1499;"	d	file:
NGLM_PROB_ADD	HLVLM.h	130;"	d
NGLM_PROB_GREATER	HLVLM.h	129;"	d
NGLM_PROB_GREATER	HLVLM.h	137;"	d
NGLM_PROB_LZERO	HLVLM.h	127;"	d
NGLM_PROB_LZERO	HLVLM.h	135;"	d
NGLM_PROB_TO_FLOAT	HLVLM.h	125;"	d
NGLM_PROB_TO_FLOAT	HLVLM.h	133;"	d
NGLM_PROB_ZERO	HLVLM.h	128;"	d
NGLM_PROB_ZERO	HLVLM.h	136;"	d
NGLM_Prob	HLVLM.h	/^   typedef float NGLM_Prob;$/;"	t
NGLM_Prob	HLVLM.h	/^   typedef unsigned short NGLM_Prob;$/;"	t
NGram	kenlm/lm/builder/ngram.hh	/^    NGram(void *begin, std::size_t order)$/;"	f	class:lm::builder::NGram
NGram	kenlm/lm/builder/ngram.hh	/^class NGram {$/;"	c	namespace:lm::builder
NGramIter	kenlm/lm/trie_sort.cc	/^typedef util::SizedIterator NGramIter;$/;"	t	namespace:lm::ngram::trie::__anon26	file:
NGramStream	kenlm/lm/builder/ngram_stream.hh	/^    NGramStream() : gram_(NULL, 0) {}$/;"	f	class:lm::builder::NGramStream
NGramStream	kenlm/lm/builder/ngram_stream.hh	/^    NGramStream(const util::stream::ChainPosition &position) : gram_(NULL, 0) {$/;"	f	class:lm::builder::NGramStream
NGramStream	kenlm/lm/builder/ngram_stream.hh	/^class NGramStream {$/;"	c	namespace:lm::builder
NGramStreams	kenlm/lm/builder/ngram_stream.hh	/^typedef util::stream::GenericStreams<NGramStream> NGramStreams;$/;"	t	namespace:lm::builder
NLAYERS	HLVNet.h	131;"	d
NONE	kenlm/lm/config.hh	/^  enum ARPALoadComplain {ALL, EXPENSIVE, NONE};$/;"	e	enum:lm::ngram::Config::ARPALoadComplain
NONE_ALLOCATED	kenlm/util/mmap.hh	/^    typedef enum {MMAP_ALLOCATED, ARRAY_ALLOCATED, MALLOC_ALLOCATED, NONE_ALLOCATED} Alloc;$/;"	e	enum:util::scoped_memory::__anon41
NO_FLAGS	kenlm/util/double-conversion/double-conversion.h	/^    NO_FLAGS = 0,$/;"	e	enum:double_conversion::DoubleToStringConverter::Flags
NO_FLAGS	kenlm/util/double-conversion/double-conversion.h	/^    NO_FLAGS = 0,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
NPLM_MAX_ORDER	kenlm/lm/wrappers/nplm.hh	46;"	d
NSIZE	HLVLM.h	98;"	d
NULL	kenlm/util/getopt.c	15;"	d	file:
NUMBER_OF_HOOKS	kenlm/lm/builder/output.hh	/^  NUMBER_OF_HOOKS \/\/ Keep this last so we know how many values there are.$/;"	e	enum:lm::builder::HookType
NaN	kenlm/util/double-conversion/ieee.h	/^  static double NaN() {$/;"	f	class:double_conversion::Double
NaN	kenlm/util/double-conversion/ieee.h	/^  static float NaN() {$/;"	f	class:double_conversion::Single
NameFromFD	kenlm/util/file.cc	/^std::string NameFromFD(int fd) {$/;"	f	namespace:util
NameGuess	kenlm/util/file.hh	/^    const std::string &NameGuess() const { return name_guess_; }$/;"	f	class:util::FDException
NamePossiblyFind	kenlm/util/file_piece.cc	/^std::string NamePossiblyFind(int fd, const char *name) {$/;"	f	namespace:util::__anon38
NeverCombine	kenlm/util/stream/sort.hh	/^struct NeverCombine {$/;"	s	namespace:util::stream
NewInput	kenlm/lm/filter/thread.hh	/^    void NewInput() {$/;"	f	class:lm::Controller
NewSTLLink	HLVNet.c	/^STLexLink *NewSTLLink (MemHeap *heap)$/;"	f
NewSTLNode	HLVNet.c	/^STLexNode *NewSTLNode (MemHeap *heap)$/;"	f
NewTLexNodeCon	HLVNet.c	/^TLexNode *NewTLexNodeCon (MemHeap *heap, TLexNet *net, int layerId, LabId lc, LabId rc)$/;"	f
NewTLexNodeMod	HLVNet.c	/^TLexNode *NewTLexNodeMod (MemHeap *heap, TLexNet *net, int layerId, HLink hmm)$/;"	f
NewTLexNodeWe	HLVNet.c	/^TLexNode *NewTLexNodeWe (MemHeap *heap, TLexNet *net, int layerId, Pron pron)$/;"	f
NewTokSetArray	HLVRec.c	/^static TokenSet *NewTokSetArray(DecoderInst *dec, int N)$/;"	f	file:
NewTokSetArrayVar	HLVRec.c	/^static TokenSet *NewTokSetArrayVar(DecoderInst *dec, int N, Boolean isSil)$/;"	f	file:
Next	kenlm/lm/trie.hh	/^  uint64_t Next() const { return next; }$/;"	f	struct:lm::ngram::trie::UnigramValue
Next	kenlm/lm/value.hh	/^    uint64_t Next() const { return next; }$/;"	f	struct:lm::ngram::BackoffValue::TrieUnigramValue
Next	kenlm/lm/value.hh	/^    uint64_t Next() const { return next; }$/;"	f	struct:lm::ngram::RestValue::TrieUnigramValue
Next	kenlm/util/stream/multi_progress.cc	/^uint64_t Next(unsigned char stone, uint64_t complete) {$/;"	f	namespace:util::stream::__anon47
NextDouble	kenlm/util/double-conversion/ieee.h	/^  double NextDouble() const {$/;"	f	class:double_conversion::Double
NextInMemory	kenlm/lm/builder/ngram.hh	/^    void NextInMemory() {$/;"	f	class:lm::builder::NGram
NextSize	kenlm/util/stream/sort.hh	/^    uint64_t NextSize() {$/;"	f	class:util::stream::Offsets
NoOpUniqueWords	kenlm/lm/vocab.hh	/^    NoOpUniqueWords() {}$/;"	f	class:lm::ngram::NoOpUniqueWords
NoOpUniqueWords	kenlm/lm/vocab.hh	/^class NoOpUniqueWords {$/;"	c	namespace:lm::ngram
NoRestBuild	kenlm/lm/value_build.hh	/^    NoRestBuild() {}$/;"	f	class:lm::ngram::NoRestBuild
NoRestBuild	kenlm/lm/value_build.hh	/^class NoRestBuild {$/;"	c	namespace:lm::ngram
Node	kenlm/lm/search_hashed.hh	/^    typedef uint64_t Node;$/;"	t	class:lm::ngram::detail::HashedSearch
Node	kenlm/lm/search_trie.hh	/^    typedef NodeRange Node;$/;"	t	class:lm::ngram::trie::TrieSearch
NodeRange	kenlm/lm/trie.hh	/^struct NodeRange {$/;"	s	namespace:lm::ngram::trie
NonTerminal	kenlm/lm/left.hh	/^    void NonTerminal(const ChartState &in, float prob = 0.0) {$/;"	f	class:lm::ngram::RuleScore
Normalize	kenlm/util/double-conversion/diy-fp.h	/^  static DiyFp Normalize(const DiyFp& a) {$/;"	f	class:double_conversion::DiyFp
Normalize	kenlm/util/double-conversion/diy-fp.h	/^  void Normalize() {$/;"	f	class:double_conversion::DiyFp
NormalizeTempPrefix	kenlm/util/file.cc	/^void NormalizeTempPrefix(std::string &base) {$/;"	f	namespace:util
NormalizedBoundaries	kenlm/util/double-conversion/ieee.h	/^  void NormalizedBoundaries(DiyFp* out_m_minus, DiyFp* out_m_plus) const {$/;"	f	class:double_conversion::Double
NormalizedBoundaries	kenlm/util/double-conversion/ieee.h	/^  void NormalizedBoundaries(DiyFp* out_m_minus, DiyFp* out_m_plus) const {$/;"	f	class:double_conversion::Single
NormalizedExponent	kenlm/util/double-conversion/bignum-dtoa.cc	/^static int NormalizedExponent(uint64_t significand, int exponent) {$/;"	f	namespace:double_conversion
NotFound	kenlm/lm/virtual_interface.hh	/^    WordIndex NotFound() const { return not_found_; }$/;"	f	class:lm::base::Vocabulary
NullContextMemory	kenlm/lm/virtual_interface.hh	/^    const void *NullContextMemory() const { return null_context_memory_; }$/;"	f	class:lm::base::Model
NullContextState	kenlm/lm/facade.hh	/^    const State &NullContextState() const { return null_context_; }$/;"	f	class:lm::base::ModelFacade
NullContextWrite	kenlm/lm/virtual_interface.hh	/^    void NullContextWrite(void *to) const { memcpy(to, null_context_memory_, StateSize()); }$/;"	f	class:lm::base::Model
NullWord	kenlm/lm/wrappers/nplm.hh	/^    lm::WordIndex NullWord() const { return null_word_; }$/;"	f	class:lm::np::Vocabulary
ObtainBackoffs	kenlm/lm/search_trie.cc	/^    void ObtainBackoffs(unsigned char total_order, FILE *unigram_file, RecordReader *reader) {$/;"	f	class:lm::ngram::trie::__anon24::SRISucks
Offset	kenlm/util/file_piece.hh	/^    uint64_t Offset() const {$/;"	f	class:util::FilePiece
Offsets	kenlm/util/stream/sort.hh	/^    explicit Offsets(int fd) : log_(fd) {$/;"	f	class:util::stream::Offsets
Offsets	kenlm/util/stream/sort.hh	/^class Offsets {$/;"	c	namespace:util::stream
OldSanity	kenlm/lm/binary_format.cc	/^struct OldSanity {$/;"	s	namespace:lm::ngram::__anon7	file:
OnlyGamma	kenlm/lm/builder/initial_probabilities.cc	/^    OnlyGamma(bool pruning) : pruning_(pruning) {}$/;"	f	class:lm::builder::__anon11::OnlyGamma
OnlyGamma	kenlm/lm/builder/initial_probabilities.cc	/^class OnlyGamma {$/;"	c	namespace:lm::builder::__anon11	file:
OpenReadOrThrow	kenlm/util/file.cc	/^int OpenReadOrThrow(const char *name) {$/;"	f	namespace:util
Order	kenlm/lm/builder/ngram.hh	/^    std::size_t Order() const { return end_ - begin_; }$/;"	f	class:lm::builder::NGram
Order	kenlm/lm/builder/sort.hh	/^    std::size_t Order() const { return order_; }$/;"	f	class:lm::builder::Comparator
Order	kenlm/lm/interpolate/arpa_to_stream.hh	/^    std::size_t Order() const { return counts_.size(); }$/;"	f	class:lm::interpolate::ARPAToStream
Order	kenlm/lm/search_hashed.hh	/^    unsigned char Order() const {$/;"	f	class:lm::ngram::detail::HashedSearch
Order	kenlm/lm/search_trie.hh	/^    unsigned char Order() const {$/;"	f	class:lm::ngram::trie::TrieSearch
Order	kenlm/lm/virtual_interface.hh	/^    unsigned char Order() const { return order_; }$/;"	f	class:lm::base::Model
OrderFromSize	kenlm/lm/builder/ngram.hh	/^    static std::size_t OrderFromSize(std::size_t size) {$/;"	f	class:lm::builder::NGram
OrderStat	kenlm/lm/builder/adjust_counts.cc	/^    struct OrderStat {$/;"	s	class:lm::builder::__anon8::StatCollector	file:
OutOfTokens	kenlm/util/tokenize_piece.hh	/^    OutOfTokens() throw() {}$/;"	f	class:util::OutOfTokens
OutOfTokens	kenlm/util/tokenize_piece.hh	/^class OutOfTokens : public Exception {$/;"	c	namespace:util
OutPBlock	HLVModel.c	/^void OutPBlock (StateInfo_lv *si, Observation **obsBlock, $/;"	f
OutPBlock_HMod	HLVRec-outP.c	/^void OutPBlock_HMod (StateInfo_lv *si, Observation **obsBlock, $/;"	f
OutPCache	HLVRec.h	/^typedef struct _OutPCache OutPCache;$/;"	t	typeref:struct:_OutPCache
OutP_lv	HLVModel.c	/^LogFloat OutP_lv (StateInfo_lv *si,  unsigned short s, float *x)$/;"	f
Output	kenlm/lm/builder/output.hh	/^    Output() {}$/;"	f	class:lm::builder::Output
Output	kenlm/lm/builder/output.hh	/^class Output : boost::noncopyable {$/;"	c	namespace:lm::builder
Output	kenlm/lm/filter/format.hh	/^  typedef ARPAOutput Output;$/;"	t	struct:lm::ARPAFormat
Output	kenlm/lm/filter/format.hh	/^  typedef CountOutput Output;$/;"	t	struct:lm::CountFormat
Output	kenlm/util/stream/sort.hh	/^    void Output(Chain &out) {$/;"	f	class:util::stream::Sort
Output	kenlm/util/stream/sort.hh	/^    void Output(Chain &out, std::size_t lazy_memory) {$/;"	f	class:util::stream::Sort
OutputHook	kenlm/lm/builder/output.hh	/^    explicit OutputHook(HookType hook_type) : type_(hook_type), master_(NULL) {}$/;"	f	class:lm::builder::OutputHook
OutputHook	kenlm/lm/builder/output.hh	/^class OutputHook {$/;"	c	namespace:lm::builder
OutputProbBackoff	kenlm/lm/builder/interpolate.cc	/^    explicit OutputProbBackoff(std::size_t \/*order*\/) {}$/;"	f	class:lm::builder::__anon12::OutputProbBackoff
OutputProbBackoff	kenlm/lm/builder/interpolate.cc	/^class OutputProbBackoff {$/;"	c	namespace:lm::builder::__anon12	file:
OutputQ	kenlm/lm/builder/interpolate.cc	/^    explicit OutputQ(std::size_t order) : q_delta_(order) {}$/;"	f	class:lm::builder::__anon12::OutputQ
OutputQ	kenlm/lm/builder/interpolate.cc	/^class OutputQ {$/;"	c	namespace:lm::builder::__anon12	file:
OutputWorker	kenlm/lm/filter/thread.hh	/^    OutputWorker(Output &output, util::PCQueue<Request> &done) : output_(output), done_(done), base_sequence_(0) {}$/;"	f	class:lm::OutputWorker
OutputWorker	kenlm/lm/filter/thread.hh	/^template <class Batch, class Output> class OutputWorker {$/;"	c	namespace:lm
OverflowException	kenlm/util/exception.cc	/^OverflowException::OverflowException() throw() {}$/;"	f	class:util::OverflowException
OverflowException	kenlm/util/exception.hh	/^class OverflowException : public Exception {$/;"	c	namespace:util
Overwrite	kenlm/lm/trie_sort.cc	/^void RecordReader::Overwrite(const void *start, std::size_t amount) {$/;"	f	class:lm::ngram::trie::RecordReader
OwningMergingReader	kenlm/util/stream/sort.hh	/^    OwningMergingReader(int data, const Offsets &offsets, std::size_t buffer, std::size_t lazy, const Compare &compare, const Combine &combine) $/;"	f	class:util::stream::OwningMergingReader
OwningMergingReader	kenlm/util/stream/sort.hh	/^template <class Compare, class Combine> class OwningMergingReader : public MergingReader<Compare, Combine> {$/;"	c	namespace:util::stream
P	kenlm/lm/builder/sort.hh	/^    typedef util::FixedArray<S> P;$/;"	t	class:lm::builder::Sorts
P	kenlm/lm/model.hh	/^    typedef base::ModelFacade<GenericModel<Search, VocabularyT>, State, VocabularyT> P;$/;"	t	class:lm::ngram::detail::GenericModel
P	kenlm/lm/wrappers/nplm.hh	/^    typedef lm::base::ModelFacade<Model, State, Vocabulary> P;$/;"	t	class:lm::np::Model
P	kenlm/util/stream/multi_stream.hh	/^    typedef util::FixedArray<T> P;$/;"	t	class:util::stream::GenericStreams
P	kenlm/util/stream/sort.hh	/^    typedef MergingReader<Compare, Combine> P;$/;"	t	class:util::stream::OwningMergingReader
PARALLEL_READ	kenlm/util/mmap.hh	/^  PARALLEL_READ,$/;"	e	enum:util::__anon42
PCQueue	kenlm/util/pcqueue.hh	/^  explicit PCQueue(size_t size)$/;"	f	class:util::PCQueue
PCQueue	kenlm/util/pcqueue.hh	/^template <class T> class PCQueue : boost::noncopyable {$/;"	c	namespace:util
PFN_MS_EX	kenlm/util/usage.cc	/^typedef WINBOOL (WINAPI *PFN_MS_EX) (lMEMORYSTATUSEX*);$/;"	t	file:
PI_GEN	HLVRec-propagate.c	/^static int PI_GEN = 0;$/;"	v	file:
PI_LR	HLVRec-propagate.c	/^static int PI_LR = 0;$/;"	v	file:
POPULATE_OR_LAZY	kenlm/util/mmap.hh	/^  POPULATE_OR_LAZY,$/;"	e	enum:util::__anon42
POPULATE_OR_READ	kenlm/util/mmap.hh	/^  POPULATE_OR_READ,$/;"	e	enum:util::__anon42
POutP_HModel	HLVRec-outP.c	/^LogFloat POutP_HModel (HMMSet *hset,Observation *x, StateInfo *si, int id)$/;"	f
PRECISION	kenlm/util/double-conversion/double-conversion.h	/^    PRECISION$/;"	e	enum:double_conversion::DoubleToStringConverter::DtoaMode
PROBING	kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon20
PROB_PARALLEL_HOOK	kenlm/lm/builder/output.hh	/^  PROB_PARALLEL_HOOK, \/\/ Probability and backoff (or just q).  Output must process the orders in parallel or there will be a deadlock.$/;"	e	enum:lm::builder::HookType
PROB_SEQUENTIAL_HOOK	kenlm/lm/builder/output.hh	/^  PROB_SEQUENTIAL_HOOK, \/\/ Probability and backoff (or just q).  Output can process orders any way it likes.  This requires writing the data to disk then reading.  Useful for ARPA files, which put unigrams first etc.$/;"	e	enum:lm::builder::HookType
PROGRESS	HLVLM.c	298;"	d	file:
PRUNE	HLVRec.c	59;"	d	file:
PRead	kenlm/util/stream/io.hh	/^    explicit PRead(int fd, bool take_own = false) : file_(fd), own_(take_own) {}$/;"	f	class:util::stream::PRead
PRead	kenlm/util/stream/io.hh	/^class PRead {$/;"	c	namespace:util::stream
PWriteAndRecycle	kenlm/util/stream/io.hh	/^    explicit PWriteAndRecycle(int fd) : file_(fd) {}$/;"	f	class:util::stream::PWriteAndRecycle
PWriteAndRecycle	kenlm/util/stream/io.hh	/^class PWriteAndRecycle {$/;"	c	namespace:util::stream
PairedIterator	kenlm/util/joint_sort.hh	/^    PairedIterator(const KeyIter &key, const ValueIter &value) :$/;"	f	class:util::PairedIterator
PairedIterator	kenlm/util/joint_sort.hh	/^template <class KeyIter, class ValueIter> class PairedIterator : public ProxyIterator<detail::JointProxy<KeyIter, ValueIter> > {$/;"	c	namespace:util
ParallelRead	kenlm/util/parallel_read.cc	/^void ParallelRead(int fd, void *to, std::size_t amount, uint64_t offset) {$/;"	f	namespace:util
Parameters	kenlm/lm/binary_format.hh	/^struct Parameters {$/;"	s	namespace:lm::ngram
ParseNum	kenlm/util/usage.cc	/^template <class Num> uint64_t ParseNum(const std::string &arg) {$/;"	f	namespace:util::__anon50
ParseNumber	kenlm/util/file_piece.cc	/^void ParseNumber(const char *begin, const char *&end, double &out) {$/;"	f	namespace:util::__anon39
ParseNumber	kenlm/util/file_piece.cc	/^void ParseNumber(const char *begin, const char *&end, float &out) {$/;"	f	namespace:util::__anon39
ParseNumber	kenlm/util/file_piece.cc	/^void ParseNumber(const char *begin, const char *&end, long int &out) {$/;"	f	namespace:util::__anon39
ParseNumber	kenlm/util/file_piece.cc	/^void ParseNumber(const char *begin, const char *&end, unsigned long int &out) {$/;"	f	namespace:util::__anon39
ParseNumberException	kenlm/util/file_piece.cc	/^ParseNumberException::ParseNumberException(StringPiece value) throw() {$/;"	f	class:util::ParseNumberException
ParseNumberException	kenlm/util/file_piece.hh	/^class ParseNumberException : public Exception {$/;"	c	namespace:util
ParseSize	kenlm/util/usage.cc	/^uint64_t ParseSize(const std::string &arg) {$/;"	f	namespace:util
PartialIter	kenlm/lm/trie_sort.cc	/^typedef util::ProxyIterator<PartialViewProxy> PartialIter;$/;"	t	namespace:lm::ngram::trie::__anon26	file:
PartialRead	kenlm/util/file.cc	/^std::size_t PartialRead(int fd, void *to, std::size_t amount) {$/;"	f	namespace:util
PartialViewProxy	kenlm/lm/trie_sort.cc	/^    PartialViewProxy() : attention_size_(0), inner_() {}$/;"	f	class:lm::ngram::trie::__anon26::PartialViewProxy
PartialViewProxy	kenlm/lm/trie_sort.cc	/^    PartialViewProxy(void *ptr, std::size_t block_size, std::size_t attention_size) : attention_size_(attention_size), inner_(ptr, block_size) {}$/;"	f	class:lm::ngram::trie::__anon26::PartialViewProxy
PartialViewProxy	kenlm/lm/trie_sort.cc	/^class PartialViewProxy {$/;"	c	namespace:lm::ngram::trie::__anon26	file:
PassNGram	kenlm/lm/filter/phrase.hh	/^    template <class Iterator> bool PassNGram(const Iterator &begin, const Iterator &end) {$/;"	f	class:lm::phrase::Union
PassNGram	kenlm/lm/filter/vocab.hh	/^    template <class Iterator> bool PassNGram(const Iterator &begin, const Iterator &end) {$/;"	f	class:lm::vocab::Single
PassNGram	kenlm/lm/filter/vocab.hh	/^    template <class Iterator> bool PassNGram(const Iterator &begin, const Iterator &end) {$/;"	f	class:lm::vocab::Union
Paths2Lat	HLVRec-traceback.c	/^static void Paths2Lat (DecoderInst *dec, Lattice *lat, WordendHyp *path,$/;"	f	file:
Payload	kenlm/lm/builder/ngram.hh	/^union Payload {$/;"	u	namespace:lm::builder
PeekSize	kenlm/util/stream/sort.hh	/^    uint64_t PeekSize() const {$/;"	f	class:util::stream::Offsets
Pipeline	kenlm/lm/builder/pipeline.cc	/^void Pipeline(PipelineConfig &config, int text_file, Output &output) {$/;"	f	namespace:lm::builder
PipelineConfig	kenlm/lm/builder/pipeline.hh	/^struct PipelineConfig {$/;"	s	namespace:lm::builder
Pivot32	kenlm/util/sorted_uniform.hh	/^struct Pivot32 {$/;"	s	namespace:util
Pivot64	kenlm/util/sorted_uniform.hh	/^struct Pivot64 {$/;"	s	namespace:util
PivotSelect	kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<2> { typedef Pivot32 T; };$/;"	s	namespace:util
PivotSelect	kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<4> { typedef Pivot32 T; };$/;"	s	namespace:util
PivotSelect	kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<8> { typedef Pivot64 T; };$/;"	s	namespace:util
PlusCompare	kenlm/util/double-conversion/bignum.cc	/^int Bignum::PlusCompare(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:double_conversion::Bignum
PlusEqual	kenlm/util/double-conversion/bignum.h	/^  static bool PlusEqual(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:double_conversion::Bignum
PlusLess	kenlm/util/double-conversion/bignum.h	/^  static bool PlusLess(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:double_conversion::Bignum
PlusLessEqual	kenlm/util/double-conversion/bignum.h	/^  static bool PlusLessEqual(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:double_conversion::Bignum
Poison	kenlm/lm/builder/ngram_stream.hh	/^    void Poison() { stream_.Poison(); }$/;"	f	class:lm::builder::NGramStream
Poison	kenlm/util/stream/chain.cc	/^void Link::Poison() {$/;"	f	class:util::stream::Link
Poison	kenlm/util/stream/stream.hh	/^    void Poison() {$/;"	f	class:util::stream::Stream
Pool	kenlm/util/pool.cc	/^Pool::Pool() {$/;"	f	class:util::Pool
Pool	kenlm/util/pool.hh	/^class Pool {$/;"	c	namespace:util
Pop	kenlm/util/stream/sort.hh	/^    void Pop() {$/;"	f	class:util::stream::MergeQueue
PopFront	kenlm/lm/trie_sort.cc	/^    void PopFront() {$/;"	f	class:lm::ngram::trie::__anon27::Closer
Populate	kenlm/lm/quantize.hh	/^        float *Populate() { return begin_; }$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
PopulateUnigramWeights	kenlm/lm/search_trie.cc	/^void PopulateUnigramWeights(FILE *file, WordIndex unigram_count, RecordReader &contexts, UnigramValue *unigrams) {$/;"	f	namespace:lm::ngram::trie::__anon24
PositiveProbWarn	kenlm/lm/read_arpa.hh	/^    PositiveProbWarn() : action_(THROW_UP) {}$/;"	f	class:lm::PositiveProbWarn
PositiveProbWarn	kenlm/lm/read_arpa.hh	/^    explicit PositiveProbWarn(WarningAction action) : action_(action) {}$/;"	f	class:lm::PositiveProbWarn
PositiveProbWarn	kenlm/lm/read_arpa.hh	/^class PositiveProbWarn {$/;"	c	namespace:lm
PowersOfTenCache	kenlm/util/double-conversion/cached-powers.h	/^class PowersOfTenCache {$/;"	c	namespace:double_conversion
PrefixOrder	kenlm/lm/builder/sort.hh	/^    explicit PrefixOrder(std::size_t order) : Comparator<PrefixOrder>(order) {}$/;"	f	class:lm::builder::PrefixOrder
PrefixOrder	kenlm/lm/builder/sort.hh	/^class PrefixOrder : public Comparator<PrefixOrder> {$/;"	c	namespace:lm::builder
PreviousDouble	kenlm/util/double-conversion/ieee.h	/^  double PreviousDouble() const {$/;"	f	class:double_conversion::Double
Print	kenlm/lm/builder/print.hh	/^    explicit Print(const VocabReconstitute &vocab, int fd) : vocab_(vocab), to_(fd) {}$/;"	f	class:lm::builder::Print
Print	kenlm/lm/builder/print.hh	/^template <class V> class Print {$/;"	c	namespace:lm::builder
PrintARPA	kenlm/lm/builder/print.hh	/^    explicit PrintARPA(int fd, bool verbose_header)$/;"	f	class:lm::builder::PrintARPA
PrintARPA	kenlm/lm/builder/print.hh	/^class PrintARPA : public OutputHook {$/;"	c	namespace:lm::builder
PrintAlignBestInfo	HDecode.c	/^void PrintAlignBestInfo (DecoderInst *dec, BestInfo *b)$/;"	f
PrintAlignBestInfo	HDecode.mod.c	/^void PrintAlignBestInfo (DecoderInst *dec, BestInfo *b)$/;"	f
PrintLMHashStats	HLVLM.c	/^void PrintLMHashStats(FSLM *lm)$/;"	f
PrintModPath	HLVRec-traceback.c	/^void PrintModPath (DecoderInst *dec, ModendHyp *m)$/;"	f
PrintPath	HLVRec-traceback.c	/^static void PrintPath (DecoderInst *dec, WordendHyp *we)$/;"	f	file:
PrintPayload	kenlm/lm/builder/print.hh	/^template <> inline void PrintPayload<ProbBackoff>(util::FakeOFStream &to, const Payload &payload) {$/;"	f	namespace:lm::builder
PrintPayload	kenlm/lm/builder/print.hh	/^template <> inline void PrintPayload<Uninterpolated>(util::FakeOFStream &to, const Payload &payload) {$/;"	f	namespace:lm::builder
PrintPayload	kenlm/lm/builder/print.hh	/^template <> inline void PrintPayload<uint64_t>(util::FakeOFStream &to, const Payload &payload) {$/;"	f	namespace:lm::builder
PrintRelTok	HLVRec-traceback.c	/^static void PrintRelTok(DecoderInst *dec, RelToken *tok)$/;"	f	file:
PrintState_lv	HLVModel.c	/^void PrintState_lv (StateInfo_lv *si,  unsigned short s)$/;"	f
PrintStatistics	kenlm/lm/builder/pipeline.cc	/^void PrintStatistics(const std::vector<uint64_t> &counts, const std::vector<uint64_t> &counts_pruned, const std::vector<Discount> &discounts) {$/;"	f	namespace:lm::builder::__anon13
PrintTok	HLVRec-traceback.c	/^static void PrintTok(DecoderInst *dec, Token *tok)$/;"	f	file:
PrintTokSet	HLVRec-traceback.c	/^static void PrintTokSet (DecoderInst *dec, TokenSet *ts)$/;"	f	file:
PrintUsage	kenlm/util/usage.cc	/^void PrintUsage(std::ostream &out) {$/;"	f	namespace:util
Prob	kenlm/lm/quantize.hh	/^        float Prob() const {$/;"	f	class:lm::ngram::DontQuantize::LongestPointer
Prob	kenlm/lm/quantize.hh	/^        float Prob() const {$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
Prob	kenlm/lm/quantize.hh	/^        float Prob() const {$/;"	f	class:lm::ngram::SeparatelyQuantize::LongestPointer
Prob	kenlm/lm/quantize.hh	/^        float Prob() const {$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
Prob	kenlm/lm/search_hashed.hh	/^    float Prob() const {$/;"	f	class:lm::ngram::detail::LongestPointer
Prob	kenlm/lm/trie.hh	/^    float Prob() const { return to_->prob; }$/;"	f	class:lm::ngram::trie::UnigramPointer
Prob	kenlm/lm/value.hh	/^    float Prob() const { return to_->prob; }$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
Prob	kenlm/lm/value.hh	/^    float Prob() const {$/;"	f	class:lm::ngram::GenericProbingProxy
Prob	kenlm/lm/weights.hh	/^struct Prob {$/;"	s	namespace:lm
ProbBackoff	kenlm/lm/weights.hh	/^struct ProbBackoff {$/;"	s	namespace:lm
ProbBins	kenlm/lm/quantize.hh	/^        const Bins &ProbBins() const { return bins_[0]; }$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
ProbEntry	kenlm/lm/search_hashed.hh	/^struct ProbEntry {$/;"	s	namespace:lm::ngram::detail
ProbPointer	kenlm/lm/search_trie.cc	/^struct ProbPointer {$/;"	s	namespace:lm::ngram::trie::__anon24	file:
ProbingEntry	kenlm/lm/value.hh	/^  struct ProbingEntry {$/;"	s	struct:lm::ngram::BackoffValue
ProbingEntry	kenlm/lm/value.hh	/^  struct ProbingEntry {$/;"	s	struct:lm::ngram::RestValue
ProbingHashTable	kenlm/util/probing_hash_table.hh	/^    ProbingHashTable() : entries_(0)$/;"	f	class:util::ProbingHashTable
ProbingHashTable	kenlm/util/probing_hash_table.hh	/^    ProbingHashTable(void *start, std::size_t allocated, const Key &invalid = Key(), const Hash &hash_func = Hash(), const Equal &equal_func = Equal())$/;"	f	class:util::ProbingHashTable
ProbingHashTable	kenlm/util/probing_hash_table.hh	/^template <class EntryT, class HashT, class EqualT = std::equal_to<typename EntryT::Key> > class ProbingHashTable {$/;"	c	namespace:util
ProbingProxy	kenlm/lm/value.hh	/^      ProbingProxy() {}$/;"	f	class:lm::ngram::BackoffValue::ProbingProxy
ProbingProxy	kenlm/lm/value.hh	/^      ProbingProxy() {}$/;"	f	class:lm::ngram::RestValue::ProbingProxy
ProbingProxy	kenlm/lm/value.hh	/^      explicit ProbingProxy(const Weights &to) : GenericProbingProxy<RestWeights>(to) {}$/;"	f	class:lm::ngram::RestValue::ProbingProxy
ProbingProxy	kenlm/lm/value.hh	/^      explicit ProbingProxy(const Weights &to) : GenericProbingProxy<Weights>(to) {}$/;"	f	class:lm::ngram::BackoffValue::ProbingProxy
ProbingProxy	kenlm/lm/value.hh	/^  class ProbingProxy : public GenericProbingProxy<RestWeights> {$/;"	c	struct:lm::ngram::RestValue
ProbingProxy	kenlm/lm/value.hh	/^  class ProbingProxy : public GenericProbingProxy<Weights> {$/;"	c	struct:lm::ngram::BackoffValue
ProbingSizeException	kenlm/util/probing_hash_table.hh	/^    ProbingSizeException() throw() {}$/;"	f	class:util::ProbingSizeException
ProbingSizeException	kenlm/util/probing_hash_table.hh	/^class ProbingSizeException : public Exception {$/;"	c	namespace:util
ProbingVocabulary	kenlm/lm/vocab.cc	/^ProbingVocabulary::ProbingVocabulary() : enumerate_(NULL) {}$/;"	f	class:lm::ngram::ProbingVocabulary
ProbingVocabulary	kenlm/lm/vocab.hh	/^class ProbingVocabulary : public base::Vocabulary {$/;"	c	namespace:lm::ngram
ProbingVocabularyEntry	kenlm/lm/vocab.hh	/^struct ProbingVocabularyEntry {$/;"	s	namespace:lm::ngram
ProbingVocabularyHeader	kenlm/lm/vocab.cc	/^struct ProbingVocabularyHeader {$/;"	s	namespace:lm::ngram::detail	file:
Process	kenlm/util/read_compressed.cc	/^    bool Process() {$/;"	f	class:util::__anon45::BZip
Process	kenlm/util/read_compressed.cc	/^    bool Process() {$/;"	f	class:util::__anon45::GZip
Process	kenlm/util/read_compressed.cc	/^    bool Process() {$/;"	f	class:util::__anon45::XZip
ProcessFrame	HLVRec-propagate.c	/^void ProcessFrame (DecoderInst *dec, Observation **obsBlock, int nObs, $/;"	f
ProcessRet	kenlm/lm/left.hh	/^    void ProcessRet(const FullScoreReturn &ret) {$/;"	f	class:lm::ngram::RuleScore
Produce	kenlm/util/pcqueue.hh	/^  void Produce(const T &val) {$/;"	f	class:util::PCQueue
Produce	kenlm/util/thread_pool.hh	/^    void Produce(const Request &request) {$/;"	f	class:util::ThreadPool
ProgressMessages	kenlm/lm/config.hh	/^  std::ostream *ProgressMessages() const {$/;"	f	struct:lm::ngram::Config
PronId	config.h	/^typedef unsigned int PronId;$/;"	t
PropIntoNode	HLVRec-propagate.c	/^static void PropIntoNode (DecoderInst *dec, TokenSet *ts, LexNode *ln, Boolean updateLMLA)$/;"	f	file:
PropagateExternal	HLVRec-propagate.c	/^static void PropagateExternal (DecoderInst *dec, LexNodeInst *inst, $/;"	f	file:
PropagateInternal	HLVRec-propagate.c	/^static void PropagateInternal (DecoderInst *dec, LexNodeInst *inst)$/;"	f	file:
ProxyIterator	kenlm/util/proxy_iterator.hh	/^    ProxyIterator() {}$/;"	f	class:util::ProxyIterator
ProxyIterator	kenlm/util/proxy_iterator.hh	/^    explicit ProxyIterator(const Proxy &p) : p_(p) {}$/;"	f	class:util::ProxyIterator
ProxyIterator	kenlm/util/proxy_iterator.hh	/^    template <class AlternateProxy> ProxyIterator(const ProxyIterator<AlternateProxy> &in) : p_(*in) {}$/;"	f	class:util::ProxyIterator
ProxyIterator	kenlm/util/proxy_iterator.hh	/^template <class Proxy> class ProxyIterator {$/;"	c	namespace:util
PruneNGramStream	kenlm/lm/builder/initial_probabilities.cc	/^    PruneNGramStream(const util::stream::ChainPosition &position) :$/;"	f	class:lm::builder::__anon11::PruneNGramStream
PruneNGramStream	kenlm/lm/builder/initial_probabilities.cc	/^class PruneNGramStream {$/;"	c	namespace:lm::builder::__anon11	file:
PruneTokSet	HLVRec.c	/^static void PruneTokSet (DecoderInst *dec, TokenSet *ts)$/;"	f	file:
Push	kenlm/util/stream/sort.hh	/^    void Push(void *base, uint64_t offset, uint64_t amount) {$/;"	f	class:util::stream::MergeQueue
QUANT_ARRAY_TRIE	kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon20
QUANT_ARRAY_TRIE_SORTED	kenlm/lm/model_type.hh	/^const ModelType QUANT_ARRAY_TRIE_SORTED = QUANT_ARRAY_TRIE;$/;"	m	namespace:lm::ngram
QUANT_TRIE	kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon20
QUANT_TRIE_SORTED	kenlm/lm/model_type.hh	/^const ModelType QUANT_TRIE_SORTED = QUANT_TRIE;$/;"	m	namespace:lm::ngram
Query	kenlm/lm/ngram_query.hh	/^template <class Model, class Printer> void Query(const Model &model, bool sentence_context) {$/;"	f	namespace:lm::ngram
Query	kenlm/lm/ngram_query.hh	/^template <class Model> void Query(const char *file, const Config &config, bool sentence_context, bool show_words) {$/;"	f	namespace:lm::ngram
Queue	kenlm/util/stream/sort.hh	/^    typedef std::priority_queue<Entry, std::vector<Entry>, Greater> Queue;$/;"	t	class:util::stream::MergeQueue
READ	kenlm/util/mmap.hh	/^  READ,$/;"	e	enum:util::__anon42
REST_LOWER	kenlm/lm/config.hh	/^    REST_LOWER, \/\/ Use lower-order files given below.$/;"	e	enum:lm::ngram::Config::RestFunction
REST_MAX	kenlm/lm/config.hh	/^    REST_MAX,   \/\/ Maximum of any score to the left$/;"	e	enum:lm::ngram::Config::RestFunction
REST_PROBING	kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon20
RadixStringToIeee	kenlm/util/double-conversion/double-conversion.cc	/^static double RadixStringToIeee(const char* current,$/;"	f	namespace:double_conversion
RangeLessBySize	kenlm/util/multi_intersection.hh	/^template <class Range> struct RangeLessBySize : public std::binary_function<const Range &, const Range &, bool> {$/;"	s	namespace:util::detail
Raw	kenlm/lm/search_hashed.hh	/^        typename Value::Weights *Raw() { return unigram_; }$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Raw	kenlm/lm/trie.hh	/^    UnigramValue *Raw() {$/;"	f	class:lm::ngram::trie::Unigram
RawAmount	kenlm/util/read_compressed.hh	/^    uint64_t RawAmount() const { return raw_amount_; }$/;"	f	class:util::ReadCompressed
ReBase	kenlm/lm/builder/ngram.hh	/^    void ReBase(void *to) {$/;"	f	class:lm::builder::NGram
ReFormatTranscription	HLVRec.c	/^void ReFormatTranscription(Transcription *trans,HTime frameDur,$/;"	f
Read	kenlm/lm/filter/count_io.hh	/^    void Read(std::istream &in) {$/;"	f	class:lm::CountBatch
Read	kenlm/util/read_compressed.cc	/^    std::size_t Read(void *, std::size_t, ReadCompressed &) {$/;"	f	class:util::__anon45::Complete
Read	kenlm/util/read_compressed.cc	/^    std::size_t Read(void *to, std::size_t amount, ReadCompressed &thunk) {$/;"	f	class:util::__anon45::IStreamReader
Read	kenlm/util/read_compressed.cc	/^    std::size_t Read(void *to, std::size_t amount, ReadCompressed &thunk) {$/;"	f	class:util::__anon45::StreamCompressed
Read	kenlm/util/read_compressed.cc	/^    std::size_t Read(void *to, std::size_t amount, ReadCompressed &thunk) {$/;"	f	class:util::__anon45::Uncompressed
Read	kenlm/util/read_compressed.cc	/^    std::size_t Read(void *to, std::size_t amount, ReadCompressed &thunk) {$/;"	f	class:util::__anon45::UncompressedWithHeader
Read	kenlm/util/read_compressed.cc	/^std::size_t ReadCompressed::Read(void *to, std::size_t amount) {$/;"	f	class:util::ReadCompressed
Read	kenlm/util/stream/io.hh	/^    explicit Read(int fd) : file_(fd) {}$/;"	f	class:util::stream::Read
Read	kenlm/util/stream/io.hh	/^class Read {$/;"	c	namespace:util::stream
Read	kenlm/util/stream/sort.hh	/^        bool Read(int fd, std::size_t buf_size) {$/;"	f	class:util::stream::MergeQueue::Entry
Read1Gram	kenlm/lm/read_arpa.hh	/^template <class Voc, class Weights> void Read1Gram(util::FilePiece &f, Voc &vocab, Weights *unigrams, PositiveProbWarn &warn) {$/;"	f	namespace:lm
Read1Grams	kenlm/lm/read_arpa.hh	/^template <class Voc, class Weights> void Read1Grams(util::FilePiece &f, std::size_t count, Voc &vocab, Weights *unigrams, PositiveProbWarn &warn) {$/;"	f	namespace:lm
ReadARPA	kenlm/lm/filter/arpa_io.hh	/^template <class Output> void ReadARPA(util::FilePiece &in_lm, Output &out) {$/;"	f	namespace:lm
ReadARPACounts	kenlm/lm/read_arpa.cc	/^void ReadARPACounts(util::FilePiece &in, std::vector<uint64_t> &number) {$/;"	f	namespace:lm
ReadARPALM	HLVLM.c	/^FSLM *ReadARPALM(MemHeap *heap, char *lmfn, Vocab *vocab)$/;"	f
ReadARPAngram	HLVLM.c	/^static void ReadARPAngram (FSLM_ngram *nglm, Source *lmSrc, int n, int count, Boolean bin,$/;"	f	file:
ReadBackoff	kenlm/lm/read_arpa.cc	/^void ReadBackoff(util::FilePiece &in, Prob &\/*weights*\/) {$/;"	f	namespace:lm
ReadBackoff	kenlm/lm/read_arpa.cc	/^void ReadBackoff(util::FilePiece &in, float &backoff) {$/;"	f	namespace:lm
ReadBackoff	kenlm/lm/read_arpa.hh	/^inline void ReadBackoff(util::FilePiece &in, ProbBackoff &weights) {$/;"	f	namespace:lm
ReadBackoff	kenlm/lm/read_arpa.hh	/^inline void ReadBackoff(util::FilePiece &in, RestWeights &weights) {$/;"	f	namespace:lm
ReadBase	kenlm/util/read_compressed.cc	/^class ReadBase {$/;"	c	namespace:util	file:
ReadCompressed	kenlm/util/read_compressed.cc	/^ReadCompressed::ReadCompressed() {}$/;"	f	class:util::ReadCompressed
ReadCompressed	kenlm/util/read_compressed.cc	/^ReadCompressed::ReadCompressed(int fd) {$/;"	f	class:util::ReadCompressed
ReadCompressed	kenlm/util/read_compressed.cc	/^ReadCompressed::ReadCompressed(std::istream &in) {$/;"	f	class:util::ReadCompressed
ReadCompressed	kenlm/util/read_compressed.hh	/^class ReadCompressed {$/;"	c	namespace:util
ReadCount	kenlm/lm/filter/count_io.hh	/^template <class Output> void ReadCount(util::FilePiece &in_file, Output &out) {$/;"	f	namespace:lm
ReadCount	kenlm/lm/read_arpa.cc	/^uint64_t ReadCount(const std::string &from) {$/;"	f	namespace:lm::__anon22
ReadCount	kenlm/util/read_compressed.cc	/^    static uint64_t &ReadCount(ReadCompressed &thunk) {$/;"	f	class:util::ReadBase
ReadDelimited	kenlm/util/file_piece.hh	/^    StringPiece ReadDelimited(const bool *delim = kSpaces) {$/;"	f	class:util::FilePiece
ReadDiyFp	kenlm/util/double-conversion/strtod.cc	/^static void ReadDiyFp(Vector<const char> buffer,$/;"	f	namespace:double_conversion
ReadDouble	kenlm/util/file_piece.cc	/^double FilePiece::ReadDouble() {$/;"	f	class:util::FilePiece
ReadEnd	kenlm/lm/read_arpa.cc	/^void ReadEnd(util::FilePiece &in) {$/;"	f	namespace:lm
ReadEntry	kenlm/lm/trie.hh	/^    util::BitAddress ReadEntry(uint64_t pointer, NodeRange &range) {$/;"	f	class:lm::ngram::trie::BitPackedMiddle
ReadFactory	kenlm/util/read_compressed.cc	/^ReadBase *ReadFactory(int fd, uint64_t &raw_amount, const void *already_data, const std::size_t already_size, bool require_compressed) {$/;"	f	namespace:util::__anon45
ReadFloat	kenlm/util/file_piece.cc	/^float FilePiece::ReadFloat() {$/;"	f	class:util::FilePiece
ReadFloat32	kenlm/util/bit_packing.hh	/^inline float ReadFloat32(const void *base, uint64_t bit_off) {$/;"	f	namespace:util
ReadForConfig	kenlm/lm/binary_format.cc	/^void BinaryFormat::ReadForConfig(void *to, std::size_t amount, uint64_t offset_excluding_header) const {$/;"	f	class:lm::ngram::BinaryFormat
ReadHeader	kenlm/lm/binary_format.cc	/^void ReadHeader(int fd, Parameters &out) {$/;"	f	namespace:lm::ngram
ReadInput	kenlm/util/read_compressed.cc	/^    void ReadInput(ReadCompressed &thunk) {$/;"	f	class:util::__anon45::StreamCompressed	file:
ReadInt25	kenlm/util/bit_packing.hh	/^inline uint32_t ReadInt25(const void *base, uint64_t bit_off, uint8_t length, uint32_t mask) {$/;"	f	namespace:util
ReadInt57	kenlm/util/bit_packing.hh	/^inline uint64_t ReadInt57(const void *base, uint64_t bit_off, uint8_t length, uint64_t mask) {$/;"	f	namespace:util
ReadLine	kenlm/util/file_piece.cc	/^StringPiece FilePiece::ReadLine(char delim) {$/;"	f	class:util::FilePiece
ReadLineOrEOF	kenlm/util/file_piece.cc	/^bool FilePiece::ReadLineOrEOF(StringPiece &to, char delim) {$/;"	f	class:util::FilePiece
ReadLong	kenlm/util/file_piece.cc	/^long int FilePiece::ReadLong() {$/;"	f	class:util::FilePiece
ReadMultiple	kenlm/lm/filter/phrase.cc	/^unsigned int ReadMultiple(std::istream &in, Substrings &out) {$/;"	f	namespace:lm::phrase
ReadMultiple	kenlm/lm/filter/vocab.cc	/^unsigned int ReadMultiple(std::istream &in, boost::unordered_map<std::string, std::vector<unsigned int> > &out) {$/;"	f	namespace:lm::vocab
ReadNGram	kenlm/lm/read_arpa.hh	/^template <class Voc, class Weights, class Iterator> void ReadNGram(util::FilePiece &f, const unsigned char n, const Voc &vocab, Iterator indices_out, Weights &weights, PositiveProbWarn &warn) {$/;"	f	namespace:lm
ReadNGramHeader	kenlm/lm/read_arpa.cc	/^void ReadNGramHeader(util::FilePiece &in, unsigned int length) {$/;"	f	namespace:lm
ReadNGrams	kenlm/lm/filter/arpa_io.hh	/^template <class Output> void ReadNGrams(util::FilePiece &in, unsigned int length, uint64_t number, Output &out) {$/;"	f	namespace:lm
ReadNGrams	kenlm/lm/search_hashed.cc	/^template <class Build, class Activate, class Store> void ReadNGrams($/;"	f	namespace:lm::ngram::__anon23
ReadNext	kenlm/lm/bhiksha.hh	/^    void ReadNext(const void *base, uint64_t bit_offset, uint64_t \/*index*\/, uint8_t total_bits, NodeRange &out) const {$/;"	f	class:lm::ngram::trie::DontBhiksha
ReadNext	kenlm/lm/bhiksha.hh	/^    void ReadNext(const void *base, uint64_t bit_offset, uint64_t index, uint8_t total_bits, NodeRange &out) const {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
ReadNonPositiveFloat31	kenlm/util/bit_packing.hh	/^inline float ReadNonPositiveFloat31(const void *base, uint64_t bit_off) {$/;"	f	namespace:util
ReadNumber	kenlm/util/file_piece.cc	/^template <class T> T FilePiece::ReadNumber() {$/;"	f	class:util::FilePiece
ReadOff	kenlm/util/bit_packing.hh	/^inline uint64_t ReadOff(const void *base, uint64_t bit_off) {$/;"	f	namespace:util
ReadOrEOF	kenlm/util/file.cc	/^std::size_t ReadOrEOF(int fd, void *to_void, std::size_t amount) {$/;"	f	namespace:util
ReadOrEOF	kenlm/util/read_compressed.cc	/^std::size_t ReadCompressed::ReadOrEOF(void *const to_in, std::size_t amount) {$/;"	f	class:util::ReadCompressed
ReadOrThrow	kenlm/lm/search_trie.cc	/^void ReadOrThrow(FILE *from, void *data, size_t size) {$/;"	f	namespace:lm::ngram::trie::__anon24
ReadOrThrow	kenlm/util/file.cc	/^void ReadOrThrow(int fd, void *to_void, std::size_t amount) {$/;"	f	namespace:util
ReadShift	kenlm/util/file_piece.cc	/^void FilePiece::ReadShift() {$/;"	f	class:util::FilePiece
ReadSingle	kenlm/lm/filter/vocab.cc	/^void ReadSingle(std::istream &in, boost::unordered_set<std::string> &out) {$/;"	f	namespace:lm::vocab
ReadSingle	kenlm/util/stream/sort.hh	/^    void ReadSingle(uint64_t offset, const uint64_t size, const ChainPosition &position) {$/;"	f	class:util::stream::MergingReader
ReadSizeException	kenlm/util/stream/io.cc	/^ReadSizeException::ReadSizeException() throw() {}$/;"	f	class:util::stream::ReadSizeException
ReadSizeException	kenlm/util/stream/io.hh	/^class ReadSizeException : public util::Exception {$/;"	c	namespace:util::stream
ReadUInt64	kenlm/util/double-conversion/bignum.cc	/^static uint64_t ReadUInt64(Vector<const char> buffer,$/;"	f	namespace:double_conversion
ReadULong	kenlm/util/file_piece.cc	/^unsigned long int FilePiece::ReadULong() {$/;"	f	class:util::FilePiece
ReadUint64	kenlm/util/double-conversion/strtod.cc	/^static uint64_t ReadUint64(Vector<const char> buffer,$/;"	f	namespace:double_conversion
ReadWordSameLine	kenlm/util/file_piece.hh	/^    bool ReadWordSameLine(StringPiece &to, const bool *delim = kSpaces) {$/;"	f	class:util::FilePiece
ReadWords	kenlm/lm/vocab.cc	/^void ReadWords(int fd, EnumerateVocab *enumerate, WordIndex expected_count, uint64_t offset) {$/;"	f	namespace:lm::ngram::__anon28
Reader	kenlm/util/parallel_read.cc	/^    explicit Reader(int fd) : fd_(fd) {}$/;"	f	class:util::__anon44::Reader
Reader	kenlm/util/parallel_read.cc	/^class Reader {$/;"	c	namespace:util::__anon44	file:
Recognize	kenlm/lm/wrappers/nplm.cc	/^bool Model::Recognize(const std::string &name) {$/;"	f	class:lm::np::Model
RecognizeBinary	kenlm/lm/binary_format.cc	/^bool RecognizeBinary(const char *file, ModelType &recognized) {$/;"	f	namespace:lm::ngram
RecordReader	kenlm/lm/trie_sort.hh	/^    RecordReader() : remains_(true) {}$/;"	f	class:lm::ngram::trie::RecordReader
RecordReader	kenlm/lm/trie_sort.hh	/^class RecordReader {$/;"	c	namespace:lm::ngram::trie
RecordStart	kenlm/util/usage.cc	/^    RecordStart() {$/;"	f	class:util::__anon49::RecordStart
RecordStart	kenlm/util/usage.cc	/^class RecordStart {$/;"	c	namespace:util::__anon49	file:
RecursiveInsert	kenlm/lm/search_trie.cc	/^template <class Doing> void RecursiveInsert(const unsigned char total_order, const WordIndex unigram_count, RecordReader *input, std::ostream *progress_out, const char *message, Doing &doing) {$/;"	f	namespace:lm::ngram::trie::__anon24
Recycler	kenlm/util/stream/chain.hh	/^class Recycler {$/;"	c	namespace:util::stream
RelTokScore	config.h	/^typedef LogFloat RelTokScore;$/;"	t
RelToken	HLVRec.h	/^typedef struct _RelToken RelToken;      \/* Info about partial hypothesis relative to main token *\/$/;"	t	typeref:struct:_RelToken
Relocate	kenlm/lm/vocab.cc	/^void ProbingVocabulary::Relocate(void *new_start) {$/;"	f	class:lm::ngram::ProbingVocabulary
Relocate	kenlm/lm/vocab.cc	/^void SortedVocabulary::Relocate(void *new_start) {$/;"	f	class:lm::ngram::SortedVocabulary
Relocate	kenlm/util/probing_hash_table.hh	/^    void Relocate(void *new_base) {$/;"	f	class:util::ProbingHashTable
RemainingBlocks	kenlm/util/stream/sort.hh	/^    uint64_t RemainingBlocks() const { return block_count_; }$/;"	f	class:util::stream::Offsets
ReplaceThis	kenlm/util/read_compressed.cc	/^    static void ReplaceThis(ReadBase *with, ReadCompressed &thunk) {$/;"	f	class:util::ReadBase
ReportUsage	HDecode.c	/^ReportUsage (void)$/;"	f
ReportUsage	HDecode.mod.c	/^ReportUsage (void)$/;"	f
Request	kenlm/lm/filter/thread.hh	/^    typedef Batch *Request;$/;"	t	class:lm::FilterWorker
Request	kenlm/lm/filter/thread.hh	/^    typedef Batch *Request;$/;"	t	class:lm::OutputWorker
Request	kenlm/util/parallel_read.cc	/^    struct Request {$/;"	s	class:util::__anon44::Reader	file:
Request	kenlm/util/thread_pool.hh	/^    typedef typename Handler::Request Request;$/;"	t	class:util::ThreadPool
Request	kenlm/util/thread_pool.hh	/^    typedef typename Handler::Request Request;$/;"	t	class:util::Worker
RequiredBits	kenlm/util/bit_packing.cc	/^uint8_t RequiredBits(uint64_t max_value) {$/;"	f	namespace:util
Reserve	kenlm/lm/filter/format.hh	/^    void Reserve(size_t size) { lines_.reserve(size); }$/;"	f	class:lm::InputBuffer
Reserve	kenlm/lm/filter/format.hh	/^    void Reserve(size_t size) {$/;"	f	class:lm::BinaryOutputBuffer
Reserve	kenlm/lm/filter/format.hh	/^    void Reserve(size_t size) {$/;"	f	class:lm::MultipleOutputBuffer
Reserve	kenlm/lm/filter/thread.hh	/^    void Reserve(size_t size) {$/;"	f	class:lm::ThreadBatch
ReserveForCounts	kenlm/lm/filter/arpa_io.cc	/^void ARPAOutput::ReserveForCounts(std::streampos reserve) {$/;"	f	class:lm::ARPAOutput
ReserveForCounts	kenlm/lm/filter/format.hh	/^    void ReserveForCounts(std::streampos reserve) { B::output_.ReserveForCounts(reserve); }$/;"	f	class:lm::DispatchARPAInput
ReserveForCounts	kenlm/lm/filter/format.hh	/^    void ReserveForCounts(std::streampos reserve) {$/;"	f	class:lm::MultipleARPAOutput
Reset	kenlm/lm/left.hh	/^    void Reset() {$/;"	f	class:lm::ngram::RuleScore
Reset	kenlm/lm/left.hh	/^    void Reset(ChartState &replacement) {$/;"	f	class:lm::ngram::RuleScore
Reset	kenlm/util/double-conversion/utils.h	/^  void Reset() { position_ = 0; }$/;"	f	class:double_conversion::StringBuilder
Reset	kenlm/util/read_compressed.cc	/^void ReadCompressed::Reset(int fd) {$/;"	f	class:util::ReadCompressed
Reset	kenlm/util/read_compressed.cc	/^void ReadCompressed::Reset(std::istream &in) {$/;"	f	class:util::ReadCompressed
Reset	kenlm/util/stream/sort.hh	/^    void Reset() {$/;"	f	class:util::stream::Offsets
ResetFVTrans	HDecode.c	/^void ResetFVTrans (HMMSet *hset, BlockMatrix transMat)$/;"	f
ResetFVTrans	HDecode.mod.c	/^void ResetFVTrans (HMMSet *hset, BlockMatrix transMat)$/;"	f
ResetLMCache	HLVRec-LM.c	/^static void ResetLMCache (LMCache *cache)$/;"	f	file:
ResetOutPCache	HLVRec-outP.c	/^static void ResetOutPCache (OutPCache *cache)$/;"	f	file:
Resize	kenlm/lm/search_trie.cc	/^    void Resize(std::size_t to) {$/;"	f	class:lm::ngram::trie::__anon24::BackoffMessages	file:
ResizeOrThrow	kenlm/util/file.cc	/^void ResizeOrThrow(int fd, uint64_t to) {$/;"	f	namespace:util
Rest	kenlm/lm/quantize.hh	/^        float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
Rest	kenlm/lm/quantize.hh	/^        float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
Rest	kenlm/lm/trie.hh	/^    float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::trie::UnigramPointer
Rest	kenlm/lm/value.hh	/^      float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::BackoffValue::ProbingProxy
Rest	kenlm/lm/value.hh	/^      float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::BackoffValue::TrieUnigramProxy
Rest	kenlm/lm/value.hh	/^      float Rest() const { return to_->rest; }$/;"	f	class:lm::ngram::RestValue::ProbingProxy
Rest	kenlm/lm/value.hh	/^      float Rest() const { return to_->rest; }$/;"	f	class:lm::ngram::RestValue::TrieUnigramProxy
Rest	kenlm/lm/value.hh	/^    float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
RestFunction	kenlm/lm/config.hh	/^  enum RestFunction {$/;"	g	struct:lm::ngram::Config
RestValue	kenlm/lm/value.hh	/^struct RestValue {$/;"	s	namespace:lm::ngram
RestWeights	kenlm/lm/weights.hh	/^struct RestWeights {$/;"	s	namespace:lm
ResumeScore	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> void GenericModel<Search, VocabularyT>::ResumeScore(const WordIndex *hist_iter, const WordIndex *const context_rend, unsigned char order_minus_2, typename Search::Node &node, float *backoff_out, unsigned char &next_use, FullScoreReturn &ret) const {$/;"	f	class:lm::ngram::detail::GenericModel
RevealAfter	kenlm/lm/partial.hh	/^template <class Model> float RevealAfter(const Model &model, Left &left, Right &right, const Left &reveal, unsigned char seen) {$/;"	f	namespace:lm::ngram
RevealBefore	kenlm/lm/partial.hh	/^template <class Model> float RevealBefore(const Model &model, const Right &reveal, const unsigned char seen, bool reveal_full, Left &left, Right &right) {$/;"	f	namespace:lm::ngram
Rewind	kenlm/lm/trie_sort.cc	/^void RecordReader::Rewind() {$/;"	f	class:lm::ngram::trie::RecordReader
Right	kenlm/lm/state.hh	/^typedef State Right;$/;"	t	namespace:lm::ngram
Roll	kenlm/util/mmap.cc	/^void Rolling::Roll(uint64_t index) {$/;"	f	class:util::Rolling
Rolling	kenlm/util/mmap.cc	/^Rolling::Rolling(const Rolling &copy_from, uint64_t increase) {$/;"	f	class:util::Rolling
Rolling	kenlm/util/mmap.cc	/^Rolling::Rolling(int fd, bool for_write, std::size_t block, std::size_t read_bound, uint64_t offset, uint64_t amount) {$/;"	f	class:util::Rolling
Rolling	kenlm/util/mmap.hh	/^    Rolling() {}$/;"	f	class:util::Rolling
Rolling	kenlm/util/mmap.hh	/^    explicit Rolling(void *data) { Init(data); }$/;"	f	class:util::Rolling
Rolling	kenlm/util/mmap.hh	/^class Rolling {$/;"	c	namespace:util
RoundAlign	HLVModel.c	/^size_t RoundAlign(size_t addr, size_t align)$/;"	f
RoundUp	kenlm/util/double-conversion/fixed-dtoa.cc	/^static void RoundUp(Vector<char> buffer, int* length, int* decimal_point) {$/;"	f	namespace:double_conversion
RoundWeed	kenlm/util/double-conversion/fast-dtoa.cc	/^static bool RoundWeed(Vector<char> buffer,$/;"	f	namespace:double_conversion
RoundWeedCounted	kenlm/util/double-conversion/fast-dtoa.cc	/^static bool RoundWeedCounted(Vector<char> buffer,$/;"	f	namespace:double_conversion
RuleScore	kenlm/lm/left.hh	/^    explicit RuleScore(const M &model, ChartState &out) : model_(model), out_(&out), left_done_(false), prob_(0.0) {$/;"	f	class:lm::ngram::RuleScore
RuleScore	kenlm/lm/left.hh	/^template <class M> class RuleScore {$/;"	c	namespace:lm::ngram
Run	kenlm/lm/builder/adjust_counts.cc	/^void AdjustCounts::Run(const util::stream::ChainPositions &positions) {$/;"	f	class:lm::builder::AdjustCounts
Run	kenlm/lm/builder/corpus_count.cc	/^void CorpusCount::Run(const util::stream::ChainPosition &position) {$/;"	f	class:lm::builder::CorpusCount
Run	kenlm/lm/builder/initial_probabilities.cc	/^    void Run(const util::stream::ChainPosition &output) {$/;"	f	class:lm::builder::__anon11::AddRight
Run	kenlm/lm/builder/initial_probabilities.cc	/^    void Run(const util::stream::ChainPosition &position) {$/;"	f	class:lm::builder::__anon11::OnlyGamma
Run	kenlm/lm/builder/initial_probabilities.cc	/^    void Run(const util::stream::ChainPosition &primary) {$/;"	f	class:lm::builder::__anon11::MergeRight
Run	kenlm/lm/builder/interpolate.cc	/^void Interpolate::Run(const util::stream::ChainPositions &positions) {$/;"	f	class:lm::builder::Interpolate
Run	kenlm/lm/builder/print.cc	/^void PrintARPA::Run(const util::stream::ChainPositions &positions) {$/;"	f	class:lm::builder::PrintARPA
Run	kenlm/lm/builder/print.hh	/^    void Run(const util::stream::ChainPosition &position) {$/;"	f	class:lm::builder::Print
Run	kenlm/lm/builder/print.hh	/^    void Run(const util::stream::ChainPositions &chains) {$/;"	f	class:lm::builder::Print
Run	kenlm/lm/interpolate/arpa_to_stream.cc	/^void ARPAToStream::Run(const util::stream::ChainPositions &positions) {$/;"	f	class:lm::interpolate::ARPAToStream
Run	kenlm/util/stream/chain.cc	/^void Recycler::Run(const ChainPosition &position) {$/;"	f	class:util::stream::Recycler
Run	kenlm/util/stream/io.cc	/^void PRead::Run(const ChainPosition &position) {$/;"	f	class:util::stream::PRead
Run	kenlm/util/stream/io.cc	/^void PWriteAndRecycle::Run(const ChainPosition &position) {$/;"	f	class:util::stream::PWriteAndRecycle
Run	kenlm/util/stream/io.cc	/^void Read::Run(const ChainPosition &position) {$/;"	f	class:util::stream::Read
Run	kenlm/util/stream/io.cc	/^void Write::Run(const ChainPosition &position) {$/;"	f	class:util::stream::Write
Run	kenlm/util/stream/io.cc	/^void WriteAndRecycle::Run(const ChainPosition &position) {$/;"	f	class:util::stream::WriteAndRecycle
Run	kenlm/util/stream/line_input.cc	/^void LineInput::Run(const ChainPosition &position) {$/;"	f	class:util::stream::LineInput
Run	kenlm/util/stream/sort.hh	/^    void Run(const ChainPosition &position) {$/;"	f	class:util::stream::BlockSorter
Run	kenlm/util/stream/sort.hh	/^    void Run(const ChainPosition &position) {$/;"	f	class:util::stream::MergingReader
Run	kenlm/util/stream/sort.hh	/^    void Run(const ChainPosition &position) {$/;"	f	class:util::stream::OwningMergingReader
Run	kenlm/util/stream/sort.hh	/^    void Run(const ChainPosition &position, bool assert_one) {$/;"	f	class:util::stream::MergingReader
RunFilter	kenlm/lm/filter/format.hh	/^  template <class Filter, class Out> static void RunFilter(util::FilePiece &in, Filter &filter, Out &output) {$/;"	f	struct:lm::ARPAFormat
RunFilter	kenlm/lm/filter/format.hh	/^  template <class Filter, class Out> static void RunFilter(util::FilePiece &in, Filter &filter, Out &output) {$/;"	f	struct:lm::CountFormat
Running	kenlm/util/stream/chain.hh	/^    bool Running() const { return !queues_.empty(); }$/;"	f	class:util::stream::Chain
S	kenlm/lm/builder/sort.hh	/^    typedef util::stream::Sort<Compare> S;$/;"	t	class:lm::builder::Sorts
S	kenlm/util/proxy_iterator.hh	/^    typedef ProxyIterator<Proxy> S;$/;"	t	class:util::ProxyIterator
SEntry	HLVLM.h	/^} SEntry;$/;"	t	typeref:struct:sentry
SHELL	Makefile	/^SHELL   = 	\/bin\/sh$/;"	m
SHORTEST	kenlm/util/double-conversion/double-conversion.h	/^    SHORTEST,$/;"	e	enum:double_conversion::DoubleToStringConverter::DtoaMode
SHORTEST_SINGLE	kenlm/util/double-conversion/double-conversion.h	/^    SHORTEST_SINGLE,$/;"	e	enum:double_conversion::DoubleToStringConverter::DtoaMode
SILENT	kenlm/lm/lm_exception.hh	/^typedef enum {THROW_UP, COMPLAIN, SILENT} WarningAction;$/;"	e	enum:lm::__anon17
SOutP_HMod	HLVRec-outP.c	/^static LogFloat SOutP_HMod (HMMSet *hset, int s, Observation *x, StreamElem *se,$/;"	f	file:
SOutP_ID_mix_Block	HLVRec-outP.c	/^LogFloat SOutP_ID_mix_Block(HMMSet *hset, int s, Observation *x, StreamElem *se)$/;"	f
SRISucks	kenlm/lm/search_trie.cc	/^    SRISucks() {$/;"	f	class:lm::ngram::trie::__anon24::SRISucks
SRISucks	kenlm/lm/search_trie.cc	/^class SRISucks {$/;"	c	namespace:lm::ngram::trie::__anon24	file:
STATS_MAXT	HLVRec.h	158;"	d
STDIN_FILENO	kenlm/util/unistd.hh	10;"	d
STDOUT_FILENO	kenlm/util/unistd.hh	11;"	d
STLN_CON	HLVNet.c	/^  STLN_WORDEND, STLN_CON, STLN_MODEL$/;"	e	enum:_STLexNodeType	file:
STLN_MODEL	HLVNet.c	/^  STLN_WORDEND, STLN_CON, STLN_MODEL$/;"	e	enum:_STLexNodeType	file:
STLN_WORDEND	HLVNet.c	/^  STLN_WORDEND, STLN_CON, STLN_MODEL$/;"	e	enum:_STLexNodeType	file:
STLexLink	HLVNet.c	/^typedef struct _STLexLink STLexLink;$/;"	t	typeref:struct:_STLexLink	file:
STLexNode	HLVNet.c	/^typedef struct _STLexNode STLexNode;$/;"	t	typeref:struct:_STLexNode	file:
STLexNodeType	HLVNet.c	/^} STLexNodeType;$/;"	t	typeref:enum:_STLexNodeType	file:
Sanity	kenlm/lm/binary_format.cc	/^struct Sanity {$/;"	s	namespace:lm::ngram::__anon7	file:
SanityCheckCounts	kenlm/lm/search_trie.cc	/^void SanityCheckCounts(const std::vector<uint64_t> &initial, const std::vector<uint64_t> &fixed) {$/;"	f	namespace:lm::ngram::trie::__anon24
SawUnk	kenlm/lm/vocab.hh	/^    bool SawUnk() const { return saw_unk_; }$/;"	f	class:lm::ngram::ProbingVocabulary
SawUnk	kenlm/lm/vocab.hh	/^    bool SawUnk() const { return saw_unk_; }$/;"	f	class:lm::ngram::SortedVocabulary
Score	kenlm/lm/facade.hh	/^    float Score(const State &in_state, const WordIndex new_word, State &out_state) const {$/;"	f	class:lm::base::ModelFacade
ScoreExceptBackoff	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> FullScoreReturn GenericModel<Search, VocabularyT>::ScoreExceptBackoff($/;"	f	class:lm::ngram::detail::GenericModel
SeekEnd	kenlm/util/file.cc	/^void SeekEnd(int fd) {$/;"	f	namespace:util
SeekOrThrow	kenlm/util/file.cc	/^void SeekOrThrow(int fd, uint64_t off) {$/;"	f	namespace:util
Semaphore	kenlm/util/pcqueue.hh	/^    explicit Semaphore(int value) : task_(mach_task_self()) {$/;"	f	class:util::Semaphore
Semaphore	kenlm/util/pcqueue.hh	/^class Semaphore {$/;"	c	namespace:util
Send	kenlm/lm/filter/count_io.hh	/^    template <class Output> void Send(Output &out) {$/;"	f	class:lm::CountBatch
Send	kenlm/lm/search_trie.cc	/^    void Send(unsigned char begin, unsigned char order, const WordIndex *to, float prob_basis) {$/;"	f	class:lm::ngram::trie::__anon24::SRISucks
Sentence	kenlm/lm/filter/phrase.cc	/^typedef unsigned int Sentence;$/;"	t	namespace:lm::phrase::__anon14	file:
SentenceRelation	kenlm/lm/filter/phrase.hh	/^    struct SentenceRelation {$/;"	s	class:lm::phrase::Substrings
Sentences	kenlm/lm/filter/phrase.cc	/^typedef std::vector<Sentence> Sentences;$/;"	t	namespace:lm::phrase::__anon14	file:
SeparatelyQuantize	kenlm/lm/quantize.hh	/^    SeparatelyQuantize() {}$/;"	f	class:lm::ngram::SeparatelyQuantize
SeparatelyQuantize	kenlm/lm/quantize.hh	/^class SeparatelyQuantize {$/;"	c	namespace:lm::ngram
Sequence	kenlm/lm/filter/thread.hh	/^    uint64_t Sequence() const { return sequence_; }$/;"	f	class:lm::ThreadBatch
Set	kenlm/lm/filter/phrase.cc	/^void Arc::Set(Vertex &to, const Sentences &sentences) {$/;"	f	class:lm::phrase::detail::Arc
Set	kenlm/util/ersatz_progress.hh	/^    void Set(uint64_t to) {$/;"	f	class:util::ErsatzProgress
SetConfParms	HDecode.c	/^SetConfParms (void)$/;"	f
SetConfParms	HDecode.mod.c	/^SetConfParms (void)$/;"	f
SetExtension	kenlm/lm/blank.hh	/^inline void SetExtension(float &backoff) {$/;"	f	namespace:lm::ngram
SetFD	kenlm/util/fake_ofstream.hh	/^    void SetFD(int to) {$/;"	f	class:util::FakeOFStream
SetHeader	kenlm/lm/builder/output.hh	/^    void SetHeader(const HeaderInfo &header) { header_ = header; }$/;"	f	class:lm::builder::Output
SetInput	kenlm/util/read_compressed.cc	/^    void SetInput(const void *base, std::size_t amount) {$/;"	f	class:util::__anon45::BZip
SetInput	kenlm/util/read_compressed.cc	/^    void SetInput(const void *base, std::size_t amount) {$/;"	f	class:util::__anon45::GZip
SetInput	kenlm/util/read_compressed.cc	/^    void SetInput(const void *base, std::size_t amount) {$/;"	f	class:util::__anon45::XZip
SetKey	kenlm/lm/builder/corpus_count.cc	/^  void SetKey(WordIndex *to) { key = to; }$/;"	f	struct:lm::builder::__anon9::DedupeEntry
SetKey	kenlm/lm/builder/corpus_count.cc	/^  void SetKey(uint64_t to) { key = to; }$/;"	f	struct:lm::builder::__anon9::VocabEntry
SetKey	kenlm/lm/vocab.hh	/^  void SetKey(uint64_t to) { key = to; }$/;"	f	struct:lm::ngram::ProbingVocabularyEntry
SetLocation	kenlm/util/exception.cc	/^void Exception::SetLocation(const char *file, unsigned int line, const char *func, const char *child_name, const char *condition) {$/;"	f	class:util::Exception
SetNEntryBO	HLVLM.c	/^void SetNEntryBO (FSLM *lm)$/;"	f
SetOutput	kenlm/util/read_compressed.cc	/^    void SetOutput(void *base, std::size_t amount) {$/;"	f	class:util::__anon45::BZip
SetOutput	kenlm/util/read_compressed.cc	/^    void SetOutput(void *base, std::size_t amount) {$/;"	f	class:util::__anon45::XZip
SetOutput	kenlm/util/read_compressed.cc	/^    void SetOutput(void *to, std::size_t amount) {$/;"	f	class:util::__anon45::GZip
SetPhrase	kenlm/lm/filter/phrase.cc	/^    void SetPhrase(detail::Vertex &from, detail::Vertex &to, const Sentences &intersect) {$/;"	f	class:lm::phrase::detail::Arc
SetProgressTarget	kenlm/util/stream/chain.hh	/^    void SetProgressTarget(uint64_t target) {$/;"	f	class:util::stream::Chain
SetRest	kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *, unsigned int, RestWeights &weights) const {$/;"	f	class:lm::ngram::MaxRestBuild
SetRest	kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *, unsigned int, const Prob &\/*prob*\/) const {}$/;"	f	class:lm::ngram::LowerRestBuild
SetRest	kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *, unsigned int, const Prob &\/*prob*\/) const {}$/;"	f	class:lm::ngram::MaxRestBuild
SetRest	kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *, unsigned int, const Prob &\/*prob*\/) const {}$/;"	f	class:lm::ngram::NoRestBuild
SetRest	kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *, unsigned int, const ProbBackoff &) const {}$/;"	f	class:lm::ngram::NoRestBuild
SetRest	kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *vocab_ids, unsigned int n, RestWeights &weights) const {$/;"	f	class:lm::ngram::LowerRestBuild
SetRight	kenlm/lm/filter/phrase.cc	/^    void SetRight(detail::Vertex &to, const Sentences &complete) {$/;"	f	class:lm::phrase::detail::Arc
SetSign	kenlm/util/bit_packing.hh	/^inline void SetSign(float &to) {$/;"	f	namespace:util
SetSpecial	kenlm/lm/virtual_interface.cc	/^void Vocabulary::SetSpecial(WordIndex begin_sentence, WordIndex end_sentence, WordIndex not_found) {$/;"	f	class:lm::base::Vocabulary
SetStartEnd	HLVLM.c	/^void SetStartEnd (FSLM *lm, char *startWord, char *endWord, Vocab *vocab)$/;"	f
SetTarget	kenlm/util/stream/multi_progress.cc	/^void MultiProgress::SetTarget(uint64_t complete) {$/;"	f	class:util::stream::MultiProgress
SetToPoison	kenlm/util/stream/block.hh	/^    void SetToPoison() {$/;"	f	class:util::stream::Block
SetToReference	kenlm/lm/binary_format.cc	/^  void SetToReference() {$/;"	f	struct:lm::ngram::__anon7::OldSanity
SetToReference	kenlm/lm/binary_format.cc	/^  void SetToReference() {$/;"	f	struct:lm::ngram::__anon7::Sanity
SetValidSize	kenlm/util/stream/block.hh	/^    void SetValidSize(std::size_t to) { valid_size_ = to; }$/;"	f	class:util::stream::Block
SetVocabFD	kenlm/lm/builder/output.hh	/^    void SetVocabFD(int to) { vocab_fd_ = to; }$/;"	f	class:lm::builder::Output
SetupJustVocab	kenlm/lm/binary_format.cc	/^void *BinaryFormat::SetupJustVocab(std::size_t memory_size, uint8_t order) {$/;"	f	class:lm::ngram::BinaryFormat
SetupMemory	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> void GenericModel<Search, VocabularyT>::SetupMemory(void *base, const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::detail::GenericModel
SetupMemory	kenlm/lm/quantize.cc	/^void SeparatelyQuantize::SetupMemory(void *base, unsigned char order, const Config &config) {$/;"	f	class:lm::ngram::SeparatelyQuantize
SetupMemory	kenlm/lm/quantize.hh	/^    void SetupMemory(void * \/*start*\/, unsigned char \/*order*\/, const Config & \/*config*\/) {}$/;"	f	class:lm::ngram::DontQuantize
SetupMemory	kenlm/lm/search_hashed.cc	/^template <class Value> uint8_t *HashedSearch<Value>::SetupMemory(uint8_t *start, const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::detail::HashedSearch
SetupMemory	kenlm/lm/search_trie.cc	/^template <class Quant, class Bhiksha> uint8_t *TrieSearch<Quant, Bhiksha>::SetupMemory(uint8_t *start, const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::trie::TrieSearch
SetupMemory	kenlm/lm/vocab.cc	/^void ProbingVocabulary::SetupMemory(void *start, std::size_t allocated) {$/;"	f	class:lm::ngram::ProbingVocabulary
SetupMemory	kenlm/lm/vocab.cc	/^void SortedVocabulary::SetupMemory(void *start, std::size_t allocated, std::size_t entries, const Config &config) {$/;"	f	class:lm::ngram::SortedVocabulary
SetupMemory	kenlm/lm/vocab.hh	/^    void SetupMemory(void *start, std::size_t allocated, std::size_t \/*entries*\/, const Config &\/*config*\/) {$/;"	f	class:lm::ngram::ProbingVocabulary
SetupSorts	kenlm/lm/builder/pipeline.cc	/^    template <class Compare> void SetupSorts(Sorts<Compare> &sorts) {$/;"	f	class:lm::builder::__anon13::Master
Shift	kenlm/util/double-conversion/fixed-dtoa.cc	/^  void Shift(int shift_amount) {$/;"	f	class:double_conversion::UInt128
Shift	kenlm/util/file_piece.cc	/^void FilePiece::Shift() {$/;"	f	class:util::FilePiece
ShiftLeft	kenlm/util/double-conversion/bignum.cc	/^void Bignum::ShiftLeft(int shift_amount) {$/;"	f	class:double_conversion::Bignum
ShowSizes	kenlm/lm/sizes.cc	/^void ShowSizes(const char *file, const lm::ngram::Config &config) {$/;"	f	namespace:lm::ngram
ShowSizes	kenlm/lm/sizes.cc	/^void ShowSizes(const std::vector<uint64_t> &counts) {$/;"	f	namespace:lm::ngram
ShowSizes	kenlm/lm/sizes.cc	/^void ShowSizes(const std::vector<uint64_t> &counts, const lm::ngram::Config &config) {$/;"	f	namespace:lm::ngram
Sign	kenlm/util/double-conversion/ieee.h	/^  int Sign() const {$/;"	f	class:double_conversion::Double
Sign	kenlm/util/double-conversion/ieee.h	/^  int Sign() const {$/;"	f	class:double_conversion::Single
SignedZero	kenlm/util/double-conversion/double-conversion.cc	/^static double SignedZero(bool sign) {$/;"	f	namespace:double_conversion
Significand	kenlm/util/double-conversion/ieee.h	/^  uint32_t Significand() const {$/;"	f	class:double_conversion::Single
Significand	kenlm/util/double-conversion/ieee.h	/^  uint64_t Significand() const {$/;"	f	class:double_conversion::Double
SignificandSizeForOrderOfMagnitude	kenlm/util/double-conversion/ieee.h	/^  static int SignificandSizeForOrderOfMagnitude(int order) {$/;"	f	class:double_conversion::Double
Single	kenlm/lm/filter/vocab.hh	/^    explicit Single(const Words &vocab) : vocab_(vocab) {}$/;"	f	class:lm::vocab::Single
Single	kenlm/lm/filter/vocab.hh	/^class Single {$/;"	c	namespace:lm::vocab
Single	kenlm/util/double-conversion/ieee.h	/^  Single() : d32_(0) {}$/;"	f	class:double_conversion::Single
Single	kenlm/util/double-conversion/ieee.h	/^  explicit Single(float f) : d32_(float_to_uint32(f)) {}$/;"	f	class:double_conversion::Single
Single	kenlm/util/double-conversion/ieee.h	/^  explicit Single(uint32_t d32) : d32_(d32) {}$/;"	f	class:double_conversion::Single
Single	kenlm/util/double-conversion/ieee.h	/^class Single {$/;"	c	namespace:double_conversion
SingleAddNGram	kenlm/lm/filter/format.hh	/^    template <class Iterator> void SingleAddNGram(size_t offset, const Iterator &begin, const Iterator &end, const StringPiece &line) {$/;"	f	class:lm::MultipleOutput
SingleAddNGram	kenlm/lm/filter/format.hh	/^    void SingleAddNGram(size_t offset, const StringPiece &line) {$/;"	f	class:lm::MultipleOutput
SingleAddNGram	kenlm/lm/filter/format.hh	/^    void SingleAddNGram(size_t offset, const StringPiece &line) {$/;"	f	class:lm::MultipleOutputBuffer
SingleCharacter	kenlm/util/tokenize_piece.hh	/^    SingleCharacter() {}$/;"	f	class:util::SingleCharacter
SingleCharacter	kenlm/util/tokenize_piece.hh	/^    explicit SingleCharacter(char delim) : delim_(delim) {}$/;"	f	class:util::SingleCharacter
SingleCharacter	kenlm/util/tokenize_piece.hh	/^class SingleCharacter {$/;"	c	namespace:util
Singles	kenlm/lm/filter/format.hh	/^    typedef boost::ptr_vector<Single> Singles;$/;"	t	class:lm::MultipleOutput
SinglesIterator	kenlm/lm/filter/format.hh	/^    typedef typename Singles::iterator SinglesIterator;$/;"	t	class:lm::MultipleOutput
Sink	kenlm/util/stream/io.hh	/^    PWriteAndRecycle Sink() const {$/;"	f	class:util::stream::FileBuffer
Size	kenlm/lm/bhiksha.cc	/^uint64_t ArrayBhiksha::Size(uint64_t max_offset, uint64_t max_next, const Config &config) {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
Size	kenlm/lm/bhiksha.hh	/^    static uint64_t Size(uint64_t \/*max_offset*\/, uint64_t \/*max_next*\/, const Config &\/*config*\/) { return 0; }$/;"	f	class:lm::ngram::trie::DontBhiksha
Size	kenlm/lm/builder/print.hh	/^    std::size_t Size() const {$/;"	f	class:lm::builder::VocabReconstitute
Size	kenlm/lm/filter/format.hh	/^    size_t Size() { return actual_; }$/;"	f	class:lm::InputBuffer
Size	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> uint64_t GenericModel<Search, VocabularyT>::Size(const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::detail::GenericModel
Size	kenlm/lm/quantize.hh	/^    static uint64_t Size(uint8_t \/*order*\/, const Config &\/*config*\/) { return 0; }$/;"	f	class:lm::ngram::DontQuantize
Size	kenlm/lm/quantize.hh	/^    static uint64_t Size(uint8_t order, const Config &config) {$/;"	f	class:lm::ngram::SeparatelyQuantize
Size	kenlm/lm/search_hashed.hh	/^        static uint64_t Size(uint64_t count) {$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Size	kenlm/lm/search_hashed.hh	/^    static uint64_t Size(const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::detail::HashedSearch
Size	kenlm/lm/search_trie.hh	/^    static uint64_t Size(const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::trie::TrieSearch
Size	kenlm/lm/trie.cc	/^template <class Bhiksha> uint64_t BitPackedMiddle<Bhiksha>::Size(uint8_t quant_bits, uint64_t entries, uint64_t max_vocab, uint64_t max_ptr, const Config &config) {$/;"	f	class:lm::ngram::trie::BitPackedMiddle
Size	kenlm/lm/trie.hh	/^    static uint64_t Size(uint64_t count) {$/;"	f	class:lm::ngram::trie::Unigram
Size	kenlm/lm/trie.hh	/^    static uint64_t Size(uint8_t quant_bits, uint64_t entries, uint64_t max_vocab) {$/;"	f	class:lm::ngram::trie::BitPackedLongest
Size	kenlm/lm/vocab.cc	/^uint64_t ProbingVocabulary::Size(uint64_t entries, const Config &config) {$/;"	f	class:lm::ngram::ProbingVocabulary
Size	kenlm/lm/vocab.cc	/^uint64_t ProbingVocabulary::Size(uint64_t entries, float probing_multiplier) {$/;"	f	class:lm::ngram::ProbingVocabulary
Size	kenlm/lm/vocab.cc	/^uint64_t SortedVocabulary::Size(uint64_t entries, const Config &\/*config*\/) {$/;"	f	class:lm::ngram::SortedVocabulary
Size	kenlm/lm/vocab.hh	/^    WordIndex Size() const { return lookup_.Size(); }$/;"	f	class:lm::ngram::GrowableVocab
Size	kenlm/util/probing_hash_table.hh	/^    static uint64_t Size(uint64_t entries, float multiplier) {$/;"	f	class:util::ProbingHashTable
Size	kenlm/util/probing_hash_table.hh	/^    std::size_t Size() const {$/;"	f	class:util::AutoProbing
Size	kenlm/util/stream/io.hh	/^    uint64_t Size() const {$/;"	f	class:util::stream::FileBuffer
Size	kenlm/util/stream/sort.hh	/^    std::size_t Size() const {$/;"	f	class:util::stream::MergeQueue
Size	kenlm/util/stream/sort.hh	/^    uint64_t Size() const {$/;"	f	class:util::stream::Sort
SizeFile	kenlm/util/file.cc	/^uint64_t SizeFile(int fd) {$/;"	f	namespace:util
SizeInHexChars	kenlm/util/double-conversion/bignum.cc	/^static int SizeInHexChars(S number) {$/;"	f	namespace:double_conversion
SizeNeededForCounts	kenlm/lm/filter/arpa_io.cc	/^size_t SizeNeededForCounts(const std::vector<uint64_t> &number) {$/;"	f	namespace:lm
SizeNoSerialization	kenlm/util/probing_hash_table.hh	/^    std::size_t SizeNoSerialization() const {$/;"	f	class:util::ProbingHashTable
SizeOrThrow	kenlm/util/file.cc	/^uint64_t SizeOrThrow(int fd) {$/;"	f	namespace:util
SizePage	kenlm/util/mmap.cc	/^long SizePage() {$/;"	f	namespace:util
SizeParseError	kenlm/util/usage.cc	/^    explicit SizeParseError(const std::string &str) throw() {$/;"	f	class:util::__anon50::SizeParseError
SizeParseError	kenlm/util/usage.cc	/^class SizeParseError : public Exception {$/;"	c	namespace:util::__anon50	file:
SizedCompare	kenlm/util/sized_iterator.hh	/^    explicit SizedCompare(const Delegate &delegate = Delegate()) : delegate_(delegate) {}$/;"	f	class:util::SizedCompare
SizedCompare	kenlm/util/sized_iterator.hh	/^template <class Delegate, class Proxy = SizedProxy> class SizedCompare : public std::binary_function<const Proxy &, const Proxy &, bool> {$/;"	c	namespace:util
SizedInnerIterator	kenlm/util/sized_iterator.hh	/^    SizedInnerIterator() {}$/;"	f	class:util::SizedInnerIterator
SizedInnerIterator	kenlm/util/sized_iterator.hh	/^    SizedInnerIterator(void *ptr, std::size_t size) : ptr_(static_cast<uint8_t*>(ptr)), size_(size) {}$/;"	f	class:util::SizedInnerIterator
SizedInnerIterator	kenlm/util/sized_iterator.hh	/^class SizedInnerIterator {$/;"	c	namespace:util
SizedIt	kenlm/util/sized_iterator.hh	/^inline SizedIterator SizedIt(void *ptr, std::size_t size) { return SizedIterator(SizedProxy(ptr, size)); }$/;"	f	namespace:util
SizedIterator	kenlm/util/sized_iterator.hh	/^typedef ProxyIterator<SizedProxy> SizedIterator;$/;"	t	namespace:util
SizedProxy	kenlm/util/sized_iterator.hh	/^    SizedProxy() {}$/;"	f	class:util::SizedProxy
SizedProxy	kenlm/util/sized_iterator.hh	/^    SizedProxy(void *ptr, std::size_t size) : inner_(ptr, size) {}$/;"	f	class:util::SizedProxy
SizedProxy	kenlm/util/sized_iterator.hh	/^class SizedProxy {$/;"	c	namespace:util
SkipSpaces	kenlm/util/file_piece.hh	/^    void SkipSpaces(const bool *delim = kSpaces) {$/;"	f	class:util::FilePiece
SkipSpaces	kenlm/util/usage.cc	/^const char *SkipSpaces(const char *at) {$/;"	f	namespace:util::__anon49
Sort	kenlm/util/stream/sort.hh	/^    Sort(Chain &in, const SortConfig &config, const Compare &compare = Compare(), const Combine &combine = Combine())$/;"	f	class:util::stream::Sort
Sort	kenlm/util/stream/sort.hh	/^template <class Compare, class Combine = NeverCombine> class Sort {$/;"	c	namespace:util::stream
SortAndReadTwice	kenlm/lm/builder/pipeline.cc	/^    void SortAndReadTwice(const std::vector<uint64_t> &counts, Sorts<ContextOrder> &sorts, util::stream::Chains &second, util::stream::ChainConfig second_config) {$/;"	f	class:lm::builder::__anon13::Master
SortConfig	kenlm/util/stream/config.hh	/^struct SortConfig {$/;"	s	namespace:util::stream
SortedFiles	kenlm/lm/trie_sort.cc	/^SortedFiles::SortedFiles(const Config &config, util::FilePiece &f, std::vector<uint64_t> &counts, size_t buffer, const std::string &file_prefix, SortedVocabulary &vocab) {$/;"	f	class:lm::ngram::trie::SortedFiles
SortedFiles	kenlm/lm/trie_sort.hh	/^class SortedFiles {$/;"	c	namespace:lm::ngram::trie
SortedUniformFind	kenlm/util/sorted_uniform.hh	/^template <class Iterator, class Accessor, class Pivot> bool SortedUniformFind(const Accessor &accessor, Iterator begin, Iterator end, const typename Accessor::Key key, Iterator &out) {$/;"	f	namespace:util
SortedVocabulary	kenlm/lm/vocab.cc	/^SortedVocabulary::SortedVocabulary() : begin_(NULL), end_(NULL), enumerate_(NULL) {}$/;"	f	class:lm::ngram::SortedVocabulary
SortedVocabulary	kenlm/lm/vocab.hh	/^class SortedVocabulary : public base::Vocabulary {$/;"	c	namespace:lm::ngram
Sorts	kenlm/lm/builder/sort.hh	/^    Sorts() {}$/;"	f	class:lm::builder::Sorts
Sorts	kenlm/lm/builder/sort.hh	/^    explicit Sorts(std::size_t number) : util::FixedArray<util::stream::Sort<Compare> >(number) {}$/;"	f	class:lm::builder::Sorts
Sorts	kenlm/lm/builder/sort.hh	/^template <class Compare> class Sorts : public util::FixedArray<util::stream::Sort<Compare> > {$/;"	c	namespace:lm::builder
Source	kenlm/util/stream/io.hh	/^    PRead Source() const {$/;"	f	class:util::stream::FileBuffer
SpecialWordMissingException	kenlm/lm/lm_exception.cc	/^SpecialWordMissingException::SpecialWordMissingException() throw() {}$/;"	f	class:lm::SpecialWordMissingException
SpecialWordMissingException	kenlm/lm/lm_exception.hh	/^class SpecialWordMissingException : public VocabLoadException {$/;"	c	namespace:lm
Square	kenlm/util/double-conversion/bignum.cc	/^void Bignum::Square() {$/;"	f	class:double_conversion::Bignum
Start	kenlm/util/stream/chain.cc	/^void Chain::Start() {$/;"	f	class:util::stream::Chain
StartBlock	kenlm/lm/builder/adjust_counts.cc	/^    void StartBlock() {$/;"	f	class:lm::builder::__anon8::CollapseStream	file:
StartBlock	kenlm/lm/builder/initial_probabilities.cc	/^    void StartBlock() {$/;"	f	class:lm::builder::__anon11::PruneNGramStream	file:
StartBlock	kenlm/util/stream/stream.hh	/^    void StartBlock() {$/;"	f	class:util::stream::Stream
StartSentence	kenlm/lm/builder/corpus_count.cc	/^    void StartSentence() {$/;"	f	class:lm::builder::__anon9::Writer
Started	kenlm/util/usage.cc	/^    const Wall &Started() const {$/;"	f	class:util::__anon49::RecordStart
StatCollector	kenlm/lm/builder/adjust_counts.cc	/^    StatCollector(std::size_t order, std::vector<uint64_t> &counts, std::vector<uint64_t> &counts_pruned, std::vector<Discount> &discounts)$/;"	f	class:lm::builder::__anon8::StatCollector
StatCollector	kenlm/lm/builder/adjust_counts.cc	/^class StatCollector {$/;"	c	namespace:lm::builder::__anon8	file:
State	kenlm/lm/facade.hh	/^    typedef StateT State;$/;"	t	class:lm::base::ModelFacade
State	kenlm/lm/state.hh	/^class State {$/;"	c	namespace:lm::ngram
State	kenlm/lm/wrappers/nplm.hh	/^struct State {$/;"	s	namespace:lm::np
StateInfo_lv	HLVModel.h	/^typedef struct _StateInfo_lv StateInfo_lv;$/;"	t	typeref:struct:_StateInfo_lv
StateSize	kenlm/lm/virtual_interface.hh	/^    size_t StateSize() const { return state_size_; }$/;"	f	class:lm::base::Model
StaticAssertionPassed	kenlm/util/bit_packing.cc	/^template <> struct StaticCheck<true> { typedef bool StaticAssertionPassed; };$/;"	t	struct:util::__anon30::StaticCheck	file:
StaticCheck	kenlm/util/bit_packing.cc	/^template <> struct StaticCheck<true> { typedef bool StaticAssertionPassed; };$/;"	s	namespace:util::__anon30	file:
StaticCheck	kenlm/util/bit_packing.cc	/^template <bool> struct StaticCheck {};$/;"	s	namespace:util::__anon30	file:
Stats	HLVRec.h	/^typedef struct _Stats Stats;    \/* statistics about pruning etc. *\/$/;"	t	typeref:struct:_Stats
StealCompleted	kenlm/util/stream/sort.hh	/^    int StealCompleted() {$/;"	f	class:util::stream::Sort
StealUnigram	kenlm/lm/trie_sort.hh	/^    int StealUnigram() {$/;"	f	class:lm::ngram::trie::SortedFiles
Storage	kenlm/lm/neural/wordvecs.hh	/^    typedef Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor> Storage;$/;"	t	class:lm::neural::WordVecs
StrLength	kenlm/util/double-conversion/utils.h	/^inline int StrLength(const char* string) {$/;"	f	namespace:double_conversion
Stream	kenlm/util/read_compressed.cc	/^    const bz_stream &Stream() const { return stream_; }$/;"	f	class:util::__anon45::BZip
Stream	kenlm/util/read_compressed.cc	/^    const lzma_stream &Stream() const { return stream_; }$/;"	f	class:util::__anon45::XZip
Stream	kenlm/util/read_compressed.cc	/^    const z_stream &Stream() const { return stream_; }$/;"	f	class:util::__anon45::GZip
Stream	kenlm/util/stream/stream.hh	/^    Stream() : current_(NULL), end_(NULL) {}$/;"	f	class:util::stream::Stream
Stream	kenlm/util/stream/stream.hh	/^    explicit Stream(const ChainPosition &position) {$/;"	f	class:util::stream::Stream
Stream	kenlm/util/stream/stream.hh	/^class Stream : boost::noncopyable {$/;"	c	namespace:util::stream
StreamCompressed	kenlm/util/read_compressed.cc	/^    StreamCompressed(int fd, const void *already_data, std::size_t already_size)$/;"	f	class:util::__anon45::StreamCompressed
StreamCompressed	kenlm/util/read_compressed.cc	/^template <class Compression> class StreamCompressed : public ReadBase {$/;"	c	namespace:util::__anon45	file:
Streams	kenlm/util/stream/multi_stream.hh	/^typedef GenericStreams<Stream> Streams;$/;"	t	namespace:util::stream
StringBuilder	kenlm/util/double-conversion/utils.h	/^  StringBuilder(char* buffer, int size)$/;"	f	class:double_conversion::StringBuilder
StringBuilder	kenlm/util/double-conversion/utils.h	/^class StringBuilder {$/;"	c	namespace:double_conversion
StringPiece	kenlm/util/string_piece.hh	/^  StringPiece() : ptr_(NULL), length_(0) { }$/;"	f	class:StringPiece
StringPiece	kenlm/util/string_piece.hh	/^  StringPiece(const char* offset, size_type len)$/;"	f	class:StringPiece
StringPiece	kenlm/util/string_piece.hh	/^  StringPiece(const char* str)$/;"	f	class:StringPiece
StringPiece	kenlm/util/string_piece.hh	/^  StringPiece(const std::string& str)$/;"	f	class:StringPiece
StringPiece	kenlm/util/string_piece.hh	/^class StringPiece {$/;"	c
StringPieceCompatibleEquals	kenlm/util/string_piece_hash.hh	/^struct StringPieceCompatibleEquals : public std::binary_function<const StringPiece &, const std::string &, bool> {$/;"	s
StringPieceCompatibleHash	kenlm/util/string_piece_hash.hh	/^struct StringPieceCompatibleHash : public std::unary_function<const StringPiece &, size_t> {$/;"	s
StringToDouble	kenlm/util/double-conversion/double-conversion.h	/^  double StringToDouble(const char* buffer,$/;"	f	class:double_conversion::StringToDoubleConverter
StringToDoubleConverter	kenlm/util/double-conversion/double-conversion.h	/^  StringToDoubleConverter(int flags,$/;"	f	class:double_conversion::StringToDoubleConverter
StringToDoubleConverter	kenlm/util/double-conversion/double-conversion.h	/^class StringToDoubleConverter {$/;"	c	namespace:double_conversion
StringToFloat	kenlm/util/double-conversion/double-conversion.h	/^  float StringToFloat(const char* buffer,$/;"	f	class:double_conversion::StringToDoubleConverter
StringToIeee	kenlm/util/double-conversion/double-conversion.cc	/^double StringToDoubleConverter::StringToIeee($/;"	f	class:double_conversion::StringToDoubleConverter
Strtod	kenlm/util/double-conversion/strtod.cc	/^double Strtod(Vector<const char> buffer, int exponent) {$/;"	f	namespace:double_conversion
Strtof	kenlm/util/double-conversion/strtod.cc	/^float Strtof(Vector<const char> buffer, int exponent) {$/;"	f	namespace:double_conversion
SubVector	kenlm/util/double-conversion/utils.h	/^  Vector<T> SubVector(int from, int to) {$/;"	f	class:double_conversion::Vector
Substrings	kenlm/lm/filter/phrase.hh	/^    Substrings() {}$/;"	f	class:lm::phrase::Substrings
Substrings	kenlm/lm/filter/phrase.hh	/^class Substrings {$/;"	c	namespace:lm::phrase
Subsume	kenlm/lm/partial.hh	/^template <class Model> float Subsume(const Model &model, Left &first_left, const Right &first_right, const Left &second_left, Right &second_right, const unsigned int between_length) {$/;"	f	namespace:lm::ngram
Subtract	kenlm/util/double-conversion/diy-fp.h	/^  void Subtract(const DiyFp& other) {$/;"	f	class:double_conversion::DiyFp
Subtract	kenlm/util/usage.cc	/^double Subtract(const struct timespec &first, const struct timespec &second) {$/;"	f	namespace:util::__anon49
Subtract	kenlm/util/usage.cc	/^double Subtract(const struct timeval &first, const struct timeval &second) {$/;"	f	namespace:util::__anon49
Subtract	kenlm/util/usage.cc	/^double Subtract(time_t first, time_t second) {$/;"	f	namespace:util::__anon49
SubtractBignum	kenlm/util/double-conversion/bignum.cc	/^void Bignum::SubtractBignum(const Bignum& other) {$/;"	f	class:double_conversion::Bignum
SubtractTimes	kenlm/util/double-conversion/bignum.cc	/^void Bignum::SubtractTimes(const Bignum& other, int factor) {$/;"	f	class:double_conversion::Bignum
SuffixOrder	kenlm/lm/builder/sort.hh	/^    explicit SuffixOrder(std::size_t order) : Comparator<SuffixOrder>(order) {}$/;"	f	class:lm::builder::SuffixOrder
SuffixOrder	kenlm/lm/builder/sort.hh	/^class SuffixOrder : public Comparator<SuffixOrder> {$/;"	c	namespace:lm::builder
Summary	kenlm/lm/ngram_query.hh	/^  void Summary(double ppl_including_oov, double ppl_excluding_oov, uint64_t corpus_oov, uint64_t corpus_tokens) {$/;"	f	struct:lm::ngram::FullPrint
Summary	kenlm/lm/ngram_query.hh	/^  void Summary(double, double, uint64_t, uint64_t) {}$/;"	f	struct:lm::ngram::BasicPrint
SweepAltPaths	HLVRec-GC.c	/^static void SweepAltPaths (MemHeap *heap)$/;"	f	file:
SweepModPaths	HLVRec-GC.c	/^static void SweepModPaths (MemHeap *heap)$/;"	f	file:
SweepPaths	HLVRec-GC.c	/^static void SweepPaths (MemHeap *heap)$/;"	f	file:
SyncOrThrow	kenlm/util/mmap.cc	/^void SyncOrThrow(void *start, size_t length) {$/;"	f	namespace:util
T	kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<2> { typedef Pivot32 T; };$/;"	t	struct:util::PivotSelect
T	kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<4> { typedef Pivot32 T; };$/;"	t	struct:util::PivotSelect
T	kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<8> { typedef Pivot64 T; };$/;"	t	struct:util::PivotSelect
THROW_UP	kenlm/lm/lm_exception.hh	/^typedef enum {THROW_UP, COMPLAIN, SILENT} WarningAction;$/;"	e	enum:lm::__anon17
TLexConNode	HLVNet.h	/^typedef struct _TLexNode TLexConNode;$/;"	t	typeref:struct:_TLexNode
TLexLink	HLVNet.h	/^typedef struct _TLexLink TLexLink;$/;"	t	typeref:struct:_TLexLink
TLexNet	HLVNet.h	/^} TLexNet;$/;"	t	typeref:struct:_TLexNet
TLexNode	HLVNet.h	/^typedef struct _TLexNode TLexNode;$/;"	t	typeref:struct:_TLexNode
TOK_LMSTATE_EQ	HLVRec.h	128;"	d
TOK_LMSTATE_LT	HLVRec.h	125;"	d
TRIE	kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon20
TRIE_SORTED	kenlm/lm/model_type.hh	/^const ModelType TRIE_SORTED = TRIE;$/;"	m	namespace:lm::ngram
TSIDOPT	config.h	56;"	d
TSIDOPT	config.h	59;"	d
TSIDOPT	config.h	74;"	d
T_ACCESS	HLVLM.c	54;"	d	file:
T_ACTIV	HLVRec.c	68;"	d	file:
T_ADP	HDecode.c	67;"	d	file:
T_ADP	HDecode.mod.c	67;"	d	file:
T_BEST	HLVRec.c	64;"	d	file:
T_GC	HLVRec.c	71;"	d	file:
T_LAT	HLVRec.c	70;"	d	file:
T_MEM	HDecode.c	68;"	d	file:
T_MEM	HDecode.mod.c	68;"	d	file:
T_MEM	HLVRec.c	72;"	d	file:
T_NET	HLVNet.c	62;"	d	file:
T_NETCON	HLVNet.c	63;"	d	file:
T_OBS	HDecode.c	66;"	d	file:
T_OBS	HDecode.mod.c	66;"	d	file:
T_PROP	HLVRec.c	69;"	d	file:
T_PRUNE	HLVRec.c	67;"	d	file:
T_TOKSTATS	HLVRec.c	66;"	d	file:
T_TOP	HDecode.c	65;"	d	file:
T_TOP	HDecode.mod.c	65;"	d	file:
T_TOP	HLVLM.c	53;"	d	file:
T_TOP	HLVModel.c	55;"	d	file:
T_TOP	HLVNet.c	61;"	d	file:
T_TOP	HLVRec.c	63;"	d	file:
T_WORD	HLVRec.c	65;"	d	file:
Table	kenlm/lm/filter/phrase.hh	/^    typedef boost::unordered_map<Hash, SentenceRelation> Table;$/;"	t	class:lm::phrase::Substrings
TempPrefix	kenlm/lm/builder/pipeline.hh	/^  const std::string &TempPrefix() const { return sort.temp_prefix; }$/;"	f	struct:lm::builder::PipelineConfig
Terminal	kenlm/lm/left.hh	/^    void Terminal(WordIndex word) {$/;"	f	class:lm::ngram::RuleScore
Thread	kenlm/util/stream/chain.hh	/^    template <class Position, class Worker> Thread(const Position &position, const Worker &worker)$/;"	f	class:util::stream::Thread
Thread	kenlm/util/stream/chain.hh	/^class Thread {$/;"	c	namespace:util::stream
ThreadBatch	kenlm/lm/filter/thread.hh	/^    ThreadBatch() {}$/;"	f	class:lm::ThreadBatch
ThreadBatch	kenlm/lm/filter/thread.hh	/^template <class OutputBuffer> class ThreadBatch {$/;"	c	namespace:lm
ThreadPool	kenlm/util/thread_pool.hh	/^    template <class Construct> ThreadPool(size_t queue_length, size_t workers, Construct handler_construct, Request poison) : in_(queue_length), poison_(poison) {$/;"	f	class:util::ThreadPool
ThreadPool	kenlm/util/thread_pool.hh	/^template <class HandlerT> class ThreadPool : boost::noncopyable {$/;"	c	namespace:util
ThrowCombine	kenlm/lm/trie_sort.cc	/^struct ThrowCombine {$/;"	s	namespace:lm::ngram::trie::__anon26	file:
Times	kenlm/util/double-conversion/diy-fp.h	/^  static DiyFp Times(const DiyFp& a, const DiyFp& b) {$/;"	f	class:double_conversion::DiyFp
Times10	kenlm/util/double-conversion/bignum.h	/^  void Times10() { return MultiplyByUInt32(10); }$/;"	f	class:double_conversion::Bignum
ToExponential	kenlm/util/double-conversion/double-conversion.cc	/^bool DoubleToStringConverter::ToExponential($/;"	f	class:double_conversion::DoubleToStringConverter
ToFixed	kenlm/util/double-conversion/double-conversion.cc	/^bool DoubleToStringConverter::ToFixed(double value,$/;"	f	class:double_conversion::DoubleToStringConverter
ToHexString	kenlm/util/double-conversion/bignum.cc	/^bool Bignum::ToHexString(char* buffer, int buffer_size) const {$/;"	f	class:double_conversion::Bignum
ToPrecision	kenlm/util/double-conversion/double-conversion.cc	/^bool DoubleToStringConverter::ToPrecision(double value,$/;"	f	class:double_conversion::DoubleToStringConverter
ToShortest	kenlm/util/double-conversion/double-conversion.h	/^  bool ToShortest(double value, StringBuilder* result_builder) const {$/;"	f	class:double_conversion::DoubleToStringConverter
ToShortestIeeeNumber	kenlm/util/double-conversion/double-conversion.cc	/^bool DoubleToStringConverter::ToShortestIeeeNumber($/;"	f	class:double_conversion::DoubleToStringConverter
ToShortestSingle	kenlm/util/double-conversion/double-conversion.h	/^  bool ToShortestSingle(float value, StringBuilder* result_builder) const {$/;"	f	class:double_conversion::DoubleToStringConverter
TokScore	config.h	/^typedef LogFloat TokScore;$/;"	t
Token	HLVRec.h	/^typedef struct _Token Token;            \/* Info about partial hypothesis *\/$/;"	t	typeref:struct:_Token
TokenIter	kenlm/util/tokenize_piece.hh	/^    TokenIter() {}$/;"	f	class:util::TokenIter
TokenIter	kenlm/util/tokenize_piece.hh	/^    template <class Construct> TokenIter(const StringPiece &str, const Construct &construct) : after_(str), finder_(construct) {$/;"	f	class:util::TokenIter
TokenIter	kenlm/util/tokenize_piece.hh	/^template <class Find, bool SkipEmpty = false> class TokenIter : public boost::iterator_facade<TokenIter<Find, SkipEmpty>, const StringPiece, boost::forward_traversal_tag> {$/;"	c	namespace:util
TokenSet	HLVRec.h	/^typedef struct _TokenSet TokenSet;      \/* contains n tokens with different LM states *\/$/;"	t	typeref:struct:_TokenSet
Top	kenlm/util/stream/sort.hh	/^    const void *Top() const {$/;"	f	class:util::stream::MergeQueue
TotalHeaderSize	kenlm/lm/binary_format.cc	/^std::size_t TotalHeaderSize(unsigned char order) {$/;"	f	namespace:lm::ngram::__anon7
TotalMemory	kenlm/lm/builder/pipeline.hh	/^  std::size_t TotalMemory() const { return sort.total_memory; }$/;"	f	struct:lm::builder::PipelineConfig
TotalOffset	kenlm/util/stream/sort.hh	/^    uint64_t TotalOffset() const { return output_sum_; }$/;"	f	class:util::stream::Offsets
TotalSize	kenlm/lm/builder/ngram.hh	/^    static std::size_t TotalSize(std::size_t order) {$/;"	f	class:lm::builder::NGram
TotalSize	kenlm/lm/builder/ngram.hh	/^    std::size_t TotalSize() const {$/;"	f	class:lm::builder::NGram
TraceBack	HLVRec-traceback.c	/^Transcription *TraceBack(MemHeap *heap, DecoderInst *dec)$/;"	f
Train	kenlm/lm/quantize.cc	/^void SeparatelyQuantize::Train(uint8_t order, std::vector<float> &prob, std::vector<float> &backoff) {$/;"	f	class:lm::ngram::SeparatelyQuantize
Train	kenlm/lm/quantize.hh	/^    void Train(uint8_t \/*order*\/, std::vector<float> &\/*prob*\/, std::vector<float> &\/*backoff*\/) {}$/;"	f	class:lm::ngram::DontQuantize
TrainProb	kenlm/lm/quantize.cc	/^void SeparatelyQuantize::TrainProb(uint8_t order, std::vector<float> &prob) {$/;"	f	class:lm::ngram::SeparatelyQuantize
TrainProb	kenlm/lm/quantize.hh	/^    void TrainProb(uint8_t, std::vector<float> &\/*prob*\/) {}$/;"	f	class:lm::ngram::DontQuantize
TrainProbQuantizer	kenlm/lm/search_trie.cc	/^template <class Quant> void TrainProbQuantizer(uint8_t order, uint64_t count, RecordReader &reader, util::ErsatzProgress &progress, Quant &quant) {$/;"	f	namespace:lm::ngram::trie::__anon24
TrainQuantizer	kenlm/lm/search_trie.cc	/^template <class Quant> void TrainQuantizer(uint8_t order, uint64_t count, const std::vector<float> &additional, RecordReader &reader, util::ErsatzProgress &progress, Quant &quant) {$/;"	f	namespace:lm::ngram::trie::__anon24
TransitionToRead	kenlm/util/file_piece.cc	/^void FilePiece::TransitionToRead() {$/;"	f	class:util::FilePiece
TraverseTree	HLVNet.c	/^int TraverseTree (TLexNode *ln, int start, int *lmlaCount)$/;"	f
TrieSearch	kenlm/lm/search_trie.hh	/^    TrieSearch() : middle_begin_(NULL), middle_end_(NULL) {}$/;"	f	class:lm::ngram::trie::TrieSearch
TrieSearch	kenlm/lm/search_trie.hh	/^template <class Quant, class Bhiksha> class TrieSearch {$/;"	c	namespace:lm::ngram::trie
TrieUnigramProxy	kenlm/lm/value.hh	/^      TrieUnigramProxy() {}$/;"	f	class:lm::ngram::BackoffValue::TrieUnigramProxy
TrieUnigramProxy	kenlm/lm/value.hh	/^      TrieUnigramProxy() {}$/;"	f	class:lm::ngram::RestValue::TrieUnigramProxy
TrieUnigramProxy	kenlm/lm/value.hh	/^      explicit TrieUnigramProxy(const Weights &to) : GenericTrieUnigramProxy<Weights>(to) {}$/;"	f	class:lm::ngram::BackoffValue::TrieUnigramProxy
TrieUnigramProxy	kenlm/lm/value.hh	/^      explicit TrieUnigramProxy(const Weights &to) : GenericTrieUnigramProxy<Weights>(to) {}$/;"	f	class:lm::ngram::RestValue::TrieUnigramProxy
TrieUnigramProxy	kenlm/lm/value.hh	/^  class TrieUnigramProxy : public GenericTrieUnigramProxy<Weights> {$/;"	c	struct:lm::ngram::BackoffValue
TrieUnigramProxy	kenlm/lm/value.hh	/^  class TrieUnigramProxy : public GenericTrieUnigramProxy<Weights> {$/;"	c	struct:lm::ngram::RestValue
TrieUnigramValue	kenlm/lm/value.hh	/^  struct TrieUnigramValue {$/;"	s	struct:lm::ngram::BackoffValue
TrieUnigramValue	kenlm/lm/value.hh	/^  struct TrieUnigramValue {$/;"	s	struct:lm::ngram::RestValue
TrimAndCut	kenlm/util/double-conversion/strtod.cc	/^static void TrimAndCut(Vector<const char> buffer, int exponent,$/;"	f	namespace:double_conversion
TrimLeadingZeros	kenlm/util/double-conversion/strtod.cc	/^static Vector<const char> TrimLeadingZeros(Vector<const char> buffer) {$/;"	f	namespace:double_conversion
TrimTrailingZeros	kenlm/util/double-conversion/strtod.cc	/^static Vector<const char> TrimTrailingZeros(Vector<const char> buffer) {$/;"	f	namespace:double_conversion
TrimZeros	kenlm/util/double-conversion/fixed-dtoa.cc	/^static void TrimZeros(Vector<char> buffer, int* length, int* decimal_point) {$/;"	f	namespace:double_conversion
True	kenlm/util/file.cc	/^  struct True {};$/;"	s	struct:util::__anon36::CheckOffT	file:
TryName	kenlm/util/file.cc	/^bool TryName(int fd, std::string &out) {$/;"	f	namespace:util::__anon37
UINT64_2PART_C	kenlm/util/double-conversion/utils.h	96;"	d
UInt128	kenlm/util/double-conversion/fixed-dtoa.cc	/^  UInt128() : high_bits_(0), low_bits_(0) { }$/;"	f	class:double_conversion::UInt128
UInt128	kenlm/util/double-conversion/fixed-dtoa.cc	/^  UInt128(uint64_t high, uint64_t low) : high_bits_(high), low_bits_(low) { }$/;"	f	class:double_conversion::UInt128
UInt128	kenlm/util/double-conversion/fixed-dtoa.cc	/^class UInt128 {$/;"	c	namespace:double_conversion	file:
UNIMPLEMENTED	kenlm/util/double-conversion/utils.h	39;"	d
UNIQUE_ZERO	kenlm/util/double-conversion/double-conversion.h	/^    UNIQUE_ZERO = 8$/;"	e	enum:double_conversion::DoubleToStringConverter::Flags
UNMARK_ALTPATH	HLVRec-GC.c	49;"	d	file:
UNMARK_MODPATH	HLVRec-GC.c	57;"	d	file:
UNMARK_PATH	HLVRec-GC.c	42;"	d	file:
UNREACHABLE	kenlm/util/double-conversion/utils.h	42;"	d
USE_INTEL_SSE	config.h	65;"	d
UTIL_BIT_PACKING_H	kenlm/util/bit_packing.hh	2;"	d
UTIL_BZIP	kenlm/util/read_compressed.cc	/^  UTIL_UNKNOWN, UTIL_GZIP, UTIL_BZIP, UTIL_XZIP$/;"	e	enum:util::__anon45::MagicResult	file:
UTIL_ERSATZ_PROGRESS_H	kenlm/util/ersatz_progress.hh	2;"	d
UTIL_EXCEPTION_H	kenlm/util/exception.hh	2;"	d
UTIL_FAKE_OFSTREAM_H	kenlm/util/fake_ofstream.hh	6;"	d
UTIL_FILE_H	kenlm/util/file.hh	2;"	d
UTIL_FILE_PIECE_H	kenlm/util/file_piece.hh	2;"	d
UTIL_FIXED_ARRAY_H	kenlm/util/fixed_array.hh	2;"	d
UTIL_FUNC_NAME	kenlm/util/exception.hh	56;"	d
UTIL_FUNC_NAME	kenlm/util/exception.hh	59;"	d
UTIL_FUNC_NAME	kenlm/util/exception.hh	61;"	d
UTIL_GETOPT_H	kenlm/util/getopt.hh	15;"	d
UTIL_GZIP	kenlm/util/read_compressed.cc	/^  UTIL_UNKNOWN, UTIL_GZIP, UTIL_BZIP, UTIL_XZIP$/;"	e	enum:util::__anon45::MagicResult	file:
UTIL_HAVE_H	kenlm/util/have.hh	3;"	d
UTIL_JOINT_SORT_H	kenlm/util/joint_sort.hh	2;"	d
UTIL_MMAP_H	kenlm/util/mmap.hh	2;"	d
UTIL_MULTI_INTERSECTION_H	kenlm/util/multi_intersection.hh	2;"	d
UTIL_MURMUR_HASH_H	kenlm/util/murmur_hash.hh	2;"	d
UTIL_PARALLEL_READ__	kenlm/util/parallel_read.hh	2;"	d
UTIL_PCQUEUE_H	kenlm/util/pcqueue.hh	2;"	d
UTIL_POOL_H	kenlm/util/pool.hh	5;"	d
UTIL_PROBING_HASH_TABLE_H	kenlm/util/probing_hash_table.hh	2;"	d
UTIL_PROXY_ITERATOR_H	kenlm/util/proxy_iterator.hh	2;"	d
UTIL_READ_COMPRESSED_H	kenlm/util/read_compressed.hh	2;"	d
UTIL_SCOPED_H	kenlm/util/scoped.hh	2;"	d
UTIL_SIZED_ITERATOR_H	kenlm/util/sized_iterator.hh	2;"	d
UTIL_SORTED_UNIFORM_H	kenlm/util/sorted_uniform.hh	2;"	d
UTIL_STREAM_BLOCK_H	kenlm/util/stream/block.hh	2;"	d
UTIL_STREAM_CHAIN_H	kenlm/util/stream/chain.hh	2;"	d
UTIL_STREAM_CONFIG_H	kenlm/util/stream/config.hh	2;"	d
UTIL_STREAM_IO_H	kenlm/util/stream/io.hh	2;"	d
UTIL_STREAM_LINE_INPUT_H	kenlm/util/stream/line_input.hh	2;"	d
UTIL_STREAM_MULTI_PROGRESS_H	kenlm/util/stream/multi_progress.hh	3;"	d
UTIL_STREAM_MULTI_STREAM_H	kenlm/util/stream/multi_stream.hh	2;"	d
UTIL_STREAM_SORT_H	kenlm/util/stream/sort.hh	19;"	d
UTIL_STREAM_STREAM_H	kenlm/util/stream/stream.hh	2;"	d
UTIL_STREAM_TIMER_H	kenlm/util/stream/timer.hh	2;"	d
UTIL_STRING_PIECE_H	kenlm/util/string_piece.hh	49;"	d
UTIL_STRING_PIECE_HASH_H	kenlm/util/string_piece_hash.hh	2;"	d
UTIL_THREAD_POOL_H	kenlm/util/thread_pool.hh	2;"	d
UTIL_THROW	kenlm/util/exception.hh	83;"	d
UTIL_THROW2	kenlm/util/exception.hh	86;"	d
UTIL_THROW_ARG	kenlm/util/exception.hh	80;"	d
UTIL_THROW_BACKEND	kenlm/util/exception.hh	73;"	d
UTIL_THROW_IF	kenlm/util/exception.hh	101;"	d
UTIL_THROW_IF2	kenlm/util/exception.hh	104;"	d
UTIL_THROW_IF_ARG	kenlm/util/exception.hh	95;"	d
UTIL_TIMER	kenlm/util/stream/timer.hh	13;"	d
UTIL_TOKENIZE_PIECE_H	kenlm/util/tokenize_piece.hh	2;"	d
UTIL_UNISTD_H	kenlm/util/unistd.hh	2;"	d
UTIL_UNKNOWN	kenlm/util/read_compressed.cc	/^  UTIL_UNKNOWN, UTIL_GZIP, UTIL_BZIP, UTIL_XZIP$/;"	e	enum:util::__anon45::MagicResult	file:
UTIL_UNLIKELY	kenlm/util/exception.hh	90;"	d
UTIL_UNLIKELY	kenlm/util/exception.hh	92;"	d
UTIL_USAGE_H	kenlm/util/usage.hh	2;"	d
UTIL_XZIP	kenlm/util/read_compressed.cc	/^  UTIL_UNKNOWN, UTIL_GZIP, UTIL_BZIP, UTIL_XZIP$/;"	e	enum:util::__anon45::MagicResult	file:
UnMarkAllWords	HLVNet.c	/^void UnMarkAllWords (Vocab *voc)$/;"	f
UnRest	kenlm/lm/model.hh	/^    float UnRest(const uint64_t *pointers_begin, const uint64_t *pointers_end, unsigned char first_length) const {$/;"	f	class:lm::ngram::detail::GenericModel
UncheckedInsert	kenlm/util/probing_hash_table.hh	/^    template <class T> MutableIterator UncheckedInsert(const T &t) {$/;"	f	class:util::ProbingHashTable
Uncompressed	kenlm/util/read_compressed.cc	/^    explicit Uncompressed(int fd) : fd_(fd) {}$/;"	f	class:util::__anon45::Uncompressed
Uncompressed	kenlm/util/read_compressed.cc	/^class Uncompressed : public ReadBase {$/;"	c	namespace:util::__anon45	file:
UncompressedWithHeader	kenlm/util/read_compressed.cc	/^    UncompressedWithHeader(int fd, const void *already_data, std::size_t already_size) : fd_(fd) {$/;"	f	class:util::__anon45::UncompressedWithHeader
UncompressedWithHeader	kenlm/util/read_compressed.cc	/^class UncompressedWithHeader : public ReadBase {$/;"	c	namespace:util::__anon45	file:
UnhandledException	kenlm/util/stream/chain.cc	/^void Thread::UnhandledException(const std::exception &e) {$/;"	f	class:util::stream::Thread
Unigram	kenlm/lm/search_hashed.hh	/^        Unigram() {}$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Unigram	kenlm/lm/search_hashed.hh	/^        Unigram(void *start, uint64_t count) :$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Unigram	kenlm/lm/search_hashed.hh	/^    class Unigram {$/;"	c	class:lm::ngram::detail::HashedSearch
Unigram	kenlm/lm/search_trie.cc	/^    void Unigram(WordIndex \/*index*\/) {$/;"	f	class:lm::ngram::trie::__anon24::FindBlanks
Unigram	kenlm/lm/search_trie.cc	/^    void Unigram(WordIndex word) {$/;"	f	class:lm::ngram::trie::__anon24::WriteEntries
Unigram	kenlm/lm/search_trie.hh	/^    typedef ::lm::ngram::trie::Unigram Unigram;$/;"	t	class:lm::ngram::trie::TrieSearch
Unigram	kenlm/lm/trie.hh	/^    Unigram() {}$/;"	f	class:lm::ngram::trie::Unigram
Unigram	kenlm/lm/trie.hh	/^class Unigram {$/;"	c	namespace:lm::ngram::trie
UnigramLMIdMapper	HLVLM.c	/^static LMId UnigramLMIdMapper(FSLM_ngram *nglm, char *w)$/;"	f	file:
UnigramPointer	kenlm/lm/search_hashed.hh	/^    typedef typename Value::ProbingProxy UnigramPointer;$/;"	t	class:lm::ngram::detail::HashedSearch
UnigramPointer	kenlm/lm/search_trie.hh	/^    typedef ::lm::ngram::trie::UnigramPointer UnigramPointer;$/;"	t	class:lm::ngram::trie::TrieSearch
UnigramPointer	kenlm/lm/trie.hh	/^    UnigramPointer() : to_(NULL) {}$/;"	f	class:lm::ngram::trie::UnigramPointer
UnigramPointer	kenlm/lm/trie.hh	/^    explicit UnigramPointer(const ProbBackoff &to) : to_(&to) {}$/;"	f	class:lm::ngram::trie::UnigramPointer
UnigramPointer	kenlm/lm/trie.hh	/^class UnigramPointer {$/;"	c	namespace:lm::ngram::trie
UnigramProb	kenlm/lm/search_trie.cc	/^    float UnigramProb(WordIndex index) const { return unigrams_[index].weights.prob; }$/;"	f	class:lm::ngram::trie::__anon24::WriteEntries
UnigramProb	kenlm/lm/search_trie.cc	/^    float UnigramProb(WordIndex index) const {$/;"	f	class:lm::ngram::trie::__anon24::FindBlanks
UnigramValue	kenlm/lm/trie.hh	/^struct UnigramValue {$/;"	s	namespace:lm::ngram::trie
Uninterpolated	kenlm/lm/builder/ngram.hh	/^struct Uninterpolated {$/;"	s	namespace:lm::builder
Union	kenlm/lm/filter/phrase.hh	/^    explicit Union(const Substrings &substrings) : detail::ConditionCommon(substrings) {}$/;"	f	class:lm::phrase::Union
Union	kenlm/lm/filter/phrase.hh	/^class Union : public detail::ConditionCommon {$/;"	c	namespace:lm::phrase
Union	kenlm/lm/filter/vocab.hh	/^    explicit Union(const Words &vocabs) : vocabs_(vocabs) {}$/;"	f	class:lm::vocab::Union
Union	kenlm/lm/filter/vocab.hh	/^class Union {$/;"	c	namespace:lm::vocab
UnkCountChangePadding	kenlm/lm/vocab.hh	/^    std::size_t UnkCountChangePadding() const { return 0; }$/;"	f	class:lm::ngram::ProbingVocabulary
UnkCountChangePadding	kenlm/lm/vocab.hh	/^    std::size_t UnkCountChangePadding() const { return SawUnk() ? 0 : sizeof(uint64_t); }$/;"	f	class:lm::ngram::SortedVocabulary
Unknown	kenlm/lm/search_hashed.hh	/^        typename Value::Weights &Unknown() { return unigram_[0]; }$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Unknown	kenlm/lm/trie.hh	/^    ProbBackoff &Unknown() { return unigram_[0].weights; }$/;"	f	class:lm::ngram::trie::Unigram
UnknownUnigram	kenlm/lm/search_hashed.hh	/^    typename Value::Weights &UnknownUnigram() { return unigram_.Unknown(); }$/;"	f	class:lm::ngram::detail::HashedSearch
UnknownUnigram	kenlm/lm/search_trie.hh	/^    ProbBackoff &UnknownUnigram() { return unigram_.Unknown(); }$/;"	f	class:lm::ngram::trie::TrieSearch
UnmapOrThrow	kenlm/util/mmap.cc	/^void UnmapOrThrow(void *start, size_t length) {$/;"	f	namespace:util
Unmark	kenlm/lm/builder/ngram.hh	/^    void Unmark() {$/;"	f	class:lm::builder::NGram
UnmarkedCount	kenlm/lm/builder/ngram.hh	/^    uint64_t UnmarkedCount() const {$/;"	f	class:lm::builder::NGram
Unpack	kenlm/lm/search_hashed.hh	/^    MiddlePointer Unpack(uint64_t extend_pointer, unsigned char extend_length, Node &node) const {$/;"	f	class:lm::ngram::detail::HashedSearch
Unpack	kenlm/lm/search_trie.hh	/^    MiddlePointer Unpack(uint64_t extend_pointer, unsigned char extend_length, Node &node) const {$/;"	f	class:lm::ngram::trie::TrieSearch
UnsafeMutableFind	kenlm/util/probing_hash_table.hh	/^    template <class Key> bool UnsafeMutableFind(const Key key, MutableIterator &out) {$/;"	f	class:util::AutoProbing
UnsafeMutableFind	kenlm/util/probing_hash_table.hh	/^    template <class Key> bool UnsafeMutableFind(const Key key, MutableIterator &out) {$/;"	f	class:util::ProbingHashTable
UnsafeMutableMustFind	kenlm/util/probing_hash_table.hh	/^    template <class Key> MutableIterator UnsafeMutableMustFind(const Key key) {$/;"	f	class:util::AutoProbing
UnsafeMutableMustFind	kenlm/util/probing_hash_table.hh	/^    template <class Key> MutableIterator UnsafeMutableMustFind(const Key key) {$/;"	f	class:util::ProbingHashTable
UnsetSign	kenlm/util/bit_packing.hh	/^inline void UnsetSign(float &to) {$/;"	f	namespace:util
UpdateConfigFromBinary	kenlm/lm/bhiksha.cc	/^void ArrayBhiksha::UpdateConfigFromBinary(const BinaryFormat &file, uint64_t offset, Config &config) {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
UpdateConfigFromBinary	kenlm/lm/bhiksha.hh	/^    static void UpdateConfigFromBinary(const BinaryFormat &, uint64_t, Config &\/*config*\/) {}$/;"	f	class:lm::ngram::trie::DontBhiksha
UpdateConfigFromBinary	kenlm/lm/quantize.cc	/^void SeparatelyQuantize::UpdateConfigFromBinary(const BinaryFormat &file, uint64_t offset, Config &config) {$/;"	f	class:lm::ngram::SeparatelyQuantize
UpdateConfigFromBinary	kenlm/lm/quantize.hh	/^    static void UpdateConfigFromBinary(const BinaryFormat &, uint64_t, Config &) {}$/;"	f	class:lm::ngram::DontQuantize
UpdateConfigFromBinary	kenlm/lm/search_hashed.hh	/^    static void UpdateConfigFromBinary(const BinaryFormat &, const std::vector<uint64_t> &, uint64_t, Config &) {}$/;"	f	class:lm::ngram::detail::HashedSearch
UpdateConfigFromBinary	kenlm/lm/search_trie.hh	/^    static void UpdateConfigFromBinary(const BinaryFormat &file, const std::vector<uint64_t> &counts, uint64_t offset, Config &config) {$/;"	f	class:lm::ngram::trie::TrieSearch
UpdateCopyFrom	kenlm/lm/builder/adjust_counts.cc	/^    void UpdateCopyFrom() {$/;"	f	class:lm::builder::__anon8::CollapseStream	file:
UpdateLMlookahead	HLVRec-LM.c	/^static void UpdateLMlookahead(DecoderInst *dec, LexNode *ln)$/;"	f	file:
UpdateModPaths	HLVRec-propagate.c	/^void UpdateModPaths (DecoderInst *dec, TokenSet *ts, LexNode *ln)$/;"	f
UpdateSpkrModels	HDecode.c	/^Boolean UpdateSpkrModels (char *fn)$/;"	f
UpdateSpkrModels	HDecode.mod.c	/^Boolean UpdateSpkrModels (char *fn)$/;"	f
UpdateWordEndHyp	HLVRec-propagate.c	/^static void UpdateWordEndHyp (DecoderInst *dec, LexNodeInst *inst)$/;"	f	file:
UpperBoundary	kenlm/util/double-conversion/ieee.h	/^  DiyFp UpperBoundary() const {$/;"	f	class:double_conversion::Double
UpperBoundary	kenlm/util/double-conversion/ieee.h	/^  DiyFp UpperBoundary() const {$/;"	f	class:double_conversion::Single
ValidEnd	kenlm/util/stream/block.hh	/^    const void *ValidEnd() const { $/;"	f	class:util::stream::Block
ValidSize	kenlm/util/stream/block.hh	/^    std::size_t ValidSize() const { return valid_size_; }$/;"	f	class:util::stream::Block
Value	kenlm/lm/builder/ngram.hh	/^    Payload &Value() { return *reinterpret_cast<Payload *>(end_); }$/;"	f	class:lm::builder::NGram
Value	kenlm/lm/builder/ngram.hh	/^    const Payload &Value() const { return *reinterpret_cast<const Payload *>(end_); }$/;"	f	class:lm::builder::NGram
Value	kenlm/lm/search_hashed.hh	/^  typedef Prob Value;$/;"	t	struct:lm::ngram::detail::ProbEntry
Value	kenlm/lm/value.hh	/^    typedef Weights Value;$/;"	t	struct:lm::ngram::BackoffValue::ProbingEntry
Value	kenlm/lm/value.hh	/^    typedef Weights Value;$/;"	t	struct:lm::ngram::RestValue::ProbingEntry
Value	kenlm/lm/value_build.hh	/^    typedef BackoffValue Value;$/;"	t	class:lm::ngram::NoRestBuild
Value	kenlm/lm/value_build.hh	/^    typedef RestValue Value;$/;"	t	class:lm::ngram::LowerRestBuild
Value	kenlm/lm/value_build.hh	/^    typedef RestValue Value;$/;"	t	class:lm::ngram::MaxRestBuild
Values	kenlm/lm/search_trie.cc	/^    const std::vector<float> &Values(unsigned char order) const {$/;"	f	class:lm::ngram::trie::__anon24::SRISucks
Vector	kenlm/util/double-conversion/utils.h	/^  Vector() : start_(NULL), length_(0) {}$/;"	f	class:double_conversion::Vector
Vector	kenlm/util/double-conversion/utils.h	/^  Vector(T* data, int length) : start_(data), length_(length) {$/;"	f	class:double_conversion::Vector
Vector	kenlm/util/double-conversion/utils.h	/^class Vector {$/;"	c	namespace:double_conversion
Vectors	kenlm/lm/neural/wordvecs.hh	/^    const Storage &Vectors() const { return vecs_; }$/;"	f	class:lm::neural::WordVecs
Vertex	kenlm/lm/filter/phrase.cc	/^    Vertex() : current_(0) {}$/;"	f	class:lm::phrase::detail::Vertex
Vertex	kenlm/lm/filter/phrase.cc	/^class Vertex {$/;"	c	namespace:lm::phrase::detail	file:
Visit	kenlm/lm/search_trie.cc	/^    void Visit(const WordIndex *to, unsigned char length, float prob) {$/;"	f	class:lm::ngram::trie::__anon24::BlankManager
VocabEntry	kenlm/lm/builder/corpus_count.cc	/^struct VocabEntry {$/;"	s	namespace:lm::builder::__anon9	file:
VocabLoadException	kenlm/lm/lm_exception.cc	/^VocabLoadException::VocabLoadException() throw() {}$/;"	f	class:lm::VocabLoadException
VocabLoadException	kenlm/lm/lm_exception.hh	/^class VocabLoadException : public LoadException {$/;"	c	namespace:lm
VocabReconstitute	kenlm/lm/builder/print.cc	/^VocabReconstitute::VocabReconstitute(int fd) {$/;"	f	class:lm::builder::VocabReconstitute
VocabReconstitute	kenlm/lm/builder/print.hh	/^class VocabReconstitute {$/;"	c	namespace:lm::builder
VocabStringReadingOffset	kenlm/lm/binary_format.hh	/^    uint64_t VocabStringReadingOffset() const {$/;"	f	class:lm::ngram::BinaryFormat
VocabUsage	kenlm/lm/builder/corpus_count.cc	/^std::size_t CorpusCount::VocabUsage(std::size_t vocab_estimate) {$/;"	f	class:lm::builder::CorpusCount
Vocabulary	kenlm/lm/facade.hh	/^    typedef VocabularyT Vocabulary;$/;"	t	class:lm::base::ModelFacade
Vocabulary	kenlm/lm/model.hh	/^typedef ::lm::ngram::ProbingVocabulary Vocabulary;$/;"	t	namespace:lm::ngram
Vocabulary	kenlm/lm/virtual_interface.hh	/^    Vocabulary() {}$/;"	f	class:lm::base::Vocabulary
Vocabulary	kenlm/lm/virtual_interface.hh	/^    Vocabulary(WordIndex begin_sentence, WordIndex end_sentence, WordIndex not_found) {$/;"	f	class:lm::base::Vocabulary
Vocabulary	kenlm/lm/virtual_interface.hh	/^class Vocabulary {$/;"	c	namespace:lm::base
Vocabulary	kenlm/lm/wrappers/nplm.cc	/^Vocabulary::Vocabulary(const nplm::vocabulary &vocab) $/;"	f	class:lm::np::Vocabulary
Vocabulary	kenlm/lm/wrappers/nplm.hh	/^class Vocabulary : public base::Vocabulary {$/;"	c	namespace:lm::np
WIN32_LEAN_AND_MEAN	kenlm/util/usage.cc	17;"	d	file:
WINBOOL	kenlm/util/usage.cc	/^typedef int WINBOOL;$/;"	t	file:
WRITE_AFTER	kenlm/lm/config.hh	/^    WRITE_AFTER \/\/ Write after we're done.$/;"	e	enum:lm::ngram::Config::WriteMethod
WRITE_MMAP	kenlm/lm/config.hh	/^    WRITE_MMAP, \/\/ Map the file directly.$/;"	e	enum:lm::ngram::Config::WriteMethod
Wait	kenlm/util/stream/chain.cc	/^void Chain::Wait(bool release_memory) {$/;"	f	class:util::stream::Chain
Wait	kenlm/util/stream/multi_stream.hh	/^    void Wait(bool release_memory = true) {$/;"	f	class:util::stream::Chains
WaitSemaphore	kenlm/util/pcqueue.hh	/^inline void WaitSemaphore(Semaphore &semaphore) {$/;"	f	namespace:util
Wall	kenlm/util/usage.cc	/^typedef struct timeval Wall;$/;"	t	namespace:util::__anon49	typeref:struct:util::__anon49::timeval	file:
WallTime	kenlm/util/usage.cc	/^double WallTime() {$/;"	f	namespace:util
Warn	kenlm/lm/read_arpa.cc	/^void PositiveProbWarn::Warn(float prob) {$/;"	f	class:lm::PositiveProbWarn
WarningAction	kenlm/lm/lm_exception.hh	/^typedef enum {THROW_UP, COMPLAIN, SILENT} WarningAction;$/;"	t	namespace:lm	typeref:enum:lm::__anon17
Weights	kenlm/lm/value.hh	/^  typedef ProbBackoff Weights;$/;"	t	struct:lm::ngram::BackoffValue
Weights	kenlm/lm/value.hh	/^  typedef RestWeights Weights;$/;"	t	struct:lm::ngram::RestValue
Word	kenlm/lm/ngram_query.hh	/^  void Word(StringPiece surface, WordIndex vocab, const FullScoreReturn &ret) const {$/;"	f	struct:lm::ngram::FullPrint
Word	kenlm/lm/ngram_query.hh	/^  void Word(StringPiece, WordIndex, const FullScoreReturn &) const {}$/;"	f	struct:lm::ngram::BasicPrint
WordIndex	kenlm/lm/word_index.hh	/^typedef unsigned int WordIndex;$/;"	t	namespace:lm
WordVecs	kenlm/lm/neural/wordvecs.cc	/^WordVecs::WordVecs(util::FilePiece &f) {$/;"	f	class:lm::neural::WordVecs
WordVecs	kenlm/lm/neural/wordvecs.hh	/^class WordVecs {$/;"	c	namespace:lm::neural
WordendHyp	HLVRec.h	/^typedef struct _WordendHyp WordendHyp;      \/* records word level tracback *\/$/;"	t	typeref:struct:_WordendHyp
Words	kenlm/lm/filter/vocab.hh	/^    typedef boost::unordered_map<std::string, std::vector<unsigned int> > Words;$/;"	t	class:lm::vocab::Multiple
Words	kenlm/lm/filter/vocab.hh	/^    typedef boost::unordered_map<std::string, std::vector<unsigned int> > Words;$/;"	t	class:lm::vocab::Union
Words	kenlm/lm/filter/vocab.hh	/^    typedef boost::unordered_set<std::string> Words;$/;"	t	class:lm::vocab::Single
Worker	kenlm/util/thread_pool.hh	/^    template <class Construct> Worker(PCQueue<Request> &in, Construct &construct, const Request &poison)$/;"	f	class:util::Worker
Worker	kenlm/util/thread_pool.hh	/^template <class HandlerT> class Worker : boost::noncopyable {$/;"	c	namespace:util
WorkerProgress	kenlm/util/stream/multi_progress.hh	/^    WorkerProgress() : parent_(NULL) {}$/;"	f	class:util::stream::WorkerProgress
WorkerProgress	kenlm/util/stream/multi_progress.hh	/^    WorkerProgress(uint64_t next, MultiProgress &parent, char character) $/;"	f	class:util::stream::WorkerProgress
WorkerProgress	kenlm/util/stream/multi_progress.hh	/^class WorkerProgress {$/;"	c	namespace:util::stream
Write	kenlm/lm/quantize.hh	/^        void Write(float prob) const {$/;"	f	class:lm::ngram::SeparatelyQuantize::LongestPointer
Write	kenlm/lm/quantize.hh	/^        void Write(float prob) {$/;"	f	class:lm::ngram::DontQuantize::LongestPointer
Write	kenlm/lm/quantize.hh	/^        void Write(float prob, float backoff) const {$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
Write	kenlm/lm/quantize.hh	/^        void Write(float prob, float backoff) {$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
Write	kenlm/util/stream/io.hh	/^    explicit Write(int fd) : file_(fd) {}$/;"	f	class:util::stream::Write
Write	kenlm/util/stream/io.hh	/^class Write {$/;"	c	namespace:util::stream
WriteAndRecycle	kenlm/util/stream/io.hh	/^    explicit WriteAndRecycle(int fd) : file_(fd) {}$/;"	f	class:util::stream::WriteAndRecycle
WriteAndRecycle	kenlm/util/stream/io.hh	/^class WriteAndRecycle {$/;"	c	namespace:util::stream
WriteContextFile	kenlm/lm/trie_sort.cc	/^FILE *WriteContextFile(uint8_t *begin, uint8_t *end, const std::string &temp_prefix, std::size_t entry_size, unsigned char order) {$/;"	f	namespace:lm::ngram::trie::__anon26
WriteCounts	kenlm/lm/filter/arpa_io.cc	/^void WriteCounts(std::ostream &out, const std::vector<uint64_t> &number) {$/;"	f	namespace:lm
WriteEntries	kenlm/lm/search_trie.cc	/^    WriteEntries(RecordReader *contexts, const Quant &quant, UnigramValue *unigrams, BitPackedMiddle<Bhiksha> *middle, BitPackedLongest &longest, unsigned char order, SRISucks &sri) :$/;"	f	class:lm::ngram::trie::__anon24::WriteEntries
WriteEntries	kenlm/lm/search_trie.cc	/^template <class Quant, class Bhiksha> class WriteEntries {$/;"	c	namespace:lm::ngram::trie::__anon24	file:
WriteFloat32	kenlm/util/bit_packing.hh	/^inline void WriteFloat32(void *base, uint64_t bit_off, float value) {$/;"	f	namespace:util
WriteHeader	kenlm/lm/binary_format.cc	/^void WriteHeader(void *to, const Parameters &params) {$/;"	f	namespace:lm::ngram::__anon7
WriteInt25	kenlm/util/bit_packing.hh	/^inline void WriteInt25(void *base, uint64_t bit_off, uint8_t length, uint32_t value) {$/;"	f	namespace:util
WriteInt57	kenlm/util/bit_packing.hh	/^inline void WriteInt57(void *base, uint64_t bit_off, uint8_t length, uint64_t value) {$/;"	f	namespace:util
WriteMethod	kenlm/lm/config.hh	/^  enum WriteMethod {$/;"	g	struct:lm::ngram::Config
WriteNext	kenlm/lm/bhiksha.hh	/^    void WriteNext(void *base, uint64_t bit_offset, uint64_t \/*index*\/, uint64_t value) {$/;"	f	class:lm::ngram::trie::DontBhiksha
WriteNext	kenlm/lm/bhiksha.hh	/^    void WriteNext(void *base, uint64_t bit_offset, uint64_t index, uint64_t value) {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
WriteNonPositiveFloat31	kenlm/util/bit_packing.hh	/^inline void WriteNonPositiveFloat31(void *base, uint64_t bit_off, float value) {$/;"	f	namespace:util
WriteOrThrow	kenlm/util/file.cc	/^void WriteOrThrow(FILE *to, const void *data, std::size_t size) {$/;"	f	namespace:util
WriteOrThrow	kenlm/util/file.cc	/^void WriteOrThrow(int fd, const void *data_void, std::size_t size) {$/;"	f	namespace:util
WriteTLex	HLVNet.c	/^void WriteTLex (TLexNet *net, char *fn)$/;"	f
WriteUniqueWords	kenlm/lm/vocab.hh	/^    explicit WriteUniqueWords(int fd) : word_list_(fd) {}$/;"	f	class:lm::ngram::WriteUniqueWords
WriteUniqueWords	kenlm/lm/vocab.hh	/^class WriteUniqueWords {$/;"	c	namespace:lm::ngram
WriteVocabWords	kenlm/lm/binary_format.cc	/^void BinaryFormat::WriteVocabWords(const std::string &buffer, void *&vocab_base, void *&search_base) {$/;"	f	class:lm::ngram::BinaryFormat
WriteWordsWrapper	kenlm/lm/vocab.cc	/^WriteWordsWrapper::WriteWordsWrapper(EnumerateVocab *inner) : inner_(inner) {}$/;"	f	class:lm::ngram::WriteWordsWrapper
WriteWordsWrapper	kenlm/lm/vocab.hh	/^class WriteWordsWrapper : public EnumerateVocab {$/;"	c	namespace:lm::ngram
Writer	kenlm/lm/builder/corpus_count.cc	/^    Writer(std::size_t order, const util::stream::ChainPosition &position, void *dedupe_mem, std::size_t dedupe_mem_size) $/;"	f	class:lm::builder::__anon9::Writer
Writer	kenlm/lm/builder/corpus_count.cc	/^class Writer {$/;"	c	namespace:lm::builder::__anon9	file:
XZException	kenlm/util/read_compressed.cc	/^XZException::XZException() throw() {}$/;"	f	class:util::XZException
XZException	kenlm/util/read_compressed.hh	/^class XZException : public CompressedException {$/;"	c	namespace:util
XZip	kenlm/util/read_compressed.cc	/^    XZip(const void *base, std::size_t amount)$/;"	f	class:util::__anon45::XZip
XZip	kenlm/util/read_compressed.cc	/^class XZip {$/;"	c	namespace:util::__anon45	file:
Zero	kenlm/util/double-conversion/bignum.cc	/^void Bignum::Zero() {$/;"	f	class:double_conversion::Bignum
ZeroRemaining	kenlm/lm/state.hh	/^    void ZeroRemaining() {$/;"	f	class:lm::ngram::State
ZeroRemaining	kenlm/lm/state.hh	/^  void ZeroRemaining() {$/;"	f	struct:lm::ngram::ChartState
ZeroRemaining	kenlm/lm/state.hh	/^  void ZeroRemaining() {$/;"	f	struct:lm::ngram::Left
_AltWordendHyp	HLVRec.h	/^struct _AltWordendHyp {         \/* stores info about N-best word(end) for lattice traceback *\/$/;"	s
_BestInfo	HDecode.c	/^struct _BestInfo {$/;"	s	file:
_BestInfo	HDecode.mod.c	/^struct _BestInfo {$/;"	s	file:
_CompLMlaNode	HLVNet.h	/^typedef struct _CompLMlaNode {$/;"	s
_DecoderInst	HLVRec.h	/^struct _DecoderInst {$/;"	s
_FILE_OFFSET_BITS	kenlm/util/file.cc	2;"	d	file:
_FSLM	HLVLM.h	/^struct _FSLM {$/;"	s
_FSLM_LatArc	HLVLM.h	/^typedef struct _FSLM_LatArc {$/;"	s
_FSLM_LatNode	HLVLM.h	/^struct _FSLM_LatNode {$/;"	s
_FSLM_latlm	HLVLM.h	/^struct _FSLM_latlm {$/;"	s
_FSLM_ngram	HLVLM.h	/^struct _FSLM_ngram {$/;"	s
_HLVLM_H_	HLVLM.h	32;"	d
_HLVMODEL_H_	HLVModel.h	31;"	d
_HLVNET_H_	HLVNet.h	51;"	d
_HLVREC_H_	HLVRec.h	38;"	d
_LARGEFILE64_SOURCE	kenlm/util/file.cc	1;"	d	file:
_LMCache	HLVRec.h	/^struct _LMCache {$/;"	s
_LMCacheLA	HLVRec.h	/^struct _LMCacheLA {$/;"	s
_LMLACacheEntry	HLVRec.h	/^struct _LMLACacheEntry {$/;"	s
_LMNodeCache	HLVRec.h	/^struct _LMNodeCache {$/;"	s
_LMlaNode	HLVNet.h	/^typedef struct _LMlaNode {$/;"	s
_LMlaTree	HLVNet.h	/^struct _LMlaTree {$/;"	s
_LayerId	HLVNet.h	/^typedef enum _LayerId {$/;"	g
_LayerStats	HLVRec-misc.c	/^struct _LayerStats {$/;"	s	file:
_LexLink	HLVNet.h	/^struct _LexLink {$/;"	s
_LexNet	HLVNet.h	/^typedef struct _LexNet {$/;"	s
_LexNode	HLVNet.h	/^struct _LexNode {$/;"	s
_LexNodeInst	HLVRec.h	/^struct _LexNodeInst {           \/* attached to active LexNode's, contains info about tokens *\/$/;"	s
_LexNodeType	HLVNet.h	/^typedef enum _LexNodeType {$/;"	g
_ModendHyp	HLVRec.h	/^struct _ModendHyp {             \/* stores info about one model(end) *\/$/;"	s
_OutPCache	HLVRec.h	/^struct _OutPCache {$/;"	s
_RelToken	HLVRec.h	/^struct _RelToken {$/;"	s
_STLexLink	HLVNet.c	/^struct _STLexLink {$/;"	s	file:
_STLexNode	HLVNet.c	/^struct _STLexNode {$/;"	s	file:
_STLexNodeType	HLVNet.c	/^typedef enum _STLexNodeType {$/;"	g	file:
_StateInfo_lv	HLVModel.h	/^struct _StateInfo_lv {$/;"	s
_Stats	HLVRec.h	/^struct _Stats {$/;"	s
_TLexLink	HLVNet.h	/^struct _TLexLink {$/;"	s
_TLexNet	HLVNet.h	/^typedef struct _TLexNet {$/;"	s
_TLexNode	HLVNet.h	/^struct _TLexNode {$/;"	s
_Token	HLVRec.h	/^struct _Token {$/;"	s
_TokenSet	HLVRec.h	/^struct _TokenSet {$/;"	s
_WordendHyp	HLVRec.h	/^struct _WordendHyp {            \/* stores info about one word(end) *\/$/;"	s
acScale	HDecode.c	/^static float acScale = 1.0;     \/* acoustic scaling factor *\/$/;"	v	file:
acScale	HDecode.mod.c	/^static float acScale = 1.0;     \/* acoustic scaling factor *\/$/;"	v	file:
acScale	HLVRec.h	/^   float acScale;               \/* acoustic scaling factor *\/$/;"	m	struct:_DecoderInst
action_	kenlm/lm/read_arpa.hh	/^    WarningAction action_;$/;"	m	class:lm::PositiveProbWarn
action_	kenlm/util/read_compressed.cc	/^    lzma_action action_;$/;"	m	class:util::__anon45::XZip	file:
active_	kenlm/util/stream/multi_progress.hh	/^    bool active_;$/;"	m	class:util::stream::MultiProgress
actual_	kenlm/lm/filter/format.hh	/^    size_t actual_;$/;"	m	class:lm::InputBuffer
actual_base_	kenlm/lm/quantize.hh	/^    uint8_t *actual_base_;$/;"	m	class:lm::ngram::SeparatelyQuantize
adder_in	kenlm/lm/builder/initial_probabilities.hh	/^  util::stream::ChainConfig adder_in;$/;"	m	struct:lm::builder::InitialProbabilitiesConfig
adder_out	kenlm/lm/builder/initial_probabilities.hh	/^  util::stream::ChainConfig adder_out;$/;"	m	struct:lm::builder::InitialProbabilitiesConfig
address_	kenlm/lm/quantize.hh	/^        util::BitAddress address_;$/;"	m	class:lm::ngram::DontQuantize::LongestPointer
address_	kenlm/lm/quantize.hh	/^        util::BitAddress address_;$/;"	m	class:lm::ngram::DontQuantize::MiddlePointer
address_	kenlm/lm/quantize.hh	/^        util::BitAddress address_;$/;"	m	class:lm::ngram::SeparatelyQuantize::LongestPointer
address_	kenlm/lm/quantize.hh	/^        util::BitAddress address_;$/;"	m	class:lm::ngram::SeparatelyQuantize::MiddlePointer
adjust	kenlm/lm/partial.hh	/^  float adjust;$/;"	m	struct:lm::ngram::ExtendReturn
after_	kenlm/util/tokenize_piece.hh	/^    StringPiece after_;$/;"	m	class:util::TokenIter
allocated_	kenlm/lm/search_trie.cc	/^    uint8_t *current_, *allocated_;$/;"	m	class:lm::ngram::trie::__anon24::BackoffMessages	file:
allocated_	kenlm/util/probing_hash_table.hh	/^    std::size_t allocated_;$/;"	m	class:util::AutoProbing
allocated_end_	kenlm/util/fixed_array.hh	/^    T *allocated_end_;$/;"	m	class:util::FixedArray
alt	HLVRec.h	/^   AltWordendHyp *alt;          \/* alternative paths for lattice traceback *\/$/;"	m	struct:_WordendHyp
altweHypHeap	HLVRec.h	/^   MemHeap altweHypHeap;        \/* MHEAP for alt word end hyps (for latgen) *\/$/;"	m	struct:_DecoderInst
amount	kenlm/lm/builder/discount.hh	/^  float amount[4];$/;"	m	struct:lm::builder::Discount
annotated_	kenlm/lm/filter/format.hh	/^    std::vector<Annotated> annotated_;$/;"	m	class:lm::MultipleOutputBuffer
arcs_	kenlm/lm/filter/phrase.hh	/^    std::vector<detail::Arc> arcs_;$/;"	m	class:lm::phrase::detail::ConditionCommon
arpa_complain	kenlm/lm/config.hh	/^  ARPALoadComplain arpa_complain;$/;"	m	struct:lm::ngram::Config
array	kenlm/lm/search_trie.cc	/^  unsigned char array;$/;"	m	struct:lm::ngram::trie::__anon24::ProbPointer	file:
as_string	kenlm/util/string_piece.hh	/^  std::string as_string() const {$/;"	f	class:StringPiece
at_end_	kenlm/util/file_piece.hh	/^    bool at_end_;$/;"	m	class:util::FilePiece
attention_size_	kenlm/lm/trie_sort.cc	/^    const std::size_t attention_size_;$/;"	m	class:lm::ngram::trie::__anon26::PartialViewProxy	file:
back	kenlm/util/fixed_array.hh	/^    T &back() { return *(end() - 1); }$/;"	f	class:util::FixedArray
back	kenlm/util/fixed_array.hh	/^    const T &back() const { return *(end() - 1); }$/;"	f	class:util::FixedArray
back_	kenlm/util/pcqueue.hh	/^    semaphore_t back_;$/;"	m	class:util::Semaphore
back_	kenlm/util/read_compressed.cc	/^    Compression back_;$/;"	m	class:util::__anon45::StreamCompressed	file:
backend_	kenlm/lm/filter/wrapper.hh	/^    Filter backend_;$/;"	m	class:lm::ContextFilter
backend_	kenlm/lm/wrappers/nplm.hh	/^    mutable boost::thread_specific_ptr<nplm::neuralLM> backend_;$/;"	m	class:lm::np::Model
backend_	kenlm/util/probing_hash_table.hh	/^    Backend backend_;$/;"	m	class:util::AutoProbing
backing_	kenlm/lm/model.hh	/^    BinaryFormat backing_;$/;"	m	class:lm::ngram::detail::GenericModel
backing_	kenlm/lm/search_trie.cc	/^    util::scoped_malloc backing_;$/;"	m	class:lm::ngram::trie::__anon24::BackoffMessages	file:
backoff	kenlm/lm/state.hh	/^    float backoff[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::State
backoff	kenlm/lm/weights.hh	/^  float backoff;$/;"	m	struct:lm::ProbBackoff
backoff	kenlm/lm/weights.hh	/^  float backoff;$/;"	m	struct:lm::RestWeights
backoff_bits	kenlm/lm/config.hh	/^  uint8_t prob_bits, backoff_bits;$/;"	m	struct:lm::ngram::Config
backoff_bits_	kenlm/lm/quantize.hh	/^    uint8_t prob_bits_, backoff_bits_;$/;"	m	class:lm::ngram::SeparatelyQuantize
backoffs_	kenlm/lm/builder/interpolate.cc	/^    util::FixedArray<util::stream::Stream> backoffs_;$/;"	m	class:lm::builder::__anon12::Callback	file:
backoffs_	kenlm/lm/builder/interpolate.hh	/^    util::stream::ChainPositions backoffs_;$/;"	m	class:lm::builder::Interpolate
bad_action	kenlm/lm/builder/adjust_counts.hh	/^  WarningAction bad_action;$/;"	m	struct:lm::builder::DiscountConfig
base	HLVModel.h	/^   float *base;$/;"	m	struct:_StateInfo_lv
base	kenlm/lm/facade.hh	/^namespace base {$/;"	n	namespace:lm
base	kenlm/lm/virtual_interface.cc	/^namespace base {$/;"	n	namespace:lm	file:
base	kenlm/lm/virtual_interface.hh	/^namespace base {$/;"	n	namespace:lm
base	kenlm/util/bit_packing.hh	/^  void *base;$/;"	m	struct:util::BitAddress
base_	kenlm/lm/trie.cc	/^    const uint8_t *const base_;$/;"	m	class:lm::ngram::trie::__anon25::KeyAccessor	file:
base_	kenlm/lm/trie.hh	/^    uint8_t *base_;$/;"	m	class:lm::ngram::trie::BitPacked
base_instance_	kenlm/lm/wrappers/nplm.hh	/^    boost::scoped_ptr<nplm::neuralLM> base_instance_;$/;"	m	class:lm::np::Model
base_sequence_	kenlm/lm/filter/thread.hh	/^    uint64_t base_sequence_;$/;"	m	class:lm::OutputWorker
base_vocab_	kenlm/lm/virtual_interface.hh	/^    const Vocabulary *base_vocab_;$/;"	m	class:lm::base::Model
basis_	kenlm/lm/search_trie.cc	/^    float basis_[KENLM_MAX_ORDER];$/;"	m	class:lm::ngram::trie::__anon24::BlankManager	file:
batch_size_	kenlm/lm/filter/thread.hh	/^    const size_t batch_size_;$/;"	m	class:lm::Controller
batches_	kenlm/lm/filter/thread.hh	/^    std::vector<Batch> batches_;$/;"	m	class:lm::Controller
beamLimit	HLVRec.h	/^   TokScore beamLimit;          \/* threshold of the main beam (bestScore - beamWidth) *\/$/;"	m	struct:_DecoderInst
beamWidth	HDecode.c	/^static LogFloat beamWidth = - LZERO;     \/* pruning global beam width *\/$/;"	v	file:
beamWidth	HDecode.mod.c	/^static LogFloat beamWidth = - LZERO;     \/* pruning global beam width *\/$/;"	v	file:
beamWidth	HLVRec.h	/^   TokScore beamWidth;          \/* max beamWidth main beam (set by -t cmd line option) *\/$/;"	m	struct:_DecoderInst
been_	kenlm/lm/search_trie.cc	/^    WordIndex been_[KENLM_MAX_ORDER];$/;"	m	class:lm::ngram::trie::__anon24::BlankManager	file:
been_length_	kenlm/lm/search_trie.cc	/^    unsigned char been_length_;$/;"	m	class:lm::ngram::trie::__anon24::BlankManager	file:
begin	kenlm/lm/builder/ngram.hh	/^    WordIndex *begin() { return begin_; }$/;"	f	class:lm::builder::NGram
begin	kenlm/lm/builder/ngram.hh	/^    const WordIndex *begin() const { return begin_; }$/;"	f	class:lm::builder::NGram
begin	kenlm/lm/search_trie.cc	/^  const WordIndex *begin, *end;$/;"	m	struct:lm::ngram::trie::__anon24::Gram	file:
begin	kenlm/lm/trie.hh	/^  uint64_t begin, end;$/;"	m	struct:lm::ngram::trie::NodeRange
begin	kenlm/util/fixed_array.hh	/^    T *begin() { return static_cast<T*>(block_.get()); }$/;"	f	class:util::FixedArray
begin	kenlm/util/fixed_array.hh	/^    const T *begin() const { return static_cast<const T*>(block_.get()); }$/;"	f	class:util::FixedArray
begin	kenlm/util/mmap.hh	/^    const char *begin() const { return reinterpret_cast<char*>(data_); }$/;"	f	class:util::scoped_memory
begin	kenlm/util/mmap.hh	/^    const uint8_t *begin() const { return reinterpret_cast<uint8_t*>(data_); }$/;"	f	class:util::scoped_mmap
begin	kenlm/util/string_piece.hh	/^  iterator begin() const { return ptr_; }$/;"	f	class:StringPiece
begin_	kenlm/lm/builder/ngram.hh	/^    WordIndex *begin_, *end_;$/;"	m	class:lm::builder::NGram
begin_	kenlm/lm/quantize.hh	/^        float *begin_;$/;"	m	class:lm::ngram::SeparatelyQuantize::Bins
begin_	kenlm/lm/vocab.hh	/^    uint64_t *begin_, *end_;$/;"	m	class:lm::ngram::SortedVocabulary
begin_	kenlm/util/probing_hash_table.hh	/^    MutableIterator begin_;$/;"	m	class:util::ProbingHashTable
begin_sentence_	kenlm/lm/facade.hh	/^    State begin_sentence_, null_context_;$/;"	m	class:lm::base::ModelFacade
begin_sentence_	kenlm/lm/virtual_interface.hh	/^    WordIndex begin_sentence_, end_sentence_, not_found_;$/;"	m	class:lm::base::Vocabulary
begin_sentence_memory_	kenlm/lm/virtual_interface.hh	/^    const void *begin_sentence_memory_, *null_context_memory_;$/;"	m	class:lm::base::Model
best	HLVRec.h	/^   TokScore best;               \/* score of best token in any HMM state and LM state,$/;"	m	struct:_LexNodeInst
bestAlignMLF	HDecode.c	/^static char *bestAlignMLF;      \/* MLF with 1-best alignment *\/$/;"	v	file:
bestAlignMLF	HDecode.mod.c	/^static char *bestAlignMLF;      \/* MLF with 1-best alignment *\/$/;"	v	file:
bestInst	HLVRec.h	/^   LexNodeInst *bestInst;       \/* instance containing best token *\/$/;"	m	struct:_DecoderInst
bestScore	HLVRec-misc.c	/^   TokScore bestScore;$/;"	m	struct:_LayerStats	file:
bestScore	HLVRec.h	/^   LogFloat bestScore;          \/* score of best token *\/$/;"	m	struct:_DecoderInst
bhiksha_	kenlm/lm/trie.hh	/^    Bhiksha bhiksha_;$/;"	m	class:lm::ngram::trie::BitPackedMiddle
bigits_	kenlm/util/double-conversion/bignum.h	/^  Vector<Chunk> bigits_;$/;"	m	class:double_conversion::Bignum
bigits_buffer_	kenlm/util/double-conversion/bignum.h	/^  Chunk bigits_buffer_[kBigitCapacity];$/;"	m	class:double_conversion::Bignum
bigram_pack_	kenlm/lm/search_trie.cc	/^    BitPacked &bigram_pack_;$/;"	m	class:lm::ngram::trie::__anon24::WriteEntries	file:
binary_	kenlm/lm/filter/wrapper.hh	/^    Binary binary_;$/;"	m	class:lm::BinaryFilter
binary_exponent	kenlm/util/double-conversion/cached-powers.cc	/^  int16_t binary_exponent;$/;"	m	struct:double_conversion::CachedPower	file:
bindir	Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bins_	kenlm/lm/quantize.hh	/^        const Bins *bins_;$/;"	m	class:lm::ngram::SeparatelyQuantize::MiddlePointer
bits	kenlm/util/bit_packing.hh	/^  uint8_t bits;$/;"	m	struct:util::BitsMask
bits_	kenlm/lm/quantize.hh	/^        uint8_t bits_;$/;"	m	class:lm::ngram::SeparatelyQuantize::Bins
block	HLVRec.h	/^   int block;$/;"	m	struct:_OutPCache
block_	kenlm/lm/builder/adjust_counts.cc	/^    util::stream::Link block_;$/;"	m	class:lm::builder::__anon8::CollapseStream	file:
block_	kenlm/lm/builder/corpus_count.cc	/^    util::stream::Link block_;$/;"	m	class:lm::builder::__anon9::Writer	file:
block_	kenlm/lm/builder/initial_probabilities.cc	/^    util::stream::Link block_;$/;"	m	class:lm::builder::__anon11::PruneNGramStream	file:
block_	kenlm/util/fixed_array.hh	/^    util::scoped_malloc block_;$/;"	m	class:util::FixedArray
block_	kenlm/util/mmap.hh	/^    std::size_t block_;$/;"	m	class:util::Rolling
block_count	kenlm/lm/builder/pipeline.hh	/^  std::size_t block_count;$/;"	m	struct:lm::builder::PipelineConfig
block_count	kenlm/util/stream/config.hh	/^  std::size_t block_count;$/;"	m	struct:util::stream::ChainConfig
block_count_	kenlm/util/stream/sort.hh	/^    uint64_t block_count_;$/;"	m	class:util::stream::Offsets
block_it_	kenlm/util/stream/stream.hh	/^    Link block_it_;$/;"	m	class:util::stream::Stream
block_size_	kenlm/lm/builder/corpus_count.cc	/^    const std::size_t block_size_;$/;"	m	class:lm::builder::__anon9::Writer	file:
block_size_	kenlm/util/stream/chain.hh	/^    std::size_t block_size_;$/;"	m	class:util::stream::Chain
block_size_	kenlm/util/stream/stream.hh	/^    std::size_t block_size_;$/;"	m	class:util::stream::Stream
bound	kenlm/lm/vocab.cc	/^  WordIndex bound;$/;"	m	struct:lm::ngram::detail::ProbingVocabularyHeader	file:
bound_	kenlm/lm/vocab.hh	/^    WordIndex bound_;$/;"	m	class:lm::ngram::ProbingVocabulary
bound_	kenlm/lm/vocab.hh	/^    WordIndex bound_;$/;"	m	class:lm::ngram::SortedVocabulary
bowt	HLVLM.h	/^   NGLM_Prob bowt;              \/* Back-off weight *\/$/;"	m	struct:nentry
buckets_	kenlm/util/probing_hash_table.hh	/^    std::size_t buckets_;$/;"	m	class:util::ProbingHashTable
buf_	kenlm/util/fake_ofstream.hh	/^    util::scoped_malloc buf_;$/;"	m	class:util::FakeOFStream
buf_	kenlm/util/read_compressed.cc	/^    scoped_malloc buf_;$/;"	m	class:util::__anon45::UncompressedWithHeader	file:
buffer_	kenlm/lm/builder/corpus_count.cc	/^    boost::scoped_array<WordIndex> buffer_;$/;"	m	class:lm::builder::__anon9::Writer	file:
buffer_	kenlm/lm/filter/arpa_io.hh	/^    boost::scoped_array<char> buffer_;$/;"	m	class:lm::ARPAOutput
buffer_	kenlm/lm/filter/count_io.hh	/^    std::vector<char> buffer_;$/;"	m	class:lm::CountBatch
buffer_	kenlm/lm/vocab.hh	/^    std::string buffer_;$/;"	m	class:lm::ngram::WriteWordsWrapper
buffer_	kenlm/util/double-conversion/utils.h	/^  Vector<char> buffer_;$/;"	m	class:double_conversion::StringBuilder
buffer_end_	kenlm/util/stream/sort.hh	/^        uint8_t *current_, *buffer_end_;$/;"	m	class:util::stream::MergeQueue::Entry
buffer_size	kenlm/util/stream/config.hh	/^  std::size_t buffer_size;$/;"	m	struct:util::stream::SortConfig
buffer_size_	kenlm/util/fake_ofstream.hh	/^    const std::size_t buffer_size_;$/;"	m	class:util::FakeOFStream
buffer_size_	kenlm/util/stream/sort.hh	/^    const std::size_t buffer_size_;$/;"	m	class:util::stream::MergeQueue
buffer_size_	kenlm/util/stream/sort.hh	/^    std::size_t buffer_size_;$/;"	m	class:util::stream::MergingReader
buildLatSE	HLVRec.c	/^static Boolean buildLatSE = FALSE;\/* build lat from single tok in SENTEND node *\/$/;"	v	file:
builder	kenlm/lm/builder/adjust_counts.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	kenlm/lm/builder/adjust_counts.hh	/^namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/corpus_count.cc	/^namespace builder {$/;"	n	namespace:lm	file:
builder	kenlm/lm/builder/corpus_count.hh	/^namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/discount.hh	/^namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/hash_gamma.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/initial_probabilities.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	kenlm/lm/builder/initial_probabilities.hh	/^namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/interpolate.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	kenlm/lm/builder/interpolate.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/joint_order.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/ngram.hh	/^namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/ngram_stream.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/output.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	kenlm/lm/builder/output.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/pipeline.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	kenlm/lm/builder/pipeline.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/print.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	kenlm/lm/builder/print.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	kenlm/lm/builder/sort.hh	/^namespace builder {$/;"	n	namespace:lm
builder_	kenlm/util/fake_ofstream.hh	/^    double_conversion::StringBuilder builder_;$/;"	m	class:util::FakeOFStream
building_memory	kenlm/lm/config.hh	/^  std::size_t building_memory;$/;"	m	struct:lm::ngram::Config
cOutP	HLVRec-outP.c	/^static LogFloat cOutP (DecoderInst *dec, Observation *x, HLink hmm, int state)$/;"	f	file:
cParm	HDecode.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HDecode.mod.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLVLM.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLVModel.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLVNet.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLVRec.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cacheHit	HLVRec.h	/^   int cacheHit;$/;"	m	struct:_OutPCache
cacheMiss	HLVRec.h	/^   int cacheMiss;$/;"	m	struct:_OutPCache
cache_size_	kenlm/lm/wrappers/nplm.hh	/^    const std::size_t cache_size_;$/;"	m	class:lm::np::Model
call_realloc	kenlm/util/mmap.cc	/^void scoped_memory::call_realloc(std::size_t size) {$/;"	f	class:util::scoped_memory
call_realloc	kenlm/util/scoped.cc	/^void scoped_malloc::call_realloc(std::size_t requested) {$/;"	f	class:util::scoped_malloc
capacity	kenlm/util/string_piece.hh	/^  size_type capacity() const { return length_; }$/;"	f	class:StringPiece
chain	HLVNet.h	/^   TLexNode *chain;              \/* global chain of all TLexNodes *\/$/;"	m	struct:_TLexNode
chain_	kenlm/util/stream/chain.hh	/^    Chain *chain_;$/;"	m	class:util::stream::ChainPosition
chains_	kenlm/lm/builder/pipeline.cc	/^    util::stream::Chains chains_;$/;"	m	class:lm::builder::__anon13::Master	file:
character_	kenlm/util/stream/multi_progress.hh	/^    char character_;$/;"	m	class:util::stream::WorkerProgress
character_handout_	kenlm/util/stream/multi_progress.hh	/^    std::size_t character_handout_;$/;"	m	class:util::stream::MultiProgress
chars_	kenlm/util/tokenize_piece.hh	/^    StringPiece chars_;$/;"	m	class:util::AnyCharacter
chars_	kenlm/util/tokenize_piece.hh	/^    StringPiece chars_;$/;"	m	class:util::AnyCharacterLast
clear	kenlm/util/fixed_array.hh	/^    void clear() {$/;"	f	class:util::FixedArray
clear	kenlm/util/string_piece.hh	/^  void clear() { ptr_ = NULL; length_ = 0; }$/;"	f	class:StringPiece
combine_	kenlm/util/stream/sort.hh	/^    Combine combine_;$/;"	m	class:util::stream::MergingReader
combine_	kenlm/util/stream/sort.hh	/^    const Combine combine_;$/;"	m	class:util::stream::Sort
compNode	HLVNet.h	/^   CompLMlaNode *compNode;      \/* [0..nCompNodes-1] arry of entries *\/$/;"	m	struct:_LMlaTree
comp_stll	HLVNet.c	/^int comp_stll (const void *v1, const void *v2) {$/;"	f
compare	kenlm/util/string_piece.hh	/^  int compare(const StringPiece& x) const {$/;"	f	class:StringPiece
compare_	kenlm/util/stream/sort.hh	/^        const Compare compare_;$/;"	m	class:util::stream::MergeQueue::Greater
compare_	kenlm/util/stream/sort.hh	/^    Compare compare_;$/;"	m	class:util::stream::MergingReader
compare_	kenlm/util/stream/sort.hh	/^    SizedCompare<Compare> compare_;$/;"	m	class:util::stream::BlockSorter
compare_	kenlm/util/stream/sort.hh	/^    const Compare compare_;$/;"	m	class:util::stream::Sort
complete	kenlm/lm/builder/ngram.hh	/^  ProbBackoff complete;$/;"	m	union:lm::builder::Payload
complete_	kenlm/util/ersatz_progress.hh	/^    uint64_t current_, next_, complete_;$/;"	m	class:util::ErsatzProgress
complete_	kenlm/util/stream/multi_progress.hh	/^    uint64_t complete_;$/;"	m	class:util::stream::MultiProgress
complete_called_	kenlm/util/stream/chain.hh	/^    bool complete_called_;$/;"	m	class:util::stream::Chain
config_	kenlm/lm/builder/pipeline.cc	/^    PipelineConfig &config_;$/;"	m	class:lm::builder::__anon13::Master	file:
config_	kenlm/util/stream/chain.hh	/^    ChainConfig config_;$/;"	m	class:util::stream::Chain
config_	kenlm/util/stream/sort.hh	/^    SortConfig config_;$/;"	m	class:util::stream::Sort
const_iterator	kenlm/util/string_piece.hh	/^  typedef const char* const_iterator;$/;"	t	class:StringPiece
const_reference	kenlm/util/string_piece.hh	/^  typedef const char& const_reference;$/;"	t	class:StringPiece
const_reverse_iterator	kenlm/util/string_piece.hh	/^  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:StringPiece
consume_at_	kenlm/util/pcqueue.hh	/^  T *consume_at_;$/;"	m	class:util::PCQueue
consume_at_mutex_	kenlm/util/pcqueue.hh	/^  boost::mutex consume_at_mutex_;$/;"	m	class:util::PCQueue
context_	kenlm/lm/trie_sort.hh	/^    util::scoped_FILE full_[KENLM_MAX_ORDER - 1], context_[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::trie::SortedFiles
contexts_	kenlm/lm/search_trie.cc	/^    RecordReader *contexts_;$/;"	m	class:lm::ngram::trie::__anon24::WriteEntries	file:
convert_	kenlm/util/fake_ofstream.hh	/^    double_conversion::DoubleToStringConverter convert_;$/;"	m	class:util::FakeOFStream
copy_from_	kenlm/lm/builder/adjust_counts.cc	/^    uint8_t *copy_from_;$/;"	m	class:lm::builder::__anon8::CollapseStream	file:
count	kenlm/lm/builder/adjust_counts.cc	/^      uint64_t count;$/;"	m	struct:lm::builder::__anon8::StatCollector::OrderStat	file:
count	kenlm/lm/builder/ngram.hh	/^  uint64_t count;$/;"	m	union:lm::builder::Payload
count_	kenlm/lm/search_hashed.hh	/^        uint64_t count_;$/;"	m	class:lm::ngram::detail::HashedSearch::Unigram
count_pruned	kenlm/lm/builder/adjust_counts.cc	/^      uint64_t count_pruned;$/;"	m	struct:lm::builder::__anon8::StatCollector::OrderStat	file:
counts	HLVLM.h	/^   int counts[NSIZE+1];         \/* Number of [n]grams *\/$/;"	m	struct:_FSLM_ngram
counts	kenlm/lm/binary_format.hh	/^  std::vector<uint64_t> counts;$/;"	m	struct:lm::ngram::Parameters
counts_	kenlm/lm/builder/adjust_counts.cc	/^    std::vector<uint64_t> &counts_;$/;"	m	class:lm::builder::__anon8::StatCollector	file:
counts_	kenlm/lm/builder/adjust_counts.hh	/^    std::vector<uint64_t> &counts_;$/;"	m	class:lm::builder::AdjustCounts
counts_	kenlm/lm/filter/arpa_io.hh	/^    std::vector<uint64_t> counts_;$/;"	m	class:lm::ARPAOutput
counts_	kenlm/lm/interpolate/arpa_to_stream.hh	/^    std::vector<uint64_t> counts_;$/;"	m	class:lm::interpolate::ARPAToStream
counts_	kenlm/lm/search_trie.cc	/^    std::vector<uint64_t> counts_;$/;"	m	class:lm::ngram::trie::__anon24::FindBlanks	file:
counts_pruned	kenlm/lm/builder/header_info.hh	/^  std::vector<uint64_t> counts_pruned;$/;"	m	struct:HeaderInfo
counts_pruned_	kenlm/lm/builder/adjust_counts.cc	/^    std::vector<uint64_t> &counts_pruned_;$/;"	m	class:lm::builder::__anon8::StatCollector	file:
counts_pruned_	kenlm/lm/builder/adjust_counts.hh	/^    std::vector<uint64_t> &counts_pruned_;$/;"	m	class:lm::builder::AdjustCounts
curBeamWidth	HLVRec.h	/^   TokScore curBeamWidth;       \/* current dynamic beamWidth (due to max model pruning) *\/$/;"	m	struct:_DecoderInst
cur_	kenlm/util/stream/sort.hh	/^    Entry cur_;$/;"	m	class:util::stream::Offsets
currentCount_	kenlm/lm/builder/initial_probabilities.cc	/^    uint64_t currentCount_;$/;"	m	class:lm::builder::__anon11::PruneNGramStream	file:
current_	kenlm/lm/builder/adjust_counts.cc	/^    NGram current_;$/;"	m	class:lm::builder::__anon8::CollapseStream	file:
current_	kenlm/lm/builder/initial_probabilities.cc	/^    NGram current_; \/\/ input iterator$/;"	m	class:lm::builder::__anon11::PruneNGramStream	file:
current_	kenlm/lm/filter/phrase.cc	/^    const Sentence *current_;$/;"	m	class:lm::phrase::detail::Arc	file:
current_	kenlm/lm/filter/phrase.cc	/^    unsigned int current_;$/;"	m	class:lm::phrase::detail::Vertex	file:
current_	kenlm/lm/search_trie.cc	/^    uint8_t *current_, *allocated_;$/;"	m	class:lm::ngram::trie::__anon24::BackoffMessages	file:
current_	kenlm/util/ersatz_progress.hh	/^    uint64_t current_, next_, complete_;$/;"	m	class:util::ErsatzProgress
current_	kenlm/util/pool.hh	/^    uint8_t *current_, *current_end_;$/;"	m	class:util::Pool
current_	kenlm/util/stream/chain.hh	/^    Block current_;$/;"	m	class:util::stream::Link
current_	kenlm/util/stream/multi_progress.hh	/^    uint64_t current_, next_;$/;"	m	class:util::stream::WorkerProgress
current_	kenlm/util/stream/sort.hh	/^        uint8_t *current_, *buffer_end_;$/;"	m	class:util::stream::MergeQueue::Entry
current_	kenlm/util/stream/stream.hh	/^    uint8_t *current_, *end_;$/;"	m	class:util::stream::Stream
current_	kenlm/util/tokenize_piece.hh	/^    StringPiece current_;$/;"	m	class:util::TokenIter
current_begin_	kenlm/util/mmap.hh	/^    uint64_t current_begin_;$/;"	m	class:util::Rolling
current_end_	kenlm/util/mmap.hh	/^    uint64_t current_end_;$/;"	m	class:util::Rolling
current_end_	kenlm/util/pool.hh	/^    uint8_t *current_, *current_end_;$/;"	m	class:util::Pool
d32_	kenlm/util/double-conversion/ieee.h	/^  const uint32_t d32_;$/;"	m	class:double_conversion::Single
d64_	kenlm/util/double-conversion/ieee.h	/^  const uint64_t d64_;$/;"	m	class:double_conversion::Double
data	HLVLM.h	/^   } data;$/;"	m	struct:_FSLM	typeref:union:_FSLM::__anon2
data	HLVNet.c	/^   } data;$/;"	m	struct:_STLexNode	typeref:union:_STLexNode::__anon3	file:
data	HLVNet.h	/^   } data;$/;"	m	struct:_LexNode	typeref:union:_LexNode::__anon4
data	kenlm/util/string_piece.hh	/^  const char* data() const { return ptr_; }$/;"	f	class:StringPiece
dataForm	HDecode.c	/^static FileFormat dataForm = UNDEFF; \/* data input file format *\/$/;"	v	file:
dataForm	HDecode.mod.c	/^static FileFormat dataForm = UNDEFF; \/* data input file format *\/$/;"	v	file:
data_	kenlm/lm/trie_sort.hh	/^    util::scoped_malloc data_;$/;"	m	class:lm::ngram::trie::RecordReader
data_	kenlm/util/file_piece.hh	/^    scoped_memory data_;$/;"	m	class:util::FilePiece
data_	kenlm/util/mmap.hh	/^    void *data_;$/;"	m	class:util::scoped_memory
data_	kenlm/util/mmap.hh	/^    void *data_;$/;"	m	class:util::scoped_mmap
data_	kenlm/util/stream/sort.hh	/^    int data_;$/;"	m	class:util::stream::OwningMergingReader
data_	kenlm/util/stream/sort.hh	/^    scoped_fd data_;$/;"	m	class:util::stream::Sort
datadir	Makefile	/^datadir = ${prefix}\/share$/;"	m
debug_stderr	HDecode.mod.c	/^FILE *debug_stderr = stderr;$/;"	v
debug_stdout	HDecode.mod.c	/^FILE *debug_stdout = stdout;$/;"	v
decimal_exponent	kenlm/util/double-conversion/cached-powers.cc	/^  int16_t decimal_exponent;$/;"	m	struct:double_conversion::CachedPower	file:
decimal_in_shortest_high_	kenlm/util/double-conversion/double-conversion.h	/^  const int decimal_in_shortest_high_;$/;"	m	class:double_conversion::DoubleToStringConverter
decimal_in_shortest_low_	kenlm/util/double-conversion/double-conversion.h	/^  const int decimal_in_shortest_low_;$/;"	m	class:double_conversion::DoubleToStringConverter
dedupe_	kenlm/lm/builder/corpus_count.cc	/^    Dedupe dedupe_;$/;"	m	class:lm::builder::__anon9::Writer	file:
dedupe_invalid_	kenlm/lm/builder/corpus_count.cc	/^    std::vector<WordIndex> dedupe_invalid_;$/;"	m	class:lm::builder::__anon9::Writer	file:
dedupe_mem_	kenlm/lm/builder/corpus_count.hh	/^    util::scoped_malloc dedupe_mem_;$/;"	m	class:lm::builder::CorpusCount
dedupe_mem_size_	kenlm/lm/builder/corpus_count.hh	/^    std::size_t dedupe_mem_size_;$/;"	m	class:lm::builder::CorpusCount
default_map_size_	kenlm/util/file_piece.hh	/^    std::size_t default_map_size_;$/;"	m	class:util::FilePiece
delegate_	kenlm/util/sized_iterator.hh	/^    const Delegate delegate_;$/;"	m	class:util::SizedCompare
delim_	kenlm/util/tokenize_piece.hh	/^    char delim_;$/;"	m	class:util::SingleCharacter
delimiter_	kenlm/util/tokenize_piece.hh	/^    StringPiece delimiter_;$/;"	m	class:util::MultiCharacter
delimiter_	kenlm/util/tokenize_piece.hh	/^    const bool *delimiter_;$/;"	m	class:util::BoolCharacter
delta	HLVRec.h	/^   RelTokScore  delta;          \/* delta score relative to main token, $/;"	m	struct:_RelToken
denominator	kenlm/lm/builder/initial_probabilities.cc	/^  float denominator;$/;"	m	struct:lm::builder::__anon11::BufferEntry	file:
dereference	kenlm/util/tokenize_piece.hh	/^    const StringPiece &dereference() const {$/;"	f	class:util::TokenIter
dest	HLVLM.h	/^   FSLM_LatNode *dest;$/;"	m	struct:_FSLM_LatArc
dest_	kenlm/lm/builder/initial_probabilities.cc	/^    NGram dest_;    \/\/ output iterator$/;"	m	class:lm::builder::__anon11::PruneNGramStream	file:
detail	kenlm/lm/filter/phrase.cc	/^namespace detail { $/;"	n	namespace:lm::phrase	file:
detail	kenlm/lm/filter/phrase.cc	/^namespace detail {$/;"	n	namespace:lm::phrase	file:
detail	kenlm/lm/filter/phrase.hh	/^namespace detail {$/;"	n	namespace:lm::phrase
detail	kenlm/lm/model.cc	/^namespace detail {$/;"	n	namespace:lm::ngram	file:
detail	kenlm/lm/model.hh	/^namespace detail {$/;"	n	namespace:lm::ngram
detail	kenlm/lm/search_hashed.cc	/^namespace detail {$/;"	n	namespace:lm::ngram	file:
detail	kenlm/lm/search_hashed.hh	/^namespace detail {$/;"	n	namespace:lm::ngram
detail	kenlm/lm/vocab.cc	/^namespace detail {$/;"	n	namespace:lm::ngram	file:
detail	kenlm/lm/vocab.hh	/^namespace detail {$/;"	n	namespace:lm::ngram
detail	kenlm/util/joint_sort.hh	/^namespace detail {$/;"	n	namespace:util
detail	kenlm/util/multi_intersection.hh	/^namespace detail {$/;"	n	namespace:util
dictfn	HDecode.c	/^static char *dictfn;		\/* dict filename from commandline *\/$/;"	v	file:
dictfn	HDecode.mod.c	/^static char *dictfn;		\/* dict filename from commandline *\/$/;"	v	file:
difference_type	kenlm/util/proxy_iterator.hh	/^    typedef std::ptrdiff_t difference_type;$/;"	t	class:util::ProxyIterator
difference_type	kenlm/util/string_piece.hh	/^  typedef ptrdiff_t difference_type;$/;"	t	class:StringPiece
disallowed_symbol_action	kenlm/lm/builder/pipeline.hh	/^  WarningAction disallowed_symbol_action;$/;"	m	struct:lm::builder::PipelineConfig
disallowed_symbol_action_	kenlm/lm/builder/corpus_count.hh	/^    WarningAction disallowed_symbol_action_;$/;"	m	class:lm::builder::CorpusCount
discount	kenlm/lm/builder/pipeline.hh	/^  DiscountConfig discount;$/;"	m	struct:lm::builder::PipelineConfig
discount_	kenlm/lm/builder/initial_probabilities.cc	/^    Discount discount_;$/;"	m	class:lm::builder::__anon11::MergeRight	file:
discount_	kenlm/lm/builder/initial_probabilities.cc	/^    const Discount &discount_;$/;"	m	class:lm::builder::__anon11::AddRight	file:
discount_config_	kenlm/lm/builder/adjust_counts.hh	/^    DiscountConfig discount_config_;$/;"	m	class:lm::builder::AdjustCounts
discounts_	kenlm/lm/builder/adjust_counts.cc	/^    std::vector<Discount> &discounts_;$/;"	m	class:lm::builder::__anon8::StatCollector	file:
discounts_	kenlm/lm/builder/adjust_counts.hh	/^    std::vector<Discount> &discounts_;$/;"	m	class:lm::builder::AdjustCounts
display_	kenlm/util/stream/multi_progress.hh	/^    char display_[kWidth + 1];$/;"	m	class:util::stream::MultiProgress
doing_	kenlm/lm/search_trie.cc	/^    Doing &doing_;$/;"	m	class:lm::ngram::trie::__anon24::BlankManager	file:
done_	kenlm/lm/filter/thread.hh	/^    util::PCQueue<Request> &done_;$/;"	m	class:lm::FilterWorker
done_	kenlm/lm/filter/thread.hh	/^    util::PCQueue<Request> &done_;$/;"	m	class:lm::OutputWorker
double_conversion	kenlm/util/double-conversion/bignum-dtoa.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	kenlm/util/double-conversion/bignum-dtoa.h	/^namespace double_conversion {$/;"	n
double_conversion	kenlm/util/double-conversion/bignum.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	kenlm/util/double-conversion/bignum.h	/^namespace double_conversion {$/;"	n
double_conversion	kenlm/util/double-conversion/cached-powers.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	kenlm/util/double-conversion/cached-powers.h	/^namespace double_conversion {$/;"	n
double_conversion	kenlm/util/double-conversion/diy-fp.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	kenlm/util/double-conversion/diy-fp.h	/^namespace double_conversion {$/;"	n
double_conversion	kenlm/util/double-conversion/double-conversion.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	kenlm/util/double-conversion/double-conversion.h	/^namespace double_conversion {$/;"	n
double_conversion	kenlm/util/double-conversion/fast-dtoa.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	kenlm/util/double-conversion/fast-dtoa.h	/^namespace double_conversion {$/;"	n
double_conversion	kenlm/util/double-conversion/fixed-dtoa.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	kenlm/util/double-conversion/fixed-dtoa.h	/^namespace double_conversion {$/;"	n
double_conversion	kenlm/util/double-conversion/ieee.h	/^namespace double_conversion {$/;"	n
double_conversion	kenlm/util/double-conversion/strtod.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	kenlm/util/double-conversion/strtod.h	/^namespace double_conversion {$/;"	n
double_conversion	kenlm/util/double-conversion/utils.h	/^namespace double_conversion {$/;"	n
double_to_uint64	kenlm/util/double-conversion/ieee.h	/^static uint64_t double_to_uint64(double d) { return BitCast<uint64_t>(d); }$/;"	f	namespace:double_conversion
dwLength	kenlm/util/usage.cc	/^  DWORD dwLength;$/;"	m	struct:__anon48	file:
dwMemoryLoad	kenlm/util/usage.cc	/^  DWORD dwMemoryLoad;$/;"	m	struct:__anon48	file:
dynBeamInc	HLVRec.c	/^static float dynBeamInc = 1.3;          \/* dynamic beam increment for max model pruning *\/$/;"	v	file:
e	kenlm/util/double-conversion/diy-fp.h	/^  int e() const { return e_; }$/;"	f	class:double_conversion::DiyFp
e_	kenlm/util/double-conversion/diy-fp.h	/^  int e_;$/;"	m	class:double_conversion::DiyFp
empty	kenlm/util/fixed_array.hh	/^    bool empty() const { return begin() == end(); }$/;"	f	class:util::FixedArray
empty	kenlm/util/string_piece.hh	/^  bool empty() const { return length_ == 0; }$/;"	f	class:StringPiece
empty_	kenlm/util/pcqueue.hh	/^  Semaphore empty_;$/;"	m	class:util::PCQueue
empty_string_value_	kenlm/util/double-conversion/double-conversion.h	/^  const double empty_string_value_;$/;"	m	class:double_conversion::StringToDoubleConverter
end	HDecode.c	/^   int end;$/;"	m	struct:_BestInfo	file:
end	HDecode.mod.c	/^   int end;$/;"	m	struct:_BestInfo	file:
end	HLVNet.h	/^   LexNode *end;                \/* single end node *\/$/;"	m	struct:_LexNet
end	HLVNet.h	/^   LexNode *end;$/;"	m	struct:_LexLink
end	HLVNet.h	/^   TLexNode *end;       \/* end node of network *\/$/;"	m	struct:_TLexNet
end	HLVNet.h	/^   TLexNode *end;$/;"	m	struct:_TLexLink
end	kenlm/lm/builder/ngram.hh	/^    WordIndex *end() { return end_; }$/;"	f	class:lm::builder::NGram
end	kenlm/lm/builder/ngram.hh	/^    const WordIndex *end() const { return end_; }$/;"	f	class:lm::builder::NGram
end	kenlm/lm/search_trie.cc	/^  const WordIndex *begin, *end;$/;"	m	struct:lm::ngram::trie::__anon24::Gram	file:
end	kenlm/lm/trie.hh	/^  uint64_t begin, end;$/;"	m	struct:lm::ngram::trie::NodeRange
end	kenlm/util/fixed_array.hh	/^    T *end() { return newed_end_; }$/;"	f	class:util::FixedArray
end	kenlm/util/fixed_array.hh	/^    const T *end() const { return newed_end_; }$/;"	f	class:util::FixedArray
end	kenlm/util/mmap.hh	/^    const char *end() const { return reinterpret_cast<char*>(data_) + size_; }$/;"	f	class:util::scoped_memory
end	kenlm/util/mmap.hh	/^    const uint8_t *end() const { return reinterpret_cast<uint8_t*>(data_) + size_; }$/;"	f	class:util::scoped_mmap
end	kenlm/util/string_piece.hh	/^  iterator end() const { return ptr_ + length_; }$/;"	f	class:StringPiece
end	kenlm/util/tokenize_piece.hh	/^    static TokenIter<Find, SkipEmpty> end() {$/;"	f	class:util::TokenIter
endId	HLVNet.h	/^   LabId endId;         \/* id of ENDWORD (from config) *\/$/;"	m	struct:_TLexNet
endLab	HDecode.c	/^static LabId endLab;            \/*   corresponding LabId *\/$/;"	v	file:
endLab	HDecode.mod.c	/^static LabId endLab;            \/*   corresponding LabId *\/$/;"	v	file:
endPron	HLVNet.h	/^   PronId endPron;              \/* pron of <\/s> *\/$/;"	m	struct:_LexNet
endPronId	HLVLM.h	/^   PronId endPronId;$/;"	m	struct:_FSLM
endWord	HDecode.c	/^static char *endWord = "<\/s>";  \/* word used at end of network *\/$/;"	v	file:
endWord	HDecode.mod.c	/^static char *endWord = "<\/s>";  \/* word used at end of network *\/$/;"	v	file:
end_	kenlm/lm/builder/ngram.hh	/^    WordIndex *begin_, *end_;$/;"	m	class:lm::builder::NGram
end_	kenlm/lm/quantize.hh	/^        const float *end_;$/;"	m	class:lm::ngram::SeparatelyQuantize::Bins
end_	kenlm/lm/vocab.hh	/^    uint64_t *begin_, *end_;$/;"	m	class:lm::ngram::SortedVocabulary
end_	kenlm/util/pcqueue.hh	/^  T *const end_;$/;"	m	class:util::PCQueue
end_	kenlm/util/probing_hash_table.hh	/^    MutableIterator end_;$/;"	m	class:util::ProbingHashTable
end_	kenlm/util/read_compressed.cc	/^    uint8_t *end_;$/;"	m	class:util::__anon45::UncompressedWithHeader	file:
end_	kenlm/util/stream/stream.hh	/^    uint8_t *current_, *end_;$/;"	m	class:util::stream::Stream
end_sentence_	kenlm/lm/virtual_interface.hh	/^    WordIndex begin_sentence_, end_sentence_, not_found_;$/;"	m	class:lm::base::Vocabulary
ends_with	kenlm/util/string_piece.hh	/^  bool ends_with(const StringPiece& x) const {$/;"	f	class:StringPiece
entries_	kenlm/util/probing_hash_table.hh	/^    std::size_t entries_;$/;"	m	class:util::ProbingHashTable
entry_size	kenlm/util/stream/config.hh	/^  std::size_t entry_size;$/;"	m	struct:util::stream::ChainConfig
entry_size_	kenlm/lm/search_trie.cc	/^    std::size_t entry_size_;$/;"	m	class:lm::ngram::trie::__anon24::BackoffMessages	file:
entry_size_	kenlm/lm/trie_sort.hh	/^    std::size_t entry_size_;$/;"	m	class:lm::ngram::trie::RecordReader
entry_size_	kenlm/util/stream/sort.hh	/^    const std::size_t entry_size_;$/;"	m	class:util::stream::MergeQueue
entry_size_	kenlm/util/stream/sort.hh	/^    const std::size_t entry_size_;$/;"	m	class:util::stream::Sort
entry_size_	kenlm/util/stream/stream.hh	/^    std::size_t entry_size_;$/;"	m	class:util::stream::Stream
enumerate_	kenlm/lm/vocab.hh	/^    EnumerateVocab *enumerate_;$/;"	m	class:lm::ngram::ProbingVocabulary
enumerate_	kenlm/lm/vocab.hh	/^    EnumerateVocab *enumerate_;$/;"	m	class:lm::ngram::SortedVocabulary
enumerate_vocab	kenlm/lm/config.hh	/^  EnumerateVocab *enumerate_vocab;$/;"	m	struct:lm::ngram::Config
equal	kenlm/util/tokenize_piece.hh	/^    bool equal(const TokenIter<Find, SkipEmpty> &other) const {$/;"	f	class:util::TokenIter
equal_	kenlm/util/probing_hash_table.hh	/^    Equal equal_;$/;"	m	class:util::ProbingHashTable
errno_	kenlm/util/exception.hh	/^    int errno_;$/;"	m	class:util::ErrnoException
eventT	HLVNet.h	/^   int eventT;          \/* frame # of last (de)activation *\/$/;"	m	struct:_LexNode
exact_powers_of_ten	kenlm/util/double-conversion/strtod.cc	/^static const double exact_powers_of_ten[] = {$/;"	m	namespace:double_conversion	file:
exec_prefix	Makefile	/^exec_prefix = ${prefix}$/;"	m
exponent_	kenlm/util/double-conversion/bignum.h	/^  int exponent_;$/;"	m	class:double_conversion::Bignum
exponent_character_	kenlm/util/double-conversion/double-conversion.h	/^  const char exponent_character_;$/;"	m	class:double_conversion::DoubleToStringConverter
extend_left	kenlm/lm/return.hh	/^  uint64_t extend_left; \/\/ Defined only if independent_left$/;"	m	struct:lm::FullScoreReturn
f	kenlm/util/bit_packing.hh	/^typedef union { float f; uint32_t i; } FloatEnc;$/;"	m	union:util::__anon31
f	kenlm/util/double-conversion/diy-fp.h	/^  uint64_t f() const { return f_; }$/;"	f	class:double_conversion::DiyFp
f_	kenlm/util/double-conversion/diy-fp.h	/^  uint64_t f_;$/;"	m	class:double_conversion::DiyFp
fallback	kenlm/lm/builder/adjust_counts.hh	/^  Discount fallback;$/;"	m	struct:lm::builder::DiscountConfig
fallback_to_read_	kenlm/util/file_piece.hh	/^    bool fallback_to_read_;$/;"	m	class:util::FilePiece
fast_counter_	kenlm/lm/filter/arpa_io.hh	/^    size_t fast_counter_;$/;"	m	class:lm::ARPAOutput
fastlmla	HLVRec.h	/^   Boolean fastlmla;            \/* use fast LM lookahead, i.e. back-off to bigram states *\/$/;"	m	struct:_DecoderInst
fastlmlaBeam	HDecode.c	/^static LogFloat fastlmlaBeam = - LZERO;  \/* do fast LM la outside this beam *\/$/;"	v	file:
fastlmlaBeam	HDecode.mod.c	/^static LogFloat fastlmlaBeam = - LZERO;  \/* do fast LM la outside this beam *\/$/;"	v	file:
fastlmlaBeam	HLVRec.h	/^   LogFloat fastlmlaBeam;       \/* beam in which to use full lmla *\/$/;"	m	struct:_DecoderInst
fd_	kenlm/util/fake_ofstream.hh	/^    int fd_;$/;"	m	class:util::FakeOFStream
fd_	kenlm/util/file.hh	/^    int fd_;$/;"	m	class:util::FDException
fd_	kenlm/util/file.hh	/^    int fd_;$/;"	m	class:util::scoped_fd
fd_	kenlm/util/mmap.hh	/^    int fd_;$/;"	m	class:util::Rolling
fd_	kenlm/util/parallel_read.cc	/^    int fd_;$/;"	m	class:util::__anon44::Reader	file:
fd_	kenlm/util/read_compressed.cc	/^    scoped_fd fd_;$/;"	m	class:util::__anon45::Uncompressed	file:
fd_	kenlm/util/read_compressed.cc	/^    scoped_fd fd_;$/;"	m	class:util::__anon45::UncompressedWithHeader	file:
fd_	kenlm/util/stream/line_input.hh	/^    int fd_;$/;"	m	class:util::stream::LineInput
fell_back_	kenlm/util/file_piece.hh	/^    ReadCompressed fell_back_;$/;"	m	class:util::FilePiece
file_	kenlm/lm/binary_format.hh	/^    util::scoped_fd file_;$/;"	m	class:lm::ngram::BinaryFormat
file_	kenlm/lm/filter/arpa_io.hh	/^    std::fstream file_;$/;"	m	class:lm::ARPAOutput
file_	kenlm/lm/filter/count_io.hh	/^    util::FakeOFStream file_;$/;"	m	class:lm::CountOutput
file_	kenlm/lm/trie_sort.hh	/^    FILE *file_;$/;"	m	class:lm::ngram::trie::RecordReader
file_	kenlm/util/file_piece.hh	/^    scoped_fd file_;$/;"	m	class:util::FilePiece
file_	kenlm/util/read_compressed.cc	/^    scoped_fd file_;$/;"	m	class:util::__anon45::StreamCompressed	file:
file_	kenlm/util/stream/io.hh	/^    int file_;$/;"	m	class:util::stream::PRead
file_	kenlm/util/stream/io.hh	/^    int file_;$/;"	m	class:util::stream::PWriteAndRecycle
file_	kenlm/util/stream/io.hh	/^    int file_;$/;"	m	class:util::stream::Read
file_	kenlm/util/stream/io.hh	/^    int file_;$/;"	m	class:util::stream::Write
file_	kenlm/util/stream/io.hh	/^    int file_;$/;"	m	class:util::stream::WriteAndRecycle
file_	kenlm/util/stream/io.hh	/^    scoped_fd file_;$/;"	m	class:util::stream::FileBuffer
file_begin_	kenlm/util/mmap.hh	/^    uint64_t file_begin_;$/;"	m	class:util::Rolling
file_end_	kenlm/util/mmap.hh	/^    uint64_t file_end_;$/;"	m	class:util::Rolling
file_name_	kenlm/lm/filter/arpa_io.hh	/^    const std::string file_name_;$/;"	m	class:lm::ARPAOutput
file_name_	kenlm/lm/filter/arpa_io.hh	/^    const std::string file_name_;$/;"	m	class:lm::ARPAOutputException
file_name_	kenlm/util/file_piece.hh	/^    std::string file_name_;$/;"	m	class:util::FilePiece
files_	kenlm/lm/builder/pipeline.cc	/^    util::FixedArray<util::stream::FileBuffer> files_;$/;"	m	class:lm::builder::__anon13::Master	file:
files_	kenlm/lm/filter/format.hh	/^    Singles files_;$/;"	m	class:lm::MultipleOutput
files_	kenlm/lm/trie_sort.cc	/^    std::deque<FILE*> &files_;$/;"	m	class:lm::ngram::trie::__anon27::Closer	file:
filter_	kenlm/lm/filter/format.hh	/^    Filter &filter_;$/;"	m	class:lm::DispatchInput
filter_	kenlm/lm/filter/thread.hh	/^    Filter filter_;$/;"	m	class:lm::FilterWorker
filter_	kenlm/lm/filter/thread.hh	/^    util::ThreadPool<FilterWorker<Batch, Filter> > filter_;$/;"	m	class:lm::Controller
find	kenlm/util/string_piece.cc	/^size_type StringPiece::find(char c, size_type pos) const {$/;"	f	class:StringPiece
find	kenlm/util/string_piece.cc	/^size_type StringPiece::find(const StringPiece& s, size_type pos) const {$/;"	f	class:StringPiece
find_first_not_of	kenlm/util/string_piece.cc	/^size_type StringPiece::find_first_not_of(char c, size_type pos) const {$/;"	f	class:StringPiece
find_first_not_of	kenlm/util/string_piece.cc	/^size_type StringPiece::find_first_not_of(const StringPiece& s,$/;"	f	class:StringPiece
find_first_of	kenlm/util/string_piece.cc	/^size_type StringPiece::find_first_of(const StringPiece& s,$/;"	f	class:StringPiece
find_first_of	kenlm/util/string_piece.hh	/^  size_type find_first_of(char c, size_type pos = 0) const {$/;"	f	class:StringPiece
find_last_not_of	kenlm/util/string_piece.cc	/^size_type StringPiece::find_last_not_of(char c, size_type pos) const {$/;"	f	class:StringPiece
find_last_not_of	kenlm/util/string_piece.cc	/^size_type StringPiece::find_last_not_of(const StringPiece& s,$/;"	f	class:StringPiece
find_last_of	kenlm/util/string_piece.cc	/^size_type StringPiece::find_last_of(const StringPiece& s, size_type pos) const {$/;"	f	class:StringPiece
find_last_of	kenlm/util/string_piece.hh	/^  size_type find_last_of(char c, size_type pos = npos) const {$/;"	f	class:StringPiece
finder_	kenlm/util/tokenize_piece.hh	/^    Find finder_;$/;"	m	class:util::TokenIter
first	kenlm/util/double-conversion/utils.h	/^  T& first() { return start_[0]; }$/;"	f	class:double_conversion::Vector
fixed	kenlm/lm/binary_format.hh	/^  FixedWidthParameters fixed;$/;"	m	struct:lm::ngram::Parameters
flags	HLVNet.h	/^   unsigned char flags;         \/* flags like LEFT_RIGHT *\/$/;"	m	struct:_LexNode
flags_	kenlm/util/double-conversion/double-conversion.h	/^  const int flags_;$/;"	m	class:double_conversion::DoubleToStringConverter
flags_	kenlm/util/double-conversion/double-conversion.h	/^  const int flags_;$/;"	m	class:double_conversion::StringToDoubleConverter
float_to_uint32	kenlm/util/double-conversion/ieee.h	/^static uint32_t float_to_uint32(float f) { return BitCast<uint32_t>(f); }$/;"	f	namespace:double_conversion
floatsPerBlock	HLVModel.h	/^   size_t floatsPerBlock;        \/* mixPerBlock * floatsPerMix *\/$/;"	m	struct:_StateInfo_lv
floatsPerMix	HLVModel.h	/^   size_t floatsPerMix;$/;"	m	struct:_StateInfo_lv
foll	HLVLM.h	/^   FSLM_LatArc *foll;$/;"	m	struct:_FSLM_LatNode
foll	HLVNet.h	/^   LexNode **foll;		\/* array of following nodes *\/$/;"	m	struct:_LexNode
for_write_	kenlm/util/mmap.hh	/^    bool for_write_;$/;"	m	class:util::Rolling
forceLatOut	HLVRec.c	/^static Boolean forceLatOut = TRUE;\/* always output lattice, even when no token survived *\/$/;"	v	file:
frame	HLVRec.h	/^   int frame;                   \/* current frame number *\/$/;"	m	struct:_DecoderInst
frame	HLVRec.h	/^   short frame;                 \/* end frame number of this model *\/$/;"	m	struct:_ModendHyp
frame	HLVRec.h	/^   short frame;                 \/* end frame number of this word *\/$/;"	m	struct:_WordendHyp
frameDur	HLVRec.h	/^   HTime frameDur;              \/* Duration of one frame in seconds *\/$/;"	m	struct:_DecoderInst
free_list_	kenlm/util/pool.hh	/^    std::vector<void *> free_list_;$/;"	m	class:util::Pool
from_	kenlm/lm/builder/corpus_count.hh	/^    util::FilePiece &from_;$/;"	m	class:lm::builder::CorpusCount
from_	kenlm/lm/filter/phrase.cc	/^    detail::Vertex *from_;$/;"	m	class:lm::phrase::detail::Arc	file:
from_adder_	kenlm/lm/builder/initial_probabilities.cc	/^    util::stream::ChainPosition from_adder_;$/;"	m	class:lm::builder::__anon11::MergeRight	file:
fslm_latlm	HLVLM.h	/^typedef enum {fslm_ngram, fslm_latlm, kenlm} FSLMType;$/;"	e	enum:__anon1
fslm_ngram	HLVLM.h	/^typedef enum {fslm_ngram, fslm_latlm, kenlm} FSLMType;$/;"	e	enum:__anon1
fslmln	HLVLM.h	/^   FSLM_LatNode *fslmln;$/;"	m	struct:_FSLM_latlm
full	kenlm/lm/state.hh	/^  bool full;$/;"	m	struct:lm::ngram::Left
full_	kenlm/lm/builder/adjust_counts.cc	/^    OrderStat &full_;$/;"	m	class:lm::builder::__anon8::StatCollector	file:
full_	kenlm/lm/trie_sort.hh	/^    util::scoped_FILE full_[KENLM_MAX_ORDER - 1], context_[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::trie::SortedFiles
gamma	kenlm/lm/builder/hash_gamma.hh	/^    float gamma;$/;"	m	struct:lm::builder::HashGamma
gamma	kenlm/lm/builder/initial_probabilities.cc	/^  float gamma;$/;"	m	struct:lm::builder::__anon11::BufferEntry	file:
gamma	kenlm/lm/builder/ngram.hh	/^  float gamma; \/\/ Interpolation weight for lower order.$/;"	m	struct:lm::builder::Uninterpolated
gcFreq	HLVRec.c	/^static int gcFreq = 100;          \/* run Garbage Collection every gcFreq frames *\/$/;"	v	file:
get	kenlm/util/file.hh	/^    int get() const { return fd_; }$/;"	f	class:util::scoped_fd
get	kenlm/util/file_piece.hh	/^    char get() {$/;"	f	class:util::FilePiece
get	kenlm/util/mmap.hh	/^    void *get() const { return data_; }$/;"	f	class:util::scoped_memory
get	kenlm/util/mmap.hh	/^    void *get() const { return data_; }$/;"	f	class:util::scoped_mmap
get	kenlm/util/mmap.hh	/^    void *get() const { return ptr_; }$/;"	f	class:util::Rolling
get	kenlm/util/scoped.hh	/^    T *get() { return p_; }$/;"	f	class:util::scoped_base
get	kenlm/util/scoped.hh	/^    const T *get() const { return p_; }$/;"	f	class:util::scoped_base
getopt	kenlm/util/getopt.c	/^getopt(argc, argv, opts)$/;"	f
gram_	kenlm/lm/builder/corpus_count.cc	/^    NGram gram_;$/;"	m	class:lm::builder::__anon9::Writer	file:
gram_	kenlm/lm/builder/ngram_stream.hh	/^    NGram gram_;$/;"	m	class:lm::builder::NGramStream
handler_	kenlm/util/thread_pool.hh	/^    boost::optional<Handler> handler_;$/;"	m	class:util::Worker
has_vocabulary	kenlm/lm/binary_format.hh	/^  bool has_vocabulary;$/;"	m	struct:lm::ngram::FixedWidthParameters
hash_	kenlm/util/probing_hash_table.hh	/^    Hash hash_;$/;"	m	class:util::ProbingHashTable
hash_value	kenlm/lm/builder/hash_gamma.hh	/^    uint64_t hash_value;$/;"	m	struct:lm::builder::HashGamma
hash_value	kenlm/lm/builder/initial_probabilities.cc	/^  uint64_t hash_value;$/;"	m	struct:lm::builder::__anon11::HashBufferEntry	file:
hash_value	kenlm/lm/state.hh	/^inline uint64_t hash_value(const ChartState &state) {$/;"	f	namespace:lm::ngram
hash_value	kenlm/lm/state.hh	/^inline uint64_t hash_value(const Left &left) {$/;"	f	namespace:lm::ngram
hash_value	kenlm/lm/state.hh	/^inline uint64_t hash_value(const State &state, uint64_t seed = 0) {$/;"	f	namespace:lm::ngram
hash_value	kenlm/util/string_piece_hash.hh	/^inline size_t hash_value(const StringPiece &str) {$/;"	f
hashes_	kenlm/lm/filter/phrase.hh	/^    std::vector<Hash> hashes_;$/;"	m	class:lm::phrase::detail::ConditionCommon
hashsize	HLVLM.h	/^   unsigned int hashsize;       \/* Size of hashtab (adjusted by lm counts) *\/$/;"	m	struct:_FSLM_ngram
hashtab	HLVLM.h	/^   NEntry **hashtab;            \/* Hash table for finding NEntries *\/$/;"	m	struct:_FSLM_ngram
hdecode_sccs_id	HDecode.c	/^char *hdecode_sccs_id = "$Id: HDecode.c,v 1.1.1.1 2006\/10\/11 09:54:55 jal58 Exp $";$/;"	v
hdecode_sccs_id	HDecode.mod.c	/^char *hdecode_sccs_id = "$Id: HDecode.mod.c,v 1.1.1.1 2006\/10\/11 09:54:55 jal58 Exp $";$/;"	v
hdecode_version	HDecode.c	/^char *hdecode_version = "!HVER!HDecode:   3.4.1 [GE 12\/03\/09]";$/;"	v
hdecode_version	HDecode.mod.c	/^char *hdecode_version = "!HVER!HDecode:   3.4.1 [GE 12\/03\/09]";$/;"	v
header_	kenlm/lm/builder/output.hh	/^    HeaderInfo header_;$/;"	m	class:lm::builder::Output
header_	kenlm/lm/vocab.hh	/^    detail::ProbingVocabularyHeader *header_;$/;"	m	class:lm::ngram::ProbingVocabulary
header_size_	kenlm/lm/binary_format.hh	/^    std::size_t header_size_, vocab_size_, vocab_pad_;$/;"	m	class:lm::ngram::BinaryFormat
heap	HLVLM.h	/^   MemHeap *heap;$/;"	m	struct:_FSLM
heap	HLVLM.h	/^   MemHeap *heap;$/;"	m	struct:_FSLM_ngram
heap	HLVNet.h	/^   MemHeap *heap;$/;"	m	struct:_LexNet
heap	HLVNet.h	/^   MemHeap *heap;$/;"	m	struct:_TLexNet
heap	HLVRec.h	/^   MemHeap heap;                \/* MSTACK for general allocation *\/$/;"	m	struct:_DecoderInst
hiWE	HLVNet.h	/^   LMId hiWE;$/;"	m	struct:_LMlaNode
hiWE	HLVNet.h	/^   int hiWE;            \/* highest WE LMId reachable from here *\/$/;"	m	struct:_TLexNode
high_bits_	kenlm/util/double-conversion/fixed-dtoa.cc	/^  uint64_t high_bits_;$/;"	m	class:double_conversion::UInt128	file:
hlvlm_vc_id	HLVLM.c	/^char *hlvlm_vc_id = "$Id: HLVLM.c,v 1.1.1.1 2006\/10\/11 09:54:55 jal58 Exp $";$/;"	v
hlvlm_version	HLVLM.c	/^char *hlvlm_version = "!HVER!HLVLM:   3.4.1 [GE 12\/03\/09]";$/;"	v
hlvmodel_vc_id	HLVModel.c	/^char *hlvmodel_vc_id = "$Id: HLVModel.c,v 1.1.1.1 2006\/10\/11 09:54:55 jal58 Exp $";$/;"	v
hlvmodel_version	HLVModel.c	/^char *hlvmodel_version = "!HVER!HLVmodel:   3.4.1 [GE 12\/03\/09]";$/;"	v
hlvnet_vc_id	HLVNet.c	/^char *hlvnet_vc_id = "$Id: HLVNet.c,v 1.1.1.1 2006\/10\/11 09:54:55 jal58 Exp $";$/;"	v
hlvnet_version	HLVNet.c	/^char *hlvnet_version = "!HVER!HLVNet:   3.4.1 [GE 12\/03\/09]";$/;"	v
hlvrec_prop_vc_id	HLVRec-propagate.c	/^char *hlvrec_prop_vc_id = "$Id: HLVRec-propagate.c,v 1.1.1.1 2006\/10\/11 09:54:56 jal58 Exp $";$/;"	v
hlvrec_vc_id	HLVRec.c	/^char *hlvrec_vc_id = "$Id: HLVRec.c,v 1.1.1.1 2006\/10\/11 09:54:56 jal58 Exp $";$/;"	v
hlvrec_version	HLVRec.c	/^char *hlvrec_version = "!HVER!HLVRec:   3.4.1 [GE 12\/03\/09]";$/;"	v
hmm	HLVNet.h	/^      HLink hmm;                \/* #### switch to HMM Ids (2 byte ints) *\/$/;"	m	union:_LexNode::__anon4
hmm	HLVNet.h	/^   HLink hmm;$/;"	m	struct:_TLexNode
hmmDir	HDecode.c	/^static char *hmmDir = NULL;     \/* directory to look for HMM def files *\/$/;"	v	file:
hmmDir	HDecode.mod.c	/^static char *hmmDir = NULL;     \/* directory to look for HMM def files *\/$/;"	v	file:
hmmExt	HDecode.c	/^static char *hmmExt = NULL;     \/* HMM def file extension *\/$/;"	v	file:
hmmExt	HDecode.mod.c	/^static char *hmmExt = NULL;     \/* HMM def file extension *\/$/;"	v	file:
hmmListfn	HDecode.c	/^static char *hmmListfn;		\/* model list filename from commandline *\/$/;"	v	file:
hmmListfn	HDecode.mod.c	/^static char *hmmListfn;		\/* model list filename from commandline *\/$/;"	v	file:
hmmSP	HLVNet.h	/^   HLink hmmSP;                 \/* pointer to "sp" hmm for spSkipLayer handling *\/$/;"	m	struct:_LexNet
hset	HDecode.c	/^static HMMSet hset;		\/* HMM set *\/$/;"	v	file:
hset	HDecode.mod.c	/^static HMMSet hset;		\/* HMM set *\/$/;"	v	file:
hset	HLVModel.h	/^   HMMSet *hset;$/;"	m	struct:_StateInfo_lv
hset	HLVNet.h	/^   HMMSet *hset;$/;"	m	struct:_LexNet
hset	HLVNet.h	/^   HMMSet *hset;$/;"	m	struct:_TLexNet
hset	HLVRec.h	/^   HMMSet *hset;$/;"	m	struct:_DecoderInst
hvs	HLVLM.c	/^static int hvs[]= { 165902236, 220889002, 32510287, 117809592,$/;"	v	file:
i	kenlm/util/bit_packing.hh	/^typedef union { float f; uint32_t i; } FloatEnc;$/;"	m	union:util::__anon31
id	HLVRec.h	/^   unsigned int id;             \/*####  should be only 2byte short! *\/$/;"	m	struct:_TokenSet
idx	HLVRec.h	/^   int idx;$/;"	m	struct:_LMNodeCache
idx	HLVRec.h	/^   unsigned int idx;$/;"	m	struct:_LMLACacheEntry
inXForm	HLVRec.c	/^static AdaptXForm *inXForm;$/;"	v	file:
in_	kenlm/lm/interpolate/arpa_to_stream.hh	/^    util::FilePiece in_;$/;"	m	class:lm::interpolate::ARPAToStream
in_	kenlm/util/stream/chain.hh	/^    PCQueue<Block> *in_, *out_;$/;"	m	class:util::stream::ChainPosition
in_	kenlm/util/stream/chain.hh	/^    PCQueue<Block> *in_, *out_;$/;"	m	class:util::stream::Link
in_	kenlm/util/stream/sort.hh	/^    const int in_;$/;"	m	class:util::stream::MergeQueue
in_	kenlm/util/stream/sort.hh	/^    int in_;$/;"	m	class:util::stream::MergingReader
in_	kenlm/util/thread_pool.hh	/^    PCQueue<Request> &in_;$/;"	m	class:util::Worker
in_	kenlm/util/thread_pool.hh	/^    PCQueue<Request> in_;$/;"	m	class:util::ThreadPool
in_buffer_	kenlm/util/read_compressed.cc	/^    scoped_malloc in_buffer_;$/;"	m	class:util::__anon45::StreamCompressed	file:
in_offsets_	kenlm/util/stream/sort.hh	/^    Offsets *in_offsets_;$/;"	m	class:util::stream::MergingReader
inc	Makefile	/^inc     = 	..\/HTKLib$/;"	m
include_vocab	kenlm/lm/config.hh	/^  bool include_vocab;$/;"	m	struct:lm::ngram::Config
includedir	Makefile	/^includedir = ${prefix}\/include$/;"	m
incoming_	kenlm/lm/filter/phrase.cc	/^    std::priority_queue<Arc*, std::vector<Arc*>, ArcGreater> incoming_;$/;"	m	class:lm::phrase::detail::Vertex	file:
increment	kenlm/util/tokenize_piece.hh	/^    void increment() {$/;"	f	class:util::TokenIter
independent_left	kenlm/lm/return.hh	/^  bool independent_left;$/;"	m	struct:lm::FullScoreReturn
index	kenlm/lm/search_trie.cc	/^  uint64_t index;$/;"	m	struct:lm::ngram::trie::__anon24::ProbPointer	file:
infinity_symbol_	kenlm/util/double-conversion/double-conversion.h	/^  const char* const infinity_symbol_;$/;"	m	class:double_conversion::DoubleToStringConverter
infinity_symbol_	kenlm/util/double-conversion/double-conversion.h	/^  const char* const infinity_symbol_;$/;"	m	class:double_conversion::StringToDoubleConverter
infodir	Makefile	/^infodir = ${prefix}\/share\/info$/;"	m
initial	HLVLM.h	/^   LMState initial;$/;"	m	struct:_FSLM
initial_probs	kenlm/lm/builder/pipeline.hh	/^  InitialProbabilitiesConfig initial_probs;$/;"	m	struct:lm::builder::PipelineConfig
initial_read_	kenlm/lm/filter/count_io.hh	/^    std::streamsize initial_read_;$/;"	m	class:lm::CountBatch
initialized_	kenlm/util/probing_hash_table.hh	/^    bool initialized_;$/;"	m	class:util::ProbingHashTable
inner_	kenlm/lm/trie_sort.cc	/^    InnerIterator inner_;$/;"	m	class:lm::ngram::trie::__anon26::PartialViewProxy	file:
inner_	kenlm/lm/vocab.hh	/^    EnumerateVocab *inner_;$/;"	m	class:lm::ngram::WriteWordsWrapper
inner_	kenlm/util/joint_sort.hh	/^    InnerIterator inner_;$/;"	m	class:util::detail::JointProxy
inner_	kenlm/util/sized_iterator.hh	/^    InnerIterator inner_;$/;"	m	class:util::SizedProxy
inputBufHeap	HDecode.c	/^static MemHeap inputBufHeap;$/;"	v	file:
inputBufHeap	HDecode.mod.c	/^static MemHeap inputBufHeap;$/;"	v	file:
input_	kenlm/lm/builder/initial_probabilities.cc	/^    const util::stream::ChainPosition input_;$/;"	m	class:lm::builder::__anon11::AddRight	file:
input_	kenlm/lm/filter/thread.hh	/^    InputBuffer *input_;$/;"	m	class:lm::Controller
input_	kenlm/lm/filter/thread.hh	/^    InputBuffer input_;$/;"	m	class:lm::ThreadBatch
input_file	kenlm/lm/builder/header_info.hh	/^  std::string input_file;$/;"	m	struct:HeaderInfo
insPen	HDecode.c	/^static LogFloat insPen = 0.0;   \/* word insertion penalty *\/$/;"	v	file:
insPen	HDecode.mod.c	/^static LogFloat insPen = 0.0;   \/* word insertion penalty *\/$/;"	v	file:
insPen	HLVRec.h	/^   LogFloat insPen;             \/* word insertion penalty *\/$/;"	m	struct:_DecoderInst
insert_index_	kenlm/lm/trie.hh	/^    uint64_t insert_index_, max_vocab_;$/;"	m	class:lm::ngram::trie::BitPacked
inst	HLVNet.h	/^   LexNodeInst *inst;		\/* model instance or NULL if inactive *\/$/;"	m	struct:_LexNode
instsLayer	HLVRec.h	/^   LexNodeInst **instsLayer;    \/* array of pointers to the linked list of $/;"	m	struct:_DecoderInst
int16_t	kenlm/util/double-conversion/utils.h	/^typedef short int16_t;  \/\/ NOLINT$/;"	t
int32_t	kenlm/util/double-conversion/utils.h	/^typedef int int32_t;$/;"	t
int64_t	kenlm/util/double-conversion/utils.h	/^typedef __int64 int64_t;$/;"	t
int8_t	kenlm/util/double-conversion/utils.h	/^typedef signed char int8_t;$/;"	t
internal_	kenlm/util/read_compressed.hh	/^    scoped_ptr<ReadBase> internal_;$/;"	m	class:util::ReadCompressed
interpolate	kenlm/lm/interpolate/arpa_to_stream.cc	/^namespace lm { namespace interpolate {$/;"	n	namespace:lm	file:
interpolate	kenlm/lm/interpolate/arpa_to_stream.hh	/^namespace interpolate {$/;"	n	namespace:lm
interpolate_unigrams	kenlm/lm/builder/initial_probabilities.hh	/^  bool interpolate_unigrams;$/;"	m	struct:lm::builder::InitialProbabilitiesConfig
interpolate_unigrams_	kenlm/lm/builder/initial_probabilities.cc	/^    bool interpolate_unigrams_;$/;"	m	class:lm::builder::__anon11::MergeRight	file:
invVarOffset	HLVModel.h	/^   size_t invVarOffset;         \/* 4 + nDim * floatsPerMix*\/$/;"	m	struct:_StateInfo_lv
invalid_	kenlm/util/probing_hash_table.hh	/^    Key invalid_;$/;"	m	class:util::ProbingHashTable
isDigit	kenlm/util/double-conversion/double-conversion.cc	/^static bool isDigit(int x, int radix) {$/;"	f	namespace:double_conversion
is_empty	kenlm/util/double-conversion/utils.h	/^  bool is_empty() const { return length_ == 0; }$/;"	f	class:double_conversion::Vector
is_finalized	kenlm/util/double-conversion/utils.h	/^  bool is_finalized() const { return position_ < 0; }$/;"	f	class:double_conversion::StringBuilder
it_	kenlm/lm/search_trie.cc	/^    float *it_[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::trie::__anon24::SRISucks	file:
iterator	kenlm/util/string_piece.hh	/^  typedef const char* iterator;$/;"	t	class:StringPiece
iterator_category	kenlm/util/proxy_iterator.hh	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:util::ProxyIterator
junk_string_value_	kenlm/util/double-conversion/double-conversion.h	/^  const double junk_string_value_;$/;"	m	class:double_conversion::StringToDoubleConverter
kARPASpaces	kenlm/lm/read_arpa.cc	/^const bool kARPASpaces[256] = {0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};$/;"	m	namespace:lm	file:
kArrayAdd	kenlm/lm/model_type.hh	/^const static ModelType kArrayAdd = static_cast<ModelType>(ARRAY_TRIE - TRIE);$/;"	m	namespace:lm::ngram
kArrayBhikshaVersion	kenlm/lm/bhiksha.cc	/^const uint8_t kArrayBhikshaVersion = 0;$/;"	m	namespace:lm::ngram::trie	file:
kBOS	kenlm/lm/builder/ngram.hh	/^const WordIndex kBOS = 1;$/;"	m	namespace:lm::builder
kBadProb	kenlm/lm/search_trie.cc	/^const float kBadProb = std::numeric_limits<float>::infinity();$/;"	m	namespace:lm::ngram::trie::__anon24	file:
kBadSize	kenlm/util/file.hh	/^const uint64_t kBadSize = (uint64_t)-1;$/;"	m	namespace:util
kBase10MaximalLength	kenlm/util/double-conversion/double-conversion.h	/^  static const int kBase10MaximalLength = 17;$/;"	m	class:double_conversion::DoubleToStringConverter
kBigitCapacity	kenlm/util/double-conversion/bignum.h	/^  static const int kBigitCapacity = kMaxSignificantBits \/ kBigitSize;$/;"	m	class:double_conversion::Bignum
kBigitMask	kenlm/util/double-conversion/bignum.h	/^  static const Chunk kBigitMask = (1 << kBigitSize) - 1;$/;"	m	class:double_conversion::Bignum
kBigitSize	kenlm/util/double-conversion/bignum.h	/^  static const int kBigitSize = 28;$/;"	m	class:double_conversion::Bignum
kBinaryMagic	kenlm/lm/read_arpa.cc	/^const char kBinaryMagic[] = "mmap lm http:\/\/kheafield.com\/code";$/;"	m	namespace:lm::__anon22	file:
kCachedPowers	kenlm/util/double-conversion/cached-powers.cc	/^static const CachedPower kCachedPowers[] = {$/;"	m	namespace:double_conversion	file:
kCachedPowersLength	kenlm/util/double-conversion/cached-powers.cc	/^static const int kCachedPowersLength = ARRAY_SIZE(kCachedPowers);$/;"	m	namespace:double_conversion	file:
kCachedPowersOffset	kenlm/util/double-conversion/cached-powers.cc	/^static const int kCachedPowersOffset = 348;  \/\/ -1 * the first decimal_exponent.$/;"	m	namespace:double_conversion	file:
kCharSize	kenlm/util/double-conversion/utils.h	/^static const int kCharSize = sizeof(char);$/;"	m	namespace:double_conversion
kChunkSize	kenlm/util/double-conversion/bignum.h	/^  static const int kChunkSize = sizeof(Chunk) * 8;$/;"	m	class:double_conversion::Bignum
kD_1_LOG2_10	kenlm/util/double-conversion/cached-powers.cc	/^static const double kD_1_LOG2_10 = 0.30102999566398114;  \/\/  1 \/ lg(10)$/;"	m	namespace:double_conversion	file:
kDecimalExponentDistance	kenlm/util/double-conversion/cached-powers.cc	/^const int PowersOfTenCache::kDecimalExponentDistance = 8;$/;"	m	class:double_conversion::PowersOfTenCache	file:
kDecimalExponentDistance	kenlm/util/double-conversion/cached-powers.h	/^  static const int kDecimalExponentDistance;$/;"	m	class:double_conversion::PowersOfTenCache
kDenormalExponent	kenlm/util/double-conversion/ieee.h	/^  static const int kDenormalExponent = -kExponentBias + 1;$/;"	m	class:double_conversion::Double
kDenormalExponent	kenlm/util/double-conversion/ieee.h	/^  static const int kDenormalExponent = -kExponentBias + 1;$/;"	m	class:double_conversion::Single
kDifferentRest	kenlm/lm/search_hashed.hh	/^    static const bool kDifferentRest = Value::kDifferentRest;$/;"	m	class:lm::ngram::detail::HashedSearch
kDifferentRest	kenlm/lm/search_trie.hh	/^    static const bool kDifferentRest = false;$/;"	m	class:lm::ngram::trie::TrieSearch
kDifferentRest	kenlm/lm/value.hh	/^  const static bool kDifferentRest = false;$/;"	m	struct:lm::ngram::BackoffValue
kDifferentRest	kenlm/lm/value.hh	/^  const static bool kDifferentRest = true;$/;"	m	struct:lm::ngram::RestValue
kDisplayCharacters	kenlm/util/stream/multi_progress.cc	/^const char kDisplayCharacters[] = "-+*#0123456789";$/;"	m	namespace:util::stream::__anon47	file:
kDoubleChunkSize	kenlm/util/double-conversion/bignum.h	/^  static const int kDoubleChunkSize = sizeof(DoubleChunk) * 8;$/;"	m	class:double_conversion::Bignum
kDoubleSignificandSize	kenlm/util/double-conversion/fixed-dtoa.cc	/^static const int kDoubleSignificandSize = 53;  \/\/ Includes the hidden bit.$/;"	m	namespace:double_conversion	file:
kEOS	kenlm/lm/builder/ngram.hh	/^const WordIndex kEOS = 2;$/;"	m	namespace:lm::builder
kExactPowersOfTenSize	kenlm/util/double-conversion/strtod.cc	/^static const int kExactPowersOfTenSize = ARRAY_SIZE(exact_powers_of_ten);$/;"	m	namespace:double_conversion	file:
kExponentBias	kenlm/util/double-conversion/ieee.h	/^  static const int kExponentBias = 0x3FF + kPhysicalSignificandSize;$/;"	m	class:double_conversion::Double
kExponentBias	kenlm/util/double-conversion/ieee.h	/^  static const int kExponentBias = 0x7F + kPhysicalSignificandSize;$/;"	m	class:double_conversion::Single
kExponentMask	kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kExponentMask = 0x7F800000;$/;"	m	class:double_conversion::Single
kExponentMask	kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kExponentMask = UINT64_2PART_C(0x7FF00000, 00000000);$/;"	m	class:double_conversion::Double
kExtensionBackoff	kenlm/lm/blank.hh	/^const float kExtensionBackoff = 0.0;$/;"	m	namespace:lm::ngram
kExtensionQuant	kenlm/lm/blank.hh	/^const uint64_t kExtensionQuant = 1;$/;"	m	namespace:lm::ngram
kFastDtoaMaximalLength	kenlm/util/double-conversion/fast-dtoa.h	/^static const int kFastDtoaMaximalLength = 17;$/;"	m	namespace:double_conversion
kFastDtoaMaximalSingleLength	kenlm/util/double-conversion/fast-dtoa.h	/^static const int kFastDtoaMaximalSingleLength = 9;$/;"	m	namespace:double_conversion
kFileFlags	kenlm/util/mmap.cc	/^const int kFileFlags =$/;"	m	namespace:util	file:
kHiddenBit	kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kHiddenBit = 0x00800000;$/;"	m	class:double_conversion::Single
kHiddenBit	kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kHiddenBit = UINT64_2PART_C(0x00100000, 00000000);$/;"	m	class:double_conversion::Double
kInfinity	kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kInfinity = 0x7F800000;$/;"	m	class:double_conversion::Single
kInfinity	kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kInfinity = UINT64_2PART_C(0x7FF00000, 00000000);$/;"	m	class:double_conversion::Double
kInputBuffer	kenlm/util/read_compressed.cc	/^static const std::size_t kInputBuffer = 16384;$/;"	m	namespace:util::__anon45	file:
kInvalidOffset	kenlm/lm/binary_format.hh	/^    static const uint64_t kInvalidOffset = (uint64_t)-1;$/;"	m	class:lm::ngram::BinaryFormat
kInvalidSize	kenlm/lm/binary_format.cc	/^const std::size_t kInvalidSize = static_cast<std::size_t>(-1);$/;"	m	namespace:lm::ngram	file:
kMagicBeforeVersion	kenlm/lm/binary_format.cc	/^const char kMagicBeforeVersion[] = "mmap lm http:\/\/kheafield.com\/code format version";$/;"	m	namespace:lm::ngram::__anon7	file:
kMagicBytes	kenlm/lm/binary_format.cc	/^const char kMagicBytes[] = "mmap lm http:\/\/kheafield.com\/code format version 5\\n\\0";$/;"	m	namespace:lm::ngram::__anon7	file:
kMagicIncomplete	kenlm/lm/binary_format.cc	/^const char kMagicIncomplete[] = "mmap lm http:\/\/kheafield.com\/code incomplete\\n";$/;"	m	namespace:lm::ngram::__anon7	file:
kMagicSize	kenlm/util/read_compressed.hh	/^    static const std::size_t kMagicSize = 6;$/;"	m	class:util::ReadCompressed
kMagicVersion	kenlm/lm/binary_format.cc	/^const long int kMagicVersion = 5;$/;"	m	namespace:lm::ngram::__anon7	file:
kMarkEvenLower	kenlm/lm/value_build.hh	/^    const static bool kMarkEvenLower = false;$/;"	m	class:lm::ngram::LowerRestBuild
kMarkEvenLower	kenlm/lm/value_build.hh	/^    const static bool kMarkEvenLower = false;$/;"	m	class:lm::ngram::NoRestBuild
kMarkEvenLower	kenlm/lm/value_build.hh	/^    const static bool kMarkEvenLower = true;$/;"	m	class:lm::ngram::MaxRestBuild
kMask32	kenlm/util/double-conversion/fixed-dtoa.cc	/^  static const uint64_t kMask32 = 0xFFFFFFFF;$/;"	m	class:double_conversion::UInt128	file:
kMatchOffset	kenlm/lm/builder/sort.hh	/^    static const unsigned kMatchOffset = 0;$/;"	m	class:lm::builder::PrefixOrder
kMatchOffset	kenlm/lm/builder/sort.hh	/^    static const unsigned kMatchOffset = 1;$/;"	m	class:lm::builder::SuffixOrder
kMaxDWORD	kenlm/util/file.cc	/^const std::size_t kMaxDWORD = static_cast<std::size_t>(4294967295UL);$/;"	m	namespace:util::__anon35	file:
kMaxDecimalExponent	kenlm/util/double-conversion/cached-powers.cc	/^const int PowersOfTenCache::kMaxDecimalExponent = 340;$/;"	m	class:double_conversion::PowersOfTenCache	file:
kMaxDecimalExponent	kenlm/util/double-conversion/cached-powers.h	/^  static const int kMaxDecimalExponent;$/;"	m	class:double_conversion::PowersOfTenCache
kMaxDecimalPower	kenlm/util/double-conversion/strtod.cc	/^static const int kMaxDecimalPower = 309;$/;"	m	namespace:double_conversion	file:
kMaxExactDoubleIntegerDecimalDigits	kenlm/util/double-conversion/strtod.cc	/^static const int kMaxExactDoubleIntegerDecimalDigits = 15;$/;"	m	namespace:double_conversion	file:
kMaxExponent	kenlm/util/double-conversion/ieee.h	/^  static const int kMaxExponent = 0x7FF - kExponentBias;$/;"	m	class:double_conversion::Double
kMaxExponent	kenlm/util/double-conversion/ieee.h	/^  static const int kMaxExponent = 0xFF - kExponentBias;$/;"	m	class:double_conversion::Single
kMaxExponentialDigits	kenlm/util/double-conversion/double-conversion.h	/^  static const int kMaxExponentialDigits = 120;$/;"	m	class:double_conversion::DoubleToStringConverter
kMaxFixedDigitsAfterPoint	kenlm/util/double-conversion/double-conversion.h	/^  static const int kMaxFixedDigitsAfterPoint = 60;$/;"	m	class:double_conversion::DoubleToStringConverter
kMaxFixedDigitsBeforePoint	kenlm/util/double-conversion/double-conversion.h	/^  static const int kMaxFixedDigitsBeforePoint = 60;$/;"	m	class:double_conversion::DoubleToStringConverter
kMaxPrecisionDigits	kenlm/util/double-conversion/double-conversion.h	/^  static const int kMaxPrecisionDigits = 120;$/;"	m	class:double_conversion::DoubleToStringConverter
kMaxSignificantBits	kenlm/util/double-conversion/bignum.h	/^  static const int kMaxSignificantBits = 3584;$/;"	m	class:double_conversion::Bignum
kMaxSignificantDecimalDigits	kenlm/util/double-conversion/strtod.cc	/^static const int kMaxSignificantDecimalDigits = 780;$/;"	m	namespace:double_conversion	file:
kMaxSignificantDigits	kenlm/util/double-conversion/double-conversion.cc	/^const int kMaxSignificantDigits = 772;$/;"	m	namespace:double_conversion	file:
kMaxUint64	kenlm/util/double-conversion/strtod.cc	/^static const uint64_t kMaxUint64 = UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);$/;"	m	namespace:double_conversion	file:
kMaxUint64DecimalDigits	kenlm/util/double-conversion/strtod.cc	/^static const int kMaxUint64DecimalDigits = 19;$/;"	m	namespace:double_conversion	file:
kMaxWordIndex	kenlm/lm/word_index.hh	/^const WordIndex kMaxWordIndex = UINT_MAX;$/;"	m	namespace:lm
kMaximalTargetExponent	kenlm/util/double-conversion/fast-dtoa.cc	/^static const int kMaximalTargetExponent = -32;$/;"	m	namespace:double_conversion	file:
kMinDecimalExponent	kenlm/util/double-conversion/cached-powers.cc	/^const int PowersOfTenCache::kMinDecimalExponent = -348;$/;"	m	class:double_conversion::PowersOfTenCache	file:
kMinDecimalExponent	kenlm/util/double-conversion/cached-powers.h	/^  static const int kMinDecimalExponent;$/;"	m	class:double_conversion::PowersOfTenCache
kMinDecimalPower	kenlm/util/double-conversion/strtod.cc	/^static const int kMinDecimalPower = -324;$/;"	m	namespace:double_conversion	file:
kMinPrecisionDigits	kenlm/util/double-conversion/double-conversion.h	/^  static const int kMinPrecisionDigits = 1;$/;"	m	class:double_conversion::DoubleToStringConverter
kMinimalTargetExponent	kenlm/util/double-conversion/fast-dtoa.cc	/^static const int kMinimalTargetExponent = -60;$/;"	m	namespace:double_conversion	file:
kModelNames	kenlm/lm/binary_format.cc	/^const char *kModelNames[6] = {"probing hash tables", "probing hash tables with rest costs", "trie", "trie with quantization", "trie with array-compressed pointers", "trie with quantization and array-compressed pointers"};$/;"	m	namespace:lm::ngram	file:
kModelType	kenlm/lm/model.cc	/^template <class Search, class VocabularyT> const ModelType GenericModel<Search, VocabularyT>::kModelType = Search::kModelType;$/;"	m	class:lm::ngram::detail::GenericModel	file:
kModelType	kenlm/lm/model.hh	/^    static const ModelType kModelType;$/;"	m	class:lm::ngram::detail::GenericModel
kModelType	kenlm/lm/search_hashed.hh	/^    static const ModelType kModelType = Value::kProbingModelType;$/;"	m	class:lm::ngram::detail::HashedSearch
kModelType	kenlm/lm/search_trie.hh	/^    static const ModelType kModelType = static_cast<ModelType>(TRIE_SORTED + Quant::kModelTypeAdd + Bhiksha::kModelTypeAdd);$/;"	m	class:lm::ngram::trie::TrieSearch
kModelTypeAdd	kenlm/lm/bhiksha.hh	/^    static const ModelType kModelTypeAdd = kArrayAdd;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
kModelTypeAdd	kenlm/lm/bhiksha.hh	/^    static const ModelType kModelTypeAdd = static_cast<ModelType>(0);$/;"	m	class:lm::ngram::trie::DontBhiksha
kModelTypeAdd	kenlm/lm/quantize.hh	/^    static const ModelType kModelTypeAdd = kQuantAdd;$/;"	m	class:lm::ngram::SeparatelyQuantize
kModelTypeAdd	kenlm/lm/quantize.hh	/^    static const ModelType kModelTypeAdd = static_cast<ModelType>(0);$/;"	m	class:lm::ngram::DontQuantize
kNaN	kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kNaN = 0x7FC00000;$/;"	m	class:double_conversion::Single
kNaN	kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kNaN = UINT64_2PART_C(0x7FF80000, 00000000);$/;"	m	class:double_conversion::Double
kNoExtensionBackoff	kenlm/lm/blank.hh	/^const float kNoExtensionBackoff = -0.0;$/;"	m	namespace:lm::ngram
kNoExtensionQuant	kenlm/lm/blank.hh	/^const uint64_t kNoExtensionQuant = 0;$/;"	m	namespace:lm::ngram
kPhysicalSignificandSize	kenlm/util/double-conversion/ieee.h	/^  static const int kPhysicalSignificandSize = 23;  \/\/ Excludes the hidden bit.$/;"	m	class:double_conversion::Single
kPhysicalSignificandSize	kenlm/util/double-conversion/ieee.h	/^  static const int kPhysicalSignificandSize = 52;  \/\/ Excludes the hidden bit.$/;"	m	class:double_conversion::Double
kProbingModelType	kenlm/lm/value.hh	/^  static const ModelType kProbingModelType = PROBING;$/;"	m	struct:lm::ngram::BackoffValue
kProbingModelType	kenlm/lm/value.hh	/^  static const ModelType kProbingModelType = REST_PROBING;$/;"	m	struct:lm::ngram::RestValue
kProbingMultiplier	kenlm/lm/builder/corpus_count.cc	/^const float kProbingMultiplier = 1.5;$/;"	m	namespace:lm::builder::__anon9	file:
kProbingVocabularyVersion	kenlm/lm/vocab.cc	/^const unsigned int kProbingVocabularyVersion = 0;$/;"	m	namespace:lm::ngram::__anon29	file:
kProgressBanner	kenlm/util/ersatz_progress.cc	/^const char kProgressBanner[] = "----5---10---15---20---25---30---35---40---45---50---55---60---65---70---75---80---85---90---95--100\\n";$/;"	m	namespace:util	file:
kQuantAdd	kenlm/lm/model_type.hh	/^const static ModelType kQuantAdd = static_cast<ModelType>(QUANT_TRIE - TRIE);$/;"	m	namespace:lm::ngram
kRecordStart	kenlm/util/usage.cc	/^const RecordStart kRecordStart;$/;"	m	namespace:util::__anon49	file:
kRecycle	kenlm/util/stream/chain.cc	/^const Recycler kRecycle = Recycler();$/;"	m	namespace:util::stream	file:
kSeparatelyQuantizeVersion	kenlm/lm/quantize.cc	/^const char kSeparatelyQuantizeVersion = 2;$/;"	m	namespace:lm::ngram::__anon21	file:
kSignBit	kenlm/util/bit_packing.hh	/^const uint32_t kSignBit = 0x80000000;$/;"	m	namespace:util
kSignMask	kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kSignMask = 0x80000000;$/;"	m	class:double_conversion::Single
kSignMask	kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kSignMask = UINT64_2PART_C(0x80000000, 00000000);$/;"	m	class:double_conversion::Double
kSignificandMask	kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kSignificandMask = 0x007FFFFF;$/;"	m	class:double_conversion::Single
kSignificandMask	kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kSignificandMask = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);$/;"	m	class:double_conversion::Double
kSignificandSize	kenlm/util/double-conversion/diy-fp.h	/^  static const int kSignificandSize = 64;$/;"	m	class:double_conversion::DiyFp
kSignificandSize	kenlm/util/double-conversion/ieee.h	/^  static const int kSignificandSize = 24;$/;"	m	class:double_conversion::Single
kSignificandSize	kenlm/util/double-conversion/ieee.h	/^  static const int kSignificandSize = 53;$/;"	m	class:double_conversion::Double
kSmallPowersOfTen	kenlm/util/double-conversion/fast-dtoa.cc	/^static unsigned int const kSmallPowersOfTen[] =$/;"	m	namespace:double_conversion	file:
kSpaces	kenlm/util/file_piece.cc	/^const bool kSpaces[256] = {0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};$/;"	m	namespace:util	file:
kTrain	kenlm/lm/quantize.hh	/^    static const bool kTrain = false;$/;"	m	class:lm::ngram::DontQuantize
kTrain	kenlm/lm/quantize.hh	/^    static const bool kTrain = true;$/;"	m	class:lm::ngram::SeparatelyQuantize
kUNK	kenlm/lm/builder/ngram.hh	/^const WordIndex kUNK = 0;$/;"	m	namespace:lm::builder
kUint64MSB	kenlm/util/double-conversion/diy-fp.h	/^  static const uint64_t kUint64MSB = UINT64_2PART_C(0x80000000, 00000000);$/;"	m	class:double_conversion::DiyFp
kUnknownCapHash	kenlm/lm/vocab.cc	/^const uint64_t kUnknownCapHash = detail::HashForVocab("<UNK>", 5);$/;"	m	namespace:lm::ngram::__anon28	file:
kUnknownHash	kenlm/lm/vocab.cc	/^const uint64_t kUnknownHash = detail::HashForVocab("<unk>", 5);$/;"	m	namespace:lm::ngram::__anon28	file:
kVersion	kenlm/lm/model.hh	/^    static const unsigned int kVersion = Search::kVersion;$/;"	m	class:lm::ngram::detail::GenericModel
kVersion	kenlm/lm/search_hashed.hh	/^    static const unsigned int kVersion = 0;$/;"	m	class:lm::ngram::detail::HashedSearch
kVersion	kenlm/lm/search_trie.hh	/^    static const unsigned int kVersion = 1;$/;"	m	class:lm::ngram::trie::TrieSearch
kWidth	kenlm/util/ersatz_progress.cc	/^namespace { const unsigned char kWidth = 100; }$/;"	m	namespace:util::__anon32	file:
kWidth	kenlm/util/stream/multi_progress.hh	/^    static const unsigned char kWidth = 100;$/;"	m	class:util::stream::MultiProgress
kenlm	HLVLM.h	/^typedef enum {fslm_ngram, fslm_latlm, kenlm} FSLMType;$/;"	e	enum:__anon1
key	kenlm/lm/builder/corpus_count.cc	/^  Key key;$/;"	m	struct:lm::builder::__anon9::DedupeEntry	file:
key	kenlm/lm/builder/corpus_count.cc	/^  uint64_t key;$/;"	m	struct:lm::builder::__anon9::VocabEntry	file:
key	kenlm/lm/search_hashed.hh	/^  uint64_t key;$/;"	m	struct:lm::ngram::detail::ProbEntry
key	kenlm/lm/value.hh	/^    Key key;$/;"	m	struct:lm::ngram::RestValue::ProbingEntry
key	kenlm/lm/value.hh	/^    uint64_t key;$/;"	m	struct:lm::ngram::BackoffValue::ProbingEntry
key	kenlm/lm/vocab.hh	/^  uint64_t key;$/;"	m	struct:lm::ngram::ProbingVocabularyEntry
key	kenlm/util/joint_sort.hh	/^      typename std::iterator_traits<KeyIter>::value_type key;$/;"	m	struct:util::detail::JointProxy::__anon40
key_	kenlm/util/joint_sort.hh	/^    KeyIter key_;$/;"	m	class:util::detail::JointIter
key_bits_	kenlm/lm/trie.cc	/^    const uint8_t key_bits_, total_bits_;$/;"	m	class:lm::ngram::trie::__anon25::KeyAccessor	file:
key_mask_	kenlm/lm/trie.cc	/^    const WordIndex key_mask_;$/;"	m	class:lm::ngram::trie::__anon25::KeyAccessor	file:
lMEMORYSTATUSEX	kenlm/util/usage.cc	/^} lMEMORYSTATUSEX;$/;"	t	typeref:struct:__anon48	file:
la	HLVRec.h	/^   LMCacheLA la[LMCACHE_NLA];$/;"	m	struct:_LMNodeCache
laHit	HLVRec.h	/^   int laHit;$/;"	m	struct:_LMCache
laMiss	HLVRec.h	/^   int laMiss;$/;"	m	struct:_LMCache
laTree	HLVNet.h	/^   LMlaTree *laTree;            \/* look ahead tree *\/$/;"	m	struct:_LexNet
la_cmp	HLVLM.c	/^static int la_cmp(const void *v1,const void *v2)$/;"	f	file:
labDir	HDecode.c	/^static char *labDir = NULL;	\/* output label file directory *\/$/;"	v	file:
labDir	HDecode.mod.c	/^static char *labDir = NULL;	\/* output label file directory *\/$/;"	v	file:
labExt	HDecode.c	/^static char *labExt = "rec";	\/* output label file extension *\/$/;"	v	file:
labExt	HDecode.mod.c	/^static char *labExt = "rec";	\/* output label file extension *\/$/;"	v	file:
labForm	HDecode.c	/^static char *labForm = NULL;	\/* output label format *\/$/;"	v	file:
labForm	HDecode.mod.c	/^static char *labForm = NULL;	\/* output label format *\/$/;"	v	file:
lablist	HLVLM.h	/^   LabId *lablist;              \/* Lookup table for LabIds from LMId *\/ $/;"	m	struct:_FSLM_ngram
langfn	HDecode.c	/^static char *langfn;		\/* LM filename from commandline *\/$/;"	v	file:
langfn	HDecode.mod.c	/^static char *langfn;		\/* LM filename from commandline *\/$/;"	v	file:
last	kenlm/util/double-conversion/utils.h	/^  T& last() { return start_[length_ - 1]; }$/;"	f	class:double_conversion::Vector
last_	kenlm/lm/filter/format.hh	/^    StringPiece last_;$/;"	m	class:lm::MultipleOutputBuffer
last_	kenlm/lm/filter/phrase.cc	/^    const Sentence *last_;$/;"	m	class:lm::phrase::detail::Arc	file:
last_space_	kenlm/util/file_piece.hh	/^    const char *position_, *last_space_, *position_end_;$/;"	m	class:util::FilePiece
latFileMask	HDecode.c	/^static char *latFileMask = NULL; \/* mask for reading lattice *\/$/;"	v	file:
latGen	HDecode.c	/^static Boolean latGen = FALSE;  \/* output lattice? *\/$/;"	v	file:
latGen	HDecode.mod.c	/^static Boolean latGen = FALSE;  \/* output lattice? *\/$/;"	v	file:
latInDir	HDecode.c	/^static char *latInDir = NULL;   \/* lattice input directory *\/$/;"	v	file:
latInDir	HDecode.mod.c	/^static char *latInDir = NULL;   \/* lattice input directory *\/$/;"	v	file:
latInExt	HDecode.c	/^static char *latInExt = "lat";  \/* latttice input extension *\/$/;"	v	file:
latInExt	HDecode.mod.c	/^static char *latInExt = "lat";  \/* latttice input extension *\/$/;"	v	file:
latOutDir	HDecode.c	/^static char *latOutDir = NULL;  \/* lattice output directory *\/$/;"	v	file:
latOutDir	HDecode.mod.c	/^static char *latOutDir = NULL;  \/* lattice output directory *\/$/;"	v	file:
latOutExt	HDecode.c	/^static char *latOutExt = "lat"; \/* latttice output extension *\/$/;"	v	file:
latOutExt	HDecode.mod.c	/^static char *latOutExt = "lat"; \/* latttice output extension *\/$/;"	v	file:
latOutForm	HDecode.c	/^static char *latOutForm = NULL;  \/* lattice output format *\/$/;"	v	file:
latOutForm	HDecode.mod.c	/^static char *latOutForm = NULL;  \/* lattice output format *\/$/;"	v	file:
latPruneAPS	HDecode.c	/^static LogFloat latPruneAPS = 0;;        \/* lattice pruning arcs per sec limit *\/$/;"	v	file:
latPruneAPS	HDecode.mod.c	/^static LogFloat latPruneAPS = 0;;        \/* lattice pruning arcs per sec limit *\/$/;"	v	file:
latPruneBeam	HDecode.c	/^static LogFloat latPruneBeam = - LZERO;  \/* lattice pruning beam width *\/$/;"	v	file:
latPruneBeam	HDecode.mod.c	/^static LogFloat latPruneBeam = - LZERO;  \/* lattice pruning beam width *\/$/;"	v	file:
latRescore	HDecode.c	/^static Boolean latRescore = FALSE; \/* read lattice for each utterance and rescore? *\/$/;"	v	file:
latRescore	HDecode.mod.c	/^static Boolean latRescore = FALSE; \/* read lattice for each utterance and rescore? *\/$/;"	v	file:
latgen	HLVRec.h	/^   Boolean latgen;              \/* generate lattices or just 1-bet? *\/$/;"	m	struct:_DecoderInst
latlm	HLVLM.h	/^      FSLM_latlm *latlm;$/;"	m	union:_FSLM::__anon2
layerId	HLVNet.h	/^   int layerId;$/;"	m	struct:_TLexNode
layerStart	HLVNet.h	/^   LexNode **layerStart;        \/* array of pointers to the first node in each layer *\/$/;"	m	struct:_LexNet
lc	HLVNet.h	/^   LabId lc;            \/* left context phone *\/$/;"	m	struct:_TLexNode
left	kenlm/lm/filter/phrase.hh	/^      std::vector<unsigned int> substring, left, right, phrase;$/;"	m	struct:lm::phrase::Substrings::SentenceRelation
left	kenlm/lm/state.hh	/^  Left left;$/;"	m	struct:lm::ngram::ChartState
left_done_	kenlm/lm/left.hh	/^    bool left_done_;$/;"	m	class:lm::ngram::RuleScore
length	kenlm/lm/state.hh	/^    unsigned char length;$/;"	m	class:lm::ngram::State
length	kenlm/lm/state.hh	/^  unsigned char length;$/;"	m	struct:lm::ngram::Left
length	kenlm/util/double-conversion/utils.h	/^  int length() const { return length_; }$/;"	f	class:double_conversion::Vector
length	kenlm/util/stream/sort.hh	/^      uint64_t length;$/;"	m	struct:util::stream::Offsets::Entry
length	kenlm/util/string_piece.hh	/^  size_type length() const { return length_; }$/;"	f	class:StringPiece
length_	kenlm/util/double-conversion/utils.h	/^  int length_;$/;"	m	class:double_conversion::Vector
length_	kenlm/util/string_piece.hh	/^  size_type     length_;$/;"	m	class:StringPiece
less_	kenlm/util/joint_sort.hh	/^    const Less less_;$/;"	m	class:util::detail::LessWrapper
letters	kenlm/util/file.cc	/^static const char letters[] =$/;"	m	namespace:util	file:
lexA	HLVNet.h	/^   LabId *lexA;$/;"	m	struct:_TLexNet
lexABhash	HLVNet.h	/^   TLexNode *lexABhash[LEX_CON_HASH_SIZE];$/;"	m	struct:_TLexNet
lexP	HLVNet.h	/^   LabId *lexP;$/;"	m	struct:_TLexNet
lexSAhash	HLVNet.h	/^   TLexNode *lexSAhash[LEX_CON_HASH_SIZE];$/;"	m	struct:_TLexNet
lexYZhash	HLVNet.h	/^   TLexNode *lexYZhash[LEX_CON_HASH_SIZE];$/;"	m	struct:_TLexNet
lexZ	HLVNet.h	/^   LabId *lexZ;$/;"	m	struct:_TLexNet
lexZShash	HLVNet.h	/^   TLexNode *lexZShash[LEX_CON_HASH_SIZE];$/;"	m	struct:_TLexNet
libdir	Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libexecdir	Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
line	kenlm/lm/filter/format.hh	/^      StringPiece line;$/;"	m	struct:lm::MultipleOutputBuffer::Annotated
line	kenlm/lm/filter/format.hh	/^      std::string line;$/;"	m	struct:lm::InputBuffer::Line
line_	kenlm/lm/filter/vocab.hh	/^        const StringPiece &line_;$/;"	m	class:lm::vocab::Multiple::Callback
lines_	kenlm/lm/filter/format.hh	/^    std::vector<Line> lines_;$/;"	m	class:lm::InputBuffer
lines_	kenlm/lm/filter/format.hh	/^    std::vector<StringPiece> lines_;$/;"	m	class:lm::BinaryOutputBuffer
link	HLVLM.h	/^   struct nentry *link;         \/* Next entry in hash table *\/$/;"	m	struct:nentry	typeref:struct:nentry::nentry
link	HLVNet.c	/^   STLexLink *link[2];$/;"	m	struct:_STLexNode	file:
link	HLVNet.h	/^   TLexLink *link;		\/* linked list of  TLexLinks to successor nodes *\/$/;"	m	struct:_TLexNode
ll	HDecode.c	/^   LLink ll;           \/* get rid of this? currently start\/end are redundant *\/$/;"	m	struct:_BestInfo	file:
ll	HDecode.mod.c	/^   LLink ll;           \/* get rid of this? currently start\/end are redundant *\/$/;"	m	struct:_BestInfo	file:
lm	HLVRec.h	/^   FSLM *lm;$/;"	m	struct:_DecoderInst
lm	HLVRec.h	/^   LMTokScore lm;               \/* LM likelihood of this word given history *\/$/;"	m	struct:_AltWordendHyp
lm	HLVRec.h	/^   LMTokScore lm;               \/* LM likelihood of this word given history *\/$/;"	m	struct:_WordendHyp
lm	kenlm/lm/bhiksha.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/bhiksha.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/binary_format.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/binary_format.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/blank.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/builder/adjust_counts.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	kenlm/lm/builder/adjust_counts.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/builder/corpus_count.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/builder/corpus_count.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/builder/discount.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/builder/hash_gamma.hh	/^namespace lm { namespace builder {$/;"	n
lm	kenlm/lm/builder/initial_probabilities.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	kenlm/lm/builder/initial_probabilities.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/builder/interpolate.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	kenlm/lm/builder/interpolate.hh	/^namespace lm { namespace builder {$/;"	n
lm	kenlm/lm/builder/joint_order.hh	/^namespace lm { namespace builder {$/;"	n
lm	kenlm/lm/builder/ngram.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/builder/ngram_stream.hh	/^namespace lm { namespace builder {$/;"	n
lm	kenlm/lm/builder/output.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	kenlm/lm/builder/output.hh	/^namespace lm { namespace builder {$/;"	n
lm	kenlm/lm/builder/pipeline.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	kenlm/lm/builder/pipeline.hh	/^namespace lm { namespace builder {$/;"	n
lm	kenlm/lm/builder/print.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	kenlm/lm/builder/print.hh	/^namespace lm { namespace builder {$/;"	n
lm	kenlm/lm/builder/sort.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/config.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/config.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/enumerate_vocab.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/facade.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/filter/arpa_io.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/filter/arpa_io.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/filter/count_io.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/filter/format.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/filter/phrase.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/filter/phrase.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/filter/thread.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/filter/vocab.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/filter/vocab.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/filter/wrapper.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/interpolate/arpa_to_stream.cc	/^namespace lm { namespace interpolate {$/;"	n	file:
lm	kenlm/lm/interpolate/arpa_to_stream.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/left.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/lm_exception.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/lm_exception.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/model.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/model.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/model_type.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/neural/wordvecs.cc	/^namespace lm { namespace neural {$/;"	n	file:
lm	kenlm/lm/neural/wordvecs.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/ngram_query.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/partial.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/quantize.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/quantize.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/read_arpa.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/read_arpa.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/return.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/search_hashed.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/search_hashed.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/search_trie.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/search_trie.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/sizes.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/sizes.hh	/^namespace lm { namespace ngram {$/;"	n
lm	kenlm/lm/state.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/trie.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/trie.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/trie_sort.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/trie_sort.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/value.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/value_build.cc	/^namespace lm { $/;"	n	file:
lm	kenlm/lm/value_build.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/virtual_interface.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/virtual_interface.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/vocab.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/vocab.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/weights.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/word_index.hh	/^namespace lm {$/;"	n
lm	kenlm/lm/wrappers/nplm.cc	/^namespace lm {$/;"	n	file:
lm	kenlm/lm/wrappers/nplm.hh	/^namespace lm {$/;"	n
lmCache	HLVRec.h	/^   LMCache *lmCache;$/;"	m	struct:_DecoderInst
lmHeap	HDecode.c	/^static MemHeap lmHeap;$/;"	v	file:
lmHeap	HDecode.mod.c	/^static MemHeap lmHeap;$/;"	v	file:
lmScale	HDecode.c	/^static float lmScale = 1.0;     \/* LM scaling factor *\/$/;"	v	file:
lmScale	HDecode.mod.c	/^static float lmScale = 1.0;     \/* LM scaling factor *\/$/;"	v	file:
lmScale	HLVRec.h	/^   float lmScale;               \/* LM scaling factor *\/$/;"	m	struct:_DecoderInst
lmState	HLVRec.h	/^   LMState lmState;$/;"	m	struct:_RelToken
lmState	HLVRec.h	/^   LMState lmState;$/;"	m	struct:_Token
lmState_kenlm	HLVRec.h	/^   lm::ngram::State lmState_kenlm;$/;"	m	struct:_RelToken
lm_htk	HDecode.c	/^static FSLM *lm_htk;                \/* language model *\/$/;"	v	file:
lm_htk	HDecode.mod.c	/^static FSLM *lm_htk;                \/* language model *\/$/;"	v	file:
lm_kenlm	HDecode.c	/^lm::base::Model *lm_kenlm;         \/* language model using kenlm*\/$/;"	v
lm_kenlm	HLVRec.h	/^   lm::base::Model *lm_kenlm;$/;"	m	struct:_DecoderInst
lmlaCount	HLVNet.h	/^   int lmlaCount;       \/* number of unique look ahead intervals *\/$/;"	m	struct:_TLexNet
lmlaIdx	HLVNet.h	/^   int *lmlaIdx;$/;"	m	struct:_CompLMlaNode
lmlaIdx	HLVNet.h	/^   int lmlaIdx;         \/* index of node in (compressed) LMlaTree *\/$/;"	m	struct:_TLexNode
lmlaIdx	HLVNet.h	/^   unsigned int lmlaIdx;        \/* Idx of corresponding node in compressed LM $/;"	m	struct:_LexNode
lmscore	HLVRec.h	/^   LMTokScore lmscore;          \/* LM lookahead score for current word *\/$/;"	m	struct:_RelToken
lmscore	HLVRec.h	/^   LMTokScore lmscore;          \/* LM lookahead score for current word *\/$/;"	m	struct:_Token
ln	HDecode.c	/^   LexNode *ln;$/;"	m	struct:_BestInfo	file:
ln	HDecode.mod.c	/^   LexNode *ln;$/;"	m	struct:_BestInfo	file:
ln	HLVNet.h	/^   LexNode *ln;        \/* the actual Lexicon Node *\/$/;"	m	struct:_TLexNode
ln	HLVRec.h	/^   LexNode *ln;                 \/* lexnode that finished *\/$/;"	m	struct:_ModendHyp
lnDeadT	HLVRec.h	/^   unsigned long lnDeadT[STATS_MAXT+1];$/;"	m	struct:_Stats
lnINF	HLVRec.h	/^   unsigned long lnINF;$/;"	m	struct:_Stats
lnLiveT	HLVRec.h	/^   unsigned long lnLiveT[STATS_MAXT+1];$/;"	m	struct:_Stats
lnSEsil	HLVNet.h	/^   LexNode *lnSEsil;            \/* sil lexnode leading to SENT_END *\/$/;"	m	struct:_LexNet
lnSEsil	HLVNet.h	/^   TLexNode *lnSEsil;            \/* sil lexnode leading to SENT_END *\/$/;"	m	struct:_TLexNet
lnSEsp	HLVNet.h	/^   LexNode *lnSEsp;             \/* sp lexnode leading to SENT_END *\/$/;"	m	struct:_LexNet
lnSEsp	HLVNet.h	/^   TLexNode *lnSEsp;             \/* sp lexnode leading to SENT_END *\/$/;"	m	struct:_TLexNet
loWE	HLVNet.h	/^   LMId loWE;$/;"	m	struct:_LMlaNode
loWE	HLVNet.h	/^   int loWE;            \/* lowest WE LMId reachable from here *\/$/;"	m	struct:_TLexNode
load_method	kenlm/lm/config.hh	/^  util::LoadMethod load_method;$/;"	m	struct:lm::ngram::Config
load_method_	kenlm/lm/binary_format.hh	/^    util::LoadMethod load_method_;$/;"	m	class:lm::ngram::BinaryFormat
local_read_	kenlm/lm/filter/thread.hh	/^    std::stack<Batch*> local_read_;$/;"	m	class:lm::Controller
localstatedir	Makefile	/^localstatedir = ${prefix}\/var$/;"	m
log_	kenlm/util/stream/sort.hh	/^    int log_;$/;"	m	class:util::stream::Offsets
longest_	kenlm/lm/quantize.hh	/^    Bins longest_;$/;"	m	class:lm::ngram::SeparatelyQuantize
longest_	kenlm/lm/search_hashed.hh	/^    Longest longest_;$/;"	m	class:lm::ngram::detail::HashedSearch
longest_	kenlm/lm/search_trie.cc	/^    BitPackedLongest &longest_;$/;"	m	class:lm::ngram::trie::__anon24::WriteEntries	file:
longest_	kenlm/lm/search_trie.hh	/^    Longest longest_;$/;"	m	class:lm::ngram::trie::TrieSearch
lookahead	HLVLM.h	/^   LogFloat (*lookahead) (FSLM *lm, LMState src, PronId minPron, PronId maxPron);$/;"	m	struct:_FSLM
lookup_	kenlm/lm/vocab.hh	/^    Lookup lookup_;$/;"	m	class:lm::ngram::GrowableVocab
lookup_	kenlm/lm/vocab.hh	/^    Lookup lookup_;$/;"	m	class:lm::ngram::ProbingVocabulary
low_bits_	kenlm/util/double-conversion/fixed-dtoa.cc	/^  uint64_t low_bits_;$/;"	m	class:double_conversion::UInt128	file:
lrelTokHeap	HLVRec.h	/^   MemHeap lrelTokHeap;         \/* MHEAP for larger size RelToken arrays (e.g. 6 * dec->nTok-1 elements) *\/$/;"	m	struct:_DecoderInst
magic	kenlm/lm/binary_format.cc	/^  char magic[ALIGN8(sizeof(kMagicBytes))];$/;"	m	struct:lm::ngram::__anon7::Sanity	file:
magic	kenlm/lm/binary_format.cc	/^  char magic[sizeof(kMagicBytes)];$/;"	m	struct:lm::ngram::__anon7::OldSanity	file:
main	HDecode.c	/^main (int argc, char *argv[])$/;"	f
main	HDecode.mod.c	/^main (int argc, char *argv[])$/;"	f
make_full	kenlm/lm/partial.hh	/^  bool make_full;$/;"	m	struct:lm::ngram::ExtendReturn
mandir	Makefile	/^mandir = ${prefix}\/share\/man$/;"	m
map_	kenlm/lm/builder/print.hh	/^    std::vector<const char*> map_;$/;"	m	class:lm::builder::VocabReconstitute
mapped_offset_	kenlm/util/file_piece.hh	/^    uint64_t mapped_offset_;$/;"	m	class:util::FilePiece
mapping_	kenlm/lm/binary_format.hh	/^    util::scoped_memory mapping_;$/;"	m	class:lm::ngram::BinaryFormat
mask	kenlm/util/bit_packing.hh	/^  uint64_t mask;$/;"	m	struct:util::BitsMask
mask_	kenlm/lm/quantize.hh	/^        uint64_t mask_;$/;"	m	class:lm::ngram::SeparatelyQuantize::Bins
master_	kenlm/lm/builder/output.hh	/^    const Output *master_;$/;"	m	class:lm::builder::OutputHook
max	kenlm/util/string_piece.hh	91;"	d
maxLMLA	HLVRec.c	/^static LogFloat maxLMLA = -LZERO; \/* maximum jump in LM lookahead per model *\/$/;"	v	file:
maxLMLA	HLVRec.h	/^   float maxLMLA;               \/* maximum jump in LM lookahead per model *\/$/;"	m	struct:_DecoderInst
maxLNBeamFlr	HLVRec.c	/^static float maxLNBeamFlr = 0.8;        \/* maximum percentile of glogal beam for max model pruning *\/$/;"	v	file:
maxModel	HDecode.c	/^static int maxModel = 0;        \/* max model pruning *\/$/;"	v	file:
maxModel	HDecode.mod.c	/^static int maxModel = 0;        \/* max model pruning *\/$/;"	v	file:
maxModel	HLVRec.h	/^   int maxModel;                \/* for max model pruning (set by -u cmd line option) *\/$/;"	m	struct:_DecoderInst
maxNStates	HLVRec.h	/^   int maxNStates;              \/* max number of states in a HMM in HMMSet *\/$/;"	m	struct:_DecoderInst
max_leading_padding_zeroes_in_precision_mode_	kenlm/util/double-conversion/double-conversion.h	/^  const int max_leading_padding_zeroes_in_precision_mode_;$/;"	m	class:double_conversion::DoubleToStringConverter
max_size	kenlm/util/string_piece.hh	/^  size_type max_size() const { return length_; }$/;"	f	class:StringPiece
max_trailing_padding_zeroes_in_precision_mode_	kenlm/util/double-conversion/double-conversion.h	/^  const int max_trailing_padding_zeroes_in_precision_mode_;$/;"	m	class:double_conversion::DoubleToStringConverter
max_vocab_	kenlm/lm/trie.hh	/^    uint64_t insert_index_, max_vocab_;$/;"	m	class:lm::ngram::trie::BitPacked
max_word_index	kenlm/lm/binary_format.cc	/^  WordIndex one_word_index, max_word_index, padding_to_8;$/;"	m	struct:lm::ngram::__anon7::Sanity	file:
max_word_index	kenlm/lm/binary_format.cc	/^  WordIndex one_word_index, max_word_index;$/;"	m	struct:lm::ngram::__anon7::OldSanity	file:
mem_	kenlm/util/mmap.hh	/^    scoped_memory mem_;$/;"	m	class:util::Rolling
mem_	kenlm/util/probing_hash_table.hh	/^    util::scoped_malloc mem_;$/;"	m	class:util::AutoProbing
mem_	kenlm/util/stream/block.hh	/^    void *mem_;$/;"	m	class:util::stream::Block
memory_	kenlm/lm/builder/print.hh	/^    util::scoped_memory memory_;$/;"	m	class:lm::builder::VocabReconstitute
memory_	kenlm/util/stream/chain.hh	/^    scoped_malloc memory_;$/;"	m	class:util::stream::Chain
memory_search_	kenlm/lm/binary_format.hh	/^    util::scoped_memory memory_vocab_, memory_search_;$/;"	m	class:lm::ngram::BinaryFormat
memory_vocab_	kenlm/lm/binary_format.hh	/^    util::scoped_memory memory_vocab_, memory_search_;$/;"	m	class:lm::ngram::BinaryFormat
mergeTokOnly	HLVRec.c	/^static Boolean mergeTokOnly = TRUE;     \/* if merge token set with pruning *\/$/;"	v	file:
messages	kenlm/lm/config.hh	/^  std::ostream *messages;$/;"	m	struct:lm::ngram::Config
messages_	kenlm/lm/search_trie.cc	/^    BackoffMessages messages_[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::trie::__anon24::SRISucks	file:
middle_	kenlm/lm/search_hashed.hh	/^    std::vector<Middle> middle_;$/;"	m	class:lm::ngram::detail::HashedSearch
middle_	kenlm/lm/search_trie.cc	/^    BitPackedMiddle<Bhiksha> *const middle_;$/;"	m	class:lm::ngram::trie::__anon24::WriteEntries	file:
middle_begin_	kenlm/lm/search_trie.hh	/^    Middle *middle_begin_, *middle_end_;$/;"	m	class:lm::ngram::trie::TrieSearch
middle_end_	kenlm/lm/search_trie.hh	/^    Middle *middle_begin_, *middle_end_;$/;"	m	class:lm::ngram::trie::TrieSearch
min	kenlm/util/string_piece.hh	92;"	d
minimum_block	kenlm/lm/builder/pipeline.hh	/^  std::size_t minimum_block;$/;"	m	struct:lm::builder::PipelineConfig
minus_half_f	kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon7::OldSanity	file:
minus_half_f	kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon7::Sanity	file:
mixOutP	HLVRec.h	/^   LogFloat *mixOutP;$/;"	m	struct:_OutPCache
mixPerBlock	HLVModel.h	/^   unsigned long mixPerBlock;$/;"	m	struct:_StateInfo_lv
mixT	HLVRec.h	/^   int *mixT;$/;"	m	struct:_OutPCache
mkstemp_and_unlink	kenlm/util/file.cc	/^mkstemp_and_unlink(char *tmpl) {$/;"	f	namespace:util
mkstemp_and_unlink	kenlm/util/file.cc	/^mkstemp_and_unlink(char *tmpl)$/;"	f	namespace:util
modAlign	HLVRec.h	/^   Boolean modAlign;$/;"	m	struct:_DecoderInst
modelHeap	HDecode.c	/^static MemHeap modelHeap;$/;"	v	file:
modelHeap	HDecode.mod.c	/^static MemHeap modelHeap;$/;"	v	file:
model_	kenlm/lm/left.hh	/^    const M &model_;$/;"	m	class:lm::ngram::RuleScore
model_type	kenlm/lm/binary_format.hh	/^  ModelType model_type;$/;"	m	struct:lm::ngram::FixedWidthParameters
models_	kenlm/lm/value_build.hh	/^    std::vector<const Model*> models_;$/;"	m	class:lm::ngram::LowerRestBuild
modendHypHeap	HLVRec.h	/^   MemHeap modendHypHeap;       \/* MHEAP for word end hyps *\/$/;"	m	struct:_DecoderInst
modify_	kenlm/lm/search_hashed.cc	/^    Middle &modify_;$/;"	m	class:lm::ngram::__anon23::ActivateLowerMiddle	file:
modify_	kenlm/lm/search_hashed.cc	/^    Weights *modify_;$/;"	m	class:lm::ngram::__anon23::ActivateUnigram	file:
modpath	HLVRec.h	/^   ModendHyp *modpath;          \/* model level traceback *\/$/;"	m	struct:_AltWordendHyp
modpath	HLVRec.h	/^   ModendHyp *modpath;          \/* model level traceback *\/$/;"	m	struct:_RelToken
modpath	HLVRec.h	/^   ModendHyp *modpath;          \/* model level traceback *\/$/;"	m	struct:_WordendHyp
monoId	HLVNet.c	/^      LabId monoId;$/;"	m	union:_STLexNode::__anon3	file:
monoPhone	HLVRec.h	/^   LabId monoPhone[100];           \/* #### hard limit -- fix this *\/$/;"	m	struct:_DecoderInst
mts_copy	HLVRec-propagate.c	/^static int mts_copy = 0;$/;"	v	file:
mts_fast	HLVRec-propagate.c	/^static int mts_fast = 0;$/;"	v	file:
mts_newid	HLVRec-propagate.c	/^static int mts_newid = 0;$/;"	v	file:
mts_newidNTOK	HLVRec-propagate.c	/^static int mts_newidNTOK = 0;$/;"	v	file:
mts_slow	HLVRec-propagate.c	/^static int mts_slow = 0;$/;"	v	file:
mutex_	kenlm/util/stream/multi_progress.hh	/^    boost::mutex mutex_;$/;"	m	class:util::stream::MultiProgress
n	HLVNet.h	/^   int n;$/;"	m	struct:_CompLMlaNode
n	HLVRec.h	/^   unsigned short n;$/;"	m	struct:_TokenSet
n	kenlm/lm/builder/adjust_counts.cc	/^      uint64_t n[5];$/;"	m	struct:lm::builder::__anon8::StatCollector::OrderStat	file:
nActivate	HLVRec.h	/^   unsigned long nActivate;$/;"	m	struct:_Stats
nActive	HLVRec.h	/^   unsigned long nActive;$/;"	m	struct:_Stats
nBlocks	HLVModel.h	/^   unsigned long nBlocks;$/;"	m	struct:_StateInfo_lv
nCompNodes	HLVNet.h	/^   int nCompNodes;              \/* number of complex nodes in LM LA tree *\/$/;"	m	struct:_LMlaTree
nDeActivate	HLVRec.h	/^   unsigned long nDeActivate;$/;"	m	struct:_Stats
nDim	HLVModel.h	/^   unsigned long nDim;         \/* real number of dimensions, e.g. 39 *\/$/;"	m	struct:_StateInfo_lv
nEntries	HLVRec.h	/^   int nEntries;$/;"	m	struct:_LMNodeCache
nFrames	HLVRec.h	/^   unsigned long nFrames;$/;"	m	struct:_Stats
nInst	HLVRec-misc.c	/^   int nInst;$/;"	m	struct:_LayerStats	file:
nLMlaCacheHit	HLVRec.h	/^   unsigned long nLMlaCacheHit;$/;"	m	struct:_Stats
nLMlaCacheMiss	HLVRec.h	/^   unsigned long nLMlaCacheMiss;$/;"	m	struct:_Stats
nLayers	HLVNet.h	/^   int nLayers;                 \/* nuber of node layers *\/$/;"	m	struct:_LexNet
nLayers	HLVRec.h	/^   int nLayers;                 \/* nuber of node layers *\/$/;"	m	struct:_DecoderInst
nMix	HLVRec.h	/^   int nMix;$/;"	m	struct:_OutPCache
nNode	HLVRec.h	/^   int nNode;$/;"	m	struct:_LMCache
nNodeA	HLVNet.h	/^   int nNodeA;         \/* hastable of A LexNodes *\/$/;"	m	struct:_TLexNet
nNodeBY	HLVNet.h	/^   int nNodeBY;         \/* linked list of nodes in main prefix tree B -- Y *\/$/;"	m	struct:_TLexNet
nNodeSIL	HLVNet.h	/^   int nNodeSIL;         \/* linked list of silencs (sil\/sp) nodes between ZS and SA *\/$/;"	m	struct:_TLexNet
nNodeZ	HLVNet.h	/^   int nNodeZ;         \/* hastable of Z LexNodes *\/$/;"	m	struct:_TLexNet
nNodes	HLVNet.h	/^   int nNodes;                  \/* number of nodes in LM LA tree *\/$/;"	m	struct:_LMlaTree
nNodes	HLVNet.h	/^   int nNodes;$/;"	m	struct:_LexNet
nNodesLayer	HLVNet.h	/^   int nNodesLayer[NLAYERS]; \/* number of nodes in each layer *\/$/;"	m	struct:_TLexNet
nObs	HLVRec.h	/^   int nObs;                    \/* num of valid obs in bock *\/$/;"	m	struct:_DecoderInst
nParm	HDecode.c	/^static int nParm = 0;		\/* total num params *\/$/;"	v	file:
nParm	HDecode.mod.c	/^static int nParm = 0;		\/* total num params *\/$/;"	v	file:
nParm	HLVLM.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLVModel.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLVNet.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLVRec.c	/^static int nParm = 0;$/;"	v	file:
nPhone	HLVRec.h	/^   int nPhone;$/;"	m	struct:_DecoderInst
nPronIds	HLVNet.h	/^   int nPronIds;        \/* number of wordend Ids assigned, should be = voc->nprons *\/$/;"	m	struct:_TLexNet
nStates	HLVRec.h	/^   int nStates;$/;"	m	struct:_OutPCache
nTS	HLVRec-misc.c	/^   int nTS;$/;"	m	struct:_LayerStats	file:
nTok	HDecode.c	/^static int nTok = 32;           \/* number of different LMStates per HMM state *\/$/;"	v	file:
nTok	HDecode.mod.c	/^static int nTok = 32;           \/* number of different LMStates per HMM state *\/$/;"	v	file:
nTok	HLVRec-misc.c	/^   int nTok;$/;"	m	struct:_LayerStats	file:
nTok	HLVRec.h	/^   int nTok;                    \/* max number of tokens per state *\/$/;"	m	struct:_DecoderInst
nTokSet	HLVRec.h	/^   unsigned long nTokSet;$/;"	m	struct:_Stats
nVec	HLVModel.h	/^   unsigned long nVec;         \/* number of vecotrs (e.g. 10 = RoundAlign (nDim,  HLVMODEL_VEC_PAD) *\/$/;"	m	struct:_StateInfo_lv
name	HLVLM.h	/^   char *name;$/;"	m	struct:_FSLM
name_guess_	kenlm/util/file.hh	/^    std::string name_guess_;$/;"	m	class:util::FDException
nan_symbol_	kenlm/util/double-conversion/double-conversion.h	/^  const char* const nan_symbol_;$/;"	m	class:double_conversion::DoubleToStringConverter
nan_symbol_	kenlm/util/double-conversion/double-conversion.h	/^  const char* const nan_symbol_;$/;"	m	class:double_conversion::StringToDoubleConverter
nebo	HLVLM.h	/^   struct nentry *nebo;                \/* NEntry for back-off *\/$/;"	m	struct:nentry	typeref:struct:nentry::nentry
nentry	HLVLM.h	/^typedef struct nentry {         \/* HLM NGram history *\/$/;"	s
net	HDecode.c	/^static LexNet *net;             \/* Lexicon network of all required words\/prons *\/$/;"	v	file:
net	HDecode.mod.c	/^static LexNet *net;             \/* Lexicon network of all required words\/prons *\/$/;"	v	file:
net	HLVRec.h	/^   LexNet *net;                 \/* network, contains pointers to Vocab and HMMSet *\/$/;"	m	struct:_DecoderInst
netHeap	HDecode.c	/^static MemHeap netHeap;$/;"	v	file:
netHeap	HDecode.mod.c	/^static MemHeap netHeap;$/;"	v	file:
neural	kenlm/lm/neural/wordvecs.cc	/^namespace lm { namespace neural {$/;"	n	namespace:lm	file:
neural	kenlm/lm/neural/wordvecs.hh	/^namespace neural {$/;"	n	namespace:lm
new_word_	kenlm/lm/vocab.hh	/^    NewWordAction new_word_;$/;"	m	class:lm::ngram::GrowableVocab
newed_end_	kenlm/util/fixed_array.hh	/^    T *newed_end_;$/;"	m	class:util::FixedArray
next	HDecode.c	/^   BestInfo *next;$/;"	m	struct:_BestInfo	file:
next	HDecode.mod.c	/^   BestInfo *next;$/;"	m	struct:_BestInfo	file:
next	HLVNet.c	/^   STLexLink *next[2];$/;"	m	struct:_STLexLink	file:
next	HLVNet.h	/^   TLexLink *next;              \/* next link from this start node *\/$/;"	m	struct:_TLexLink
next	HLVNet.h	/^   TLexNode *next;               \/* next node in hash table for some net part (A, B..Y or Z) *\/$/;"	m	struct:_TLexNode
next	HLVRec.h	/^   AltWordendHyp *next;$/;"	m	struct:_AltWordendHyp
next	HLVRec.h	/^   LexNodeInst *next;           \/* next instance in linked linst for this layer *\/$/;"	m	struct:_LexNodeInst
next	HLVRec.h	/^   struct _LMLACacheEntry *next;$/;"	m	struct:_LMLACacheEntry	typeref:struct:_LMLACacheEntry::_LMLACacheEntry
next	kenlm/lm/trie.hh	/^  uint64_t next;$/;"	m	struct:lm::ngram::trie::UnigramValue
next	kenlm/lm/value.hh	/^    uint64_t next;$/;"	m	struct:lm::ngram::BackoffValue::TrieUnigramValue
next	kenlm/lm/value.hh	/^    uint64_t next;$/;"	m	struct:lm::ngram::RestValue::TrieUnigramValue
nextFree	HLVRec.h	/^   int nextFree;$/;"	m	struct:_LMNodeCache
next_	kenlm/lm/bhiksha.hh	/^    util::BitsMask next_;$/;"	m	class:lm::ngram::trie::DontBhiksha
next_	kenlm/util/ersatz_progress.hh	/^    uint64_t current_, next_, complete_;$/;"	m	class:util::ErsatzProgress
next_	kenlm/util/stream/multi_progress.hh	/^    uint64_t current_, next_;$/;"	m	class:util::stream::WorkerProgress
next_inline_	kenlm/lm/bhiksha.hh	/^    const util::BitsMask next_inline_;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
next_source_	kenlm/lm/trie.hh	/^    const BitPacked *next_source_;$/;"	m	class:lm::ngram::trie::BitPackedMiddle
next_use	kenlm/lm/partial.hh	/^  unsigned char next_use;$/;"	m	struct:lm::ngram::ExtendReturn
nfoll	HLVLM.h	/^   int nfoll;$/;"	m	struct:_FSLM_LatNode
nfoll	HLVNet.h	/^   short nfoll;$/;"	m	struct:_LexNode
nglm	HLVLM.h	/^      FSLM_ngram *nglm;$/;"	m	union:_FSLM::__anon2
ngram	kenlm/lm/bhiksha.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/bhiksha.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/binary_format.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/binary_format.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/blank.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/config.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/config.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/filter/format.hh	/^      StringPiece ngram;$/;"	m	struct:lm::InputBuffer::Line
ngram	kenlm/lm/interpolate/arpa_to_stream.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/left.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/model.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/model.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/model_type.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/ngram_query.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/partial.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/quantize.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/quantize.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/search_hashed.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/search_hashed.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/search_trie.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/search_trie.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/sizes.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/sizes.hh	/^namespace lm { namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/state.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/trie.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/trie.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/trie_sort.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/trie_sort.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/value.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/value_build.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/value_build.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	kenlm/lm/vocab.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	kenlm/lm/vocab.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram_length	kenlm/lm/return.hh	/^  unsigned char ngram_length;$/;"	m	struct:lm::FullScoreReturn
nlexA	HLVNet.h	/^   int nlexA;           \/* array of initial phones *\/$/;"	m	struct:_TLexNet
nlexAB	HLVNet.h	/^   int nlexAB;          \/* hastable of A-B contexts *\/$/;"	m	struct:_TLexNet
nlexP	HLVNet.h	/^   int nlexP;           \/* array of phones in single phone words*\/$/;"	m	struct:_TLexNet
nlexSA	HLVNet.h	/^   int nlexSA;         \/* hastable of (Z+'sil') - A contexts *\/$/;"	m	struct:_TLexNet
nlexYZ	HLVNet.h	/^   int nlexYZ;         \/* hastable of Y-Z contexts *\/$/;"	m	struct:_TLexNet
nlexZ	HLVNet.h	/^   int nlexZ;           \/* array of final phones *\/$/;"	m	struct:_TLexNet
nlexZS	HLVNet.h	/^   int nlexZS;         \/* hastable of Z - (A+'sil') contexts *\/$/;"	m	struct:_TLexNet
nlinks	HLVNet.h	/^   int nlinks;$/;"	m	struct:_TLexNode
nnodes	HLVLM.h	/^   int nnodes;$/;"	m	struct:_FSLM_latlm
node	HLVNet.c	/^   STLexNode *node[2];  \/* numbered left to right *\/$/;"	m	struct:_STLexLink	file:
node	HLVNet.h	/^   LMlaNode *node;              \/* [0..nNodes-1] arry of entries *\/$/;"	m	struct:_LMlaTree
node	HLVNet.h	/^   LexNode *node;               \/* pointer to array of LexNodes *\/$/;"	m	struct:_LexNet
node	HLVRec.h	/^   LMNodeCache **node;$/;"	m	struct:_LMCache
node	HLVRec.h	/^   LexNode *node;$/;"	m	struct:_LexNodeInst
nodeAhash	HLVNet.h	/^   TLexNode *nodeAhash[LEX_MOD_HASH_SIZE];$/;"	m	struct:_TLexNet
nodeBY	HLVNet.h	/^   TLexNode *nodeBY;$/;"	m	struct:_TLexNet
nodeHeap	HLVRec.h	/^   MemHeap nodeHeap;            \/* MHEAP for LMNodeCache entries *\/$/;"	m	struct:_LMCache
nodeInstanceHeap	HLVRec.h	/^   MemHeap nodeInstanceHeap;    \/* MHEAP for LexNodeInsts *\/$/;"	m	struct:_DecoderInst
nodeSIL	HLVNet.h	/^   TLexNode *nodeSIL;$/;"	m	struct:_TLexNet
nodeZhash	HLVNet.h	/^   TLexNode *nodeZhash[LEX_MOD_HASH_SIZE];$/;"	m	struct:_TLexNet
not_found_	kenlm/lm/virtual_interface.hh	/^    WordIndex begin_sentence_, end_sentence_, not_found_;$/;"	m	class:lm::base::Vocabulary
np	kenlm/lm/wrappers/nplm.cc	/^namespace np {$/;"	n	namespace:lm	file:
np	kenlm/lm/wrappers/nplm.hh	/^namespace np {$/;"	n	namespace:lm
nplm	kenlm/lm/wrappers/nplm.hh	/^namespace nplm {$/;"	n
npos	kenlm/util/string_piece.cc	/^const size_type StringPiece::npos = size_type(-1);$/;"	m	class:StringPiece	file:
npos	kenlm/util/string_piece.hh	/^  static const size_type npos;$/;"	m	class:StringPiece
nse	HLVLM.h	/^   LMId nse;                    \/* Number of ngrams for this entry *\/$/;"	m	struct:nentry
nsize	HLVLM.h	/^   int nsize;                   \/* Unigram==1, Bigram==2, Trigram==3 *\/$/;"	m	struct:_FSLM_ngram
null_context_	kenlm/lm/facade.hh	/^    State begin_sentence_, null_context_;$/;"	m	class:lm::base::ModelFacade
null_context_memory_	kenlm/lm/virtual_interface.hh	/^    const void *begin_sentence_memory_, *null_context_memory_;$/;"	m	class:lm::base::Model
null_word_	kenlm/lm/wrappers/nplm.hh	/^    const lm::WordIndex null_word_;$/;"	m	class:lm::np::Vocabulary
null_word_	kenlm/lm/wrappers/nplm.hh	/^    lm::WordIndex null_word_;$/;"	m	class:lm::np::Model
obs	HDecode.c	/^static Observation *obs;        \/* array of Observations *\/$/;"	v	file:
obs	HDecode.mod.c	/^static Observation *obs;        \/* array of Observations *\/$/;"	v	file:
obs	HLVRec.h	/^   Observation *obs;            \/* Observation for current frame *\/$/;"	m	struct:_DecoderInst
obsBlock	HLVRec.h	/^   Observation *obsBlock[MAXBLOCKOBS]; \/* block of current and future Observations *\/$/;"	m	struct:_DecoderInst
offset	kenlm/util/bit_packing.hh	/^  uint64_t offset;$/;"	m	struct:util::BitAddress
offset	kenlm/util/parallel_read.cc	/^      uint64_t offset;$/;"	m	struct:util::__anon44::Reader::Request	file:
offset_	kenlm/util/stream/sort.hh	/^        uint64_t remaining_, offset_;$/;"	m	class:util::stream::MergeQueue::Entry
offset_begin_	kenlm/lm/bhiksha.hh	/^    const uint64_t *const offset_begin_;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
offset_end_	kenlm/lm/bhiksha.hh	/^    const uint64_t *const offset_end_;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
offsets_	kenlm/util/stream/sort.hh	/^    Offsets *offsets_;$/;"	m	class:util::stream::BlockSorter
offsets_	kenlm/util/stream/sort.hh	/^    Offsets offsets_;$/;"	m	class:util::stream::OwningMergingReader
offsets_	kenlm/util/stream/sort.hh	/^    Offsets offsets_;$/;"	m	class:util::stream::Sort
offsets_file_	kenlm/util/stream/sort.hh	/^    scoped_fd offsets_file_;$/;"	m	class:util::stream::Sort
ofmt	HDecode.c	/^static FileFormat ofmt = UNDEFF;	\/* Label output file format *\/$/;"	v	file:
ofmt	HDecode.mod.c	/^static FileFormat ofmt = UNDEFF;	\/* Label output file format *\/$/;"	v	file:
oldincludedir	Makefile	/^oldincludedir = \/usr\/include$/;"	m
one_f	kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon7::OldSanity	file:
one_f	kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon7::Sanity	file:
one_uint64	kenlm/lm/binary_format.cc	/^  uint64_t one_uint64;$/;"	m	struct:lm::ngram::__anon7::OldSanity	file:
one_uint64	kenlm/lm/binary_format.cc	/^  uint64_t one_uint64;$/;"	m	struct:lm::ngram::__anon7::Sanity	file:
one_word_index	kenlm/lm/binary_format.cc	/^  WordIndex one_word_index, max_word_index, padding_to_8;$/;"	m	struct:lm::ngram::__anon7::Sanity	file:
one_word_index	kenlm/lm/binary_format.cc	/^  WordIndex one_word_index, max_word_index;$/;"	m	struct:lm::ngram::__anon7::OldSanity	file:
operator !	kenlm/lm/builder/ngram_stream.hh	/^    bool operator!() const { return !stream_; }$/;"	f	class:lm::builder::NGramStream
operator !	kenlm/util/stream/block.hh	/^    bool operator!() const { return mem_ == NULL; }$/;"	f	class:util::stream::Block
operator !	kenlm/util/stream/stream.hh	/^    bool operator!() const { return current_ == NULL; }$/;"	f	class:util::stream::Stream
operator !	kenlm/util/tokenize_piece.hh	/^    bool operator!() const {$/;"	f	class:util::TokenIter
operator !=	kenlm/util/proxy_iterator.hh	/^    bool operator!=(const S &other) const { return !(*this == other); }$/;"	f	class:util::ProxyIterator
operator !=	kenlm/util/string_piece.hh	/^inline bool operator!=(const StringPiece& x, const StringPiece& y) {$/;"	f
operator ()	kenlm/lm/builder/corpus_count.cc	/^    bool operator()(const WordIndex *first, const WordIndex *second) const {$/;"	f	class:lm::builder::__anon9::DedupeEquals
operator ()	kenlm/lm/builder/corpus_count.cc	/^    std::size_t operator()(const WordIndex *start) const {$/;"	f	class:lm::builder::__anon9::DedupeHash
operator ()	kenlm/lm/builder/sort.hh	/^    inline bool operator()(const void *lhs, const void *rhs) const {$/;"	f	class:lm::builder::Comparator
operator ()	kenlm/lm/builder/sort.hh	/^  bool operator()(void *first_void, const void *second_void, const SuffixOrder &compare) const {$/;"	f	struct:lm::builder::AddCombiner
operator ()	kenlm/lm/filter/phrase.cc	/^  bool operator()(const Arc *first, const Arc *second) const {$/;"	f	struct:lm::phrase::detail::ArcGreater
operator ()	kenlm/lm/filter/thread.hh	/^    void operator()(Request request) {$/;"	f	class:lm::FilterWorker
operator ()	kenlm/lm/filter/thread.hh	/^    void operator()(Request request) {$/;"	f	class:lm::OutputWorker
operator ()	kenlm/lm/filter/vocab.hh	/^        void operator()(unsigned int index) {$/;"	f	class:lm::vocab::Multiple::Callback
operator ()	kenlm/lm/search_hashed.cc	/^    void operator()(const WordIndex *vocab_ids, const unsigned int \/*n*\/) {$/;"	f	class:lm::ngram::__anon23::ActivateUnigram
operator ()	kenlm/lm/search_hashed.cc	/^    void operator()(const WordIndex *vocab_ids, const unsigned int n) {$/;"	f	class:lm::ngram::__anon23::ActivateLowerMiddle
operator ()	kenlm/lm/trie.cc	/^    Key operator()(uint64_t index) const {$/;"	f	class:lm::ngram::trie::__anon25::KeyAccessor
operator ()	kenlm/lm/trie_sort.cc	/^  void operator()(std::size_t entry_size, unsigned char \/*order*\/, const void *first, const void * \/*second*\/, FILE *out) const {$/;"	f	struct:lm::ngram::trie::__anon26::FirstCombine
operator ()	kenlm/lm/trie_sort.cc	/^  void operator()(std::size_t entry_size, unsigned char order, const void *first, const void *second, FILE * \/*out*\/) const {$/;"	f	struct:lm::ngram::trie::__anon26::ThrowCombine
operator ()	kenlm/lm/trie_sort.hh	/^    bool operator()(const void *first_void, const void *second_void) const {$/;"	f	class:lm::ngram::trie::EntryCompare
operator ()	kenlm/lm/vocab.hh	/^    void operator()(const StringPiece &word) {$/;"	f	class:lm::ngram::WriteUniqueWords
operator ()	kenlm/lm/vocab.hh	/^    void operator()(const StringPiece &word) {}$/;"	f	class:lm::ngram::NoOpUniqueWords
operator ()	kenlm/util/joint_sort.hh	/^    bool operator()(const Proxy &left, const Proxy &right) const {$/;"	f	class:util::detail::LessWrapper
operator ()	kenlm/util/joint_sort.hh	/^    bool operator()(const Proxy &left, const typename Proxy::value_type &right) const {$/;"	f	class:util::detail::LessWrapper
operator ()	kenlm/util/joint_sort.hh	/^    bool operator()(const typename Proxy::value_type &left, const Proxy &right) const {$/;"	f	class:util::detail::LessWrapper
operator ()	kenlm/util/joint_sort.hh	/^    bool operator()(const typename Proxy::value_type &left, const typename Proxy::value_type &right) const {$/;"	f	class:util::detail::LessWrapper
operator ()	kenlm/util/multi_intersection.hh	/^  bool operator()(const Range &left, const Range &right) const {$/;"	f	struct:util::detail::RangeLessBySize
operator ()	kenlm/util/parallel_read.cc	/^    void operator()(const Request &request) {$/;"	f	class:util::__anon44::Reader
operator ()	kenlm/util/probing_hash_table.hh	/^  template <class T> T operator()(T arg) const { return arg; }$/;"	f	struct:util::IdentityHash
operator ()	kenlm/util/sized_iterator.hh	/^    bool operator()(const Proxy &first, const Proxy &second) const {$/;"	f	class:util::SizedCompare
operator ()	kenlm/util/sized_iterator.hh	/^    bool operator()(const Proxy &first, const std::string &second) const {$/;"	f	class:util::SizedCompare
operator ()	kenlm/util/sized_iterator.hh	/^    bool operator()(const std::string &first, const Proxy &second) const {$/;"	f	class:util::SizedCompare
operator ()	kenlm/util/sized_iterator.hh	/^    bool operator()(const std::string &first, const std::string &second) const {$/;"	f	class:util::SizedCompare
operator ()	kenlm/util/sorted_uniform.hh	/^    T operator()(const T *in) const { return *in; }$/;"	f	class:util::IdentityAccessor
operator ()	kenlm/util/stream/chain.hh	/^    template <class Position, class Worker> void operator()(const Position &position, Worker &worker) {$/;"	f	class:util::stream::Thread
operator ()	kenlm/util/stream/sort.hh	/^        bool operator()(const Entry &first, const Entry &second) const {$/;"	f	class:util::stream::MergeQueue::Greater
operator ()	kenlm/util/stream/sort.hh	/^  template <class Compare> bool operator()(const void *, const void *, const Compare &) const { $/;"	f	struct:util::stream::NeverCombine
operator ()	kenlm/util/string_piece_hash.hh	/^  bool operator()(const StringPiece &first, const StringPiece &second) const {$/;"	f	struct:StringPieceCompatibleEquals
operator ()	kenlm/util/string_piece_hash.hh	/^  size_t operator()(const StringPiece &str) const {$/;"	f	struct:StringPieceCompatibleHash
operator ()	kenlm/util/thread_pool.hh	/^    void operator()() {$/;"	f	class:util::Worker
operator *	kenlm/lm/builder/adjust_counts.cc	/^    const NGram &operator*() const { return current_; }$/;"	f	class:lm::builder::__anon8::CollapseStream
operator *	kenlm/lm/builder/initial_probabilities.cc	/^    NGram &operator*() { return current_; }$/;"	f	class:lm::builder::__anon11::PruneNGramStream
operator *	kenlm/lm/builder/ngram_stream.hh	/^    NGram &operator*() { return gram_; }$/;"	f	class:lm::builder::NGramStream
operator *	kenlm/lm/builder/ngram_stream.hh	/^    const NGram &operator*() const { return gram_; }$/;"	f	class:lm::builder::NGramStream
operator *	kenlm/util/file.hh	/^    int operator*() const { return fd_; }$/;"	f	class:util::scoped_fd
operator *	kenlm/util/proxy_iterator.hh	/^    Proxy operator*() { return p_; }$/;"	f	class:util::ProxyIterator
operator *	kenlm/util/proxy_iterator.hh	/^    const Proxy operator*() const { return p_; }$/;"	f	class:util::ProxyIterator
operator *	kenlm/util/scoped.hh	/^    T &operator*() { return *scoped_base<T, Closer>::p_; }$/;"	f	class:util::scoped
operator *	kenlm/util/scoped.hh	/^    const T&operator*() const { return *scoped_base<T, Closer>::p_; }$/;"	f	class:util::scoped
operator *	kenlm/util/stream/chain.hh	/^    Block &operator*() { return current_; }$/;"	f	class:util::stream::Link
operator *	kenlm/util/stream/chain.hh	/^    const Block &operator*() const { return current_; }$/;"	f	class:util::stream::Link
operator +	kenlm/util/proxy_iterator.hh	/^    S operator+(std::ptrdiff_t amount) const { S ret(*this); ret += amount; return ret; }$/;"	f	class:util::ProxyIterator
operator +	kenlm/util/proxy_iterator.hh	/^template <class Proxy> ProxyIterator<Proxy> operator+(std::ptrdiff_t amount, const ProxyIterator<Proxy> &it) {$/;"	f	namespace:util
operator ++	kenlm/lm/builder/adjust_counts.cc	/^    CollapseStream &operator++() {$/;"	f	class:lm::builder::__anon8::CollapseStream
operator ++	kenlm/lm/builder/initial_probabilities.cc	/^    PruneNGramStream &operator++() {$/;"	f	class:lm::builder::__anon11::PruneNGramStream
operator ++	kenlm/lm/builder/ngram_stream.hh	/^    NGramStream &operator++() {$/;"	f	class:lm::builder::NGramStream
operator ++	kenlm/lm/trie_sort.hh	/^    RecordReader &operator++() {$/;"	f	class:lm::ngram::trie::RecordReader
operator ++	kenlm/util/ersatz_progress.hh	/^    ErsatzProgress &operator++() {$/;"	f	class:util::ErsatzProgress
operator ++	kenlm/util/proxy_iterator.hh	/^    S &operator++() { return *this += 1; }$/;"	f	class:util::ProxyIterator
operator ++	kenlm/util/proxy_iterator.hh	/^    S operator++(int) { S ret(*this); ++*this; return ret; }$/;"	f	class:util::ProxyIterator
operator ++	kenlm/util/stream/chain.cc	/^Link &Link::operator++() {$/;"	f	class:util::stream::Link
operator ++	kenlm/util/stream/multi_progress.hh	/^    WorkerProgress &operator++() {$/;"	f	class:util::stream::WorkerProgress
operator ++	kenlm/util/stream/stream.hh	/^    Stream &operator++() {$/;"	f	class:util::stream::Stream
operator +=	kenlm/util/ersatz_progress.hh	/^    ErsatzProgress &operator+=(uint64_t amount) {$/;"	f	class:util::ErsatzProgress
operator +=	kenlm/util/joint_sort.hh	/^    JointIter<KeyIter, ValueIter> &operator+=(std::ptrdiff_t amount) {$/;"	f	class:util::detail::JointIter
operator +=	kenlm/util/proxy_iterator.hh	/^    S &operator+=(std::ptrdiff_t amount) { I() += amount; return *this; }$/;"	f	class:util::ProxyIterator
operator +=	kenlm/util/sized_iterator.hh	/^    SizedInnerIterator &operator+=(std::ptrdiff_t amount) {$/;"	f	class:util::SizedInnerIterator
operator +=	kenlm/util/stream/multi_progress.hh	/^    WorkerProgress &operator+=(uint64_t amount) {$/;"	f	class:util::stream::WorkerProgress
operator -	kenlm/util/joint_sort.hh	/^    std::ptrdiff_t operator-(const JointIter<KeyIter, ValueIter> &other) const { return key_ - other.key_; }$/;"	f	class:util::detail::JointIter
operator -	kenlm/util/proxy_iterator.hh	/^    S operator-(std::ptrdiff_t amount) const { S ret(*this); ret -= amount; return ret; }$/;"	f	class:util::ProxyIterator
operator -	kenlm/util/proxy_iterator.hh	/^    std::ptrdiff_t operator-(const S &other) const { return I() - other.I(); }$/;"	f	class:util::ProxyIterator
operator -	kenlm/util/sized_iterator.hh	/^    std::ptrdiff_t operator-(const SizedInnerIterator &other) const {$/;"	f	class:util::SizedInnerIterator
operator --	kenlm/util/proxy_iterator.hh	/^    S &operator--() { return *this -= 1; }$/;"	f	class:util::ProxyIterator
operator --	kenlm/util/proxy_iterator.hh	/^    S operator--(int) { S ret(*this); --*this; return ret; }$/;"	f	class:util::ProxyIterator
operator -=	kenlm/util/proxy_iterator.hh	/^    S &operator-=(std::ptrdiff_t amount) { I() += (-amount); return *this; }$/;"	f	class:util::ProxyIterator
operator ->	kenlm/lm/builder/adjust_counts.cc	/^    const NGram *operator->() const { return &current_; }$/;"	f	class:lm::builder::__anon8::CollapseStream
operator ->	kenlm/lm/builder/initial_probabilities.cc	/^    NGram *operator->() { return &current_; }$/;"	f	class:lm::builder::__anon11::PruneNGramStream
operator ->	kenlm/lm/builder/ngram_stream.hh	/^    NGram *operator->() { return &gram_; }$/;"	f	class:lm::builder::NGramStream
operator ->	kenlm/lm/builder/ngram_stream.hh	/^    const NGram *operator->() const { return &gram_; }$/;"	f	class:lm::builder::NGramStream
operator ->	kenlm/util/proxy_iterator.hh	/^    Proxy *operator->() { return &p_; }$/;"	f	class:util::ProxyIterator
operator ->	kenlm/util/proxy_iterator.hh	/^    const Proxy *operator->() const { return &p_; }$/;"	f	class:util::ProxyIterator
operator ->	kenlm/util/scoped.hh	/^    T *operator->() { return p_; }$/;"	f	class:util::scoped_base
operator ->	kenlm/util/scoped.hh	/^    const T *operator->() const { return p_; }$/;"	f	class:util::scoped_base
operator ->	kenlm/util/stream/chain.hh	/^    Block *operator->() { return &current_; }$/;"	f	class:util::stream::Link
operator ->	kenlm/util/stream/chain.hh	/^    const Block *operator->() const { return &current_; }$/;"	f	class:util::stream::Link
operator <	kenlm/lm/search_trie.cc	/^  bool operator<(const Gram &other) const {$/;"	f	struct:lm::ngram::trie::__anon24::Gram
operator <	kenlm/lm/state.hh	/^    bool operator<(const State &other) const {$/;"	f	class:lm::ngram::State
operator <	kenlm/lm/state.hh	/^  bool operator<(const ChartState &other) const {$/;"	f	struct:lm::ngram::ChartState
operator <	kenlm/lm/state.hh	/^  bool operator<(const Left &other) const {$/;"	f	struct:lm::ngram::Left
operator <	kenlm/util/joint_sort.hh	/^    bool operator<(const JointIter<KeyIter, ValueIter> &other) const { return (key_ < other.key_); }$/;"	f	class:util::detail::JointIter
operator <	kenlm/util/proxy_iterator.hh	/^    bool operator<(const S &other) const { return I() < other.I(); }$/;"	f	class:util::ProxyIterator
operator <	kenlm/util/sized_iterator.hh	/^    bool operator<(const SizedInnerIterator &other) const {$/;"	f	class:util::SizedInnerIterator
operator <	kenlm/util/string_piece.hh	/^inline bool operator<(const StringPiece& x, const StringPiece& y) {$/;"	f
operator <<	kenlm/util/exception.hh	/^template <class Except, class Data> typename Except::template ExceptionTag<Except&>::Identity operator<<(Except &e, const Data &data) {$/;"	f	namespace:util
operator <<	kenlm/util/fake_ofstream.hh	/^    FakeOFStream &operator<<(StringPiece str) {$/;"	f	class:util::FakeOFStream
operator <<	kenlm/util/fake_ofstream.hh	/^    FakeOFStream &operator<<(char c) {$/;"	f	class:util::FakeOFStream
operator <<	kenlm/util/fake_ofstream.hh	/^    FakeOFStream &operator<<(double value) {$/;"	f	class:util::FakeOFStream
operator <<	kenlm/util/fake_ofstream.hh	/^    FakeOFStream &operator<<(float value) {$/;"	f	class:util::FakeOFStream
operator <<	kenlm/util/fake_ofstream.hh	/^    FakeOFStream &operator<<(unsigned value) {$/;"	f	class:util::FakeOFStream
operator <<	kenlm/util/string_piece.hh	/^inline std::ostream& operator<<(std::ostream& o, const StringPiece& piece) {$/;"	f
operator <=	kenlm/util/proxy_iterator.hh	/^    bool operator<=(const S &other) const { return !(*this > other); }$/;"	f	class:util::ProxyIterator
operator <=	kenlm/util/string_piece.hh	/^inline bool operator<=(const StringPiece& x, const StringPiece& y) {$/;"	f
operator =	kenlm/lm/trie_sort.cc	/^    PartialViewProxy &operator=(const PartialViewProxy &from) {$/;"	f	class:lm::ngram::trie::__anon26::PartialViewProxy
operator =	kenlm/lm/trie_sort.cc	/^    PartialViewProxy &operator=(const std::string &from) {$/;"	f	class:lm::ngram::trie::__anon26::PartialViewProxy
operator =	kenlm/util/exception.cc	/^Exception &Exception::operator=(const Exception &from) {$/;"	f	class:util::Exception
operator =	kenlm/util/joint_sort.hh	/^    JointProxy &operator=(const JointProxy &other) {$/;"	f	class:util::detail::JointProxy
operator =	kenlm/util/joint_sort.hh	/^    JointProxy &operator=(const value_type &other) {$/;"	f	class:util::detail::JointProxy
operator =	kenlm/util/mmap.cc	/^Rolling &Rolling::operator=(const Rolling &copy_from) {$/;"	f	class:util::Rolling
operator =	kenlm/util/proxy_iterator.hh	/^    S &operator=(const S &other) {$/;"	f	class:util::ProxyIterator
operator =	kenlm/util/sized_iterator.hh	/^    SizedProxy &operator=(const SizedProxy &from) {$/;"	f	class:util::SizedProxy
operator =	kenlm/util/sized_iterator.hh	/^    SizedProxy &operator=(const std::string &from) {$/;"	f	class:util::SizedProxy
operator ==	kenlm/lm/state.hh	/^    bool operator==(const State &other) const {$/;"	f	class:lm::ngram::State
operator ==	kenlm/lm/state.hh	/^  bool operator==(const ChartState &other) const {$/;"	f	struct:lm::ngram::ChartState
operator ==	kenlm/lm/state.hh	/^  bool operator==(const Left &other) const {$/;"	f	struct:lm::ngram::Left
operator ==	kenlm/util/joint_sort.hh	/^    bool operator==(const JointIter<KeyIter, ValueIter> &other) const { return key_ == other.key_; }$/;"	f	class:util::detail::JointIter
operator ==	kenlm/util/parallel_read.cc	/^      bool operator==(const Request &other) const {$/;"	f	struct:util::__anon44::Reader::Request
operator ==	kenlm/util/proxy_iterator.hh	/^    bool operator==(const S &other) const { return I() == other.I(); }$/;"	f	class:util::ProxyIterator
operator ==	kenlm/util/sized_iterator.hh	/^    bool operator==(const SizedInnerIterator &other) const {$/;"	f	class:util::SizedInnerIterator
operator ==	kenlm/util/string_piece.hh	/^inline bool operator==(const StringPiece& x, const StringPiece& y) {$/;"	f
operator >	kenlm/util/proxy_iterator.hh	/^    bool operator>(const S &other) const { return other < *this; }$/;"	f	class:util::ProxyIterator
operator >	kenlm/util/string_piece.hh	/^inline bool operator>(const StringPiece& x, const StringPiece& y) {$/;"	f
operator >=	kenlm/util/proxy_iterator.hh	/^    bool operator>=(const S &other) const { return !(*this < other); }$/;"	f	class:util::ProxyIterator
operator >=	kenlm/util/string_piece.hh	/^inline bool operator>=(const StringPiece& x, const StringPiece& y) {$/;"	f
operator >>	kenlm/lm/builder/ngram_stream.hh	/^inline util::stream::Chain &operator>>(util::stream::Chain &chain, NGramStream &str) {$/;"	f	namespace:lm::builder
operator >>	kenlm/lm/builder/pipeline.cc	/^    template <class T> Master &operator>>(const T &worker) {$/;"	f	class:lm::builder::__anon13::Master
operator >>	kenlm/util/stream/chain.cc	/^Chain &Chain::operator>>(const PWriteAndRecycle &writer) {$/;"	f	class:util::stream::Chain
operator >>	kenlm/util/stream/chain.cc	/^Chain &Chain::operator>>(const WriteAndRecycle &writer) {$/;"	f	class:util::stream::Chain
operator >>	kenlm/util/stream/chain.hh	/^    Chain &operator>>(const Recycler &) {$/;"	f	class:util::stream::Chain
operator >>	kenlm/util/stream/chain.hh	/^    template <class Worker> typename CheckForRun<Worker>::type &operator>>(const Worker &worker) {$/;"	f	class:util::stream::Chain
operator >>	kenlm/util/stream/chain.hh	/^    template <class Worker> typename CheckForRun<Worker>::type &operator>>(const boost::reference_wrapper<Worker> &worker) {$/;"	f	class:util::stream::Chain
operator >>	kenlm/util/stream/chain.hh	/^inline Chain &operator>>(Chain &chain, Link &link) {$/;"	f	namespace:util::stream
operator >>	kenlm/util/stream/multi_stream.hh	/^    Chains &operator>>(const util::stream::Recycler &recycler) {$/;"	f	class:util::stream::Chains
operator >>	kenlm/util/stream/multi_stream.hh	/^    template <class Worker> typename CheckForRun<Worker>::type &operator>>(const Worker &worker) {$/;"	f	class:util::stream::Chains
operator >>	kenlm/util/stream/multi_stream.hh	/^    template <class Worker> typename CheckForRun<Worker>::type &operator>>(const boost::reference_wrapper<Worker> &worker) {$/;"	f	class:util::stream::Chains
operator >>	kenlm/util/stream/multi_stream.hh	/^inline Chains &operator>>(Chains &chains, ChainPositions &positions) {$/;"	f	namespace:util::stream
operator >>	kenlm/util/stream/multi_stream.hh	/^template <class T> inline Chains &operator>>(Chains &chains, GenericStreams<T> &streams) {$/;"	f	namespace:util::stream
operator >>	kenlm/util/stream/stream.hh	/^inline Chain &operator>>(Chain &chain, Stream &stream) {$/;"	f	namespace:util::stream
operator []	kenlm/util/double-conversion/utils.h	/^  T& operator[](int index) const {$/;"	f	class:double_conversion::Vector
operator []	kenlm/util/fixed_array.hh	/^    T &operator[](std::size_t i) { return begin()[i]; }$/;"	f	class:util::FixedArray
operator []	kenlm/util/fixed_array.hh	/^    const T &operator[](std::size_t i) const { return begin()[i]; }$/;"	f	class:util::FixedArray
operator []	kenlm/util/proxy_iterator.hh	/^    Proxy operator[](std::ptrdiff_t amount) const { return *(*this + amount); }$/;"	f	class:util::ProxyIterator
operator []	kenlm/util/scoped.hh	/^    T &operator[](std::size_t idx) { return scoped<T, scoped_delete_array_forward>::p_[idx]; }$/;"	f	class:util::scoped_array
operator []	kenlm/util/scoped.hh	/^    const T &operator[](std::size_t idx) const { return scoped<T, scoped_delete_array_forward>::p_[idx]; }$/;"	f	class:util::scoped_array
operator []	kenlm/util/string_piece.hh	/^  char operator[](size_type i) const { return ptr_[i]; }$/;"	f	class:StringPiece
operator bool	kenlm/lm/builder/adjust_counts.cc	/^    operator bool() const { return block_; }$/;"	f	class:lm::builder::__anon8::CollapseStream
operator bool	kenlm/lm/builder/initial_probabilities.cc	/^    operator bool() const {$/;"	f	class:lm::builder::__anon11::PruneNGramStream
operator bool	kenlm/lm/builder/ngram_stream.hh	/^    operator bool() const { return stream_; }$/;"	f	class:lm::builder::NGramStream
operator bool	kenlm/lm/trie_sort.hh	/^    operator bool() const { return remains_; }$/;"	f	class:lm::ngram::trie::RecordReader
operator bool	kenlm/util/stream/block.hh	/^    operator bool() const { return mem_ != NULL; }$/;"	f	class:util::stream::Block
operator bool	kenlm/util/stream/chain.hh	/^    operator bool() const { return current_; }$/;"	f	class:util::stream::Link
operator bool	kenlm/util/stream/stream.hh	/^    operator bool() const { return current_ != NULL; }$/;"	f	class:util::stream::Stream
operator bool	kenlm/util/tokenize_piece.hh	/^    operator bool() const {$/;"	f	class:util::TokenIter
operator std::string	kenlm/lm/trie_sort.cc	/^    operator std::string() const {$/;"	f	class:lm::ngram::trie::__anon26::PartialViewProxy
operator std::string	kenlm/util/sized_iterator.hh	/^    operator std::string() const {$/;"	f	class:util::SizedProxy
operator value_type	kenlm/util/joint_sort.hh	/^    operator value_type() const {$/;"	f	class:util::detail::JointProxy
optarg	kenlm/util/getopt.c	/^char	*optarg;$/;"	v
opterr	kenlm/util/getopt.c	/^int	opterr = 1;$/;"	v
optind	kenlm/util/getopt.c	/^int	optind = 1;$/;"	v
optopt	kenlm/util/getopt.c	/^int	optopt;$/;"	v
order	kenlm/lm/binary_format.hh	/^  unsigned char order;$/;"	m	struct:lm::ngram::FixedWidthParameters
order	kenlm/lm/builder/pipeline.hh	/^  std::size_t order;$/;"	m	struct:lm::builder::PipelineConfig
order_	kenlm/lm/builder/sort.hh	/^    std::size_t order_;$/;"	m	class:lm::builder::Comparator
order_	kenlm/lm/search_trie.cc	/^    const unsigned char order_;$/;"	m	class:lm::ngram::trie::__anon24::WriteEntries	file:
order_	kenlm/lm/trie_sort.hh	/^    unsigned char order_;$/;"	m	class:lm::ngram::trie::EntryCompare
order_	kenlm/lm/virtual_interface.hh	/^    unsigned char order_;$/;"	m	class:lm::base::Model
ordering_	kenlm/lm/filter/thread.hh	/^    std::deque<Request> ordering_;$/;"	m	class:lm::OutputWorker
orders_	kenlm/lm/builder/adjust_counts.cc	/^    std::vector<OrderStat> orders_;$/;"	m	class:lm::builder::__anon8::StatCollector	file:
original_base_	kenlm/lm/bhiksha.hh	/^    void *original_base_;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
outPCache	HLVRec.h	/^   OutPCache *outPCache;        \/* cache of outP values for block of observations *\/$/;"	m	struct:_DecoderInst
out_	kenlm/lm/filter/vocab.hh	/^        Output &out_;$/;"	m	class:lm::vocab::Multiple::Callback
out_	kenlm/lm/left.hh	/^    ChartState *out_;$/;"	m	class:lm::ngram::RuleScore
out_	kenlm/util/ersatz_progress.hh	/^    std::ostream *out_;$/;"	m	class:util::ErsatzProgress
out_	kenlm/util/stream/chain.hh	/^    PCQueue<Block> *in_, *out_;$/;"	m	class:util::stream::ChainPosition
out_	kenlm/util/stream/chain.hh	/^    PCQueue<Block> *in_, *out_;$/;"	m	class:util::stream::Link
out_fd_	kenlm/lm/builder/print.hh	/^    util::scoped_fd out_fd_;$/;"	m	class:lm::builder::PrintARPA
out_offsets_	kenlm/util/stream/sort.hh	/^    Offsets *out_offsets_;$/;"	m	class:util::stream::MergingReader
outpBlocksize	HDecode.c	/^static int outpBlocksize = 1;   \/* number of frames for which outP is calculated in one go *\/$/;"	v	file:
outpBlocksize	HDecode.mod.c	/^static int outpBlocksize = 1;   \/* number of frames for which outP is calculated in one go *\/$/;"	v	file:
output_	kenlm/lm/builder/interpolate.cc	/^    Output output_;$/;"	m	class:lm::builder::__anon12::Callback	file:
output_	kenlm/lm/filter/format.hh	/^    Output &output_;$/;"	m	class:lm::DispatchInput
output_	kenlm/lm/filter/thread.hh	/^    Output &output_;$/;"	m	class:lm::OutputWorker
output_	kenlm/lm/filter/thread.hh	/^    OutputBuffer output_;$/;"	m	class:lm::ThreadBatch
output_	kenlm/lm/filter/thread.hh	/^    util::ThreadPool<OutputWorker<Batch, RealOutput> > output_;$/;"	m	class:lm::Controller
output_q	kenlm/lm/builder/pipeline.hh	/^  bool output_q;$/;"	m	struct:lm::builder::PipelineConfig
output_q_	kenlm/lm/builder/interpolate.hh	/^    bool output_q_;$/;"	m	class:lm::builder::Interpolate
output_sum_	kenlm/util/stream/sort.hh	/^    uint64_t output_sum_;$/;"	m	class:util::stream::Offsets
outputs_	kenlm/lm/builder/output.hh	/^    boost::ptr_vector<OutputHook> outputs_[NUMBER_OF_HOOKS];$/;"	m	class:lm::builder::Output
overwrite	kenlm/lm/builder/adjust_counts.hh	/^  std::vector<Discount> overwrite;$/;"	m	struct:lm::builder::DiscountConfig
own_	kenlm/util/stream/io.hh	/^    bool own_;$/;"	m	class:util::stream::PRead
p_	kenlm/util/proxy_iterator.hh	/^    Proxy p_;$/;"	m	class:util::ProxyIterator
p_	kenlm/util/scoped.hh	/^    T *p_;$/;"	m	class:util::scoped_base
padding_to_8	kenlm/lm/binary_format.cc	/^  WordIndex one_word_index, max_word_index, padding_to_8;$/;"	m	struct:lm::ngram::__anon7::Sanity	file:
page_	kenlm/util/file_piece.hh	/^    const uint64_t page_;$/;"	m	class:util::FilePiece
parent_	kenlm/util/stream/multi_progress.hh	/^    MultiProgress *parent_;$/;"	m	class:util::stream::WorkerProgress
path	HLVRec.h	/^   WordendHyp *path;            \/* word level path for traceback *\/$/;"	m	struct:_RelToken
path	HLVRec.h	/^   WordendHyp *path;            \/* word level path for traceback *\/$/;"	m	struct:_Token
pde	HLVRec.c	/^static Boolean pde = FALSE;      \/* partial distance elimination *\/$/;"	v	file:
phoneFreq	HLVRec.h	/^   int *phoneFreq;$/;"	m	struct:_DecoderInst
phonePost	HLVRec.h	/^   LogDouble *phonePost;$/;"	m	struct:_DecoderInst
phrase	kenlm/lm/filter/phrase.cc	/^namespace phrase {$/;"	n	namespace:lm	file:
phrase	kenlm/lm/filter/phrase.hh	/^      std::vector<unsigned int> substring, left, right, phrase;$/;"	m	struct:lm::phrase::Substrings::SentenceRelation
phrase	kenlm/lm/filter/phrase.hh	/^namespace phrase {$/;"	n	namespace:lm
pointer	kenlm/util/proxy_iterator.hh	/^    typedef ProxyIterator<Proxy> * pointer;$/;"	t	class:util::ProxyIterator
pointer	kenlm/util/string_piece.hh	/^  typedef const char* pointer;$/;"	t	class:StringPiece
pointer_bhiksha_bits	kenlm/lm/config.hh	/^  uint8_t pointer_bhiksha_bits;$/;"	m	struct:lm::ngram::Config
pointers	kenlm/lm/state.hh	/^  uint64_t pointers[KENLM_MAX_ORDER - 1];$/;"	m	struct:lm::ngram::Left
poison_	kenlm/util/thread_pool.hh	/^    Request poison_;$/;"	m	class:util::ThreadPool
poison_	kenlm/util/thread_pool.hh	/^    const Request poison_;$/;"	m	class:util::Worker
poisoned_	kenlm/util/stream/chain.hh	/^    bool poisoned_;$/;"	m	class:util::stream::Link
position	kenlm/util/double-conversion/utils.h	/^  int position() const {$/;"	f	class:double_conversion::StringBuilder
position_	kenlm/util/double-conversion/utils.h	/^  int position_;$/;"	m	class:double_conversion::StringBuilder
position_	kenlm/util/file_piece.hh	/^    const char *position_, *last_space_, *position_end_;$/;"	m	class:util::FilePiece
position_end_	kenlm/util/file_piece.hh	/^    const char *position_, *last_space_, *position_end_;$/;"	m	class:util::FilePiece
positive_log_probability	kenlm/lm/config.hh	/^  WarningAction positive_log_probability;$/;"	m	struct:lm::ngram::Config
post	kenlm/util/pcqueue.hh	/^    void post() {$/;"	f	class:util::Semaphore
prefix	Makefile	/^prefix = \/home\/siyujing\/openSource\/htk_linux\/htk\/$/;"	m
prev	HLVRec.h	/^   ModendHyp *prev;             \/* previous model info *\/$/;"	m	struct:_ModendHyp
prev	HLVRec.h	/^   WordendHyp *prev;            \/* previous word info *\/$/;"	m	struct:_AltWordendHyp
prev	HLVRec.h	/^   WordendHyp *prev;            \/* previous word info *\/$/;"	m	struct:_WordendHyp
prob	HLVLM.h	/^   NGLM_Prob prob;              \/* probability *\/$/;"	m	struct:sentry
prob	HLVLM.h	/^   float prob;                  \/* probability *\/$/;"	m	struct:_FSLM_LatArc
prob	HLVRec.h	/^   LMTokScore prob;$/;"	m	struct:_LMCacheLA
prob	HLVRec.h	/^   LMTokScore prob;$/;"	m	struct:_LMLACacheEntry
prob	kenlm/lm/builder/ngram.hh	/^  float prob;  \/\/ Uninterpolated probability.$/;"	m	struct:lm::builder::Uninterpolated
prob	kenlm/lm/return.hh	/^  float prob;$/;"	m	struct:lm::FullScoreReturn
prob	kenlm/lm/weights.hh	/^  float prob;$/;"	m	struct:lm::Prob
prob	kenlm/lm/weights.hh	/^  float prob;$/;"	m	struct:lm::ProbBackoff
prob	kenlm/lm/weights.hh	/^  float prob;$/;"	m	struct:lm::RestWeights
prob_	kenlm/lm/left.hh	/^    float prob_;$/;"	m	class:lm::ngram::RuleScore
prob_bits	kenlm/lm/config.hh	/^  uint8_t prob_bits, backoff_bits;$/;"	m	struct:lm::ngram::Config
prob_bits_	kenlm/lm/quantize.hh	/^    uint8_t prob_bits_, backoff_bits_;$/;"	m	class:lm::ngram::SeparatelyQuantize
probing_multiplier	kenlm/lm/binary_format.hh	/^  float probing_multiplier;$/;"	m	struct:lm::ngram::FixedWidthParameters
probing_multiplier	kenlm/lm/config.hh	/^  float probing_multiplier;$/;"	m	struct:lm::ngram::Config
probs_	kenlm/lm/builder/interpolate.cc	/^    std::vector<float> probs_;$/;"	m	class:lm::builder::__anon12::Callback	file:
produce_at_	kenlm/util/pcqueue.hh	/^  T *produce_at_;$/;"	m	class:util::PCQueue
produce_at_mutex_	kenlm/util/pcqueue.hh	/^  boost::mutex produce_at_mutex_;$/;"	m	class:util::PCQueue
progress_	kenlm/util/file_piece.hh	/^    ErsatzProgress progress_;$/;"	m	class:util::FilePiece
progress_	kenlm/util/stream/chain.hh	/^    MultiProgress progress_;$/;"	m	class:util::stream::Chain
progress_	kenlm/util/stream/chain.hh	/^    WorkerProgress progress_;$/;"	m	class:util::stream::ChainPosition
progress_	kenlm/util/stream/chain.hh	/^    WorkerProgress progress_;$/;"	m	class:util::stream::Link
pron	HLVNet.c	/^      Pron pron;$/;"	m	union:_STLexNode::__anon3	file:
pron	HLVNet.h	/^      PronId pron;$/;"	m	union:_LexNode::__anon4
pron	HLVNet.h	/^   Pron pron;$/;"	m	struct:_TLexNode
pron	HLVRec.h	/^   PronId pron;                 \/* pronunciation chosen *\/$/;"	m	struct:_WordendHyp
pronId2LMId	HLVLM.h	/^   LMId *pronId2LMId;           \/* PronId -> LMId mapping array [1..voc->nprons] $/;"	m	struct:_FSLM_ngram
pronScale	HDecode.c	/^static float pronScale = 1.0;   \/* pronunciation scaling factor *\/$/;"	v	file:
pronScale	HDecode.mod.c	/^static float pronScale = 1.0;   \/* pronunciation scaling factor *\/$/;"	v	file:
pronScale	HLVRec.h	/^   float pronScale;             \/* pronunciation scaling factor *\/$/;"	m	struct:_DecoderInst
pronlist	HLVNet.h	/^   Pron *pronlist;              \/* array [1..voc->nprons]  of Prons for given PronId *\/$/;"	m	struct:_LexNet
prune_threshold_	kenlm/lm/builder/adjust_counts.cc	/^    uint64_t prune_threshold_;$/;"	m	class:lm::builder::__anon8::CollapseStream	file:
prune_thresholds	kenlm/lm/builder/pipeline.hh	/^  std::vector<uint64_t> prune_thresholds; \/\/mjd$/;"	m	struct:lm::builder::PipelineConfig
prune_thresholds_	kenlm/lm/builder/adjust_counts.hh	/^    const std::vector<uint64_t> &prune_thresholds_; $/;"	m	class:lm::builder::AdjustCounts
prune_thresholds_	kenlm/lm/builder/interpolate.cc	/^    const std::vector<uint64_t>& prune_thresholds_;$/;"	m	class:lm::builder::__anon12::Callback	file:
prune_thresholds_	kenlm/lm/builder/interpolate.hh	/^    const std::vector<uint64_t> prune_thresholds_;$/;"	m	class:lm::builder::Interpolate
prune_vocab	kenlm/lm/builder/pipeline.hh	/^  bool prune_vocab;$/;"	m	struct:lm::builder::PipelineConfig
prune_vocab_	kenlm/lm/builder/interpolate.cc	/^    bool prune_vocab_;$/;"	m	class:lm::builder::__anon12::Callback	file:
prune_vocab_	kenlm/lm/builder/interpolate.hh	/^    bool prune_vocab_;$/;"	m	class:lm::builder::Interpolate
prune_vocab_file	kenlm/lm/builder/pipeline.hh	/^  std::string prune_vocab_file;$/;"	m	struct:lm::builder::PipelineConfig
prune_vocab_filename_	kenlm/lm/builder/corpus_count.hh	/^    const std::string& prune_vocab_filename_; $/;"	m	class:lm::builder::CorpusCount
prune_words_	kenlm/lm/builder/adjust_counts.cc	/^    const std::vector<bool>& prune_words_;$/;"	m	class:lm::builder::__anon8::CollapseStream	file:
prune_words_	kenlm/lm/builder/adjust_counts.hh	/^    const std::vector<bool> &prune_words_;$/;"	m	class:lm::builder::AdjustCounts
prune_words_	kenlm/lm/builder/corpus_count.hh	/^    std::vector<bool>& prune_words_;$/;"	m	class:lm::builder::CorpusCount
pruning_	kenlm/lm/builder/initial_probabilities.cc	/^      bool pruning_;$/;"	m	class:lm::builder::__anon11::OnlyGamma	file:
pruning_	kenlm/lm/builder/initial_probabilities.cc	/^    bool pruning_;$/;"	m	class:lm::builder::__anon11::AddRight	file:
ptr_	kenlm/util/mmap.hh	/^    void *ptr_;$/;"	m	class:util::Rolling
ptr_	kenlm/util/sized_iterator.hh	/^    uint8_t *ptr_;$/;"	m	class:util::SizedInnerIterator
ptr_	kenlm/util/string_piece.hh	/^  const char*   ptr_;$/;"	m	class:StringPiece
push_back	kenlm/lm/builder/sort.hh	/^    void push_back(util::stream::Chain &chain, const util::stream::SortConfig &config, const Compare &compare) {$/;"	f	class:lm::builder::Sorts
push_back	kenlm/util/fixed_array.hh	/^    template <class C> void push_back(const C &c) {$/;"	f	class:util::FixedArray
q_delta_	kenlm/lm/builder/interpolate.cc	/^    std::vector<float> q_delta_;$/;"	m	class:lm::builder::__anon12::OutputQ	file:
quant_	kenlm/lm/search_trie.cc	/^    const Quant &quant_;$/;"	m	class:lm::ngram::trie::__anon24::WriteEntries	file:
quant_	kenlm/lm/search_trie.hh	/^    Quant quant_;$/;"	m	class:lm::ngram::trie::TrieSearch
quant_bits_	kenlm/lm/trie.hh	/^    uint8_t quant_bits_;$/;"	m	class:lm::ngram::trie::BitPackedMiddle
queue_	kenlm/util/stream/sort.hh	/^    Queue queue_;$/;"	m	class:util::stream::MergeQueue
queue_size_	kenlm/lm/filter/thread.hh	/^    const size_t queue_size_;$/;"	m	class:lm::Controller
queues_	kenlm/util/stream/chain.hh	/^    boost::ptr_vector<PCQueue<Block> > queues_;$/;"	m	class:util::stream::Chain
rawMITFormat	HLVLM.c	/^static Boolean rawMITFormat = FALSE;    \/* by default do not use HTK quoting *\/$/;"	v	file:
raw_amount_	kenlm/util/read_compressed.hh	/^    uint64_t raw_amount_;$/;"	m	class:util::ReadCompressed
rbegin	kenlm/util/string_piece.hh	/^  const_reverse_iterator rbegin() const {$/;"	f	class:StringPiece
rc	HLVNet.h	/^   LabId rc;            \/* right context phone *\/$/;"	m	struct:_TLexNode
read_backoffs	kenlm/lm/builder/pipeline.hh	/^  util::stream::ChainConfig read_backoffs;$/;"	m	struct:lm::builder::PipelineConfig
read_bound_	kenlm/util/mmap.hh	/^    std::size_t read_bound_;$/;"	m	class:util::Rolling
recCHeap	HLVRec.c	/^MemHeap recCHeap;                       \/* CHEAP for small general allocation *\/$/;"	v
reference	kenlm/util/proxy_iterator.hh	/^    typedef Proxy reference;$/;"	t	class:util::ProxyIterator
reference	kenlm/util/string_piece.hh	/^  typedef const char& reference;$/;"	t	class:StringPiece
regHeap	HDecode.c	/^static MemHeap regHeap;$/;"	v	file:
regHeap	HDecode.mod.c	/^static MemHeap regHeap;$/;"	v	file:
relBeamWidth	HDecode.c	/^static LogFloat relBeamWidth = - LZERO;  \/* pruning relative beam width *\/$/;"	v	file:
relBeamWidth	HDecode.mod.c	/^static LogFloat relBeamWidth = - LZERO;  \/* pruning relative beam width *\/$/;"	v	file:
relBeamWidth	HLVRec.h	/^   RelTokScore relBeamWidth;    \/* beamWidth of relative tokenset  beam *\/$/;"	m	struct:_DecoderInst
relTok	HLVRec.h	/^   RelToken *relTok;            \/*# sorted by LMState? *\/$/;"	m	struct:_TokenSet
relTokHeap	HLVRec.h	/^   MemHeap relTokHeap;          \/* MHEAP for RelToken arrays (dec->nTok-1 elements) *\/$/;"	m	struct:_DecoderInst
release	kenlm/util/file.hh	/^    int release() {$/;"	f	class:util::scoped_fd
release	kenlm/util/scoped.hh	/^    T *release() {$/;"	f	class:util::scoped_base
remain_	kenlm/util/read_compressed.cc	/^    uint8_t *remain_;$/;"	m	class:util::__anon45::UncompressedWithHeader	file:
remaining_	kenlm/util/stream/sort.hh	/^        uint64_t remaining_, offset_;$/;"	m	class:util::stream::MergeQueue::Entry
remains_	kenlm/lm/trie_sort.hh	/^    bool remains_;$/;"	m	class:lm::ngram::trie::RecordReader
remove_prefix	kenlm/util/string_piece.hh	/^  void remove_prefix(size_type n) {$/;"	f	class:StringPiece
remove_suffix	kenlm/util/string_piece.hh	/^  void remove_suffix(size_type n) {$/;"	f	class:StringPiece
rend	kenlm/util/string_piece.hh	/^  const_reverse_iterator rend() const {$/;"	f	class:StringPiece
reset	kenlm/util/file.hh	/^    void reset(int to = -1) {$/;"	f	class:util::scoped_fd
reset	kenlm/util/mmap.cc	/^void scoped_memory::reset(void *data, std::size_t size, Alloc source) {$/;"	f	class:util::scoped_memory
reset	kenlm/util/mmap.hh	/^    void reset() { reset(NULL, 0, NONE_ALLOCATED); }$/;"	f	class:util::scoped_memory
reset	kenlm/util/mmap.hh	/^    void reset() {$/;"	f	class:util::scoped_mmap
reset	kenlm/util/mmap.hh	/^    void reset(void *data, std::size_t size) {$/;"	f	class:util::scoped_mmap
reset	kenlm/util/scoped.hh	/^    void reset(T *p = NULL) {$/;"	f	class:util::scoped_base
rest	kenlm/lm/return.hh	/^  float rest;$/;"	m	struct:lm::FullScoreReturn
rest	kenlm/lm/weights.hh	/^  float rest;$/;"	m	struct:lm::RestWeights
rest_function	kenlm/lm/config.hh	/^  RestFunction rest_function;$/;"	m	struct:lm::ngram::Config
rest_lower_files	kenlm/lm/config.hh	/^  std::vector<std::string> rest_lower_files;$/;"	m	struct:lm::ngram::Config
reverse_iterator	kenlm/util/string_piece.hh	/^  typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:StringPiece
rfind	kenlm/util/string_piece.cc	/^size_type StringPiece::rfind(char c, size_type pos) const {$/;"	f	class:StringPiece
rfind	kenlm/util/string_piece.cc	/^size_type StringPiece::rfind(const StringPiece& s, size_type pos) const {$/;"	f	class:StringPiece
right	kenlm/lm/filter/phrase.hh	/^      std::vector<unsigned int> substring, left, right, phrase;$/;"	m	struct:lm::phrase::Substrings::SentenceRelation
right	kenlm/lm/state.hh	/^  State right;$/;"	m	struct:lm::ngram::ChartState
root	HLVNet.h	/^   TLexNode *root;	\/* global chain of all nodes *\/$/;"	m	struct:_TLexNet
run	kenlm/util/stream/sort.hh	/^      uint64_t run;$/;"	m	struct:util::stream::Offsets::Entry
saw_unk_	kenlm/lm/vocab.hh	/^    bool saw_unk_;$/;"	m	class:lm::ngram::ProbingVocabulary
saw_unk_	kenlm/lm/vocab.hh	/^    bool saw_unk_;$/;"	m	class:lm::ngram::SortedVocabulary
sbindir	Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
scoped	kenlm/util/scoped.hh	/^    explicit scoped(T *p = NULL) : scoped_base<T, Closer>(p) {}$/;"	f	class:util::scoped
scoped	kenlm/util/scoped.hh	/^    explicit scoped(void *p = NULL) : scoped_base<void, Closer>(p) {}$/;"	f	class:util::scoped
scoped	kenlm/util/scoped.hh	/^template <class Closer> class scoped<void, Closer> : public scoped_base<void, Closer> {$/;"	c	namespace:util
scoped	kenlm/util/scoped.hh	/^template <class T, class Closer> class scoped : public scoped_base<T, Closer> {$/;"	c	namespace:util
scoped_FILE	kenlm/util/file.hh	/^typedef scoped<std::FILE, scoped_FILE_closer> scoped_FILE;$/;"	t	namespace:util
scoped_FILE_closer	kenlm/util/file.hh	/^struct scoped_FILE_closer {$/;"	s	namespace:util
scoped_array	kenlm/util/scoped.hh	/^    explicit scoped_array(T *p = NULL) : scoped<T, scoped_delete_array_forward>(p) {}$/;"	f	class:util::scoped_array
scoped_array	kenlm/util/scoped.hh	/^template <class T> class scoped_array : public scoped<T, scoped_delete_array_forward> {$/;"	c	namespace:util
scoped_base	kenlm/util/scoped.hh	/^    explicit scoped_base(T *p = NULL) : p_(p) {}$/;"	f	class:util::scoped_base
scoped_base	kenlm/util/scoped.hh	/^template <class T, class Closer> class scoped_base {$/;"	c	namespace:util
scoped_c	kenlm/util/scoped.hh	/^    explicit scoped_c(T *p = NULL) : scoped<T, scoped_c_forward<T, clean> >(p) {}$/;"	f	class:util::scoped_c
scoped_c	kenlm/util/scoped.hh	/^template <class T, void (*clean)(T*)> class scoped_c : public scoped<T, scoped_c_forward<T, clean> > {$/;"	c	namespace:util
scoped_c_forward	kenlm/util/scoped.hh	/^template <class T, void (*clean)(T*)> struct scoped_c_forward {$/;"	s	namespace:util
scoped_delete_array_forward	kenlm/util/scoped.hh	/^struct scoped_delete_array_forward {$/;"	s	namespace:util
scoped_delete_forward	kenlm/util/scoped.hh	/^struct scoped_delete_forward {$/;"	s	namespace:util
scoped_fd	kenlm/util/file.hh	/^    explicit scoped_fd(int fd) : fd_(fd) {}$/;"	f	class:util::scoped_fd
scoped_fd	kenlm/util/file.hh	/^    scoped_fd() : fd_(-1) {}$/;"	f	class:util::scoped_fd
scoped_fd	kenlm/util/file.hh	/^class scoped_fd {$/;"	c	namespace:util
scoped_malloc	kenlm/util/scoped.hh	/^    explicit scoped_malloc(void *p = NULL) : scoped_c<void, std::free>(p) {}$/;"	f	class:util::scoped_malloc
scoped_malloc	kenlm/util/scoped.hh	/^class scoped_malloc : public scoped_c<void, std::free> {$/;"	c	namespace:util
scoped_memory	kenlm/util/mmap.hh	/^    scoped_memory() : data_(NULL), size_(0), source_(NONE_ALLOCATED) {}$/;"	f	class:util::scoped_memory
scoped_memory	kenlm/util/mmap.hh	/^    scoped_memory(void *data, std::size_t size, Alloc source) $/;"	f	class:util::scoped_memory
scoped_memory	kenlm/util/mmap.hh	/^class scoped_memory {$/;"	c	namespace:util
scoped_mmap	kenlm/util/mmap.hh	/^    scoped_mmap() : data_((void*)-1), size_(0) {}$/;"	f	class:util::scoped_mmap
scoped_mmap	kenlm/util/mmap.hh	/^    scoped_mmap(void *data, std::size_t size) : data_(data), size_(size) {}$/;"	f	class:util::scoped_mmap
scoped_mmap	kenlm/util/mmap.hh	/^class scoped_mmap {$/;"	c	namespace:util
scoped_ptr	kenlm/util/scoped.hh	/^    explicit scoped_ptr(T *p = NULL) : scoped<T, scoped_delete_forward>(p) {}$/;"	f	class:util::scoped_ptr
scoped_ptr	kenlm/util/scoped.hh	/^template <class T> class scoped_ptr : public scoped<T, scoped_delete_forward> {$/;"	c	namespace:util
score	HLVRec.h	/^   TokScore  score;             \/* current likelihood of token, $/;"	m	struct:_Token
score	HLVRec.h	/^   TokScore score;              \/* total likelihood at end of word (time t) *\/$/;"	m	struct:_AltWordendHyp
score	HLVRec.h	/^   TokScore score;              \/* total likelihood at end of word (time t) *\/$/;"	m	struct:_WordendHyp
score	HLVRec.h	/^   TokScore score;$/;"	m	struct:_TokenSet
se	HLVLM.h	/^   SEntry *se;                  \/* Array[0..nse-1] of ngram probabilities *\/$/;"	m	struct:nentry
se_cmp	HLVLM.c	/^static int se_cmp(const void *v1,const void *v2)$/;"	f	file:
search_	kenlm/lm/model.hh	/^    Search search_;$/;"	m	class:lm::ngram::detail::GenericModel
search_version	kenlm/lm/binary_format.hh	/^  unsigned int search_version;$/;"	m	struct:lm::ngram::FixedWidthParameters
sentence_marker_missing	kenlm/lm/config.hh	/^  WarningAction sentence_marker_missing;$/;"	m	struct:lm::ngram::Config
sentry	HLVLM.h	/^typedef struct sentry {         \/* HLM NGram probability *\/$/;"	s
sequence_	kenlm/lm/filter/thread.hh	/^    uint64_t sequence_;$/;"	m	class:lm::Controller
sequence_	kenlm/lm/filter/thread.hh	/^    uint64_t sequence_;$/;"	m	class:lm::ThreadBatch
set	kenlm/util/string_piece.hh	/^  void set(const char* data, size_type len) { ptr_ = data; length_ = len; }$/;"	f	class:StringPiece
set	kenlm/util/string_piece.hh	/^  void set(const char* str) {$/;"	f	class:StringPiece
set	kenlm/util/string_piece.hh	/^  void set(const void* data, size_type len) {$/;"	f	class:StringPiece
set_e	kenlm/util/double-conversion/diy-fp.h	/^  void set_e(int new_value) { e_ = new_value; }$/;"	f	class:double_conversion::DiyFp
set_f	kenlm/util/double-conversion/diy-fp.h	/^  void set_f(uint64_t new_value) { f_ = new_value; }$/;"	f	class:double_conversion::DiyFp
sets_	kenlm/lm/filter/vocab.hh	/^    std::vector<boost::iterator_range<const unsigned int*> > sets_;$/;"	m	class:lm::vocab::Multiple
sets_	kenlm/lm/filter/vocab.hh	/^    std::vector<boost::iterator_range<const unsigned int*> > sets_;$/;"	m	class:lm::vocab::Union
sharedstatedir	Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
show_progress	kenlm/lm/config.hh	/^  bool show_progress;$/;"	m	struct:lm::ngram::Config
si	HLVModel.h	/^   StateInfo **si;              \/* pointers to HModel:StateInfos  for USEHMODEL=T *\/$/;"	m	struct:_StateInfo_lv
si	HLVRec.h	/^   StateInfo_lv *si;$/;"	m	struct:_DecoderInst
significand	kenlm/util/double-conversion/cached-powers.cc	/^  uint64_t significand;$/;"	m	struct:double_conversion::CachedPower	file:
silDict	HDecode.c	/^static Boolean silDict = FALSE; \/* does dict contain -\/sp\/sil variants with probs *\/$/;"	v	file:
silDict	HDecode.mod.c	/^static Boolean silDict = FALSE; \/* does dict contain -\/sp\/sil variants with probs *\/$/;"	v	file:
silDict	HLVNet.h	/^   Boolean silDict;             \/* does dict contain -\/sp\/sil variants and pronprobs? *\/$/;"	m	struct:_LexNet
silDict	HLVNet.h	/^   Boolean silDict;     \/* does dict contain -\/sp\/sil variants and pronprobs? *\/$/;"	m	struct:_TLexNet
silLab	HDecode.c	/^static LabId silLab;            \/*   corresponding LabId *\/$/;"	v	file:
silLab	HDecode.mod.c	/^static LabId silLab;            \/*   corresponding LabId *\/$/;"	v	file:
silModel	HDecode.c	/^static char *silModel = "sil";  \/* model used as word end Silence *\/$/;"	v	file:
silModel	HDecode.mod.c	/^static char *silModel = "sil";  \/* model used as word end Silence *\/$/;"	v	file:
size	HLVRec.h	/^   int size;$/;"	m	struct:_LMNodeCache
size	kenlm/util/double-conversion/utils.h	/^  int size() const { return buffer_.length(); }$/;"	f	class:double_conversion::StringBuilder
size	kenlm/util/fixed_array.hh	/^    std::size_t size() const { return end() - begin(); }$/;"	f	class:util::FixedArray
size	kenlm/util/mmap.hh	/^    std::size_t size() const { return size_; }$/;"	f	class:util::scoped_memory
size	kenlm/util/mmap.hh	/^    std::size_t size() const { return size_; }$/;"	f	class:util::scoped_mmap
size	kenlm/util/parallel_read.cc	/^      std::size_t size;$/;"	m	struct:util::__anon44::Reader::Request	file:
size	kenlm/util/string_piece.hh	/^  size_type size() const { return length_; }$/;"	f	class:StringPiece
size_	kenlm/lm/builder/corpus_count.cc	/^    const std::size_t size_;$/;"	m	class:lm::builder::__anon9::DedupeEquals	file:
size_	kenlm/lm/builder/corpus_count.cc	/^    const std::size_t size_;$/;"	m	class:lm::builder::__anon9::DedupeHash	file:
size_	kenlm/util/mmap.hh	/^    std::size_t size_;$/;"	m	class:util::scoped_memory
size_	kenlm/util/mmap.hh	/^    std::size_t size_;$/;"	m	class:util::scoped_mmap
size_	kenlm/util/sized_iterator.hh	/^    std::size_t size_;$/;"	m	class:util::SizedInnerIterator
size_type	kenlm/util/string_piece.cc	/^typedef StringPiece::size_type size_type;$/;"	t	file:
size_type	kenlm/util/string_piece.hh	/^  typedef size_t size_type;$/;"	t	class:StringPiece
sort	kenlm/lm/builder/pipeline.hh	/^  util::stream::SortConfig sort;$/;"	m	struct:lm::builder::PipelineConfig
source	kenlm/util/mmap.hh	/^    Alloc source() const { return source_; }$/;"	f	class:util::scoped_memory
source_	kenlm/util/mmap.hh	/^    Alloc source_;$/;"	m	class:util::scoped_memory
spLab	HDecode.c	/^static LabId spLab;             \/*   corresponding LabId *\/$/;"	v	file:
spLab	HDecode.mod.c	/^static LabId spLab;             \/*   corresponding LabId *\/$/;"	v	file:
spModel	HDecode.c	/^static char *spModel = "sp";    \/* model used as word end Short Pause *\/$/;"	v	file:
spModel	HDecode.mod.c	/^static char *spModel = "sp";    \/* model used as word end Short Pause *\/$/;"	v	file:
spSkipLayer	HLVNet.h	/^   int spSkipLayer;             \/* id of layer where tokens get pronprob added and bypass sp *\/$/;"	m	struct:_LexNet
src	HLVRec.h	/^   LMState *src;$/;"	m	struct:_LMCacheLA
src	HLVRec.h	/^   LMState src;$/;"	m	struct:_LMLACacheEntry
src_kenlm	HLVRec.h	/^   lm::ngram::State src_kenlm;$/;"	m	struct:_LMCacheLA
srcdir	Makefile	/^srcdir = .$/;"	m
sri_	kenlm/lm/search_trie.cc	/^    SRISucks &sri_;$/;"	m	class:lm::ngram::trie::__anon24::FindBlanks	file:
sri_	kenlm/lm/search_trie.cc	/^    SRISucks &sri_;$/;"	m	class:lm::ngram::trie::__anon24::WriteEntries	file:
start	HDecode.c	/^   int start;           \/* frame numbers *\/$/;"	m	struct:_BestInfo	file:
start	HDecode.mod.c	/^   int start;           \/* frame numbers *\/$/;"	m	struct:_BestInfo	file:
start	HLVNet.h	/^   LexNode *start;              \/* single start node *\/$/;"	m	struct:_LexNet
start	HLVNet.h	/^   TLexNode *start;     \/* start node of network *\/$/;"	m	struct:_TLexNet
start	HLVNet.h	/^   TLexNode *start;$/;"	m	struct:_TLexLink
start	kenlm/util/double-conversion/utils.h	/^  T* start() const { return start_; }$/;"	f	class:double_conversion::Vector
startId	HLVNet.h	/^   LabId startId;       \/* id of STARTWORD (from config) *\/$/;"	m	struct:_TLexNet
startLab	HDecode.c	/^static LabId startLab;          \/*   corresponding LabId *\/$/;"	v	file:
startLab	HDecode.mod.c	/^static LabId startLab;          \/*   corresponding LabId *\/$/;"	v	file:
startPron	HLVNet.h	/^   PronId startPron;            \/* pron of <s> *\/$/;"	m	struct:_LexNet
startPronId	HLVLM.h	/^   PronId startPronId;$/;"	m	struct:_FSLM
startTok	HLVRec.c	/^RelToken startTok = {NULL, NULL, 0.0, 0.0, NULL};$/;"	v
startWord	HDecode.c	/^static char *startWord = "<s>"; \/* word used at start of network *\/$/;"	v	file:
startWord	HDecode.mod.c	/^static char *startWord = "<s>"; \/* word used at start of network *\/$/;"	v	file:
start_	kenlm/util/double-conversion/utils.h	/^  T* start_;$/;"	m	class:double_conversion::Vector
started_	kenlm/util/usage.cc	/^    Wall started_;$/;"	m	class:util::__anon49::RecordStart	file:
starts_with	kenlm/util/string_piece.hh	/^  bool starts_with(const StringPiece& x) const {$/;"	f	class:StringPiece
starts_with	kenlm/util/string_piece.hh	/^inline bool starts_with(const StringPiece& longer, const StringPiece& prefix) {$/;"	f
stateOutP	HLVRec.h	/^   LogFloat *stateOutP;$/;"	m	struct:_OutPCache
stateT	HLVRec.h	/^   int *stateT;$/;"	m	struct:_OutPCache
state_size_	kenlm/lm/virtual_interface.hh	/^    const size_t state_size_;$/;"	m	class:lm::base::Model
stats	HLVRec.h	/^   Stats stats;                 \/* statistics about pruning etc. *\/$/;"	m	struct:_DecoderInst
stlLinkN	HLVNet.c	/^int stlLinkN = 0;$/;"	v
stlNodeN	HLVNet.c	/^int stlNodeN = 0;$/;"	v
stone_	kenlm/util/stream/multi_progress.hh	/^    unsigned char stone_;$/;"	m	class:util::stream::WorkerProgress
stones_written_	kenlm/util/ersatz_progress.hh	/^    unsigned char stones_written_;$/;"	m	class:util::ErsatzProgress
storage_	kenlm/util/pcqueue.hh	/^  boost::scoped_array<T> storage_;$/;"	m	class:util::PCQueue
stream	kenlm/lm/builder/adjust_counts.hh	/^namespace util { namespace stream { class ChainPositions; } }$/;"	n	namespace:util
stream	kenlm/lm/builder/corpus_count.hh	/^namespace stream {$/;"	n	namespace:util
stream	kenlm/lm/builder/initial_probabilities.hh	/^namespace util { namespace stream { class Chains; } }$/;"	n	namespace:util
stream	kenlm/lm/builder/output.hh	/^namespace util { namespace stream { class Chains; class ChainPositions; } }$/;"	n	namespace:util
stream	kenlm/lm/interpolate/arpa_to_stream.hh	/^namespace util { namespace stream { class ChainPositions; } }$/;"	n	namespace:util
stream	kenlm/util/stream/block.hh	/^namespace stream {$/;"	n	namespace:util
stream	kenlm/util/stream/chain.cc	/^namespace stream {$/;"	n	namespace:util	file:
stream	kenlm/util/stream/chain.hh	/^namespace stream {$/;"	n	namespace:util
stream	kenlm/util/stream/config.hh	/^namespace util { namespace stream {$/;"	n	namespace:util
stream	kenlm/util/stream/io.cc	/^namespace stream {$/;"	n	namespace:util	file:
stream	kenlm/util/stream/io.hh	/^namespace stream {$/;"	n	namespace:util
stream	kenlm/util/stream/line_input.cc	/^namespace util { namespace stream {$/;"	n	namespace:util	file:
stream	kenlm/util/stream/line_input.hh	/^namespace util {namespace stream {$/;"	n	namespace:util
stream	kenlm/util/stream/multi_progress.cc	/^namespace util { namespace stream {$/;"	n	namespace:util	file:
stream	kenlm/util/stream/multi_progress.hh	/^namespace util { namespace stream {$/;"	n	namespace:util
stream	kenlm/util/stream/multi_stream.hh	/^namespace util { namespace stream {$/;"	n	namespace:util
stream	kenlm/util/stream/sort.hh	/^namespace stream {$/;"	n	namespace:util
stream	kenlm/util/stream/stream.hh	/^namespace stream {$/;"	n	namespace:util
stream_	kenlm/lm/builder/ngram_stream.hh	/^    util::stream::Stream stream_;$/;"	m	class:lm::builder::NGramStream
stream_	kenlm/util/exception.hh	/^    std::stringstream stream_;$/;"	m	class:util::Exception
stream_	kenlm/util/read_compressed.cc	/^    bz_stream stream_;$/;"	m	class:util::__anon45::BZip	file:
stream_	kenlm/util/read_compressed.cc	/^    lzma_stream stream_;$/;"	m	class:util::__anon45::XZip	file:
stream_	kenlm/util/read_compressed.cc	/^    std::istream &stream_;$/;"	m	class:util::__anon45::IStreamReader	file:
stream_	kenlm/util/read_compressed.cc	/^    z_stream stream_;$/;"	m	class:util::__anon45::GZip	file:
string_backing_	kenlm/lm/vocab.hh	/^    util::Pool string_backing_;$/;"	m	class:lm::ngram::SortedVocabulary
strings_to_enumerate_	kenlm/lm/vocab.hh	/^    std::vector<StringPiece> strings_to_enumerate_;$/;"	m	class:lm::ngram::SortedVocabulary
substr	kenlm/util/string_piece.cc	/^StringPiece StringPiece::substr(size_type pos, size_type n) const {$/;"	f	class:StringPiece
substring	kenlm/lm/filter/phrase.hh	/^      std::vector<unsigned int> substring, left, right, phrase;$/;"	m	struct:lm::phrase::Substrings::SentenceRelation
substrings_	kenlm/lm/filter/phrase.hh	/^    const Substrings &substrings_;$/;"	m	class:lm::phrase::detail::ConditionCommon
sumTokPerTS	HLVRec.h	/^   unsigned long sumTokPerTS;$/;"	m	struct:_Stats
swap	kenlm/lm/trie_sort.cc	/^    friend void swap(PartialViewProxy first, PartialViewProxy second) {$/;"	f	class:lm::ngram::trie::__anon26::PartialViewProxy
swap	kenlm/util/joint_sort.hh	/^    friend void swap(JointIter &first, JointIter &second) {$/;"	f	class:util::detail::JointIter
swap	kenlm/util/joint_sort.hh	/^    friend void swap(JointProxy<KeyIter, ValueIter> first, JointProxy<KeyIter, ValueIter> second) {$/;"	f	class:util::detail::JointProxy
swap	kenlm/util/sized_iterator.hh	/^    friend void swap(SizedInnerIterator &first, SizedInnerIterator &second) {$/;"	f	class:util::SizedInnerIterator
swap	kenlm/util/sized_iterator.hh	/^    friend void swap(SizedProxy first, SizedProxy second) {$/;"	f	class:util::SizedProxy
sysconfdir	Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
systems	kenlm/lm/filter/format.hh	/^      std::vector<size_t> systems;$/;"	m	struct:lm::MultipleOutputBuffer::Annotated
t	HLVRec.h	/^   int t;$/;"	m	struct:_LMNodeCache
table_	kenlm/lm/filter/phrase.hh	/^    Table table_;$/;"	m	class:lm::phrase::Substrings
table_	kenlm/lm/quantize.hh	/^        const Bins *table_;$/;"	m	class:lm::ngram::SeparatelyQuantize::LongestPointer
tables_	kenlm/lm/quantize.hh	/^    Bins tables_[KENLM_MAX_ORDER - 1][2];$/;"	m	class:lm::ngram::SeparatelyQuantize
task_	kenlm/util/pcqueue.hh	/^    task_t task_;$/;"	m	class:util::Semaphore
tempTS	HLVRec.h	/^   TokenSet **tempTS;           \/* temp tokset arrays for PropagateInternal() *\/$/;"	m	struct:_DecoderInst
temp_prefix	kenlm/util/stream/config.hh	/^  std::string temp_prefix;$/;"	m	struct:util::stream::SortConfig
temporary_directory_prefix	kenlm/lm/config.hh	/^  std::string temporary_directory_prefix;$/;"	m	struct:lm::ngram::Config
text_	kenlm/util/exception.hh	/^    mutable std::string text_;$/;"	m	class:util::Exception
thread_	kenlm/util/stream/chain.hh	/^    boost::thread thread_;$/;"	m	class:util::stream::Thread
thread_	kenlm/util/thread_pool.hh	/^    boost::thread thread_;$/;"	m	class:util::Worker
threads_	kenlm/util/stream/chain.hh	/^    boost::ptr_vector<Thread> threads_;$/;"	m	class:util::stream::Chain
threads_	kenlm/util/stream/multi_stream.hh	/^    boost::ptr_vector<util::stream::Thread> threads_;$/;"	m	class:util::stream::Chains
threshold_	kenlm/util/probing_hash_table.hh	/^    std::size_t threshold_;$/;"	m	class:util::AutoProbing
tnetHeap	HLVNet.c	/^static MemHeap tnetHeap;                \/* used for temporary data in net creation *\/$/;"	v	file:
to	kenlm/util/parallel_read.cc	/^      void *to;$/;"	m	struct:util::__anon44::Reader::Request	file:
to_	kenlm/lm/builder/print.hh	/^    int to_;$/;"	m	class:lm::builder::Print
to_	kenlm/lm/search_hashed.hh	/^    const float *to_;$/;"	m	class:lm::ngram::detail::LongestPointer
to_	kenlm/lm/trie.hh	/^    const ProbBackoff *to_;$/;"	m	class:lm::ngram::trie::UnigramPointer
to_	kenlm/lm/value.hh	/^    const Weights *to_;$/;"	m	class:lm::ngram::GenericProbingProxy
to_	kenlm/lm/value.hh	/^    const Weights *to_;$/;"	m	class:lm::ngram::GenericTrieUnigramProxy
to_read_	kenlm/lm/filter/thread.hh	/^    util::PCQueue<Batch*> to_read_;$/;"	m	class:lm::Controller
tokSetHeap	HLVRec.h	/^   MemHeap *tokSetHeap;         \/* MHEAPs for N TokenSet arrays *\/$/;"	m	struct:_DecoderInst
tokSetIdCount	HLVRec.h	/^   unsigned int tokSetIdCount;\/* max id used so far for token sets *\/$/;"	m	struct:_DecoderInst
token_count	kenlm/lm/builder/header_info.hh	/^  uint64_t token_count;$/;"	m	struct:HeaderInfo
token_count_	kenlm/lm/builder/corpus_count.hh	/^    uint64_t &token_count_;$/;"	m	class:lm::builder::CorpusCount
top_srcdir	Makefile	/^top_srcdir = ..$/;"	m
total_bits_	kenlm/lm/trie.cc	/^    const uint8_t key_bits_, total_bits_;$/;"	m	class:lm::ngram::trie::__anon25::KeyAccessor	file:
total_bits_	kenlm/lm/trie.hh	/^    uint8_t total_bits_;$/;"	m	class:lm::ngram::trie::BitPacked
total_memory	kenlm/util/stream/config.hh	/^  std::size_t total_memory;$/;"	m	struct:util::stream::ChainConfig
total_memory	kenlm/util/stream/config.hh	/^  std::size_t total_memory;$/;"	m	struct:util::stream::SortConfig
total_memory_	kenlm/util/stream/sort.hh	/^    std::size_t total_memory_;$/;"	m	class:util::stream::MergingReader
total_order_	kenlm/lm/search_trie.cc	/^    const unsigned char total_order_;$/;"	m	class:lm::ngram::trie::__anon24::BlankManager	file:
total_size_	kenlm/util/file_piece.hh	/^    const uint64_t total_size_;$/;"	m	class:util::FilePiece
trace	HDecode.c	/^static int trace = 0;$/;"	v	file:
trace	HDecode.mod.c	/^static int trace = 0;$/;"	v	file:
trace	HLVLM.c	/^static int trace=0;$/;"	v	file:
trace	HLVModel.c	/^static int trace=0;$/;"	v	file:
trace	HLVNet.c	/^static int trace=0;$/;"	v	file:
trace	HLVRec.c	/^static int trace=0;$/;"	v	file:
transHeap	HDecode.c	/^static MemHeap transHeap;$/;"	v	file:
transHeap	HDecode.mod.c	/^static MemHeap transHeap;$/;"	v	file:
transHit	HLVRec.h	/^   int transHit;$/;"	m	struct:_LMCache
transMiss	HLVRec.h	/^   int transMiss;$/;"	m	struct:_LMCache
transProb	HLVLM.h	/^   LogFloat (*transProb) (FSLM *lm, LMState src, PronId pronId, LMState *dest);$/;"	m	struct:_FSLM
trie	kenlm/lm/bhiksha.cc	/^namespace trie {$/;"	n	namespace:lm::ngram	file:
trie	kenlm/lm/bhiksha.hh	/^namespace trie {$/;"	n	namespace:lm::ngram
trie	kenlm/lm/search_trie.cc	/^namespace trie {$/;"	n	namespace:lm::ngram	file:
trie	kenlm/lm/search_trie.hh	/^namespace trie {$/;"	n	namespace:lm::ngram
trie	kenlm/lm/trie.cc	/^namespace trie {$/;"	n	namespace:lm::ngram	file:
trie	kenlm/lm/trie.hh	/^namespace trie {$/;"	n	namespace:lm::ngram
trie	kenlm/lm/trie_sort.cc	/^namespace trie {$/;"	n	namespace:lm::ngram	file:
trie	kenlm/lm/trie_sort.hh	/^namespace trie {$/;"	n	namespace:lm::ngram
ts	HLVRec.h	/^   TokenSet *ts;                \/* array of TokenSets; one per state (incl. entry and exit) *\/$/;"	m	struct:_LexNodeInst
type	HLVLM.h	/^   FSLMType type;$/;"	m	struct:_FSLM
type	HLVNet.c	/^   STLexNodeType type;$/;"	m	struct:_STLexNode	file:
type	HLVNet.h	/^   LexNodeType type;$/;"	m	struct:_TLexNode
type	HLVNet.h	/^   unsigned char type;          \/* using char instead of enum can save 4 bytes! *\/$/;"	m	struct:_LexNode
type	kenlm/util/stream/chain.hh	/^      typedef Chain type;$/;"	t	struct:util::stream::Chain::CheckForRun
type	kenlm/util/stream/multi_stream.hh	/^      typedef Chains type;$/;"	t	struct:util::stream::Chains::CheckForRun
type_	kenlm/lm/builder/output.hh	/^    const HookType type_;$/;"	m	class:lm::builder::OutputHook
type_count_	kenlm/lm/builder/corpus_count.hh	/^    WordIndex &type_count_;$/;"	m	class:lm::builder::CorpusCount
uint16_t	kenlm/util/double-conversion/utils.h	/^typedef unsigned short uint16_t;  \/\/ NOLINT$/;"	t
uint32_t	kenlm/util/double-conversion/utils.h	/^typedef unsigned int uint32_t;$/;"	t
uint32_to_float	kenlm/util/double-conversion/ieee.h	/^static float uint32_to_float(uint32_t d32) { return BitCast<float>(d32); }$/;"	f	namespace:double_conversion
uint64_t	kenlm/util/double-conversion/utils.h	/^typedef unsigned __int64 uint64_t;$/;"	t
uint64_to_double	kenlm/util/double-conversion/ieee.h	/^static double uint64_to_double(uint64_t d64) { return BitCast<double>(d64); }$/;"	f	namespace:double_conversion
uint8_t	kenlm/util/double-conversion/utils.h	/^typedef unsigned char uint8_t;$/;"	t
ullAvailExtendedVirtual	kenlm/util/usage.cc	/^  DWORDLONG ullAvailExtendedVirtual;$/;"	m	struct:__anon48	file:
ullAvailPageFile	kenlm/util/usage.cc	/^  DWORDLONG ullAvailPageFile;$/;"	m	struct:__anon48	file:
ullAvailPhys	kenlm/util/usage.cc	/^  DWORDLONG ullAvailPhys;$/;"	m	struct:__anon48	file:
ullAvailVirtual	kenlm/util/usage.cc	/^  DWORDLONG ullAvailVirtual;$/;"	m	struct:__anon48	file:
ullTotalPageFile	kenlm/util/usage.cc	/^  DWORDLONG ullTotalPageFile;$/;"	m	struct:__anon48	file:
ullTotalPhys	kenlm/util/usage.cc	/^  DWORDLONG ullTotalPhys;$/;"	m	struct:__anon48	file:
ullTotalVirtual	kenlm/util/usage.cc	/^  DWORDLONG ullTotalVirtual;$/;"	m	struct:__anon48	file:
uniform_prob_	kenlm/lm/builder/interpolate.hh	/^    float uniform_prob_;$/;"	m	class:lm::builder::Interpolate
unigram_	kenlm/lm/search_hashed.hh	/^        typename Value::Weights *unigram_;$/;"	m	class:lm::ngram::detail::HashedSearch::Unigram
unigram_	kenlm/lm/search_hashed.hh	/^    Unigram unigram_;$/;"	m	class:lm::ngram::detail::HashedSearch
unigram_	kenlm/lm/search_trie.hh	/^    Unigram unigram_;$/;"	m	class:lm::ngram::trie::TrieSearch
unigram_	kenlm/lm/trie.hh	/^    UnigramValue *unigram_;$/;"	m	class:lm::ngram::trie::Unigram
unigram_	kenlm/lm/trie_sort.hh	/^    util::scoped_fd unigram_;$/;"	m	class:lm::ngram::trie::SortedFiles
unigrams	HLVLM.h	/^   NGLM_Prob *unigrams;         \/* Unigram probabilities indexed by PronId! *\/$/;"	m	struct:_FSLM_ngram
unigrams_	kenlm/lm/search_trie.cc	/^    UnigramValue *const unigrams_;$/;"	m	class:lm::ngram::trie::__anon24::WriteEntries	file:
unigrams_	kenlm/lm/search_trie.cc	/^    const ProbBackoff *unigrams_;$/;"	m	class:lm::ngram::trie::__anon24::FindBlanks	file:
unigrams_	kenlm/lm/value_build.hh	/^    std::vector<float> unigrams_;$/;"	m	class:lm::ngram::LowerRestBuild
uninterp	kenlm/lm/builder/ngram.hh	/^  Uninterpolated uninterp;$/;"	m	union:lm::builder::Payload
unknown_missing	kenlm/lm/config.hh	/^  WarningAction unknown_missing;$/;"	m	struct:lm::ngram::Config
unknown_missing_logprob	kenlm/lm/config.hh	/^  float unknown_missing_logprob;$/;"	m	struct:lm::ngram::Config
useHModel	HDecode.c	/^static Boolean useHModel = FALSE; \/* use standard HModel OutP functions *\/$/;"	v	file:
useHModel	HDecode.mod.c	/^static Boolean useHModel = FALSE; \/* use standard HModel OutP functions *\/$/;"	v	file:
useHModel	HLVModel.h	/^   Boolean useHModel;$/;"	m	struct:_StateInfo_lv
useHModel	HLVRec.h	/^   Boolean useHModel;           \/* use normal HModel OutP() functions? *\/$/;"	m	struct:_DecoderInst
useOldPrune	HLVRec.c	/^static Boolean useOldPrune = FALSE;     \/* backward compatibility for max model and reltok pruning etc. *\/$/;"	v	file:
used_	kenlm/util/pcqueue.hh	/^  Semaphore used_;$/;"	m	class:util::PCQueue
used_digits_	kenlm/util/double-conversion/bignum.h	/^  int used_digits_;$/;"	m	class:double_conversion::Bignum
user	HLVRec.h	/^   int user;                  \/* general user info; #### get rid of this! *\/$/;"	m	struct:_WordendHyp
util	kenlm/lm/builder/adjust_counts.hh	/^namespace util { namespace stream { class ChainPositions; } }$/;"	n
util	kenlm/lm/builder/corpus_count.hh	/^namespace util {$/;"	n
util	kenlm/lm/builder/initial_probabilities.hh	/^namespace util { namespace stream { class Chains; } }$/;"	n
util	kenlm/lm/builder/output.hh	/^namespace util { namespace stream { class Chains; class ChainPositions; } }$/;"	n
util	kenlm/lm/filter/arpa_io.hh	/^namespace util { class FilePiece; }$/;"	n
util	kenlm/lm/interpolate/arpa_to_stream.hh	/^namespace util { namespace stream { class ChainPositions; } }$/;"	n
util	kenlm/lm/model.hh	/^namespace util { class FilePiece; }$/;"	n
util	kenlm/lm/neural/wordvecs.hh	/^namespace util { class FilePiece; }$/;"	n
util	kenlm/lm/search_hashed.hh	/^namespace util { class FilePiece; }$/;"	n
util	kenlm/lm/trie_sort.hh	/^namespace util {$/;"	n
util	kenlm/util/bit_packing.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/bit_packing.hh	/^namespace util {$/;"	n
util	kenlm/util/ersatz_progress.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/ersatz_progress.hh	/^namespace util {$/;"	n
util	kenlm/util/exception.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/exception.hh	/^namespace util {$/;"	n
util	kenlm/util/fake_ofstream.hh	/^namespace util {$/;"	n
util	kenlm/util/file.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/file.hh	/^namespace util {$/;"	n
util	kenlm/util/file_piece.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/file_piece.hh	/^namespace util {$/;"	n
util	kenlm/util/fixed_array.hh	/^namespace util {$/;"	n
util	kenlm/util/joint_sort.hh	/^namespace util {$/;"	n
util	kenlm/util/mmap.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/mmap.hh	/^namespace util {$/;"	n
util	kenlm/util/multi_intersection.hh	/^namespace util {$/;"	n
util	kenlm/util/murmur_hash.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/murmur_hash.hh	/^namespace util {$/;"	n
util	kenlm/util/parallel_read.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/parallel_read.hh	/^namespace util {$/;"	n
util	kenlm/util/pcqueue.hh	/^namespace util {$/;"	n
util	kenlm/util/pool.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/pool.hh	/^namespace util {$/;"	n
util	kenlm/util/probing_hash_table.hh	/^namespace util {$/;"	n
util	kenlm/util/proxy_iterator.hh	/^namespace util {$/;"	n
util	kenlm/util/read_compressed.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/read_compressed.hh	/^namespace util {$/;"	n
util	kenlm/util/scoped.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/scoped.hh	/^namespace util {$/;"	n
util	kenlm/util/sized_iterator.hh	/^namespace util {$/;"	n
util	kenlm/util/sorted_uniform.hh	/^namespace util {$/;"	n
util	kenlm/util/stream/block.hh	/^namespace util {$/;"	n
util	kenlm/util/stream/chain.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/stream/chain.hh	/^namespace util {$/;"	n
util	kenlm/util/stream/config.hh	/^namespace util { namespace stream {$/;"	n
util	kenlm/util/stream/io.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/stream/io.hh	/^namespace util {$/;"	n
util	kenlm/util/stream/line_input.cc	/^namespace util { namespace stream {$/;"	n	file:
util	kenlm/util/stream/line_input.hh	/^namespace util {namespace stream {$/;"	n
util	kenlm/util/stream/multi_progress.cc	/^namespace util { namespace stream {$/;"	n	file:
util	kenlm/util/stream/multi_progress.hh	/^namespace util { namespace stream {$/;"	n
util	kenlm/util/stream/multi_stream.hh	/^namespace util { namespace stream {$/;"	n
util	kenlm/util/stream/sort.hh	/^namespace util {$/;"	n
util	kenlm/util/stream/stream.hh	/^namespace util {$/;"	n
util	kenlm/util/thread_pool.hh	/^namespace util {$/;"	n
util	kenlm/util/tokenize_piece.hh	/^namespace util {$/;"	n
util	kenlm/util/usage.cc	/^namespace util {$/;"	n	file:
util	kenlm/util/usage.hh	/^namespace util {$/;"	n
utterFN	HLVRec.h	/^   char *utterFN;               \/* name of current utterance *\/$/;"	m	struct:_DecoderInst
valid_size_	kenlm/util/stream/block.hh	/^    std::size_t valid_size_;$/;"	m	class:util::stream::Block
value	kenlm/lm/builder/corpus_count.cc	/^  lm::WordIndex value;$/;"	m	struct:lm::builder::__anon9::VocabEntry	file:
value	kenlm/lm/search_hashed.hh	/^  Prob value;$/;"	m	struct:lm::ngram::detail::ProbEntry
value	kenlm/lm/value.hh	/^    ProbBackoff value;$/;"	m	struct:lm::ngram::BackoffValue::ProbingEntry
value	kenlm/lm/value.hh	/^    Value value;$/;"	m	struct:lm::ngram::RestValue::ProbingEntry
value	kenlm/lm/vocab.hh	/^  WordIndex value;$/;"	m	struct:lm::ngram::ProbingVocabularyEntry
value	kenlm/util/double-conversion/ieee.h	/^  double value() const { return uint64_to_double(d64_); }$/;"	f	class:double_conversion::Double
value	kenlm/util/double-conversion/ieee.h	/^  float value() const { return uint32_to_float(d32_); }$/;"	f	class:double_conversion::Single
value	kenlm/util/joint_sort.hh	/^      typename std::iterator_traits<ValueIter>::value_type value;$/;"	m	struct:util::detail::JointProxy::__anon40
value_	kenlm/util/joint_sort.hh	/^    ValueIter value_;$/;"	m	class:util::detail::JointIter
value_type	kenlm/lm/trie_sort.cc	/^    typedef std::string value_type;$/;"	t	class:lm::ngram::trie::__anon26::PartialViewProxy	file:
value_type	kenlm/util/joint_sort.hh	/^    } value_type;$/;"	t	class:util::detail::JointProxy	typeref:struct:util::detail::JointProxy::__anon40
value_type	kenlm/util/proxy_iterator.hh	/^    typedef typename Proxy::value_type value_type;$/;"	t	class:util::ProxyIterator
value_type	kenlm/util/sized_iterator.hh	/^    typedef std::string value_type;$/;"	t	class:util::SizedProxy
value_type	kenlm/util/string_piece.hh	/^  typedef char value_type;$/;"	t	class:StringPiece
values_	kenlm/lm/search_trie.cc	/^    std::vector<float> values_[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::trie::__anon24::SRISucks	file:
vecs_	kenlm/lm/neural/wordvecs.hh	/^    Storage vecs_;$/;"	m	class:lm::neural::WordVecs
verbose_header_	kenlm/lm/builder/print.hh	/^    bool verbose_header_;$/;"	m	class:lm::builder::PrintARPA
version	kenlm/lm/vocab.cc	/^  unsigned int version;$/;"	m	struct:lm::ngram::detail::ProbingVocabularyHeader	file:
vertices_	kenlm/lm/filter/phrase.hh	/^    std::vector<detail::Vertex> vertices_;$/;"	m	class:lm::phrase::detail::ConditionCommon
voc	HLVNet.h	/^   Vocab *voc;$/;"	m	struct:_LexNet
voc	HLVNet.h	/^   Vocab *voc;$/;"	m	struct:_TLexNet
vocSize	HLVLM.h	/^   int vocSize;                 \/* Core LM size *\/$/;"	m	struct:_FSLM_ngram
vocab	HDecode.c	/^static Vocab vocab;		\/* wordlist or dictionary *\/$/;"	v	file:
vocab	HDecode.mod.c	/^static Vocab vocab;		\/* wordlist or dictionary *\/$/;"	v	file:
vocab	HLVLM.h	/^   Vocab *vocab;                \/* Vocab used to find prons of words *\/$/;"	m	struct:_FSLM_ngram
vocab	kenlm/lm/filter/vocab.cc	/^namespace vocab {$/;"	n	namespace:lm	file:
vocab	kenlm/lm/filter/vocab.hh	/^namespace vocab {$/;"	n	namespace:lm
vocabFN	HLVNet.h	/^   char *vocabFN;$/;"	m	struct:_LexNet
vocab_	kenlm/lm/builder/print.hh	/^    const VocabReconstitute &vocab_;$/;"	m	class:lm::builder::Print
vocab_	kenlm/lm/filter/vocab.hh	/^    const Words &vocab_;$/;"	m	class:lm::vocab::Single
vocab_	kenlm/lm/interpolate/arpa_to_stream.hh	/^    ngram::GrowableVocab<ngram::WriteUniqueWords> &vocab_;$/;"	m	class:lm::interpolate::ARPAToStream
vocab_	kenlm/lm/model.hh	/^    VocabularyT vocab_;$/;"	m	class:lm::ngram::detail::GenericModel
vocab_	kenlm/lm/neural/wordvecs.hh	/^    ngram::ProbingVocabulary vocab_;$/;"	m	class:lm::neural::WordVecs
vocab_	kenlm/lm/wrappers/nplm.hh	/^    Vocabulary vocab_;$/;"	m	class:lm::np::Model
vocab_	kenlm/lm/wrappers/nplm.hh	/^    const nplm::vocabulary &vocab_;$/;"	m	class:lm::np::Vocabulary
vocab_backing_	kenlm/lm/neural/wordvecs.hh	/^    util::scoped_malloc vocab_backing_;$/;"	m	class:lm::neural::WordVecs
vocab_estimate	kenlm/lm/builder/pipeline.hh	/^  lm::WordIndex vocab_estimate;$/;"	m	struct:lm::builder::PipelineConfig
vocab_fd_	kenlm/lm/builder/output.hh	/^    int vocab_fd_;$/;"	m	class:lm::builder::Output
vocab_file	kenlm/lm/builder/pipeline.hh	/^  std::string vocab_file;$/;"	m	struct:lm::builder::PipelineConfig
vocab_htk	HLVRec.h	/^   Vocab vocab_htk;$/;"	m	struct:_DecoderInst
vocab_kenlm	HLVRec.h	/^   const lm::base::Vocabulary* vocab_kenlm;$/;"	m	struct:_DecoderInst
vocab_pad_	kenlm/lm/binary_format.hh	/^    std::size_t header_size_, vocab_size_, vocab_pad_;$/;"	m	class:lm::ngram::BinaryFormat
vocab_size_	kenlm/lm/binary_format.hh	/^    std::size_t header_size_, vocab_size_, vocab_pad_;$/;"	m	class:lm::ngram::BinaryFormat
vocab_size_for_unk	kenlm/lm/builder/pipeline.hh	/^  uint64_t vocab_size_for_unk;$/;"	m	struct:lm::builder::PipelineConfig
vocab_string_offset_	kenlm/lm/binary_format.hh	/^    uint64_t vocab_string_offset_;$/;"	m	class:lm::ngram::BinaryFormat
vocab_write_	kenlm/lm/builder/corpus_count.hh	/^    int vocab_write_;$/;"	m	class:lm::builder::CorpusCount
vocabs_	kenlm/lm/filter/vocab.hh	/^    const Words &vocabs_;$/;"	m	class:lm::vocab::Multiple
vocabs_	kenlm/lm/filter/vocab.hh	/^    const Words &vocabs_;$/;"	m	class:lm::vocab::Union
wait	kenlm/util/pcqueue.hh	/^    void wait() {$/;"	f	class:util::Semaphore
we	HLVNet.c	/^   Pron we;$/;"	m	struct:_STLexLink	file:
weBeamWidth	HDecode.c	/^static LogFloat weBeamWidth = - LZERO;   \/* pruning wordend beam width *\/$/;"	v	file:
weBeamWidth	HDecode.mod.c	/^static LogFloat weBeamWidth = - LZERO;   \/* pruning wordend beam width *\/$/;"	v	file:
weBeamWidth	HLVRec.h	/^   TokScore weBeamWidth;        \/* wordend beam width (set by -v cmd line option) *\/$/;"	m	struct:_DecoderInst
weHypHeap	HLVRec.h	/^   MemHeap weHypHeap;           \/* MHEAP for word end hyps *\/$/;"	m	struct:_DecoderInst
we_tag	HLVRec.h	/^   void *we_tag;$/;"	m	struct:_RelToken
weights	kenlm/lm/trie.hh	/^  ProbBackoff weights;$/;"	m	struct:lm::ngram::trie::UnigramValue
weights	kenlm/lm/value.hh	/^    Weights weights;$/;"	m	struct:lm::ngram::BackoffValue::TrieUnigramValue
weights	kenlm/lm/value.hh	/^    Weights weights;$/;"	m	struct:lm::ngram::RestValue::TrieUnigramValue
what	kenlm/util/exception.cc	/^const char *Exception::what() const throw() {$/;"	f	class:util::Exception
winTok	HLVRec.h	/^   RelToken *winTok;            \/* RelTok array fro MergeTokSet() *\/$/;"	m	struct:_DecoderInst
winTok_cmp	HLVRec-propagate.c	/^static int winTok_cmp (const void *v1,const void *v2)$/;"	f	file:
word	HLVLM.h	/^   LMId word[NSIZE-1];          \/* Word history representing this entry *\/$/;"	m	struct:nentry
word	HLVLM.h	/^   PronId word;                 \/* _Pron_ id !! *\/$/;"	m	struct:_FSLM_LatArc
word	HLVLM.h	/^   PronId word;                 \/* _Pron_ id !! *\/$/;"	m	struct:sentry
word	HLVLM.h	/^   Word word;$/;"	m	struct:_FSLM_LatNode
wordEndLayerId	HLVNet.h	/^   int wordEndLayerId;          \/* id of layer where token's time and score are copied to weHyp *\/$/;"	m	struct:_LexNet
word_bits_	kenlm/lm/trie.hh	/^    uint8_t word_bits_;$/;"	m	class:lm::ngram::trie::BitPacked
word_list_	kenlm/lm/vocab.hh	/^    util::FakeOFStream word_list_;$/;"	m	class:lm::ngram::WriteUniqueWords
word_mask_	kenlm/lm/trie.hh	/^    uint64_t word_mask_;$/;"	m	class:lm::ngram::trie::BitPacked
wordlist	HLVLM.h	/^   Word *wordlist;              \/* Lookup table for Words from LMId *\/$/;"	m	struct:_FSLM_ngram
wordmemcmp	kenlm/util/string_piece.hh	/^  static int wordmemcmp(const char* p, const char* p2, size_type N) {$/;"	f	class:StringPiece
words	kenlm/lm/state.hh	/^    WordIndex words[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::State
words	kenlm/lm/wrappers/nplm.hh	/^  WordIndex words[NPLM_MAX_ORDER - 1];$/;"	m	struct:lm::np::State
workers_	kenlm/util/thread_pool.hh	/^    boost::ptr_vector<Worker<Handler> > workers_;$/;"	m	class:util::ThreadPool
worstScore	HLVRec-misc.c	/^   TokScore worstScore;$/;"	m	struct:_LayerStats	file:
write_method	kenlm/lm/config.hh	/^  WriteMethod write_method;$/;"	m	struct:lm::ngram::Config
write_method_	kenlm/lm/binary_format.hh	/^    const Config::WriteMethod write_method_;$/;"	m	class:lm::ngram::BinaryFormat
write_mmap	kenlm/lm/config.hh	/^  const char *write_mmap;$/;"	m	struct:lm::ngram::Config
write_mmap_	kenlm/lm/binary_format.hh	/^    const char *write_mmap_;$/;"	m	class:lm::ngram::BinaryFormat
write_to_	kenlm/lm/bhiksha.hh	/^    uint64_t *write_to_;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
xfInfo	HDecode.c	/^static XFInfo xfInfo;$/;"	v	file:
xfInfo	HDecode.mod.c	/^static XFInfo xfInfo;$/;"	v	file:
zero_f	kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon7::OldSanity	file:
zero_f	kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon7::Sanity	file:
zsBeamWidth	HDecode.c	/^static LogFloat zsBeamWidth = - LZERO;   \/* pruning z-s beam width *\/$/;"	v	file:
zsBeamWidth	HDecode.mod.c	/^static LogFloat zsBeamWidth = - LZERO;   \/* pruning z-s beam width *\/$/;"	v	file:
zsBeamWidth	HLVRec.h	/^   TokScore zsBeamWidth;        \/* Z-S beam width (set by -v cmd line option) *\/$/;"	m	struct:_DecoderInst
~ARPAInputException	kenlm/lm/filter/arpa_io.cc	/^ARPAInputException::~ARPAInputException() throw() {}$/;"	f	class:lm::ARPAInputException
~ARPAOutputException	kenlm/lm/filter/arpa_io.cc	/^ARPAOutputException::~ARPAOutputException() throw() {}$/;"	f	class:lm::ARPAOutputException
~BZException	kenlm/util/read_compressed.cc	/^BZException::~BZException() throw() {}$/;"	f	class:util::BZException
~BZip	kenlm/util/read_compressed.cc	/^    ~BZip() {$/;"	f	class:util::__anon45::BZip
~BadDiscountException	kenlm/lm/builder/adjust_counts.cc	/^BadDiscountException::~BadDiscountException() throw() {}$/;"	f	class:lm::builder::BadDiscountException
~BadSortConfig	kenlm/util/stream/sort.hh	/^    ~BadSortConfig() throw() {}$/;"	f	class:util::stream::BadSortConfig
~Callback	kenlm/lm/builder/interpolate.cc	/^    ~Callback() {$/;"	f	class:lm::builder::__anon12::Callback
~Chain	kenlm/util/stream/chain.cc	/^Chain::~Chain() {$/;"	f	class:util::stream::Chain
~ChainConfigException	kenlm/util/stream/chain.cc	/^ChainConfigException::~ChainConfigException() throw() {}$/;"	f	class:util::stream::ChainConfigException
~Closer	kenlm/lm/trie_sort.cc	/^    ~Closer() {$/;"	f	class:lm::ngram::trie::__anon27::Closer
~CompressedException	kenlm/util/read_compressed.cc	/^CompressedException::~CompressedException() throw() {}$/;"	f	class:util::CompressedException
~ConditionCommon	kenlm/lm/filter/phrase.cc	/^ConditionCommon::~ConditionCommon() {}$/;"	f	class:lm::phrase::detail::ConditionCommon
~ConfigException	kenlm/lm/lm_exception.cc	/^ConfigException::~ConfigException() throw() {}$/;"	f	class:lm::ConfigException
~EndOfFileException	kenlm/util/file.cc	/^EndOfFileException::~EndOfFileException() throw() {}$/;"	f	class:util::EndOfFileException
~EnumerateVocab	kenlm/lm/enumerate_vocab.hh	/^    virtual ~EnumerateVocab() {}$/;"	f	class:lm::EnumerateVocab
~ErrnoException	kenlm/util/exception.cc	/^ErrnoException::~ErrnoException() throw() {}$/;"	f	class:util::ErrnoException
~ErsatzProgress	kenlm/util/ersatz_progress.cc	/^ErsatzProgress::~ErsatzProgress() {$/;"	f	class:util::ErsatzProgress
~Exception	kenlm/util/exception.cc	/^Exception::~Exception() throw() {}$/;"	f	class:util::Exception
~FDException	kenlm/util/file.cc	/^FDException::~FDException() throw() {}$/;"	f	class:util::FDException
~FakeOFStream	kenlm/util/fake_ofstream.hh	/^    ~FakeOFStream() {$/;"	f	class:util::FakeOFStream
~FileOpenException	kenlm/util/exception.hh	/^    ~FileOpenException() throw() {}$/;"	f	class:util::FileOpenException
~FilePiece	kenlm/util/file_piece.cc	/^FilePiece::~FilePiece() {}$/;"	f	class:util::FilePiece
~FixedArray	kenlm/util/fixed_array.hh	/^    ~FixedArray() { clear(); }$/;"	f	class:util::FixedArray
~FormatLoadException	kenlm/lm/lm_exception.cc	/^FormatLoadException::~FormatLoadException() throw() {}$/;"	f	class:lm::FormatLoadException
~GZException	kenlm/util/read_compressed.cc	/^GZException::~GZException() throw() {}$/;"	f	class:util::GZException
~GZip	kenlm/util/read_compressed.cc	/^    ~GZip() {$/;"	f	class:util::__anon45::GZip
~Link	kenlm/util/stream/chain.cc	/^Link::~Link() {$/;"	f	class:util::stream::Link
~LoadException	kenlm/lm/lm_exception.cc	/^LoadException::~LoadException() throw() {}$/;"	f	class:lm::LoadException
~LowerRestBuild	kenlm/lm/value_build.cc	/^template <class Model> LowerRestBuild<Model>::~LowerRestBuild() {$/;"	f	class:lm::ngram::LowerRestBuild
~MallocException	kenlm/util/scoped.cc	/^MallocException::~MallocException() throw() {}$/;"	f	class:util::MallocException
~Model	kenlm/lm/virtual_interface.cc	/^Model::~Model() {}$/;"	f	class:lm::base::Model
~Model	kenlm/lm/wrappers/nplm.cc	/^Model::~Model() {}$/;"	f	class:lm::np::Model
~ModelFacade	kenlm/lm/facade.hh	/^    virtual ~ModelFacade() {}$/;"	f	class:lm::base::ModelFacade
~MultiProgress	kenlm/util/stream/multi_progress.cc	/^MultiProgress::~MultiProgress() {$/;"	f	class:util::stream::MultiProgress
~OutOfTokens	kenlm/util/tokenize_piece.hh	/^    ~OutOfTokens() throw() {}$/;"	f	class:util::OutOfTokens
~OutputHook	kenlm/lm/builder/output.cc	/^OutputHook::~OutputHook() {}$/;"	f	class:lm::builder::OutputHook
~OverflowException	kenlm/util/exception.cc	/^OverflowException::~OverflowException() throw() {}$/;"	f	class:util::OverflowException
~ParseNumberException	kenlm/util/file_piece.hh	/^    ~ParseNumberException() throw() {}$/;"	f	class:util::ParseNumberException
~Pool	kenlm/util/pool.cc	/^Pool::~Pool() {$/;"	f	class:util::Pool
~ProbingSizeException	kenlm/util/probing_hash_table.hh	/^    ~ProbingSizeException() throw() {}$/;"	f	class:util::ProbingSizeException
~ReadBase	kenlm/util/read_compressed.cc	/^    virtual ~ReadBase() {}$/;"	f	class:util::ReadBase
~ReadCompressed	kenlm/util/read_compressed.cc	/^ReadCompressed::~ReadCompressed() {}$/;"	f	class:util::ReadCompressed
~ReadSizeException	kenlm/util/stream/io.cc	/^ReadSizeException::~ReadSizeException() throw() {}$/;"	f	class:util::stream::ReadSizeException
~Semaphore	kenlm/util/pcqueue.hh	/^    ~Semaphore() {$/;"	f	class:util::Semaphore
~SpecialWordMissingException	kenlm/lm/lm_exception.cc	/^SpecialWordMissingException::~SpecialWordMissingException() throw() {}$/;"	f	class:lm::SpecialWordMissingException
~StatCollector	kenlm/lm/builder/adjust_counts.cc	/^    ~StatCollector() {}$/;"	f	class:lm::builder::__anon8::StatCollector
~StringBuilder	kenlm/util/double-conversion/utils.h	/^  ~StringBuilder() { if (!is_finalized()) Finalize(); }$/;"	f	class:double_conversion::StringBuilder
~Thread	kenlm/util/stream/chain.cc	/^Thread::~Thread() {$/;"	f	class:util::stream::Thread
~ThreadPool	kenlm/util/thread_pool.hh	/^    ~ThreadPool() {$/;"	f	class:util::ThreadPool
~TrieSearch	kenlm/lm/search_trie.hh	/^    ~TrieSearch() { FreeMiddles(); }$/;"	f	class:lm::ngram::trie::TrieSearch
~VocabLoadException	kenlm/lm/lm_exception.cc	/^VocabLoadException::~VocabLoadException() throw() {}$/;"	f	class:lm::VocabLoadException
~Vocabulary	kenlm/lm/virtual_interface.cc	/^Vocabulary::~Vocabulary() {}$/;"	f	class:lm::base::Vocabulary
~Vocabulary	kenlm/lm/wrappers/nplm.cc	/^Vocabulary::~Vocabulary() {}$/;"	f	class:lm::np::Vocabulary
~WriteWordsWrapper	kenlm/lm/vocab.cc	/^WriteWordsWrapper::~WriteWordsWrapper() {}$/;"	f	class:lm::ngram::WriteWordsWrapper
~Writer	kenlm/lm/builder/corpus_count.cc	/^    ~Writer() {$/;"	f	class:lm::builder::__anon9::Writer
~XZException	kenlm/util/read_compressed.cc	/^XZException::~XZException() throw() {}$/;"	f	class:util::XZException
~XZip	kenlm/util/read_compressed.cc	/^    ~XZip() {$/;"	f	class:util::__anon45::XZip
~scoped_base	kenlm/util/scoped.hh	/^    ~scoped_base() { Closer::Close(p_); }$/;"	f	class:util::scoped_base
~scoped_fd	kenlm/util/file.cc	/^scoped_fd::~scoped_fd() {$/;"	f	class:util::scoped_fd
~scoped_memory	kenlm/util/mmap.hh	/^    ~scoped_memory() { reset(); }$/;"	f	class:util::scoped_memory
~scoped_mmap	kenlm/util/mmap.cc	/^scoped_mmap::~scoped_mmap() {$/;"	f	class:util::scoped_mmap
