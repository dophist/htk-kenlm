!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
#1	HTKBook/HTK.tex	/^   \\subsubsection{#1}\\label{s:#2}$/;"	b
#1	HTKBook/HTK.tex	/^  \\chapter{#1}\\label{c:#2}$/;"	c
#1	HTKBook/HTK.tex	/^  \\section{#1}\\label{s:#2}$/;"	s
#1	HTKBook/HTK.tex	/^  \\subsection{#1}\\label{s:#2}$/;"	b
A	HTKLib/HParm.c	/^   Vector A;          \/* Parameters for decompressing *\/$/;"	m	struct:__anon141	file:
ABS	HTKTools/HHEd.c	5315;"	d	file:
ABS	HTKTools/HMMIRest.c	63;"	d	file:
ACCWINDOW	HTKLib/HParm.c	/^   ACCWINDOW,     \/* Window size for 2nd diffs *\/$/;"	e	enum:__anon142	file:
ACLOCAL	Makefile	/^ACLOCAL = @ACLOCAL@$/;"	m
ACLOCAL_M4	Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ADAPTKIND	HTKLib/HModel.c	/^   NUMCLASSES, ADAPTKIND, PREQUAL, INPUTXFORM,$/;"	e	enum:__anon117	file:
ADDDITHER	HTKLib/HParm.c	/^   ADDDITHER,     \/* Amount of additional dither added to file *\/$/;"	e	enum:__anon142	file:
ADJ_OFS	HTKTools/HSLab.c	1149;"	d	file:
ADS_CLOSED	HTKLib/HAudio.c	/^               ADS_STOPPED, ADS_CLOSED } AudioDevStatus;$/;"	e	enum:__anon91	file:
ADS_INIT	HTKLib/HAudio.c	/^typedef enum { ADS_INIT, ADS_OPEN, ADS_SAMPLING, $/;"	e	enum:__anon91	file:
ADS_OPEN	HTKLib/HAudio.c	/^typedef enum { ADS_INIT, ADS_OPEN, ADS_SAMPLING, $/;"	e	enum:__anon91	file:
ADS_SAMPLING	HTKLib/HAudio.c	/^typedef enum { ADS_INIT, ADS_OPEN, ADS_SAMPLING, $/;"	e	enum:__anon91	file:
ADS_STOPPED	HTKLib/HAudio.c	/^               ADS_STOPPED, ADS_CLOSED } AudioDevStatus;$/;"	e	enum:__anon91	file:
AEntry	HTKTools/HLStats.c	/^} AEntry;$/;"	t	typeref:struct:aentry	file:
AIFF	HTKLib/HWave.h	/^        AIFF,              \/* Apple Audio Interchange format *\/$/;"	e	enum:__anon181
AI_CLEARED	HTKLib/HAudio.h	/^   AI_CLEARED,    \/* Not sampling and buffer empty *\/$/;"	e	enum:__anon93
AI_ERROR	HTKLib/HAudio.h	/^   AI_ERROR       \/* Error state - eg buffer overflow *\/$/;"	e	enum:__anon93
AI_SAMPLING	HTKLib/HAudio.h	/^   AI_SAMPLING,   \/* Sampling speech and filling buffer *\/   $/;"	e	enum:__anon93
AI_STOPPED	HTKLib/HAudio.h	/^   AI_STOPPED,    \/* Stopped but waiting for buffer to be emptied *\/$/;"	e	enum:__anon93
AI_WAITSIG	HTKLib/HAudio.h	/^   AI_WAITSIG,    \/* Wait for start signal *\/$/;"	e	enum:__anon93
AInfo	HTKLib/HAdapt.c	/^} AInfo;$/;"	t	typeref:struct:_AInfo	file:
ALIEN	HTKLib/HWave.h	/^        ALIEN,             \/* Unknown *\/$/;"	e	enum:__anon181
ALIEN and NOHEAD File Formats	HTKBook/speechio.tex	/^\\subsection{ALIEN and NOHEAD File Formats}$/;"	b
ALIGN8	HTKLVRec/kenlm/lm/binary_format.hh	39;"	d
ALL	HTKLVRec/kenlm/lm/config.hh	/^  enum ARPALoadComplain {ALL, EXPENSIVE, NONE};$/;"	e	enum:lm::ngram::Config::ARPALoadComplain
ALLOW_HEX	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_HEX = 1,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALLOW_LEADING_SPACES	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_LEADING_SPACES = 8,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALLOW_OCTALS	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_OCTALS = 2,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALLOW_SPACES_AFTER_SIGN	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_SPACES_AFTER_SIGN = 32$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALLOW_TRAILING_JUNK	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_TRAILING_JUNK = 4,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALLOW_TRAILING_SPACES	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    ALLOW_TRAILING_SPACES = 16,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
ALTPATHCHAR	HTKLib/HShell.h	489;"	d
ALT_DOWN	HTKLib/HGraf_WIN32.c	/^enum _AltState {ALT_UP,ALT_DOWN}; \/* keep track of Alt key *\/$/;"	e	enum:_AltState	file:
ALT_UP	HTKLib/HGraf_WIN32.c	/^enum _AltState {ALT_UP,ALT_DOWN}; \/* keep track of Alt key *\/$/;"	e	enum:_AltState	file:
AMPL_RANGE	HTKTools/HSLab.c	88;"	d	file:
ANON	HTKLib/HParm.h	/^      ANON};$/;"	e	enum:_BaseParmKind
APPSIL	HTKTools/HDMan.c	/^              TCTXT, APPSIL, REMSTRESS, REPLACEW, RAWMODE, $/;"	e	enum:__anon191	file:
ARPAFormat	HTKLVRec/kenlm/lm/filter/format.hh	/^struct ARPAFormat {$/;"	s	namespace:lm
ARPAInputException	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^ARPAInputException::ARPAInputException(const StringPiece &message) throw() {$/;"	f	class:lm::ARPAInputException
ARPAInputException	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^ARPAInputException::ARPAInputException(const StringPiece &message, const StringPiece &line) throw() {$/;"	f	class:lm::ARPAInputException
ARPAInputException	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^class ARPAInputException : public util::Exception {$/;"	c	namespace:lm
ARPALoadComplain	HTKLVRec/kenlm/lm/config.hh	/^  enum ARPALoadComplain {ALL, EXPENSIVE, NONE};$/;"	g	struct:lm::ngram::Config
ARPAOutput	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^ARPAOutput::ARPAOutput(const char *name, size_t buffer_size) : file_name_(name), buffer_(new char[buffer_size]) {$/;"	f	class:lm::ARPAOutput
ARPAOutput	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^class ARPAOutput : boost::noncopyable {$/;"	c	namespace:lm
ARPAOutputException	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^ARPAOutputException::ARPAOutputException(const char *message, const std::string &file_name) throw() {$/;"	f	class:lm::ARPAOutputException
ARPAOutputException	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^class ARPAOutputException : public util::ErrnoException {$/;"	c	namespace:lm
ARPAToStream	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.cc	/^ARPAToStream::ARPAToStream(int fd, ngram::GrowableVocab<ngram::WriteUniqueWords> &vocab)$/;"	f	class:lm::interpolate::ARPAToStream
ARPAToStream	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^class ARPAToStream {$/;"	c	namespace:lm::interpolate
ARRAY	HTKLib/esignal.h	65;"	d
ARRAY_ALLOCATED	HTKLVRec/kenlm/util/mmap.hh	/^    typedef enum {MMAP_ALLOCATED, ARRAY_ALLOCATED, MALLOC_ALLOCATED, NONE_ALLOCATED} Alloc;$/;"	e	enum:util::scoped_memory::__anon75
ARRAY_SIZE	HTKLVRec/kenlm/util/double-conversion/utils.h	104;"	d
ARRAY_TRIE	HTKLVRec/kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon54
ARRAY_TRIE_SORTED	HTKLVRec/kenlm/lm/model_type.hh	/^const ModelType ARRAY_TRIE_SORTED = ARRAY_TRIE;$/;"	m	namespace:lm::ngram
ASCII	HTKLib/esignal.h	106;"	d
ASIZE	HTKTools/HLStats.c	324;"	d	file:
ASSERT	HTKLVRec/kenlm/util/double-conversion/utils.h	36;"	d
ASpec2LPCep	HTKLib/HSigP.c	/^void ASpec2LPCep (Vector as, Vector ac, Vector lp, Vector c, DMatrix cm)$/;"	f
AT	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon199	file:
ATTEMPTS_MIN	HTKLVRec/kenlm/util/file.cc	384;"	d	file:
AU	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon199	file:
AUDBUFSIZE	HTKLib/HAudio.c	140;"	d	file:
AUDIOSIG	HTKLib/HParm.c	/^   AUDIOSIG,      \/* Signal for audio control *\/$/;"	e	enum:__anon142	file:
AUDIO_BSIZE	HTKTools/HList.c	335;"	d	file:
AUDIO_DEV	HTKLib/HAudio.c	126;"	d	file:
AUDIO_DEV	HTKLib/HAudio.c	81;"	d	file:
AUDIO_DEV	HTKLib/HAudio.c	83;"	d	file:
AUDIO_IO	HTKLib/HAudio.c	106;"	d	file:
AUDIO_IO	HTKLib/HAudio.c	97;"	d	file:
AUDIO_IODEV	HTKLib/HAudio.c	105;"	d	file:
AUDIO_IODEV	HTKLib/HAudio.c	96;"	d	file:
AUDIO_RD	HTKLib/HAudio.c	128;"	d	file:
AUDIO_WR	HTKLib/HAudio.c	129;"	d	file:
AUTOCONF	Makefile	/^AUTOCONF = @AUTOCONF@$/;"	m
AUTOHEADER	Makefile	/^AUTOHEADER = @AUTOHEADER@$/;"	m
AUTOMAKE	Makefile	/^AUTOMAKE = @AUTOMAKE@$/;"	m
AccAdaptBaseTriMat	HTKLib/HAdapt.c	/^static Boolean AccAdaptBaseTriMat(AdaptXForm *xform)$/;"	f	file:
AccAdaptFrame	HTKLib/HAdapt.c	/^void AccAdaptFrame(HMMSet *hset, double Lr, Vector svec, MixPDF *mp, int t)$/;"	f
AccAdaptMean	HTKLib/HAdapt.c	/^static Boolean AccAdaptMean(AdaptXForm *xform)$/;"	f	file:
AccAdaptVar	HTKLib/HAdapt.c	/^static Boolean AccAdaptVar(AdaptXForm *xform)$/;"	f	file:
AccBaseClassStats	HTKLib/HAdapt.c	/^static void AccBaseClassStats(MixPDF *mp, AccStruct *accs)$/;"	f	file:
AccBaseTriMat	HTKLib/HAdapt.c	/^static void AccBaseTriMat(HMMSet *hset, double Lr, Vector svec, MixPDF *mp, int t)$/;"	f	file:
AccCMLLRBaseStats	HTKLib/HAdapt.c	/^static void AccCMLLRBaseStats(MixPDF *mp, AccStruct *accs)$/;"	f	file:
AccCMLLRPDFStats	HTKLib/HAdapt.c	/^static void AccCMLLRPDFStats(MixPDF *mp,  AccStruct *accs)$/;"	f	file:
AccCache	HTKLib/HAdapt.c	/^} AccCache;                       \/* acc cache to save accumulators related to parent XForm *\/  $/;"	t	typeref:struct:_AccCache	file:
AccGenUtt	HTKTools/HCompV.c	/^SpkrAcc *AccGenUtt(char *SpkrPattern, char *UttFileName, SpkrAcc *sa)$/;"	f
AccMLLRCOVPDFStats	HTKLib/HAdapt.c	/^static void AccMLLRCOVPDFStats(MixPDF *mp,  AccStruct *accs)$/;"	f	file:
AccMLLRPDFStats	HTKLib/HAdapt.c	/^static void AccMLLRPDFStats(MixPDF *mp,  AccStruct *accs)$/;"	f	file:
AccMixPDFSemiTiedStats	HTKLib/HAdapt.c	/^static void AccMixPDFSemiTiedStats(HMMSet *hset,MixPDF *mp, AccStruct *accs)$/;"	f	file:
AccMixPDFStats	HTKLib/HAdapt.c	/^static void AccMixPDFStats(HMMSet *hset, MixPDF *mp, AccStruct *accs)$/;"	f	file:
AccNodeStats	HTKLib/HAdapt.c	/^static void AccNodeStats(RegNode *node, AccStruct *accs, $/;"	f	file:
AccScale	HTKLib/HFBLat.h	/^  float AccScale; \/*normally 1.0*\/$/;"	m	struct:__anon102
AccStruct	HTKLib/HAdapt.c	/^} AccStruct;$/;"	t	typeref:struct:__anon85	file:
AccSum	HTKTools/HHEd.c	/^} AccSum;$/;"	t	typeref:struct:_AccSum	file:
AccSumProb	HTKTools/HHEd.c	/^float AccSumProb(AccSum *acc)$/;"	f
AccVar	HTKTools/HCompV.c	/^void AccVar(Observation obs)$/;"	f
AccessInfo	HLMLib/LModel.h	/^typedef struct _AccessInfo  AccessInfo; \/* abstract type for access stats structure *\/$/;"	t	typeref:struct:_AccessInfo
AccumulateStats	HTKLVRec/HLVRec-misc.c	/^void AccumulateStats (DecoderInst *dec)$/;"	f
Acoustic	HTKLib/HArc.h	/^} Acoustic;  \/* for calculating acoustic likelihoods... *\/$/;"	t	typeref:struct:_Acoustic
Activate	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^void MultiProgress::Activate() {$/;"	f	class:util::stream::MultiProgress
ActivateLowerMiddle	HTKLVRec/kenlm/lm/search_hashed.cc	/^    explicit ActivateLowerMiddle(Middle &middle) : modify_(middle) {}$/;"	f	class:lm::ngram::__anon57::ActivateLowerMiddle
ActivateLowerMiddle	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <class Middle> class ActivateLowerMiddle {$/;"	c	namespace:lm::ngram::__anon57	file:
ActivateNode	HTKLVRec/HLVRec.c	/^static LexNodeInst *ActivateNode (DecoderInst *dec, LexNode *ln)$/;"	f	file:
ActivateProgress	HTKLVRec/kenlm/util/stream/chain.hh	/^    void ActivateProgress() {$/;"	f	class:util::stream::Chain
ActivateUnigram	HTKLVRec/kenlm/lm/search_hashed.cc	/^    explicit ActivateUnigram(Weights *unigram) : modify_(unigram) {}$/;"	f	class:lm::ngram::__anon57::ActivateUnigram
ActivateUnigram	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <class Weights> class ActivateUnigram {$/;"	c	namespace:lm::ngram::__anon57	file:
AdaptKind	HTKLib/HModel.h	/^typedef enum _AdaptKind AdaptKind;$/;"	t	typeref:enum:_AdaptKind
AdaptKind2Str	HTKLib/HModel.c	/^char *AdaptKind2Str(AdaptKind akind, char *buf)$/;"	f
AdaptWgt	HTKLib/HModel.h	/^} AdaptWgt; $/;"	t	typeref:union:__anon131
AdaptXForm	HTKLib/HModel.h	/^} AdaptXForm;$/;"	t	typeref:struct:_AdaptXForm
AdaptXForm2InputXForm	HTKLib/HAdapt.c	/^InputXForm *AdaptXForm2InputXForm(HMMSet *hset, AdaptXForm *xform)$/;"	f
Add	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    void Add(std::size_t order_minus_1, uint64_t count, bool pruned = false) {$/;"	f	class:lm::builder::__anon42::StatCollector
Add	HTKLVRec/kenlm/lm/builder/output.hh	/^    void Add(OutputHook *hook) {$/;"	f	class:lm::builder::Output
Add	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Add(const WordIndex *to, ProbPointer index) {$/;"	f	class:lm::ngram::trie::__anon58::BackoffMessages
Add	HTKLVRec/kenlm/lm/vocab.cc	/^void WriteWordsWrapper::Add(WordIndex index, const StringPiece &str) {$/;"	f	class:lm::ngram::WriteWordsWrapper
Add	HTKLVRec/kenlm/util/stream/chain.cc	/^ChainPosition Chain::Add() {$/;"	f	class:util::stream::Chain
Add	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^WorkerProgress MultiProgress::Add() {$/;"	f	class:util::stream::MultiProgress
AddArcTrans	HTKLib/HArc.c	/^void AddArcTrans(MemHeap *mem,  HArc *start, HArc *end, float lmlike){$/;"	f
AddAuxLab	HTKLib/HLabel.c	/^void AddAuxLab(LLink lab, int n, LabId *auxLab, float *auxScore)$/;"	f
AddBignum	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::AddBignum(const Bignum& other) {$/;"	f	class:double_conversion::Bignum
AddBinEntries	HTKTools/HQuant.c	/^VQNode AddBinEntries(ClusterSet *cs, short nid, int s)$/;"	f
AddChain	HTKLib/HNet.c	/^static void AddChain(Network*net, NetNode *hd) $/;"	f	file:
AddChar	HTKLib/esig_asc.c	/^AddChar(int     ch,$/;"	f	file:
AddCharacter	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  void AddCharacter(char c) {$/;"	f	class:double_conversion::StringBuilder
AddCombiner	HTKLVRec/kenlm/lm/builder/sort.hh	/^struct AddCombiner {$/;"	s	namespace:lm::builder
AddDiffs	HTKLib/HParm.c	/^static void AddDiffs(float *data, int nRows, int nCols, int si, int ti, int d, $/;"	f	file:
AddEquiv	HLMTools/LPlex.c	/^static void AddEquiv(char * cl, char * eq)$/;"	f	file:
AddEquiv	HTKTools/HResults.c	/^void AddEquiv(char * cl, char * eq)$/;"	f
AddField	HTKLib/esignal.c	/^AddField(FieldList   *list,     \/* variable containing field list *\/$/;"	f
AddFull	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    void AddFull(uint64_t count, bool pruned = false) {$/;"	f	class:lm::builder::__anon42::StatCollector
AddHCIContext	HTKLib/HNet.c	/^int AddHCIContext(HMMSetCxtInfo *hci,LabId labid)$/;"	f
AddHeadRegress	HTKLib/HSigP.c	/^void AddHeadRegress(float *data, int vSize, int n, int step, int offset,$/;"	f
AddInXFormDir	HTKLib/HModel.c	/^void AddInXFormDir(HMMSet *hset, char *dirname)$/;"	f
AddIncoming	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    void AddIncoming(Arc *arc) {$/;"	f	class:lm::phrase::detail::Vertex	file:
AddInitialFinal	HTKLib/HNet.c	/^static void AddInitialFinal(Lattice *wnet, Network *net,int xc)$/;"	f	file:
AddInputGFile	HLMLib/LGBase.c	/^void AddInputGFile(NGInputSet *inset, char *fn, float weight)$/;"	f
AddItem	HTKLib/HUtil.c	/^void AddItem(HLink owner, Ptr item, ILink *list)$/;"	f
AddJMix	HTKTools/HHEd.c	/^void AddJMix(MixtureElem *me)$/;"	f
AddLabel	HTKLib/HLabel.c	/^LLink AddLabel(MemHeap *x, LabList *ll, LabId id,$/;"	f
AddLabelList	HTKLib/HLabel.c	/^void AddLabelList(LabList *ll, Transcription *t)$/;"	f
AddLinEntries	HTKTools/HQuant.c	/^VQNode  AddLinEntries(ClusterSet *cs, int s)$/;"	f
AddLink	HTKLVRec/HLVNet.c	/^void AddLink (MemHeap *heap, TLexNode *start, TLexNode *end)$/;"	f
AddMMF	HTKLib/HModel.c	/^MILink AddMMF(HMMSet *hset, char *fname)$/;"	f
AddMember	HTKLib/HUtil.c	/^void AddMember(IntSet s, int x)$/;"	f
AddMonoPron_S	HTKLVRec/HLVNet.c	/^STLexNode *AddMonoPron_S (MemHeap *heap, STLexNode *root, int n, LabId *p)$/;"	f
AddNGram	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^    template <class Iterator> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line) {$/;"	f	class:lm::ARPAOutput
AddNGram	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^    void AddNGram(const StringPiece &line) {$/;"	f	class:lm::ARPAOutput
AddNGram	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^    void AddNGram(const StringPiece &ngram, const StringPiece &line) {$/;"	f	class:lm::ARPAOutput
AddNGram	HTKLVRec/kenlm/lm/filter/count_io.hh	/^    template <class Iterator> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line) {$/;"	f	class:lm::CountOutput
AddNGram	HTKLVRec/kenlm/lm/filter/count_io.hh	/^    void AddNGram(const StringPiece &line) {$/;"	f	class:lm::CountOutput
AddNGram	HTKLVRec/kenlm/lm/filter/count_io.hh	/^    void AddNGram(const StringPiece &ngram, const StringPiece &line) {$/;"	f	class:lm::CountOutput
AddNGram	HTKLVRec/kenlm/lm/filter/format.hh	/^    template <class Iterator> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line) {$/;"	f	class:lm::MultipleOutput
AddNGram	HTKLVRec/kenlm/lm/filter/format.hh	/^    template <class Output> void AddNGram(const StringPiece &ngram, const StringPiece &line, Output &output) {$/;"	f	class:lm::InputBuffer
AddNGram	HTKLVRec/kenlm/lm/filter/format.hh	/^    void AddNGram(const StringPiece &line) {$/;"	f	class:lm::BinaryOutputBuffer
AddNGram	HTKLVRec/kenlm/lm/filter/format.hh	/^    void AddNGram(const StringPiece &line) {$/;"	f	class:lm::MultipleOutput
AddNGram	HTKLVRec/kenlm/lm/filter/format.hh	/^    void AddNGram(const StringPiece &line) {$/;"	f	class:lm::MultipleOutputBuffer
AddNGram	HTKLVRec/kenlm/lm/filter/format.hh	/^    void AddNGram(const StringPiece &ngram, const StringPiece &line) {$/;"	f	class:lm::DispatchInput
AddNGram	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    template <class Iterator, class Output> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line, Output &output) {$/;"	f	class:lm::phrase::Multiple
AddNGram	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    template <class Output> void AddNGram(const StringPiece &ngram, const StringPiece &line, Output &output) {$/;"	f	class:lm::phrase::Multiple
AddNGram	HTKLVRec/kenlm/lm/filter/thread.hh	/^    void AddNGram(const StringPiece &ngram, const StringPiece &line, RealOutput &output) {$/;"	f	class:lm::Controller
AddNGram	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    template <class Iterator, class Output> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line, Output &output) {$/;"	f	class:lm::vocab::Multiple
AddNGram	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    template <class Output> void AddNGram(const StringPiece &ngram, const StringPiece &line, Output &output) {$/;"	f	class:lm::vocab::Multiple
AddNGram	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^    template <class Iterator, class Output> void AddNGram(const Iterator &begin, const Iterator &end, const StringPiece &line, Output &output) {$/;"	f	class:lm::BinaryFilter
AddNGram	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^    template <class Output> void AddNGram(const StringPiece &ngram, const StringPiece &line, Output &output) {$/;"	f	class:lm::BinaryFilter
AddNGram	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^    template <class Output> void AddNGram(const StringPiece &ngram, const StringPiece &line, Output &output) {$/;"	f	class:lm::ContextFilter
AddPadding	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  void AddPadding(char c, int count) {$/;"	f	class:double_conversion::StringBuilder
AddPhrase	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    template <class Iterator> void AddPhrase(unsigned int sentence_id, const Iterator &begin, const Iterator &end) {$/;"	f	class:lm::phrase::Substrings
AddPriorsFromPriorHMM	HTKTools/HMMIRest.c	/^void AddPriorsFromPriorHMM(int dst_index, float Tau, float K, Boolean IsMMI, float ISmoothTau){$/;"	f
AddPronProbs	HTKLVRec/HLVRec-propagate.c	/^static void AddPronProbs (DecoderInst *dec, TokenSet *ts, int var)$/;"	f	file:
AddQualifiers	HTKLib/HParm.c	/^static void AddQualifiers(ParmBuf pbuf,float *data, int nRows, IOConfig cf, $/;"	f	file:
AddRegression	HTKLib/HSigP.c	/^void AddRegression(float *data, int vSize, int n, int step, int offset,$/;"	f
AddRight	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    AddRight(const Discount &discount, const util::stream::ChainPosition &input, bool pruning)$/;"	f	class:lm::builder::__anon45::AddRight
AddRight	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^class AddRight {$/;"	c	namespace:lm::builder::__anon45	file:
AddSTLexLink	HTKLVRec/HLVNet.c	/^STLexLink *AddSTLexLink (MemHeap *heap, STLexNode *start, STLexNode *end)$/;"	f
AddSpot	HTKTools/HResults.c	/^void AddSpot(LabId key, Boolean hit, float score)$/;"	f
AddStats	HLMTools/LPlex.c	/^static void AddStats(PStats *ps1, PStats *ps2)$/;"	f	file:
AddString	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  void AddString(const char* s) {$/;"	f	class:double_conversion::StringBuilder
AddSubfield	HTKLib/esignal.c	/^AddSubfield(FieldSpec   *field,    \/* field to aquire subfield *\/$/;"	f
AddSubstring	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  void AddSubstring(const char* s, int n) {$/;"	f	class:double_conversion::StringBuilder
AddTLoopBeginEnd	HTKTools/HParse.c	/^int AddTLoopBeginEnd(int numElements, SplitName* trilist, Link a, Link b)$/;"	f
AddTailRegress	HTKLib/HSigP.c	/^void AddTailRegress(float *data, int vSize, int n, int step, int offset,$/;"	f
AddToBuffer	HTKLib/HParm.c	/^void AddToBuffer(ParmBuf pbuf, Observation o)$/;"	f
AddTrans	HTKLib/HExactMPE.c	/^void AddTrans(MemHeap *x, CorrN *start, CorrN *end, float sc_lmlike){$/;"	f
AddTransP	HTKLib/HUtil.c	/^static void AddTransP(ILink models, ILink *ilist, char *type)$/;"	f	file:
AddUInt64	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::AddUInt64(uint64_t operand) {$/;"	f	class:double_conversion::Bignum
AddUnigramWord	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    void AddUnigramWord(WordIndex index) {$/;"	f	class:lm::builder::__anon43::Writer	file:
AddUnseenCommand	HTKTools/HHEd.c	/^void AddUnseenCommand(void)$/;"	f
AddWordExtern	HTKTools/HParse.c	/^void AddWordExtern(Vocab *voc, Link p)$/;"	f
AddWordModel	HTKTools/HParse.c	/^void AddWordModel(Vocab *voc, Link p, Link history)$/;"	f
AddWordToClass	HLMLib/LCMap.c	/^void AddWordToClass(ClassMap *c, int clndx, int wdndx)$/;"	f
AddWordToMap	HLMLib/LWMap.c	/^void AddWordToMap(WordMap *wm, LabId word)$/;"	f
AddWrdtoFilter	HLMTools/LGList.c	/^void AddWrdtoFilter(char *s, int ndx)$/;"	f
AddXFormItem	HTKLib/HModel.c	/^static void AddXFormItem(MemHeap *x, Ptr item, Ptr owner, ILink *list)$/;"	f	file:
AdjSubList	HTKLib/HNet.c	/^SubLatDef *AdjSubList(Lattice *lat,LabId subLatId,Lattice *subLat,int adj)$/;"	f
AdjustBounds	HTKTools/HSLab.c	/^void AdjustBounds(RectWin *win)$/;"	f
AdjustCounts	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^    AdjustCounts($/;"	f	class:lm::builder::AdjustCounts
AdjustCounts	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^class AdjustCounts {$/;"	c	namespace:lm::builder
AdjustLower	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <class Added, class Build> void AdjustLower($/;"	f	namespace:lm::ngram::__anon57
AdjustmentPowerOfTen	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static DiyFp AdjustmentPowerOfTen(int exponent) {$/;"	f	namespace:double_conversion
AdvanceOrThrow	HTKLVRec/kenlm/util/file.cc	/^void AdvanceOrThrow(int fd, int64_t off) {$/;"	f	namespace:util
AdvanceToNonspace	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^static inline bool AdvanceToNonspace(const char** current, const char* end) {$/;"	f	namespace:double_conversion
AlarmOn	HTKLib/HGraf.c	/^static void AlarmOn(void)$/;"	f	file:
Align	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::Align(const Bignum& other) {$/;"	f	class:double_conversion::Bignum
Align	HTKLib/HRec.h	/^typedef struct align Align;        \/* Alignment route (HRec.c) *\/$/;"	t	typeref:struct:align
AlignTo8	HTKLVRec/kenlm/lm/bhiksha.cc	/^void *AlignTo8(void *from) {$/;"	f	namespace:lm::ngram::trie::__anon40
AllIntersection	HTKLVRec/kenlm/util/multi_intersection.hh	/^template <class Iterator, class Output, class Less> void AllIntersection(std::vector<boost::iterator_range<Iterator> > &sets, Output &out, const Less less) {$/;"	f	namespace:util
AllIntersection	HTKLVRec/kenlm/util/multi_intersection.hh	/^template <class Iterator, class Output> void AllIntersection(std::vector<boost::iterator_range<Iterator> > &sets, Output &out) {$/;"	f	namespace:util
Alloc	HTKLVRec/kenlm/util/mmap.hh	/^    typedef enum {MMAP_ALLOCATED, ARRAY_ALLOCATED, MALLOC_ALLOCATED, NONE_ALLOCATED} Alloc;$/;"	t	class:util::scoped_memory	typeref:enum:util::scoped_memory::__anon75
AllocBlock	HTKLib/HMem.c	/^static BlockP AllocBlock(size_t size, size_t num, HeapType type)$/;"	f	file:
AllocLMNodeCache	HTKLVRec/HLVRec-LM.c	/^LMNodeCache* AllocLMNodeCache (LMCache *cache, int lmlaIdx)$/;"	f
AllocSamples	HTKLib/esignal.c	/^AllocSamples(long       nrec,$/;"	f
Allocate	HTKLVRec/kenlm/util/pool.hh	/^    void *Allocate(std::size_t size) {$/;"	f	class:util::Pool
AllocateVectors	HTKLib/HTrain.c	/^static int AllocateVectors(float *totalCost)$/;"	f	file:
AlphaBeta	HTKLib/HFB.h	/^} AlphaBeta;$/;"	t	typeref:struct:__anon98
AltKeyState	HTKLib/HGraf_WIN32.c	/^static AltState AltKeyState = ALT_UP;$/;"	v	file:
AltPathList2Path	HTKLVRec/HLVRec-traceback.c	/^WordendHyp *AltPathList2Path (DecoderInst *dec, AltWordendHyp *alt, PronId pron)$/;"	f
AltState	HTKLib/HGraf_WIN32.c	/^typedef enum _AltState AltState;$/;"	t	typeref:enum:_AltState	file:
AltWordendHyp	HTKLVRec/HLVRec.h	/^typedef struct _AltWordendHyp AltWordendHyp;\/* records alternatives for lattice tracback *\/$/;"	t	typeref:struct:_AltWordendHyp
AnalyseSearchSpace	HTKLVRec/HDecode.c	/^void AnalyseSearchSpace (DecoderInst *dec, BestInfo *bestInfo)$/;"	f
AnalyseSearchSpace	HTKLVRec/HDecode.mod.c	/^void AnalyseSearchSpace (DecoderInst *dec, BestInfo *bestInfo)$/;"	f
Analysis Tool	HTKBook/htkoview.tex	/^\\subsection{Analysis Tool}$/;"	b
Annot	HTKLib/esignal.h	/^struct Annot {$/;"	s
Annot	HTKLib/esignal.h	/^typedef struct Annot	Annot;$/;"	t	typeref:struct:Annot
Annotated	HTKLVRec/kenlm/lm/filter/format.hh	/^    struct Annotated {$/;"	s	class:lm::MultipleOutputBuffer
AnswerQuestion	HTKTools/HHEd.c	/^void AnswerQuestion(CLink clist,QLink q)$/;"	f
AnyCKind	HTKLib/HShell.h	/^   AnyCKind             \/* dont care *\/$/;"	e	enum:__anon155
AnyCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    AnyCharacter() {}$/;"	f	class:util::AnyCharacter
AnyCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    explicit AnyCharacter(const StringPiece &chars) : chars_(chars) {}$/;"	f	class:util::AnyCharacter
AnyCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^class AnyCharacter {$/;"	c	namespace:util
AnyCharacterLast	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    AnyCharacterLast() {}$/;"	f	class:util::AnyCharacterLast
AnyCharacterLast	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    explicit AnyCharacterLast(const StringPiece &chars) : chars_(chars) {}$/;"	f	class:util::AnyCharacterLast
AnyCharacterLast	HTKLVRec/kenlm/util/tokenize_piece.hh	/^class AnyCharacterLast {$/;"	c	namespace:util
Append	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    void Append(WordIndex word) {$/;"	f	class:lm::builder::__anon43::Writer
Append	HTKLVRec/kenlm/util/stream/sort.hh	/^    void Append(uint64_t length) {$/;"	f	class:util::stream::Offsets
AppendCell	HTKTools/HResults.c	/^void AppendCell(int i, int j, char *tb, char *rb)$/;"	f
AppendItem	HTKTools/HResults.c	/^void AppendItem(char *s, char *item, int len, int width)$/;"	f
AppendLabs	HTKTools/HCopy.c	/^void AppendLabs(Transcription *t, HTime len)$/;"	f
AppendPair	HTKTools/HResults.c	/^void AppendPair(char *linea, char *a, char *lineb, char *b)$/;"	f
AppendParm	HTKTools/HCopy.c	/^HTime AppendParm(char *src)$/;"	f
AppendPhone	HTKTools/HDMan.c	/^void AppendPhone(Pronunciation *p, LabId id)$/;"	f
AppendSentence	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    void AppendSentence(std::vector<unsigned int> &vec, unsigned int sentence_id) {$/;"	f	class:lm::phrase::Substrings
AppendSilenceOp	HTKTools/HDMan.c	/^void AppendSilenceOp(WordBuf *wb, LabId *args)$/;"	f
AppendSpeechFile	HTKTools/HCopy.c	/^void AppendSpeechFile(char *s)$/;"	f
AppendSpkrAccList	HTKTools/HCompV.c	/^SpkrAccListItem *AppendSpkrAccList(SpkrAccListItem *sal, SpkrAcc *sa)$/;"	f
AppendTrace	HTKTools/HCopy.c	/^void AppendTrace(char *str)$/;"	f
AppendWave	HTKTools/HCopy.c	/^HTime AppendWave(char *src)$/;"	f
AppendWordBuf	HTKTools/HDMan.c	/^void AppendWordBuf(DBuffer *s, DBuffer *t)$/;"	f
Apply	HTKLVRec/kenlm/lm/builder/discount.hh	/^  float Apply(uint64_t count) const {$/;"	f	struct:lm::builder::Discount
Apply	HTKLVRec/kenlm/lm/builder/output.cc	/^void OutputHook::Apply(util::stream::Chains &chains) {$/;"	f	class:lm::builder::OutputHook
Apply	HTKLVRec/kenlm/lm/builder/output.hh	/^    void Apply(HookType hook_type, util::stream::Chains &chains) {$/;"	f	class:lm::builder::Output
Apply	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Apply(float *const *const base, FILE *unigrams) {$/;"	f	class:lm::ngram::trie::__anon58::BackoffMessages
Apply	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Apply(float *const *const base, RecordReader &reader) {$/;"	f	class:lm::ngram::trie::__anon58::BackoffMessages
ApplyABS	HLMLib/LPCalc.c	/^static double ApplyABS(BackOffInfo *boi, FLEntry *tgtFE, double tMass) $/;"	f	file:
ApplyBuild	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <class Value> template <class Build> void HashedSearch<Value>::ApplyBuild(util::FilePiece &f, const std::vector<uint64_t> &counts, const ProbingVocabulary &vocab, PositiveProbWarn &warn, const Build &build) {$/;"	f	class:lm::ngram::detail::HashedSearch
ApplyCompFXForm	HTKLib/HAdapt.c	/^Vector ApplyCompFXForm(MixPDF *mp, Vector svec, AdaptXForm *xform, LogFloat *det, int t)$/;"	f
ApplyCompXForm	HTKLib/HAdapt.c	/^void ApplyCompXForm(MixPDF *mp, AdaptXForm *xform)$/;"	f
ApplyHMMSetXForm	HTKLib/HAdapt.c	/^void ApplyHMMSetXForm(HMMSet *hset, AdaptXForm *xform)$/;"	f
ApplyNGram2LabLat	HTKLib/HLat.c	/^void ApplyNGram2LabLat(Lattice *lat, LModel *lm)$/;"	f
ApplyRule	HLMTools/LGPrep.c	/^void ApplyRule(RuleDef *r, LabId *buf)$/;"	f
ApplyStaticMat	HTKLib/HParm.c	/^static void ApplyStaticMat(IOConfig cf, float *data, Matrix trans, int vSize, int n, int step, int offset)$/;"	f	file:
ApplyTG	HLMLib/LPCalc.c	/^static double ApplyTG(BackOffInfo *boi, FLEntry *tgtFE, double tMass, int nSize)$/;"	f	file:
ApplyTie	HTKTools/HHEd.c	/^void ApplyTie(ILink ilist, char *macName, char type)$/;"	f
ApplyVFloor	HTKLib/HModel.c	/^void ApplyVFloor(HMMSet *hset)$/;"	f
ApplyWPNet2LabLat	HTKLib/HLat.c	/^void ApplyWPNet2LabLat(Lattice *lat, Lattice *wdNet)$/;"	f
ApplyXForm2TriMat	HTKLib/HAdapt.c	/^static void ApplyXForm2TriMat(LinXForm *linXForm, TriMat t, Matrix m)$/;"	f	file:
ApplyXForm2Vector	HTKLib/HAdapt.c	/^static void ApplyXForm2Vector(LinXForm *linXForm, Vector mean)$/;"	f	file:
ApplyXForm2Vector	HTKLib/HParm.c	/^static void ApplyXForm2Vector(LinXForm *linXForm, Vector mean)$/;"	f	file:
ApproxWidth	HTKLib/esig_asc.c	/^ApproxWidth(int type)$/;"	f	file:
Arc	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    Arc() {}$/;"	f	class:lm::phrase::detail::Arc
Arc	HTKLVRec/kenlm/lm/filter/phrase.cc	/^class Arc {$/;"	c	namespace:lm::phrase::detail	file:
ArcFromLat	HTKLib/HArc.c	/^void ArcFromLat(ArcInfo *aInfo, HMMSet *hset){$/;"	f
ArcGreater	HTKLVRec/kenlm/lm/filter/phrase.cc	/^struct ArcGreater : public std::binary_function<const Arc *, const Arc *, bool> {$/;"	s	namespace:lm::phrase::detail	file:
ArcId	HTKLib/HNet.h	/^typedef struct larc *ArcId;$/;"	t	typeref:struct:larc
ArcInfo	HTKLib/HArc.h	/^}ArcInfo;$/;"	t	typeref:struct:ArcInfoStruct
ArcInfoStruct	HTKLib/HArc.h	/^typedef struct ArcInfoStruct{$/;"	s
ArcList	HTKLib/HArc.c	/^} ArcList;$/;"	t	typeref:struct:_ArcList	file:
ArcTrans	HTKLib/HArc.h	/^typedef struct _ArcTrans ArcTrans;$/;"	t	typeref:struct:_ArcTrans
ArgError	HTKLib/HShell.c	/^static void ArgError(char *s)$/;"	f	file:
ArgKind	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	t	typeref:enum:__anon158
Array	HTKLib/esignal.h	/^struct Array {$/;"	s
Array	HTKLib/esignal.h	/^typedef struct Array	Array;$/;"	t	typeref:struct:Array
ArrayBhiksha	HTKLVRec/kenlm/lm/bhiksha.cc	/^ArrayBhiksha::ArrayBhiksha(void *base, uint64_t max_offset, uint64_t max_next, const Config &config)$/;"	f	class:lm::ngram::trie::ArrayBhiksha
ArrayBhiksha	HTKLVRec/kenlm/lm/bhiksha.hh	/^class ArrayBhiksha {$/;"	c	namespace:lm::ngram::trie
ArrayCount	HTKLVRec/kenlm/lm/bhiksha.cc	/^std::size_t ArrayCount(uint64_t max_offset, uint64_t max_next, const Config &config) {$/;"	f	namespace:lm::ngram::trie::__anon39
AsDiyFp	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  DiyFp AsDiyFp() const {$/;"	f	class:double_conversion::Double
AsDiyFp	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  DiyFp AsDiyFp() const {$/;"	f	class:double_conversion::Single
AsNormalizedDiyFp	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  DiyFp AsNormalizedDiyFp() const {$/;"	f	class:double_conversion::Double
AsUint32	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  uint32_t AsUint32() const {$/;"	f	class:double_conversion::Single
AsUint64	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  uint64_t AsUint64() const {$/;"	f	class:double_conversion::Double
AsciiRead	HTKLib/esig_asc.c	/^AsciiRead(void  *datap,$/;"	f	file:
AsciiWrite	HTKLib/esig_asc.c	/^AsciiWrite(void     *datap,$/;"	f	file:
AsciiWriteChar	HTKLib/esig_asc.c	/^AsciiWriteChar(char     *data,$/;"	f	file:
AsciiWriteSub	HTKLib/esig_asc.c	/^AsciiWriteSub(void  *data,$/;"	f	file:
AsciiWriteWchar	HTKLib/esig_asc.c	/^AsciiWriteWchar(Wchar   *data,$/;"	f	file:
AssignBignum	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignBignum(const Bignum& other) {$/;"	f	class:double_conversion::Bignum
AssignDecimalString	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignDecimalString(Vector<const char> value) {$/;"	f	class:double_conversion::Bignum
AssignHexString	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignHexString(Vector<const char> value) {$/;"	f	class:double_conversion::Bignum
AssignPowerUInt16	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignPowerUInt16(uint16_t base, int power_exponent) {$/;"	f	class:double_conversion::Bignum
AssignStructure	HTKTools/HHEd.c	/^Ptr AssignStructure(LabId id, int state)$/;"	f
AssignUInt16	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignUInt16(uint16_t value) {$/;"	f	class:double_conversion::Bignum
AssignUInt64	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::AssignUInt64(uint64_t value) {$/;"	f	class:double_conversion::Bignum
AssignWEIds	HTKLVRec/HLVNet.c	/^void AssignWEIds(TLexNet *tnet)$/;"	f
AttachAccessInfo	HLMLib/LModel.c	/^void AttachAccessInfo(BackOffLM *lm)$/;"	f
AttachAccs	HTKLib/HTrain.c	/^void AttachAccs(HMMSet *hset, MemHeap *x, UPDSet uFlags){ AttachAccsParallel(hset,x,uFlags,1); }$/;"	f
AttachAccsParallel	HTKLib/HTrain.c	/^void AttachAccsParallel(HMMSet *hset, MemHeap *x, UPDSet uFlags, int nPara)$/;"	f
AttachInst	HTKLib/HRec.c	/^static void AttachInst(NetNode *node)$/;"	f	file:
AttachMPEInfo	HTKLib/HArc.c	/^void AttachMPEInfo(ArcInfo *aInfo){  \/* attach the "mpe" structure to the arcs. *\/$/;"	f
AttachNodeInfos	HTKTools/HParse.c	/^void AttachNodeInfos(HPNetwork *theNet)$/;"	f
AttachPreComps	HTKLib/HTrain.c	/^void AttachPreComps(HMMSet *hset, MemHeap *x)$/;"	f
AttachRegAccs	HTKLib/HAdapt.c	/^static void AttachRegAccs(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
AttachReplayBuf	HTKLib/HAudio.c	/^void AttachReplayBuf(AudioIn a, int bufSize)$/;"	f
AttachSource	HTKLib/HShell.c	/^void AttachSource(FILE *file, Source *src)$/;"	f
AttachWtAccLists	HTKTools/HSmooth.c	/^void AttachWtAccLists()$/;"	f
AttachWtTrAccs	HTKLib/HFB.c	/^static void AttachWtTrAccs(HMMSet *hset, MemHeap *x)$/;"	f	file:
AttachXFormInfo	HTKLib/HAdapt.c	/^static void AttachXFormInfo(HMMSet *hset)$/;"	f	file:
AudioDevInput	HTKLib/HAudio.c	/^int AudioDevInput(int *mask) $/;"	f
AudioDevOutput	HTKLib/HAudio.c	/^int AudioDevOutput(int *mask) $/;"	f
AudioDevStatus	HTKLib/HAudio.c	/^               ADS_STOPPED, ADS_CLOSED } AudioDevStatus;$/;"	t	typeref:enum:__anon91	file:
AudioIn	HTKLib/HAudio.h	/^typedef struct _AudioIn  *AudioIn;    \/* Abstract audio input stream *\/$/;"	t	typeref:struct:_AudioIn
AudioInRec	HTKLib/HAudio.c	/^}AudioInRec;$/;"	t	typeref:struct:_AudioIn	file:
AudioInStatus	HTKLib/HAudio.h	/^}AudioInStatus;$/;"	t	typeref:enum:__anon93
AudioOut	HTKLib/HAudio.h	/^typedef struct _AudioOut *AudioOut;   \/* Abstract audio output stream *\/$/;"	t	typeref:struct:_AudioOut
AudioOutRec	HTKLib/HAudio.c	/^}AudioOutRec;$/;"	t	typeref:struct:_AudioOut	file:
AudioSigHandler	HTKLib/HAudio.c	/^static void AudioSigHandler(void)$/;"	f	file:
AutoCorrelate	HTKLib/HSigP.c	/^static float AutoCorrelate(Vector s, Vector r, int p, int frameSize)$/;"	f	file:
AutoProbing	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    AutoProbing(std::size_t initial_size = 10, const Key &invalid = Key(), const Hash &hash_func = Hash(), const Equal &equal_func = Equal()) :$/;"	f	class:util::AutoProbing
AutoProbing	HTKLVRec/kenlm/util/probing_hash_table.hh	/^template <class EntryT, class HashT, class EqualT = std::equal_to<typename EntryT::Key> > class AutoProbing {$/;"	c	namespace:util
AuxLabEndTime	HTKLib/HLabel.c	/^HTime AuxLabEndTime(LLink p, int i)$/;"	f
AvgCorr	HTKLib/HFBLat.h	/^  float AvgCorr; \/* averate correctness. *\/$/;"	m	struct:__anon102
B	HTKLVRec/kenlm/lm/filter/format.hh	/^    typedef DispatchInput<Filter, Output> B;$/;"	t	class:lm::DispatchARPAInput
B	HTKLib/HParm.c	/^   Vector B;          \/*  HTK parameterised files *\/$/;"	m	struct:__anon141	file:
BARSYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
BAR_BORDER	HTKTools/HSLab.c	334;"	d	file:
BAR_HEIGHT	HTKTools/HSLab.c	333;"	d	file:
BAR_WIDTH	HTKTools/HSLab.c	332;"	d	file:
BASE	HTKLib/HModel.h	/^enum _AdaptKind {TREE, BASE};$/;"	e	enum:_AdaptKind
BASECLASS	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon117	file:
BASEMASK	HTKLib/HParm.h	69;"	d
BASEWORDNDX	HLMLib/LWMap.h	42;"	d
BAddSearch	HTKLVRec/HLVNet.c	/^static int BAddSearch (Ptr elem, int *np, Ptr **ap)$/;"	f	file:
BAddSearch	HTKLib/HNet.c	/^static int BAddSearch(HMMSetCxtInfo *hci,LabId labid, int *np,LabId **ap)$/;"	f	file:
BEGINHMM	HTKLib/HModel.c	/^   BEGINHMM, USEMAC, ENDHMM, NUMMIXES, $/;"	e	enum:__anon117	file:
BIAS	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon117	file:
BIGNUM_DTOA_FIXED	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.h	/^  BIGNUM_DTOA_FIXED,$/;"	e	enum:double_conversion::BignumDtoaMode
BIGNUM_DTOA_PRECISION	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.h	/^  BIGNUM_DTOA_PRECISION$/;"	e	enum:double_conversion::BignumDtoaMode
BIGNUM_DTOA_SHORTEST	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.h	/^  BIGNUM_DTOA_SHORTEST,$/;"	e	enum:double_conversion::BignumDtoaMode
BIGNUM_DTOA_SHORTEST_SINGLE	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.h	/^  BIGNUM_DTOA_SHORTEST_SINGLE,$/;"	e	enum:double_conversion::BignumDtoaMode
BIG_FLOAT	HTKTools/HHEd.c	60;"	d	file:
BIN_ARPA_HAS_BOWT	HTKLVRec/HLVLM.h	170;"	d
BIN_ARPA_HAS_BOWT	HTKLib/HLM.c	366;"	d	file:
BIN_ARPA_INT_LMID	HTKLVRec/HLVLM.h	171;"	d
BIN_ARPA_INT_LMID	HTKLib/HLM.c	367;"	d	file:
BLACK	HTKLib/HGraf.h	/^                LIGHT_GREY, GREY, DARK_GREY, BLACK};$/;"	e	enum:_HColour
BLOCK	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon117	file:
BLOCKINFO	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon117	file:
BOOL	HTKLib/esignal.h	74;"	d
BOOST_LEXICAL_CAST_ASSUME_C_LOCALE	HTKLVRec/kenlm/util/fake_ofstream.hh	14;"	d
BOWT_LOG_TO_SHORT	HLMLib/LModel.c	366;"	d	file:
BOWT_LOG_TO_SHORT	HLMLib/LModel.c	377;"	d	file:
BOWT_SHORT_TO_LOG	HLMLib/LModel.c	371;"	d	file:
BOWT_SHORT_TO_LOG	HLMLib/LModel.c	378;"	d	file:
BSearch	HTKLVRec/HLVNet.c	/^static int BSearch (Ptr elem, int n, Ptr *array)$/;"	f	file:
BSearch	HTKLib/HNet.c	/^static int BSearch(LabId labid, int n,LabId *array)$/;"	f	file:
BTN_AREA_H	HTKTools/HSLab.c	92;"	d	file:
BTN_AREA_W	HTKTools/HSLab.c	91;"	d	file:
BTN_AREA_X	HTKTools/HSLab.c	93;"	d	file:
BTN_AREA_Y	HTKTools/HSLab.c	94;"	d	file:
BTN_H_SPC	HTKTools/HSLab.c	97;"	d	file:
BTN_LINE_WIDTH	HTKLib/HGraf.c	622;"	d	file:
BTN_LINE_WIDTH	HTKLib/HGraf_WIN32.c	916;"	d	file:
BTN_PER_COL	HTKTools/HSLab.c	96;"	d	file:
BTN_PER_ROW	HTKTools/HSLab.c	95;"	d	file:
BTN_V_SPC	HTKTools/HSLab.c	98;"	d	file:
BTN_WAIT	HTKLib/HGraf.c	621;"	d	file:
BTN_WAIT	HTKLib/HGraf_WIN32.c	915;"	d	file:
BT_ABOUT	HTKTools/HSLab.c	/^   BT_LEDIT, BT_LSELECT, BT_ABOUT, BT_ADJUST, $/;"	e	enum:__anon208	file:
BT_ADJUST	HTKTools/HSLab.c	/^   BT_LEDIT, BT_LSELECT, BT_ABOUT, BT_ADJUST, $/;"	e	enum:__anon208	file:
BT_LABEL	HTKTools/HSLab.c	/^   BT_LABSTR, BT_LABEL, BT_LABELAS, BT_LDELETE, $/;"	e	enum:__anon208	file:
BT_LABELAS	HTKTools/HSLab.c	/^   BT_LABSTR, BT_LABEL, BT_LABELAS, BT_LDELETE, $/;"	e	enum:__anon208	file:
BT_LABSET	HTKTools/HSLab.c	/^   BT_LABSET, BT_NEWSET,$/;"	e	enum:__anon208	file:
BT_LABSTR	HTKTools/HSLab.c	/^   BT_LABSTR, BT_LABEL, BT_LABELAS, BT_LDELETE, $/;"	e	enum:__anon208	file:
BT_LDELETE	HTKTools/HSLab.c	/^   BT_LABSTR, BT_LABEL, BT_LABELAS, BT_LDELETE, $/;"	e	enum:__anon208	file:
BT_LEDIT	HTKTools/HSLab.c	/^   BT_LEDIT, BT_LSELECT, BT_ABOUT, BT_ADJUST, $/;"	e	enum:__anon208	file:
BT_LOAD	HTKTools/HSLab.c	/^   BT_NONE, BT_LOAD, BT_SAVE, BT_SCRLL, BT_SCRLR, $/;"	e	enum:__anon208	file:
BT_LSELECT	HTKTools/HSLab.c	/^   BT_LEDIT, BT_LSELECT, BT_ABOUT, BT_ADJUST, $/;"	e	enum:__anon208	file:
BT_MARK	HTKTools/HSLab.c	/^   BT_PLAY_VOL, BT_SCALE, BT_MARK, BT_UNMARK, $/;"	e	enum:__anon208	file:
BT_NEWSET	HTKTools/HSLab.c	/^   BT_LABSET, BT_NEWSET,$/;"	e	enum:__anon208	file:
BT_NONE	HTKTools/HSLab.c	/^   BT_NONE, BT_LOAD, BT_SAVE, BT_SCRLL, BT_SCRLR, $/;"	e	enum:__anon208	file:
BT_PAUSE	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon208	file:
BT_PLAY	HTKTools/HSLab.c	/^   BT_ZOOM_IN, BT_ZOOM_OUT, BT_RESTORE, BT_PLAY, $/;"	e	enum:__anon208	file:
BT_PLAY_VOL	HTKTools/HSLab.c	/^   BT_PLAY_VOL, BT_SCALE, BT_MARK, BT_UNMARK, $/;"	e	enum:__anon208	file:
BT_QUIT	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon208	file:
BT_REC	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon208	file:
BT_RESTORE	HTKTools/HSLab.c	/^   BT_ZOOM_IN, BT_ZOOM_OUT, BT_RESTORE, BT_PLAY, $/;"	e	enum:__anon208	file:
BT_SAVE	HTKTools/HSLab.c	/^   BT_NONE, BT_LOAD, BT_SAVE, BT_SCRLL, BT_SCRLR, $/;"	e	enum:__anon208	file:
BT_SCALE	HTKTools/HSLab.c	/^   BT_PLAY_VOL, BT_SCALE, BT_MARK, BT_UNMARK, $/;"	e	enum:__anon208	file:
BT_SCRLL	HTKTools/HSLab.c	/^   BT_NONE, BT_LOAD, BT_SAVE, BT_SCRLL, BT_SCRLR, $/;"	e	enum:__anon208	file:
BT_SCRLR	HTKTools/HSLab.c	/^   BT_NONE, BT_LOAD, BT_SAVE, BT_SCRLL, BT_SCRLR, $/;"	e	enum:__anon208	file:
BT_SPCL	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon208	file:
BT_STOP	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon208	file:
BT_UNDO	HTKTools/HSLab.c	/^   BT_UNDO, BT_SPCL, BT_REC, BT_PAUSE, BT_STOP, BT_QUIT$/;"	e	enum:__anon208	file:
BT_UNMARK	HTKTools/HSLab.c	/^   BT_PLAY_VOL, BT_SCALE, BT_MARK, BT_UNMARK, $/;"	e	enum:__anon208	file:
BT_ZOOM_IN	HTKTools/HSLab.c	/^   BT_ZOOM_IN, BT_ZOOM_OUT, BT_RESTORE, BT_PLAY, $/;"	e	enum:__anon208	file:
BT_ZOOM_OUT	HTKTools/HSLab.c	/^   BT_ZOOM_IN, BT_ZOOM_OUT, BT_RESTORE, BT_PLAY, $/;"	e	enum:__anon208	file:
BUFLEN	HTKLVRec/HLVNet.c	272;"	d	file:
BUF_SIZE	HLMTools/LLink.c	172;"	d	file:
BUF_SIZE	HTKLib/HAudio.c	130;"	d	file:
BZException	HTKLVRec/kenlm/util/read_compressed.cc	/^BZException::BZException() throw() {}$/;"	f	class:util::BZException
BZException	HTKLVRec/kenlm/util/read_compressed.hh	/^class BZException : public CompressedException {$/;"	c	namespace:util
BZip	HTKLVRec/kenlm/util/read_compressed.cc	/^    BZip(const void *base, std::size_t amount) {$/;"	f	class:util::__anon79::BZip
BZip	HTKLVRec/kenlm/util/read_compressed.cc	/^class BZip {$/;"	c	namespace:util::__anon79	file:
BackOffInfo	HLMLib/LModel.h	/^} BackOffInfo;$/;"	t	typeref:struct:__anon12
BackOffLM	HLMLib/LModel.h	/^} BackOffLM;$/;"	t	typeref:struct:__anon15
BackTransitions	HTKLib/HArc.c	/^Boolean BackTransitions(ArcInfo *aInfo){ \/* a check, should never happen *\/$/;"	f
Backend	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef ProbingHashTable<EntryT, HashT, EqualT> Backend;$/;"	t	class:util::AutoProbing
Backoff	HTKLVRec/kenlm/lm/quantize.hh	/^        float Backoff() const {$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
Backoff	HTKLVRec/kenlm/lm/quantize.hh	/^        float Backoff() const {$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
Backoff	HTKLVRec/kenlm/lm/trie.hh	/^    float Backoff() const { return to_->backoff; }$/;"	f	class:lm::ngram::trie::UnigramPointer
Backoff	HTKLVRec/kenlm/lm/value.hh	/^    float Backoff() const { return to_->backoff; }$/;"	f	class:lm::ngram::GenericProbingProxy
Backoff	HTKLVRec/kenlm/lm/value.hh	/^    float Backoff() const { return to_->backoff; }$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
BackoffBins	HTKLVRec/kenlm/lm/quantize.hh	/^        const Bins &BackoffBins() const { return bins_[1]; }$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
BackoffMessages	HTKLVRec/kenlm/lm/search_trie.cc	/^class BackoffMessages {$/;"	c	namespace:lm::ngram::trie::__anon58	file:
BackoffValue	HTKLVRec/kenlm/lm/value.hh	/^struct BackoffValue {$/;"	s	namespace:lm::ngram
BadDiscountException	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^BadDiscountException::BadDiscountException() throw() {}$/;"	f	class:lm::builder::BadDiscountException
BadDiscountException	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^class BadDiscountException : public util::Exception {$/;"	c	namespace:lm::builder
BadSortConfig	HTKLVRec/kenlm/util/stream/sort.hh	/^    BadSortConfig() throw() {}$/;"	f	class:util::stream::BadSortConfig
BadSortConfig	HTKLVRec/kenlm/util/stream/sort.hh	/^class BadSortConfig : public Exception {$/;"	c	namespace:util::stream
BarType	HTKTools/HSLab.c	/^} BarType;$/;"	t	typeref:struct:__anon213	file:
Base	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    const uint8_t *Base() const { return reinterpret_cast<const uint8_t*>(begin_); }$/;"	f	class:lm::builder::NGram
Base	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    uint8_t *Base() { return reinterpret_cast<uint8_t*>(begin_); }$/;"	f	class:lm::builder::NGram
BaseClass	HTKLib/HModel.h	/^} BaseClass;$/;"	t	typeref:struct:__anon129
BaseClassKind	HTKLib/HModel.h	/^typedef enum _BaseClassKind BaseClassKind;$/;"	t	typeref:enum:_BaseClassKind
BaseClassKind2Str	HTKLib/HModel.c	/^char *BaseClassKind2Str(BaseClassKind bkind, char *buf)$/;"	f
BaseFullScore	HTKLVRec/kenlm/lm/facade.hh	/^    FullScoreReturn BaseFullScore(const void *in_state, const WordIndex new_word, void *out_state) const {$/;"	f	class:lm::base::ModelFacade
BaseFullScoreForgotState	HTKLVRec/kenlm/lm/facade.hh	/^    FullScoreReturn BaseFullScoreForgotState(const WordIndex *context_rbegin, const WordIndex *context_rend, const WordIndex new_word, void *out_state) const {$/;"	f	class:lm::base::ModelFacade
BaseInit	HTKLVRec/kenlm/lm/trie.cc	/^void BitPacked::BaseInit(void *base, uint64_t max_vocab, uint8_t remaining_bits) {$/;"	f	class:lm::ngram::trie::BitPacked
BaseOf	HTKLib/HShell.c	/^char * BaseOf(char *fn, char *s)$/;"	f
BaseParmKind	HTKLib/HParm.c	/^ParmKind BaseParmKind(ParmKind kind) { return kind & BASEMASK; }$/;"	f
BaseScore	HTKLVRec/kenlm/lm/facade.hh	/^    float BaseScore(const void *in_state, const WordIndex new_word, void *out_state) const {$/;"	f	class:lm::base::ModelFacade
BaseSize	HTKLVRec/kenlm/lm/trie.cc	/^uint64_t BitPacked::BaseSize(uint64_t entries, uint64_t max_vocab, uint8_t remaining_bits) {$/;"	f	class:lm::ngram::trie::BitPacked
BaseVocabulary	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    const Vocabulary &BaseVocabulary() const { return *base_vocab_; }$/;"	f	class:lm::base::Model
BasicPrint	HTKLVRec/kenlm/lm/ngram_query.hh	/^struct BasicPrint {$/;"	s	namespace:lm::ngram
Batch	HTKLVRec/kenlm/lm/filter/thread.hh	/^    typedef ThreadBatch<OutputBuffer> Batch;$/;"	t	class:lm::Controller
BeginLength	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^void ARPAOutput::BeginLength(unsigned int length) {$/;"	f	class:lm::ARPAOutput
BeginLength	HTKLVRec/kenlm/lm/filter/format.hh	/^    void BeginLength(unsigned int length) { B::output_.BeginLength(length); }$/;"	f	class:lm::DispatchARPAInput
BeginLength	HTKLVRec/kenlm/lm/filter/format.hh	/^    void BeginLength(unsigned int length) {$/;"	f	class:lm::MultipleARPAOutput
BeginNonTerminal	HTKLVRec/kenlm/lm/left.hh	/^    void BeginNonTerminal(const ChartState &in, float prob = 0.0) {$/;"	f	class:lm::ngram::RuleScore
BeginSentence	HTKLVRec/kenlm/lm/left.hh	/^    void BeginSentence() {$/;"	f	class:lm::ngram::RuleScore
BeginSentence	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    WordIndex BeginSentence() const { return begin_sentence_; }$/;"	f	class:lm::base::Vocabulary
BeginSentenceMemory	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    const void *BeginSentenceMemory() const { return begin_sentence_memory_; }$/;"	f	class:lm::base::Model
BeginSentenceState	HTKLVRec/kenlm/lm/facade.hh	/^    const State &BeginSentenceState() const { return begin_sentence_; }$/;"	f	class:lm::base::ModelFacade
BeginSentenceWrite	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    void BeginSentenceWrite(void *to) const { memcpy(to, begin_sentence_memory_, StateSize()); }$/;"	f	class:lm::base::Model
BestInfo	HTKLVRec/HDecode.c	/^typedef struct _BestInfo BestInfo;$/;"	t	typeref:struct:_BestInfo	file:
BestInfo	HTKLVRec/HDecode.mod.c	/^typedef struct _BestInfo BestInfo;$/;"	t	typeref:struct:_BestInfo	file:
BestTokSet	HTKLVRec/HLVRec-traceback.c	/^TokenSet *BestTokSet (DecoderInst *dec)$/;"	f
BiFactor	HTKLib/HMath.c	/^static void BiFactor(DMatrix A, DMatrix U, DMatrix V)$/;"	f	file:
BiSVD	HTKLib/HMath.c	/^static void BiSVD(DVector d, DVector f, DMatrix U, DMatrix V)$/;"	f	file:
BiggestCluster	HTKLib/HTrain.c	/^static int BiggestCluster(void)$/;"	f	file:
BiggestPowerTen	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^static void BiggestPowerTen(uint32_t number,$/;"	f	namespace:double_conversion
BigitAt	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^Bignum::Chunk Bignum::BigitAt(int index) const {$/;"	f	class:double_conversion::Bignum
BigitLength	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  int BigitLength() const { return used_digits_ + exponent_; }$/;"	f	class:double_conversion::Bignum
BigitsShiftLeft	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::BigitsShiftLeft(int shift_amount) {$/;"	f	class:double_conversion::Bignum
Bignum	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^Bignum::Bignum()$/;"	f	class:double_conversion::Bignum
Bignum	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^class Bignum {$/;"	c	namespace:double_conversion
BignumDtoa	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,$/;"	f	namespace:double_conversion
BignumDtoaMode	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.h	/^enum BignumDtoaMode {$/;"	g	namespace:double_conversion
BignumToFixed	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^static void BignumToFixed(int requested_digits, int* decimal_point,$/;"	f	namespace:double_conversion
BinaryFilter	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^    explicit BinaryFilter(Binary binary) : binary_(binary) {}$/;"	f	class:lm::BinaryFilter
BinaryFilter	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^template <class Binary> class BinaryFilter {$/;"	c	namespace:lm
BinaryFind	HTKLVRec/kenlm/util/sorted_uniform.hh	/^template <class Iterator, class Accessor> bool BinaryFind($/;"	f	namespace:util
BinaryFormat	HTKLVRec/kenlm/lm/binary_format.cc	/^BinaryFormat::BinaryFormat(const Config &config) $/;"	f	class:lm::ngram::BinaryFormat
BinaryFormat	HTKLVRec/kenlm/lm/binary_format.hh	/^class BinaryFormat {$/;"	c	namespace:lm::ngram
BinaryOutputBuffer	HTKLVRec/kenlm/lm/filter/format.hh	/^    BinaryOutputBuffer() {}$/;"	f	class:lm::BinaryOutputBuffer
BinaryOutputBuffer	HTKLVRec/kenlm/lm/filter/format.hh	/^class BinaryOutputBuffer {$/;"	c	namespace:lm
Bins	HTKLVRec/kenlm/lm/quantize.hh	/^        Bins() {}$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
Bins	HTKLVRec/kenlm/lm/quantize.hh	/^        Bins(uint8_t bits, float *begin) : begin_(begin), end_(begin_ + (1ULL << bits)), bits_(bits), mask_((1ULL << bits) - 1) {}$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
Bins	HTKLVRec/kenlm/lm/quantize.hh	/^    class Bins {$/;"	c	class:lm::ngram::SeparatelyQuantize
BitAddress	HTKLVRec/kenlm/util/bit_packing.hh	/^  BitAddress(void *in_base, uint64_t in_offset) : base(in_base), offset(in_offset) {}$/;"	f	struct:util::BitAddress
BitAddress	HTKLVRec/kenlm/util/bit_packing.hh	/^struct BitAddress {$/;"	s	namespace:util
BitAt	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^  int BitAt(int position) {$/;"	f	class:double_conversion::UInt128
BitCast	HTKLVRec/kenlm/util/double-conversion/utils.h	/^inline Dest BitCast(Source* source) {$/;"	f	namespace:double_conversion
BitCast	HTKLVRec/kenlm/util/double-conversion/utils.h	/^inline Dest BitCast(const Source& source) {$/;"	f	namespace:double_conversion
BitPackShift	HTKLVRec/kenlm/util/bit_packing.hh	/^inline uint8_t BitPackShift(uint8_t bit, uint8_t \/*length*\/) {$/;"	f	namespace:util
BitPacked	HTKLVRec/kenlm/lm/trie.hh	/^    BitPacked() {}$/;"	f	class:lm::ngram::trie::BitPacked
BitPacked	HTKLVRec/kenlm/lm/trie.hh	/^class BitPacked {$/;"	c	namespace:lm::ngram::trie
BitPackedLongest	HTKLVRec/kenlm/lm/trie.hh	/^    BitPackedLongest() {}$/;"	f	class:lm::ngram::trie::BitPackedLongest
BitPackedLongest	HTKLVRec/kenlm/lm/trie.hh	/^class BitPackedLongest : public BitPacked {$/;"	c	namespace:lm::ngram::trie
BitPackedMiddle	HTKLVRec/kenlm/lm/trie.cc	/^template <class Bhiksha> BitPackedMiddle<Bhiksha>::BitPackedMiddle(void *base, uint8_t quant_bits, uint64_t entries, uint64_t max_vocab, uint64_t max_next, const BitPacked &next_source, const Config &config) :$/;"	f	class:lm::ngram::trie::BitPackedMiddle
BitPackedMiddle	HTKLVRec/kenlm/lm/trie.hh	/^template <class Bhiksha> class BitPackedMiddle : public BitPacked {$/;"	c	namespace:lm::ngram::trie
BitPackingSanity	HTKLVRec/kenlm/util/bit_packing.cc	/^void BitPackingSanity() {$/;"	f	namespace:util
BitSize	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^static int BitSize(S value) {$/;"	f	namespace:double_conversion
Bits	HTKLVRec/kenlm/lm/quantize.hh	/^        uint8_t Bits() const { return bits_; }$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
BitsMask	HTKLVRec/kenlm/util/bit_packing.hh	/^struct BitsMask {$/;"	s	namespace:util
BlankManager	HTKLVRec/kenlm/lm/search_trie.cc	/^    BlankManager(unsigned char total_order, Doing &doing) : total_order_(total_order), been_length_(0), doing_(doing) {$/;"	f	class:lm::ngram::trie::__anon58::BlankManager
BlankManager	HTKLVRec/kenlm/lm/search_trie.cc	/^template <class Doing> class BlankManager {$/;"	c	namespace:lm::ngram::trie::__anon58	file:
BlankString	HLMLib/LUtil.c	/^Boolean BlankString(char *s)$/;"	f
Block	HTKLVRec/kenlm/util/stream/block.hh	/^    Block() : mem_(NULL), valid_size_(0) {}$/;"	f	class:util::stream::Block
Block	HTKLVRec/kenlm/util/stream/block.hh	/^    Block(void *mem, std::size_t size) : mem_(mem), valid_size_(size) {}$/;"	f	class:util::stream::Block
Block	HTKLVRec/kenlm/util/stream/block.hh	/^class Block {$/;"	c	namespace:util::stream
Block	HTKLib/HMem.h	/^} Block;$/;"	t	typeref:struct:_Block
BlockP	HTKLib/HMem.h	/^typedef struct _Block *BlockP;$/;"	t	typeref:struct:_Block
BlockReorder	HTKLib/HMem.c	/^static void BlockReorder(BlockP *p, int n)$/;"	f	file:
BlockSize	HTKLVRec/kenlm/util/stream/chain.hh	/^    std::size_t BlockSize() const {$/;"	f	class:util::stream::Chain
BlockSorter	HTKLVRec/kenlm/util/stream/sort.hh	/^    BlockSorter(Offsets &offsets, const Compare &compare) :$/;"	f	class:util::stream::BlockSorter
BlockSorter	HTKLVRec/kenlm/util/stream/sort.hh	/^template <class Compare> class BlockSorter {$/;"	c	namespace:util::stream
BlockingSort	HTKLVRec/kenlm/util/stream/sort.hh	/^template <class Compare, class Combine> uint64_t BlockingSort(Chain &chain, const SortConfig &config, const Compare &compare = Compare(), const Combine &combine = NeverCombine()) {$/;"	f	namespace:util::stream
Bool	HTKLib/esignal.h	/^typedef unsigned char			Bool;$/;"	t
BoolCKind	HTKLib/HShell.h	/^   BoolCKind,           \/* Boolean: T,F,True,False *\/$/;"	e	enum:__anon155
BoolCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    BoolCharacter() {}$/;"	f	class:util::BoolCharacter
BoolCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    explicit BoolCharacter(const bool *delimiter) { delimiter_ = delimiter; }$/;"	f	class:util::BoolCharacter
BoolCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^class BoolCharacter {$/;"	c	namespace:util
Boolean	HTKLib/HShell.h	/^typedef enum {FALSE=0, TRUE=1} Boolean;$/;"	t	typeref:enum:__anon152
Bound	HTKLVRec/kenlm/lm/vocab.hh	/^    WordIndex Bound() const { return bound_; }$/;"	f	class:lm::ngram::ProbingVocabulary
Bound	HTKLVRec/kenlm/lm/vocab.hh	/^    WordIndex Bound() const { return bound_; }$/;"	f	class:lm::ngram::SortedVocabulary
BoundedSortedUniformFind	HTKLVRec/kenlm/util/sorted_uniform.hh	/^template <class Iterator, class Accessor, class Pivot> bool BoundedSortedUniformFind($/;"	f	namespace:util
BtnId	HTKTools/HSLab.c	/^} BtnId;$/;"	t	typeref:enum:__anon208	file:
BtnLink	HTKLib/HGraf.h	/^typedef struct _HButton *BtnLink;$/;"	t	typeref:struct:_HButton
Buffer	HTKLVRec/kenlm/lm/vocab.hh	/^    const std::string &Buffer() const { return buffer_; }$/;"	f	class:lm::ngram::WriteWordsWrapper
BufferEntry	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^struct BufferEntry {$/;"	s	namespace:lm::builder::__anon45	file:
BufferFinal	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    void BufferFinal(const std::vector<uint64_t> &counts) {$/;"	f	class:lm::builder::__anon47::Master
BufferInfo	HTKLib/HParm.h	/^}BufferInfo;$/;"	t	typeref:struct:__anon149
BufferStatus	HTKLib/HParm.c	/^PBStatus BufferStatus(ParmBuf pbuf)$/;"	f
Build	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    template <unsigned Length> static void Build(const char (&characters)[Length], bool (&out)[256]) {$/;"	f	class:util::BoolCharacter
BuildCVec	HTKTools/HHEd.c	/^CLink *BuildCVec(int numClust, ILink ilist)$/;"	f
BuildForceLat	HTKLVRec/HLVRec-traceback.c	/^WordendHyp *BuildForceLat (DecoderInst *dec)$/;"	f
BuildGraph	HTKLVRec/kenlm/lm/filter/phrase.cc	/^void BuildGraph(const Substrings &phrase, const std::vector<Hash> &hashes, detail::Vertex *const vertices, detail::Arc *free_arc) {$/;"	f	namespace:lm::phrase::__anon49
BuildInfo	HLMLib/LPCalc.h	/^} BuildInfo;$/;"	t	typeref:struct:__anon16
BuildLatAltList	HTKLVRec/HLVRec-traceback.c	/^AltWordendHyp *BuildLatAltList (DecoderInst *dec, TokenSet *ts, Boolean useLM)$/;"	f
BuildLattice	HTKLVRec/HLVRec-traceback.c	/^WordendHyp *BuildLattice (DecoderInst *dec)$/;"	f
BuildLookupTable	HTKLVRec/kenlm/util/string_piece.cc	/^static inline void BuildLookupTable(const StringPiece& characters_wanted,$/;"	f	file:
BuildLookupTables	HLMLib/LWMap.c	/^void BuildLookupTables(WordMap *wm)$/;"	f
BuildNEntry	HTKTools/HLStats.c	/^static float BuildNEntry(NEntry *ne,Vector boff,float bent)$/;"	f	file:
BuildOutputMap	HLMTools/LGCopy.c	/^static WordMap *BuildOutputMap(MemHeap *heap,ClassMap *cmap)$/;"	f	file:
BuildOutputMap	HLMTools/LSubset.c	/^WordMap *BuildOutputMap(MemHeap *heap,ClassMap *cmap)$/;"	f
BuildRegClusters	HTKTools/HHEd.c	/^int BuildRegClusters(RegNode *rtree, int vSize, int nTerminals, $/;"	f
BuildTree	HTKTools/HHEd.c	/^void BuildTree(ILink ilist,float threshold, char *macRoot)$/;"	f
BuildTrie	HTKLVRec/kenlm/lm/search_trie.cc	/^template <class Quant, class Bhiksha> void BuildTrie(SortedFiles &files, std::vector<uint64_t> &counts, const Config &config, TrieSearch<Quant, Bhiksha> &out, Quant &quant, SortedVocabulary &vocab, BinaryFormat &backing) {$/;"	f	namespace:lm::ngram::trie
BuildType	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	t	typeref:enum:__anon187	file:
ButtonId	HTKLib/HGraf.h	/^typedef short ButtonId;$/;"	t
ByBits	HTKLVRec/kenlm/util/bit_packing.hh	/^  static BitsMask ByBits(uint8_t bits) {$/;"	f	struct:util::BitsMask
ByMax	HTKLVRec/kenlm/util/bit_packing.hh	/^  static BitsMask ByMax(uint64_t max_value) {$/;"	f	struct:util::BitsMask
Byte	HLMLib/LGBase.h	/^typedef unsigned char  Byte;$/;"	t
Byte	HLMLib/LModel.h	/^typedef unsigned char  Byte;$/;"	t
ByteP	HTKLib/HMem.h	/^typedef unsigned char * ByteP;$/;"	t
ByteSwap	HTKLib/HWave.c	/^void ByteSwap(Wave w)$/;"	f
CAPTURE_ALT	HTKLib/HGraf_WIN32.c	28;"	d	file:
CC	HLMLib/Makefile	/^CC = gcc$/;"	m
CC	HLMTools/Makefile	/^CC      = 	gcc$/;"	m
CC	HTKLVRec/Makefile	/^CC      = 	g++$/;"	m
CC	HTKLib/Makefile	/^CC     = g++$/;"	m
CC	HTKTools/Makefile	/^CC      = 	gcc$/;"	m
CC	Makefile	/^CC = g++$/;"	m
CEPLIFTER	HTKLib/HParm.c	/^   CEPLIFTER,     \/* Cepstral liftering coefficient *\/$/;"	e	enum:__anon142	file:
CEPSCALE	HTKLib/HParm.c	/^   CEPSCALE,      \/* Scale factor to prevent arithmetic errors *\/$/;"	e	enum:__anon142	file:
CFGSIZE	HTKLib/HParm.c	/^   CFGSIZE$/;"	e	enum:__anon142	file:
CFLAGS	HLMLib/Makefile	/^CFLAGS = -m32 -ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH="x86_64"' -Wall -Wno-switch -g -O2 -DSANITY -I. -I..\/HTKLib\/$/;"	m
CFLAGS	HLMTools/Makefile	/^CFLAGS  = 	-m32 -ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH="x86_64"' -Wall -Wno-switch -g -O2 -I$(hlib) -I$(llib) $/;"	m
CFLAGS	HTKLVRec/Makefile	/^CFLAGS  := 	-DKENLM_MAX_ORDER=6 -D__cplusplus -DNO_LAT_LM -lrt -m32 -ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH="x86_64"' -Wall -Wno-switch -g -O2  -I.\/kenlm -I$(inc)$/;"	m
CFLAGS	HTKLib/Makefile	/^CFLAGS := $(CFLAGS) -D__cplusplus -m32 -ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH="x86_64"' -Wall -Wno-switch -g  -O2 -I. -DPHNALG$/;"	m
CFLAGS	HTKTools/Makefile	/^CFLAGS  = 	-m32 -ansi -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH="x86_64"' -Wall -Wno-switch -g -O2 -I$(inc) -DPHNALG$/;"	m
CFLAGS	Makefile	/^CFLAGS = $(CPPFLAGS) -m32 -ansi -D__cplusplus -D_SVID_SOURCE -DOSS_AUDIO -D'ARCH="x86_64"' -Wall -Wno-switch -g -O2$/;"	m
CFOpen	HLMTools/LLink.c	77;"	d	file:
CHANGE	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon200	file:
CHANGE_OP	HTKTools/HSLab.c	/^   CREATE_OP, DELETE_OP, CHANGE_OP$/;"	e	enum:__anon210	file:
CHAR	HTKLib/esignal.h	80;"	d
CHEAP	HTKLib/HMem.h	/^typedef enum{MHEAP, MSTAK, CHEAP} HeapType;$/;"	e	enum:__anon115
CHR_W	HTKLib/esig_asc.c	94;"	d	file:
CKCheck	HTKLib/HVQ.c	/^static CovKind CKCheck(CovKind ck)$/;"	f	file:
CL	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon199	file:
CLASS	HTKLib/HModel.c	/^   CLASS, XFORMWGTSET, CLASSXFORM, MMFIDMASK, PARAMETERS,$/;"	e	enum:__anon117	file:
CLASSXFORM	HTKLib/HModel.c	/^   CLASS, XFORMWGTSET, CLASSXFORM, MMFIDMASK, PARAMETERS,$/;"	e	enum:__anon117	file:
CLMHASHSIZE	HLMLib/LCMap.h	41;"	d
CLR_ALL	HTKLib/HModel.h	/^typedef enum {CLR_HMMS,CLR_STATES,CLR_STREAMS,CLR_ALL} ClearDepth;$/;"	e	enum:__anon135
CLR_HMMS	HTKLib/HModel.h	/^typedef enum {CLR_HMMS,CLR_STATES,CLR_STREAMS,CLR_ALL} ClearDepth;$/;"	e	enum:__anon135
CLR_STATES	HTKLib/HModel.h	/^typedef enum {CLR_HMMS,CLR_STATES,CLR_STREAMS,CLR_ALL} ClearDepth;$/;"	e	enum:__anon135
CLR_STREAMS	HTKLib/HModel.h	/^typedef enum {CLR_HMMS,CLR_STATES,CLR_STREAMS,CLR_ALL} ClearDepth;$/;"	e	enum:__anon135
CLink	HTKTools/HHEd.c	/^typedef struct _CRec *CLink;$/;"	t	typeref:struct:_CRec	file:
CMAP_HDR	HLMLib/LUtil.h	/^   NO_HDR, WMAP_HDR, CMAP_HDR, GRAM_HDR, LFOF_HDR$/;"	e	enum:__anon19
CMEANDIR	HTKLib/HParm.c	/^   CMEANDIR,     \/* dir to find the means *\/$/;"	e	enum:__anon142	file:
CMEANMASK	HTKLib/HParm.c	/^   CMEANMASK,    \/* label mask to idenitfy mean file *\/$/;"	e	enum:__anon142	file:
CMEANPATHMASK	HTKLib/HParm.c	/^   CMEANPATHMASK,\/* label mask to idenitfy the path of mean file *\/$/;"	e	enum:__anon142	file:
CMLLR	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	e	enum:_XFormKind
CNE2FE	HLMLib/LModel.c	381;"	d	file:
CNew	HTKLib/HMem.c	/^Ptr CNew (MemHeap *x, size_t size)$/;"	f
CO	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon199	file:
COLLECT_STATS	HTKLVRec/config.h	31;"	d
COLLECT_STATS_ACTIVATION	HTKLVRec/config.h	32;"	d
COMMANDKEY	HTKLib/HGraf.h	/^enum _KeyType {NORMALKEY, SHIFTKEY, COMMANDKEY, CONTROLKEY, $/;"	e	enum:_KeyType
COMMCHAR	HTKLib/HLabel.c	582;"	d	file:
COMPLAIN	HTKLVRec/kenlm/lm/lm_exception.hh	/^typedef enum {THROW_UP, COMPLAIN, SILENT} WarningAction;$/;"	e	enum:lm::__anon51
COMPRESSFACT	HTKLib/HParm.c	/^   COMPRESSFACT,  \/* Compression Factor fo PLP *\/$/;"	e	enum:__anon142	file:
CONFIG_CLEAN_FILES	Makefile	/^CONFIG_CLEAN_FILES = $/;"	m
CONREPLACE	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon191	file:
CONTROLKEY	HTKLib/HGraf.h	/^enum _KeyType {NORMALKEY, SHIFTKEY, COMMANDKEY, CONTROLKEY, $/;"	e	enum:_KeyType
COUNT_HOOK	HTKLVRec/kenlm/lm/builder/output.hh	/^  COUNT_HOOK, \/\/ Raw N-gram counts, highest order only.$/;"	e	enum:lm::builder::HookType
COVBASE	HTKLib/HModel.h	/^enum _BaseClassKind {MIXBASE, MEANBASE, COVBASE};$/;"	e	enum:_BaseClassKind
COV_KEY	HTKLib/HUtil.c	/^   MIX_KEY, MEAN_KEY, STREAM_KEY, COV_KEY$/;"	e	enum:__anon168	file:
COutP	HTKLib/HModel.c	/^static LogFloat COutP(Vector x, int vecSize, MixPDF *mp)$/;"	f	file:
CPPFLAGS	Makefile	/^CPPFLAGS = $/;"	m
CRCC_AT_CLOSE	HTKLib/HParm.c	3354;"	d	file:
CRCC_NONE	HTKLib/HParm.c	3353;"	d	file:
CRCC_STREAM	HTKLib/HParm.c	3355;"	d	file:
CREATEFIDX	HTKLib/HModel.c	66;"	d	file:
CREATE_OP	HTKTools/HSLab.c	/^   CREATE_OP, DELETE_OP, CHANGE_OP$/;"	e	enum:__anon210	file:
CRETURN	HTKLib/HLabel.c	584;"	d	file:
CRec	HTKTools/HHEd.c	/^}CRec;$/;"	t	typeref:struct:_CRec	file:
CTrans	HTKTools/HMMIRest.c	/^static float CTrans = 1.0;$/;"	v	file:
CWeights	HTKTools/HMMIRest.c	/^static float CWeights = 1.0;$/;"	v	file:
CachedPower	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^struct CachedPower {$/;"	s	namespace:double_conversion	file:
CachingInitialised	HTKLib/HFBLat.c	/^Boolean CachingInitialised = FALSE;$/;"	v
Calc	HTKLVRec/kenlm/util/sorted_uniform.hh	/^  static inline std::size_t Calc(uint64_t off, uint64_t range, std::size_t width) {$/;"	f	struct:util::Pivot64
Calc	HTKLVRec/kenlm/util/sorted_uniform.hh	/^  static inline std::size_t Calc(uint64_t off, uint64_t range, uint64_t width) {$/;"	f	struct:util::Pivot32
CalcABSCoef	HLMLib/LPCalc.c	/^static double CalcABSCoef(int nSize, FoFTab *ftab) $/;"	f	file:
CalcAsError	HTKLib/HFBLat.c	/^static Boolean CalcAsError = FALSE;   \/* if TRUE, new way of calc'ing error... *\/ $/;"	v	file:
CalcBackOff	HLMLib/LPMerge.c	/^static void CalcBackOff(BackOffLM *lm, FLEntry **context,int lev) $/;"	f	file:
CalcClusterDistribution	HTKTools/HHEd.c	/^void CalcClusterDistribution(RNode *n, int vSize) $/;"	f
CalcCompress	HTKLib/HParm.c	/^static void CalcCompress(ParmBuf pbuf, PBlock *pbInit,int nCols, Boolean irefc)$/;"	f	file:
CalcCovs	HTKTools/HCompV.c	/^void CalcCovs(void)$/;"	f
CalcDiscountCoefs	HLMLib/LPCalc.c	/^static void CalcDiscountCoefs(BackOffLM *lm, FoFTab *ftab)$/;"	f	file:
CalcDistance	HTKTools/HHEd.c	/^void CalcDistance(CoList *list, RNode *ch1, RNode *ch2, int vSize)$/;"	f
CalcEnergy	HTKTools/HSLab.c	/^float CalcEnergy(int st,int en)$/;"	f
CalcGlobalFOM	HTKTools/HResults.c	/^void CalcGlobalFOM(void)$/;"	f
CalcKeyFOM	HTKTools/HResults.c	/^void CalcKeyFOM(int idx)$/;"	f
CalcMeanCov	HTKTools/HQuant.c	/^void CalcMeanCov(Sequence seq[], int s)$/;"	f
CalcNGramProbs	HLMLib/LPCalc.c	/^static int CalcNGramProbs(BackOffLM *lm, UInt *feId, int nSize, FLEntry *tgtFE, Boolean rebuild)$/;"	f	file:
CalcNodeScore	HTKTools/HHEd.c	/^float CalcNodeScore(RNode *n, int vSize) $/;"	f
CalcPerplexity	HLMTools/LPlex.c	/^static void CalcPerplexity(PStats *sent, LabId *pLab, int numPLabs, int nSize)$/;"	f	file:
CalcPhonePost	HTKLVRec/HLVRec-misc.c	/^void CalcPhonePost (DecoderInst *dec)$/;"	f
CalcSilDetParms	HTKLib/HParm.c	/^static void CalcSilDetParms(ParmBuf pbuf, float *res, $/;"	f	file:
CalcStats	HTKLib/HLat.c	/^void CalcStats (Lattice *lat)$/;"	f
CalcTGCoefs	HLMLib/LPCalc.c	/^static void CalcTGCoefs(MemHeap *heap, BackOffInfo *boi, int nSize, FoFTab *ftab) $/;"	f	file:
CalcTMWeights	HTKTools/HHEd.c	/^Vector CalcTMWeights(int s, StreamElem *ste, double tFloor)$/;"	f
CalcUniProbs	HLMLib/LPCalc.c	/^static int CalcUniProbs(BackOffLM *lm, FLEntry *tgtFE, Boolean rebuild)$/;"	f	file:
CalcVolume	HTKLib/HAudio.c	/^static float CalcVolume(short *data, int len)$/;"	f	file:
CalcWBar	HTKTools/HSmooth.c	/^void CalcWBar(Vector wb, int dBlk, int M)$/;"	f
CalcWCd	HTKTools/HSmooth.c	/^void CalcWCd(Vector wc, int dBlk, StreamElem *ste, int M)$/;"	f
CalcWordClassProbs	HLMLib/LModel.c	/^static void CalcWordClassProbs(BackOffLM *lm)$/;"	f	file:
CalculateDiscounts	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    void CalculateDiscounts(const DiscountConfig &config) {$/;"	f	class:lm::builder::__anon42::StatCollector
CalculateNGram	HLMLib/LPCalc.c	/^static int CalculateNGram(BackOffLM *lm, NGInputSet *inSet, int nSize)$/;"	f	file:
CallFilter	HTKLVRec/kenlm/lm/filter/format.hh	/^    template <class Filter, class Output> void CallFilter(Filter &filter, Output &output) const {$/;"	f	class:lm::InputBuffer
CallFilter	HTKLVRec/kenlm/lm/filter/thread.hh	/^    template <class Filter> void CallFilter(Filter &filter) {$/;"	f	class:lm::ThreadBatch
Callback	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    Callback(float uniform_prob, const util::stream::ChainPositions &backoffs, const std::vector<uint64_t> &prune_thresholds, bool prune_vocab)$/;"	f	class:lm::builder::__anon46::Callback
Callback	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^template <class Output> class Callback {$/;"	c	namespace:lm::builder::__anon46	file:
Callback	HTKLVRec/kenlm/lm/filter/vocab.hh	/^        Callback(Output &out, const StringPiece &line) : out_(out), line_(line) {}$/;"	f	class:lm::vocab::Multiple::Callback
Callback	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    template <class Output> class Callback {$/;"	c	class:lm::vocab::Multiple
Callback	HTKLVRec/kenlm/lm/value.hh	/^  template <class Model, class C> void Callback(const Config &, unsigned int, typename Model::Vocabulary &, C &callback) {$/;"	f	struct:lm::ngram::BackoffValue
Callback	HTKLVRec/kenlm/lm/value.hh	/^  template <class Model, class C> void Callback(const Config &config, unsigned int order, typename Model::Vocabulary &vocab, C &callback) {$/;"	f	struct:lm::ngram::RestValue
CallocOrThrow	HTKLVRec/kenlm/util/scoped.cc	/^void *CallocOrThrow(std::size_t requested) {$/;"	f	namespace:util
CanCompact	HTKTools/HParse.c	/^static Boolean CanCompact(Link p)$/;"	f	file:
Cell	HTKTools/HResults.c	/^} Cell;$/;"	t	typeref:struct:_Cell	file:
CellPtr	HTKTools/HResults.c	/^typedef struct _Cell *CellPtr;$/;"	t	typeref:struct:_Cell	file:
CentreX	HTKLib/HGraf.c	/^int CentreX(int x, char *str)$/;"	f
CentreX	HTKLib/HGraf.null.c	/^int CentreX(int x, char *str)$/;"	f
CentreX	HTKLib/HGraf_WIN32.c	/^int CentreX(int x, char *str)$/;"	f
CentreY	HTKLib/HGraf.c	/^int CentreY(int y, char *str)$/;"	f
CentreY	HTKLib/HGraf.null.c	/^int CentreY(int y, char *str)$/;"	f
CentreY	HTKLib/HGraf_WIN32.c	/^int CentreY(int y, char *str)$/;"	f
Cepstrum2LPC	HTKLib/HSigP.c	/^void Cepstrum2LPC (Vector c, Vector a)$/;"	f
ChWtAcc	HTKTools/HSmooth.c	/^} ChWtAcc;$/;"	t	typeref:struct:_ChWtAcc	file:
Chain	HTKLVRec/kenlm/util/stream/chain.cc	/^Chain::Chain(const ChainConfig &config) : config_(config), complete_called_(false) {$/;"	f	class:util::stream::Chain
Chain	HTKLVRec/kenlm/util/stream/chain.hh	/^class Chain {$/;"	c	namespace:util::stream
ChainConfig	HTKLVRec/kenlm/util/stream/config.hh	/^  ChainConfig() {}$/;"	f	struct:util::stream::ChainConfig
ChainConfig	HTKLVRec/kenlm/util/stream/config.hh	/^  ChainConfig(std::size_t in_entry_size, std::size_t in_block_count, std::size_t in_total_memory)$/;"	f	struct:util::stream::ChainConfig
ChainConfig	HTKLVRec/kenlm/util/stream/config.hh	/^struct ChainConfig {$/;"	s	namespace:util::stream
ChainConfigException	HTKLVRec/kenlm/util/stream/chain.cc	/^ChainConfigException::ChainConfigException() throw() { *this << "Chain configured with "; }$/;"	f	class:util::stream::ChainConfigException
ChainConfigException	HTKLVRec/kenlm/util/stream/chain.hh	/^class ChainConfigException : public Exception {$/;"	c	namespace:util::stream
ChainPosition	HTKLVRec/kenlm/util/stream/chain.hh	/^    ChainPosition(PCQueue<Block> &in, PCQueue<Block> &out, Chain *chain, MultiProgress &progress) $/;"	f	class:util::stream::ChainPosition
ChainPosition	HTKLVRec/kenlm/util/stream/chain.hh	/^class ChainPosition {$/;"	c	namespace:util::stream
ChainPositions	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    ChainPositions() {}$/;"	f	class:util::stream::ChainPositions
ChainPositions	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    explicit ChainPositions(Chains &chains) {$/;"	f	class:util::stream::ChainPositions
ChainPositions	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^class ChainPositions : public util::FixedArray<util::stream::ChainPosition> {$/;"	c	namespace:util::stream
Chains	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    Chains() {}$/;"	f	class:util::stream::Chains
Chains	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    explicit Chains(std::size_t limit) : util::FixedArray<util::stream::Chain>(limit) {}$/;"	f	class:util::stream::Chains
Chains	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^class Chains : public util::FixedArray<util::stream::Chain> {$/;"	c	namespace:util::stream
ChangeOp	HTKTools/HLEd.c	/^int ChangeOp(LabList *ll,LabId *args)$/;"	f
ChangeState	HTKLib/HAudio.c	/^static void ChangeState(AudioIn a, AudioInStatus newState)$/;"	f	file:
ChangeState	HTKLib/HParm.c	/^static void ChangeState(ParmBuf pbuf, PBStatus newState)$/;"	f	file:
ChannelInfo	HTKLib/HParm.c	/^ChannelInfo;$/;"	t	typeref:struct:channelinfo	file:
ChannelType	HTKLib/HParm.c	/^ChannelType;$/;"	t	typeref:enum:channeltype	file:
ChartState	HTKLVRec/kenlm/lm/state.hh	/^struct ChartState {$/;"	s	namespace:lm::ngram
CheckAdaptOptions	HTKLib/HAdapt.c	/^static void CheckAdaptOptions()$/;"	f	file:
CheckAndFillBuffer	HTKLib/HParm.c	/^static void CheckAndFillBuffer(ParmBuf pbuf)$/;"	f	file:
CheckBaseClass	HTKLib/HModel.c	/^static ReturnStatus CheckBaseClass(HMMSet *hset, BaseClass *bclass)$/;"	f	file:
CheckBuffer	HTKLib/HParm.c	/^static void CheckBuffer(ParmBuf pbuf)$/;"	f	file:
CheckButtonList	HTKLib/HGraf.c	/^HButton *CheckButtonList(HButton *btnlst, int x, int y)$/;"	f
CheckButtonList	HTKLib/HGraf.null.c	/^HButton *CheckButtonList(HButton *btnlst, int x, int y)$/;"	f
CheckButtonList	HTKLib/HGraf_WIN32.c	/^HButton *CheckButtonList(HButton *btnlst, int x, int y)$/;"	f
CheckConsistency	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    void CheckConsistency() {$/;"	f	class:util::ProbingHashTable
CheckCorners	HTKLib/HGraf.c	/^static void CheckCorners(int *x0, int *y0, int *x1, int *y1)$/;"	f	file:
CheckCorners	HTKLib/HGraf_WIN32.c	/^static void CheckCorners(int *x0, int *y0, int *x1, int *y1)$/;"	f	file:
CheckCounts	HTKLVRec/kenlm/lm/model.cc	/^void CheckCounts(const std::vector<uint64_t> &counts) {$/;"	f	namespace:lm::ngram::detail::__anon52
CheckCutoffs	HLMLib/LPCalc.c	/^static void CheckCutoffs(BackOffLM *lm)$/;"	f	file:
CheckData	HTKLib/HFB.c	/^static void CheckData(HMMSet *hset, char *fn, BufferInfo *info, $/;"	f	file:
CheckData	HTKLib/HFBLat.c	/^static void CheckData(char *fn, BufferInfo *info) $/;"	f	file:
CheckData	HTKTools/HCompV.c	/^void CheckData(char *fn, BufferInfo info) $/;"	f
CheckData	HTKTools/HInit.c	/^void CheckData(char *fn, BufferInfo info) $/;"	f
CheckData	HTKTools/HQuant.c	/^void CheckData(char *fn, BufferInfo newInfo) $/;"	f
CheckData	HTKTools/HRest.c	/^void CheckData(char *fn, BufferInfo info) $/;"	f
CheckDiscrete	HTKLib/HModel.c	/^static ReturnStatus CheckDiscrete(HMMSet *hset)$/;"	f	file:
CheckFn	HTKLib/HShell.c	/^static char *CheckFn(char *fn)$/;"	f	file:
CheckForRun	HTKLVRec/kenlm/util/stream/chain.hh	/^    template <class T, void (T::*ptr)(const ChainPosition &) = &T::Run> struct CheckForRun {$/;"	s	class:util::stream::Chain
CheckForRun	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    template <class T, void (T::*ptr)(const ChainPositions &) = &T::Run> struct CheckForRun {$/;"	s	class:util::stream::Chains
CheckForSave	HTKTools/HSLab.c	/^void CheckForSave(void)$/;"	f
CheckHMM	HTKLib/HModel.c	/^static ReturnStatus CheckHMM(char *defName, HLink hmm)$/;"	f	file:
CheckHSet	HTKLib/HModel.c	/^static ReturnStatus CheckHSet(HMMSet *hset)$/;"	f	file:
CheckLAlign	HTKLVRec/HLVRec-traceback.c	/^void CheckLAlign (DecoderInst *dec, Lattice *lat)$/;"	f
CheckLRTransP	HTKLVRec/HLVRec.c	/^static Boolean CheckLRTransP (SMatrix transP)$/;"	f	file:
CheckMarker	HTKLib/HTrain.c	/^static void CheckMarker(Source *src)$/;"	f	file:
CheckMix	HTKLib/HModel.c	/^static ReturnStatus CheckMix(char *defName, MixPDF *mp, int n, int s, int m, int sw)$/;"	f	file:
CheckOffT	HTKLVRec/kenlm/util/file.cc	/^template <> struct CheckOffT<8> {$/;"	s	namespace:util::__anon70	file:
CheckOptions	HTKLib/HModel.c	/^static ReturnStatus CheckOptions(HMMSet *hset)$/;"	f	file:
CheckOverflow	HTKLVRec/kenlm/util/exception.hh	/^inline std::size_t CheckOverflow(uint64_t value) {$/;"	f	namespace:util
CheckOverflowInternal	HTKLVRec/kenlm/util/exception.hh	/^template <> inline std::size_t CheckOverflowInternal<8>(uint64_t value) {$/;"	f	namespace:util
CheckOverflowInternal	HTKLVRec/kenlm/util/exception.hh	/^template <unsigned len> inline std::size_t CheckOverflowInternal(uint64_t value) {$/;"	f	namespace:util
CheckPName	HTKLib/HTrain.c	/^static void CheckPName(Source *src, char *pname)$/;"	f	file:
CheckPruning	HTKLib/HFB.c	/^static void CheckPruning(AlphaBeta *ab, int t, int skipstart, int skipend)$/;"	f	file:
CheckSemiTiedOptions	HTKLib/HAdapt.c	/^static void CheckSemiTiedOptions(AdaptXForm *xform, AccStruct *accs)$/;"	f	file:
CheckSpecials	HTKLVRec/kenlm/lm/vocab.hh	/^template <class Vocab> void CheckSpecials(const Config &config, const Vocab &vocab) throw(SpecialWordMissingException) {$/;"	f	namespace:lm::ngram
CheckStEndNodes	HTKLib/HNet.c	/^static ReturnStatus CheckStEndNodes(Lattice *lat)$/;"	f	file:
CheckState	HTKLib/HModel.c	/^static ReturnStatus CheckState(char *defName, HLink hmm, StateInfo *si, int n)$/;"	f	file:
CheckStream	HTKLib/HModel.c	/^static ReturnStatus CheckStream(char *defName, HLink hmm, StreamElem *se, int s, int n)$/;"	f	file:
CheckStreamWidths	HTKTools/HQuant.c	/^void CheckStreamWidths(BufferInfo info)$/;"	f
CheckTMRecs	HTKLib/HModel.c	/^static ReturnStatus CheckTMRecs(HMMSet *hset)$/;"	f	file:
CheckTokenSetId	HTKLVRec/HLVRec-misc.c	/^static void CheckTokenSetId (DecoderInst *dec, TokenSet *ts1, TokenSet *ts2)$/;"	f	file:
CheckTokenSetOrder	HTKLVRec/HLVRec-misc.c	/^void CheckTokenSetOrder (DecoderInst *dec, TokenSet *ts)$/;"	f
CheckUpdateSetUp	HTKTools/HERest.c	/^void CheckUpdateSetUp()$/;"	f
CheckVarianceKind	HTKTools/HCompV.c	/^void CheckVarianceKind(void)$/;"	f
CheckedBase	HTKLVRec/kenlm/util/mmap.hh	/^    void *CheckedBase(uint64_t index) {$/;"	f	class:util::Rolling
CheckedIndex	HTKLVRec/kenlm/util/mmap.hh	/^    void *CheckedIndex(uint64_t index) {$/;"	f	class:util::Rolling
ChkTreeObject	HTKTools/HHEd.c	/^void ChkTreeObject(ILink obj)$/;"	f
ChkType	HTKLib/HUtil.c	/^static void ChkType(char newtype, char *type)$/;"	f	file:
ChkedAlpha	HTKTools/HHEd.c	/^char *ChkedAlpha(char *what,char *buf)$/;"	f
ChkedFloat	HTKTools/HHEd.c	/^float ChkedFloat(char *what,float min,float max)$/;"	f
ChkedInt	HTKTools/HHEd.c	/^int ChkedInt(char *what,int min,int max)$/;"	f
Choleski	HTKLib/HMath.c	/^static Boolean Choleski(TriMat A, DMatrix L)$/;"	f	file:
ChopBits	HTKLVRec/kenlm/lm/bhiksha.cc	/^uint8_t ChopBits(uint64_t max_offset, uint64_t max_next, const Config &config) {$/;"	f	namespace:lm::ngram::trie::__anon39
ChopLabs	HTKTools/HCopy.c	/^void ChopLabs(Transcription *t, HTime start, HTime end)$/;"	f
ChopParm	HTKTools/HCopy.c	/^ParmBuf ChopParm(ParmBuf b, HTime start, HTime end, HTime sampRate)$/;"	f
ChopTriMat	HTKTools/HHEd.c	/^TriMat ChopTriMat(TriMat mat, int i, int j, int k)$/;"	f
ChopVector	HTKTools/HHEd.c	/^Vector ChopVector(Vector vec, int i, int j, int k)$/;"	f
ChopWave	HTKTools/HCopy.c	/^Wave ChopWave(Wave srcW, HTime start, HTime end, HTime sampRate)$/;"	f
Chunk	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  typedef uint32_t Chunk;$/;"	t	class:double_conversion::Bignum
Clamp	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::Clamp() {$/;"	f	class:double_conversion::Bignum
ClampStEn	HTKTools/HCopy.c	/^void ClampStEn(HTime length, HTime *st, HTime *en)$/;"	f
ClassEntry	HLMLib/LCMap.h	/^} ClassEntry;$/;"	t	typeref:struct:clEntry
ClassMap	HLMLib/LCMap.h	/^} ClassMap;$/;"	t	typeref:struct:__anon1
ClassSize	HLMLib/LCMap.c	/^int ClassSize(ClassMap *c, int clndx)$/;"	f
ClassifyMLFPattern	HTKLib/HLabel.c	/^MLFPatType ClassifyMLFPattern(char *s)$/;"	f
CleanDecoderInst	HTKLVRec/HLVRec.c	/^void CleanDecoderInst (DecoderInst *dec)$/;"	f
Clear	HTKLVRec/kenlm/lm/filter/format.hh	/^    void Clear() { actual_ = 0; }$/;"	f	class:lm::InputBuffer
Clear	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    void Clear() {$/;"	f	class:util::AutoProbing
Clear	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    void Clear() {$/;"	f	class:util::ProbingHashTable
ClearBoNGram	HTKLib/HLM.c	/^void ClearBoNGram(LModel *lm)$/;"	f
ClearDepth	HTKLib/HModel.h	/^typedef enum {CLR_HMMS,CLR_STATES,CLR_STREAMS,CLR_ALL} ClearDepth;$/;"	t	typeref:enum:__anon135
ClearJMat	HTKTools/HParse.c	/^static void ClearJMat(void)$/;"	f	file:
ClearLModel	HTKLib/HLM.c	/^void ClearLModel(LModel *lm)$/;"	f
ClearSeenFlags	HTKLib/HModel.c	/^void ClearSeenFlags(HMMSet *hset, ClearDepth depth)$/;"	f
ClearSet	HTKLib/HUtil.c	/^void ClearSet(IntSet s)$/;"	f
ClearStreams	HTKLib/HModel.c	/^void ClearStreams(HMMSet *hset, StreamElem *ste, ClearDepth depth)$/;"	f
ClearVocab	HTKLib/HDict.c	/^void ClearVocab(Vocab *voc)$/;"	f
ClientRect	HTKLib/HGraf_WIN32.c	/^static RECT  ClientRect;$/;"	v	file:
ClipSample	HTKTools/HSLab.c	/^short ClipSample(short sample, float sampleScale)$/;"	f
CloneCommand	HTKTools/HHEd.c	/^void CloneCommand(void)$/;"	f
CloneHMM	HTKLib/HUtil.c	/^void CloneHMM(HLink src, HLink tgt, Boolean sharing)$/;"	f
CloneInputSet	HLMLib/LPCalc.c	/^static NGInputSet *CloneInputSet(NGInputSet *src,NGInputSet *tgt)$/;"	f	file:
CloneMixPDF	HTKLib/HUtil.c	/^MixPDF *CloneMixPDF(HMMSet *hset, MixPDF *s, Boolean sharing)$/;"	f
CloneNetwork	HTKTools/HParse.c	/^HPNetwork CloneNetwork(HPNetwork prototype)$/;"	f
CloneSMatrix	HTKLib/HUtil.c	/^SMatrix CloneSMatrix(MemHeap *hmem, SMatrix s, Boolean sharing)$/;"	f
CloneSTriMat	HTKLib/HUtil.c	/^STriMat CloneSTriMat(MemHeap *hmem, STriMat s, Boolean sharing)$/;"	f
CloneSVector	HTKLib/HUtil.c	/^SVector CloneSVector(MemHeap *hmem, SVector s, Boolean sharing)$/;"	f
CloneState	HTKLib/HUtil.c	/^StateInfo *CloneState(HMMSet *hset, StateInfo *ssi, Boolean sharing)$/;"	f
CloneStream	HTKLib/HUtil.c	/^MixtureVector CloneStream(HMMSet *hset, StreamElem *ste, Boolean sharing)$/;"	f
Close	HTKLVRec/kenlm/util/file.cc	/^void scoped_FILE_closer::Close(std::FILE *file) {$/;"	f	class:util::scoped_FILE_closer
Close	HTKLVRec/kenlm/util/scoped.hh	/^  static void Close(T *p) { clean(p); }$/;"	f	struct:util::scoped_c_forward
Close	HTKLVRec/kenlm/util/scoped.hh	/^  template <class T> static void Close(T *p) { delete [] p; }$/;"	f	struct:util::scoped_delete_array_forward
Close	HTKLVRec/kenlm/util/scoped.hh	/^  template <class T> static void Close(T *p) { delete p; }$/;"	f	struct:util::scoped_delete_forward
CloseAudi	HTKLib/HAudio.c	/^static void CloseAudi(AudioIn a)$/;"	f	file:
CloseAudioInput	HTKLib/HAudio.c	/^void CloseAudioInput(AudioIn a)$/;"	f
CloseAudioOutput	HTKLib/HAudio.c	/^void CloseAudioOutput(AudioOut a)$/;"	f
CloseAudo	HTKLib/HAudio.c	/^static void CloseAudo(AudioOut a)$/;"	f	file:
CloseBuffer	HTKLib/HParm.c	/^void CloseBuffer(ParmBuf pbuf)$/;"	f
CloseInputSet	HLMLib/LGBase.c	/^void CloseInputSet(NGInputSet *inset)$/;"	f
CloseLLF	HTKLib/HLat.c	/^void CloseLLF (LLFInfo *llf)$/;"	f
CloseMLFSaveFile	HTKLib/HLabel.c	/^void CloseMLFSaveFile(void)$/;"	f
CloseNGramFile	HLMLib/LGBase.c	/^void CloseNGramFile(NGSource *ngs)$/;"	f
CloseSource	HTKLib/HShell.c	/^void CloseSource(Source *src)$/;"	f
CloseWaveInput	HTKLib/HWave.c	/^void CloseWaveInput(Wave w)$/;"	f
CloseWaveOutput	HTKLib/HWave.c	/^ReturnStatus CloseWaveOutput(Wave w, FileFormat fmt, char *fname)$/;"	f
ClosedDict	HTKLib/HNet.c	/^static Boolean ClosedDict(Vocab *voc,HMMSet *hset)$/;"	f	file:
Closer	HTKLVRec/kenlm/lm/trie_sort.cc	/^    explicit Closer(std::deque<FILE*> &files) : files_(files) {}$/;"	f	class:lm::ngram::trie::__anon61::Closer
Closer	HTKLVRec/kenlm/lm/trie_sort.cc	/^class Closer {$/;"	c	namespace:lm::ngram::trie::__anon61	file:
ClrSpkrAcc	HTKTools/HCompV.c	/^void ClrSpkrAcc(SpkrAcc *sa)$/;"	f
Cluster	HTKLib/HTrain.h	/^}Cluster;$/;"	t	typeref:struct:__anon161
ClusterChildren	HTKTools/HHEd.c	/^void ClusterChildren(RNode *parent, RNode *ch1, RNode *ch2, int vSize) $/;"	f
ClusterCommand	HTKTools/HHEd.c	/^void ClusterCommand(Boolean nCluster)$/;"	f
ClusterLogL	HTKTools/HHEd.c	/^float ClusterLogL(CLink clist,AccSum *no,AccSum *yes,float *occs)$/;"	f
ClusterSet	HTKLib/HTrain.h	/^}ClusterSet;$/;"	t	typeref:struct:__anon162
ClusterVecs	HTKTools/HQuant.c	/^void ClusterVecs(Sequence *seq, int s)$/;"	f
Cluster_vc_id	HLMTools/Cluster.c	/^char *Cluster_vc_id = "$Id: Cluster.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
Cluster_version	HLMTools/Cluster.c	/^char *Cluster_version = "!HVER!Cluster:   3.4.1 [CUED 12\/03\/09]";$/;"	v
Clustering	HTKTools/HHEd.c	/^void Clustering(ILink ilist, int *numReq, float threshold,$/;"	f
CmdIndex	HTKTools/HHEd.c	/^int CmdIndex(char *s)$/;"	f
CmdIndex	HTKTools/HLEd.c	/^int CmdIndex(char *s)$/;"	f
CmpCntr	HTKTools/HLStats.c	/^int CmpCntr(const void *p1, const void *p2)$/;"	f
CmpFE	HLMLib/LModel.c	/^int CmpFE(const void *p1, const void *p2)$/;"	f
CmpListEntry	HLMLib/LWMap.c	/^static int CmpListEntry(const void *p1, const void *p2)$/;"	f	file:
CmpMapEntry	HLMLib/LWMap.c	/^static int CmpMapEntry(const void *p1, const void *p2)$/;"	f	file:
CmpNGram	HLMLib/LGBase.c	/^static int CmpNGram(WordMap *wm, int N, UInt *ng1, UInt *ng2)$/;"	f	file:
CmpOOVE	HLMTools/LPlex.c	/^static int CmpOOVE(const void *p1, const void *p2)$/;"	f	file:
CmpSE	HLMLib/LModel.c	/^int CmpSE(const void *p1, const void *p2)$/;"	f
CmpTM	HTKLib/HModel.c	/^static int CmpTM(const void *t1, const void *t2)$/;"	f	file:
CmpTxtNGram	HLMLib/LGBase.c	/^static int CmpTxtNGram(int N, LabId *ng1, LabId *ng2)$/;"	f	file:
CmpWord	HTKTools/HDMan.c	/^static int CmpWord(const void *p1, const void *p2)$/;"	f	file:
CmpWordInfo	HTKTools/HLStats.c	/^int CmpWordInfo(const void *p1, const void *p2)$/;"	f
Cntr	HTKTools/HLStats.c	/^} Cntr;$/;"	t	typeref:struct:cntr	file:
CoList	HTKTools/HHEd.c	/^} CoList;$/;"	t	typeref:struct:_CoList	file:
CodeStyle	HTKLib/HParm.c	/^typedef enum { FFTbased, LPCbased, VQbased} CodeStyle;$/;"	t	typeref:enum:__anon140	file:
CollapseStream	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    CollapseStream(const util::stream::ChainPosition &position, uint64_t prune_threshold, const std::vector<bool>& prune_words) :$/;"	f	class:lm::builder::__anon42::CollapseStream
CollapseStream	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^class CollapseStream {$/;"	c	namespace:lm::builder::__anon42	file:
CollectPaths	HTKLib/HRec.c	/^static void CollectPaths(void)$/;"	f	file:
CollectPhoneStats	HTKLVRec/HLVNet.c	/^void CollectPhoneStats (MemHeap *heap, TLexNet *net)$/;"	f
CollectStats	HTKTools/HResults.c	/^void CollectStats(int i,int j)$/;"	f
CombineModels	HLMTools/LAdapt.c	/^BackOffLM *CombineModels(MemHeap *heap,LMInfo *lmi,int nLModel,int nSize,WordMap *wl) $/;"	f
CombinePaths	HTKLVRec/HLVRec-misc.c	/^static WordendHyp *CombinePaths (DecoderInst *dec, RelToken *winner, RelToken *loser, LogFloat diff)$/;"	f	file:
CombineWordHash	HTKLVRec/kenlm/lm/search_hashed.hh	/^inline uint64_t CombineWordHash(uint64_t current, const WordIndex next) {$/;"	f	namespace:lm::ngram::detail
CommandSet	HTKTools/HSLab.c	/^Boolean CommandSet(HSlabCmdType hcmd, char *s)$/;"	f
CommonChunk1	HTKLib/HWave.c	/^} CommonChunk1;$/;"	t	typeref:struct:__anon178	file:
CommonChunk2	HTKLib/HWave.c	/^} CommonChunk2;   $/;"	t	typeref:struct:__anon179	file:
CompBlockSizes	HTKLib/HAdapt.c	/^static Boolean CompBlockSizes(IntVec blocks1, IntVec blocks2)$/;"	f	file:
CompFXForm	HTKLib/HAdapt.c	/^static Vector CompFXForm(MixPDF *mp, Vector svec, AdaptXForm *xform, AInfo *ai, LogFloat *det)$/;"	f	file:
CompLMlaNode	HTKLVRec/HLVNet.h	/^} CompLMlaNode;$/;"	t	typeref:struct:_CompLMlaNode
CompXForm	HTKLib/HAdapt.c	/^static void CompXForm(MixPDF *mp, AdaptXForm *xform, AInfo *ai)$/;"	f	file:
CompactCommand	HTKTools/HHEd.c	/^void CompactCommand(void)$/;"	f
CompactGlueNode	HTKTools/HParse.c	/^static void CompactGlueNode(Link p)$/;"	f	file:
Comparator	HTKLVRec/kenlm/lm/builder/sort.hh	/^    explicit Comparator(std::size_t order) : order_(order) {}$/;"	f	class:lm::builder::Comparator
Comparator	HTKLVRec/kenlm/lm/builder/sort.hh	/^template <class Child> class Comparator : public std::binary_function<const void *, const void *, bool> {$/;"	c	namespace:lm::builder
Compare	HTKLVRec/kenlm/lm/builder/sort.hh	/^    inline bool Compare(const WordIndex *lhs, const WordIndex *rhs) const {$/;"	f	class:lm::builder::ContextOrder
Compare	HTKLVRec/kenlm/lm/builder/sort.hh	/^    inline bool Compare(const WordIndex *lhs, const WordIndex *rhs) const {$/;"	f	class:lm::builder::PrefixOrder
Compare	HTKLVRec/kenlm/lm/builder/sort.hh	/^    inline bool Compare(const WordIndex *lhs, const WordIndex *rhs) const {$/;"	f	class:lm::builder::SuffixOrder
Compare	HTKLVRec/kenlm/lm/search_trie.cc	/^int Compare(unsigned char order, const void *first_void, const void *second_void) {$/;"	f	namespace:lm::ngram::trie::__anon58
Compare	HTKLVRec/kenlm/lm/state.hh	/^    int Compare(const State &other) const {$/;"	f	class:lm::ngram::State
Compare	HTKLVRec/kenlm/lm/state.hh	/^  int Compare(const ChartState &other) const {$/;"	f	struct:lm::ngram::ChartState
Compare	HTKLVRec/kenlm/lm/state.hh	/^  int Compare(const Left &other) const {$/;"	f	struct:lm::ngram::Left
Compare	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^int Bignum::Compare(const Bignum& a, const Bignum& b) {$/;"	f	class:double_conversion::Bignum
CompareBasePron	HTKLVRec/HLVNet.c	/^Boolean CompareBasePron (Pron b, Pron p)$/;"	f
CompareBufferWithDiyFp	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static int CompareBufferWithDiyFp(Vector<const char> buffer,$/;"	f	namespace:double_conversion
CompareMInfo	HTKLib/HAdapt.c	/^static Boolean CompareMInfo(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
CompareMapNames	HLMLib/LGBase.c	/^static Boolean CompareMapNames(char *ngfMap, char *master)$/;"	f	file:
CompareXFormInfo	HTKLib/HAdapt.c	/^static Boolean CompareXFormInfo(AdaptXForm *xform1, AdaptXForm *xform2)$/;"	f	file:
ComplainAboutARPA	HTKLVRec/kenlm/lm/model.cc	/^void ComplainAboutARPA(const Config &config, ModelType model_type) {$/;"	f	namespace:lm::ngram::detail::__anon52
ComplainDisallowed	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  void ComplainDisallowed(StringPiece word, WarningAction &action) {$/;"	f	namespace:lm::builder::__anon44
Complete	HTKLVRec/kenlm/util/read_compressed.cc	/^class Complete : public ReadBase {$/;"	c	namespace:util::__anon79	file:
Complete	HTKLVRec/kenlm/util/stream/chain.cc	/^ChainPosition Chain::Complete() {$/;"	f	class:util::stream::Chain
CompleteLoop	HTKLVRec/kenlm/util/stream/chain.hh	/^    void CompleteLoop() {$/;"	f	class:util::stream::Chain
CompleteRecognition	HTKLib/HRec.c	/^Lattice *CompleteRecognition(VRecInfo *vri,HTime frameDur,MemHeap *heap)$/;"	f
CompressBuffer	HLMTools/LAdapt.c	/^void CompressBuffer(NGBuffer *ngb, Boolean mustSave)$/;"	f
CompressBuffer	HLMTools/LGCopy.c	/^static void CompressBuffer(Boolean mustSave)$/;"	f	file:
CompressBuffer	HLMTools/LGPrep.c	/^void CompressBuffer(NGBuffer *ngb, Boolean mustSave)$/;"	f
CompressItemList	HTKLib/HModel.c	/^static void CompressItemList(MemHeap *x, ILink ilist, ILink *bilist)$/;"	f	file:
CompressPBlock	HTKLib/HParm.c	/^static void CompressPBlock(ParmBuf pbuf, PBlock *pb, short *sp, int nCols)$/;"	f	file:
CompressType	HTKLib/HWave.c	/^typedef enum _CompressType CompressType;$/;"	t	typeref:enum:_CompressType	file:
CompressedException	HTKLVRec/kenlm/util/read_compressed.cc	/^CompressedException::CompressedException() throw() {}$/;"	f	class:util::CompressedException
CompressedException	HTKLVRec/kenlm/util/read_compressed.hh	/^class CompressedException : public Exception {$/;"	c	namespace:util
ComputeFoFTab	HLMLib/LPCalc.c	/^void ComputeFoFTab(FoFTab *ftab, int nSize, NGInputSet *inSet)$/;"	f
ComputeGuess	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static bool ComputeGuess(Vector<const char> trimmed, int exponent,$/;"	f	namespace:double_conversion
ComputeVSize	HTKTools/HSGen.c	/^void ComputeVSize(void)$/;"	f
ConcatFN	HTKLib/HModel.c	/^static char *ConcatFN(char *path, char *base, char *ext, char *fname)$/;"	f	file:
ConditionCommon	HTKLVRec/kenlm/lm/filter/phrase.cc	/^ConditionCommon::ConditionCommon(const ConditionCommon &from) : substrings_(from.substrings_) {}$/;"	f	class:lm::phrase::detail::ConditionCommon
ConditionCommon	HTKLVRec/kenlm/lm/filter/phrase.cc	/^ConditionCommon::ConditionCommon(const Substrings &substrings) : substrings_(substrings) {}$/;"	f	class:lm::phrase::detail::ConditionCommon
ConditionCommon	HTKLVRec/kenlm/lm/filter/phrase.hh	/^class ConditionCommon {$/;"	c	namespace:lm::phrase::detail
ConfKind	HTKLib/HShell.h	/^} ConfKind;$/;"	t	typeref:enum:__anon155
ConfParam	HTKLib/HShell.h	/^} ConfParam;$/;"	t	typeref:struct:__anon157
ConfVal	HTKLib/HShell.h	/^}ConfVal;$/;"	t	typeref:union:__anon156
Config	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    const PipelineConfig &Config() const { return config_; }$/;"	f	class:lm::builder::__anon47::Master
Config	HTKLVRec/kenlm/lm/config.cc	/^Config::Config() :$/;"	f	class:lm::ngram::Config
Config	HTKLVRec/kenlm/lm/config.hh	/^struct Config {$/;"	s	namespace:lm::ngram
ConfigEntry	HTKLib/HShell.c	/^}ConfigEntry;$/;"	t	typeref:struct:_ConfigEntry	file:
ConfigException	HTKLVRec/kenlm/lm/lm_exception.cc	/^ConfigException::ConfigException() throw() {}$/;"	f	class:lm::ConfigException
ConfigException	HTKLVRec/kenlm/lm/lm_exception.hh	/^class ConfigException : public util::Exception {$/;"	c	namespace:lm
ConfigureEnumerate	HTKLVRec/kenlm/lm/vocab.cc	/^void ProbingVocabulary::ConfigureEnumerate(EnumerateVocab *to, std::size_t \/*max_entries*\/) {$/;"	f	class:lm::ngram::ProbingVocabulary
ConfigureEnumerate	HTKLVRec/kenlm/lm/vocab.cc	/^void SortedVocabulary::ConfigureEnumerate(EnumerateVocab *to, std::size_t max_entries) {$/;"	f	class:lm::ngram::SortedVocabulary
ConsArcList	HTKLib/HArc.c	/^ArcList *ConsArcList(MemHeap *mem, HArc *h, ArcList *t){$/;"	f
ConstIterator	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef const Entry *ConstIterator;$/;"	t	class:util::AutoProbing
ConstIterator	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef const Entry *ConstIterator;$/;"	t	class:util::ProbingHashTable
Construct	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  static DedupeEntry Construct(WordIndex *at) {$/;"	f	struct:lm::builder::__anon43::DedupeEntry
Constructed	HTKLVRec/kenlm/util/fixed_array.hh	/^    void Constructed() {$/;"	f	class:util::FixedArray
Consume	HTKLVRec/kenlm/util/file_piece.hh	/^    StringPiece Consume(const char *to) {$/;"	f	class:util::FilePiece
Consume	HTKLVRec/kenlm/util/pcqueue.hh	/^  T Consume() {$/;"	f	class:util::PCQueue
Consume	HTKLVRec/kenlm/util/pcqueue.hh	/^  T& Consume(T &out) {$/;"	f	class:util::PCQueue
ConsumeHeader	HTKLib/HWave.c	/^static void ConsumeHeader(FILE *f, int bytesRead, int headSize)$/;"	f	file:
ConsumeSubString	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^static bool ConsumeSubString(const char** current,$/;"	f	namespace:double_conversion
Context	HTKLVRec/kenlm/lm/trie_sort.hh	/^    FILE *Context(unsigned char of_order) {$/;"	f	class:lm::ngram::trie::SortedFiles
Context	HTKTools/HLEd.c	/^} Context;$/;"	t	typeref:struct:_Context	file:
ContextFilter	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^    explicit ContextFilter(Filter &backend) : backend_(backend) {}$/;"	f	class:lm::ContextFilter
ContextFilter	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^template <class FilterT> class ContextFilter {$/;"	c	namespace:lm
ContextName	HTKLib/HNet.c	/^static LabId ContextName(HMMSetCxtInfo *hci,int c)$/;"	f	file:
ContextOrder	HTKLVRec/kenlm/lm/builder/sort.hh	/^    explicit ContextOrder(std::size_t order) : Comparator<ContextOrder>(order) {}$/;"	f	class:lm::builder::ContextOrder
ContextOrder	HTKLVRec/kenlm/lm/builder/sort.hh	/^class ContextOrder : public Comparator<ContextOrder> {$/;"	c	namespace:lm::builder
ContextRep	HTKTools/HDMan.c	/^void ContextRep(Pronunciation *p, LabId *args, DBuffer *db)$/;"	f
ContextReplaceOp	HTKTools/HDMan.c	/^void ContextReplaceOp(WordBuf *wb, LabId *args, DBuffer *db)$/;"	f
Controller	HTKLVRec/kenlm/lm/filter/thread.hh	/^    Controller(size_t batch_size, size_t queue, size_t workers, const Filter &filter, RealOutput &output) $/;"	f	class:lm::Controller
Controller	HTKLVRec/kenlm/lm/filter/thread.hh	/^template <class Filter, class OutputBuffer, class RealOutput> class Controller : boost::noncopyable {$/;"	c	namespace:lm
ConvDiagC	HTKLib/HUtil.c	/^void ConvDiagC(HMMSet *hset, Boolean convData)$/;"	f
ConvExpWt	HTKLib/HUtil.c	/^void ConvExpWt(HMMSet *hset)$/;"	f
ConvLogLikeFromBase	HTKLib/HNet.c	524;"	d	file:
ConvLogLikeToBase	HTKLib/HNet.c	526;"	d	file:
ConvLogWt	HTKLib/HUtil.c	/^void ConvLogWt(HMMSet *hset)$/;"	f
ConvertCont2Tied	HTKTools/HHEd.c	/^void ConvertCont2Tied(void)$/;"	f
ConvertFrame	HTKLib/HParm.c	/^static int ConvertFrame(IOConfig cf, float *pbuf)$/;"	f	file:
ConvertHParseNetwork	HTKTools/HParse.c	/^static void ConvertHParseNetwork(HPNetwork *theNet, char *latFn, char *dictFn)$/;"	f	file:
ConvertHSet	HTKLVRec/HLVModel.c	/^StateInfo_lv *ConvertHSet(MemHeap *heap, HMMSet *hset, Boolean useHModel)$/;"	f
ConvertNISTData	HTKLib/HWave.c	/^ReturnStatus ConvertNISTData(Wave w, InputAction ia)$/;"	f
ConvertSUNAU8Data	HTKLib/HWave.c	/^static ReturnStatus ConvertSUNAU8Data(Wave w)$/;"	f	file:
ConvertSilDict	HTKLVRec/HLVNet.c	/^void ConvertSilDict (Vocab *voc, LabId spLab, LabId silLab, $/;"	f
ConvertTLex2Lex	HTKLVRec/HLVNet.c	/^LexNet *ConvertTLex2Lex (MemHeap *heap, TLexNet *tnet)$/;"	f
ConvertToLog	HLMLib/LPCalc.c	/^static void ConvertToLog(FLEntry *parent)$/;"	f	file:
ConvertToSorted	HTKLVRec/kenlm/lm/trie_sort.cc	/^void SortedFiles::ConvertToSorted(util::FilePiece &f, const SortedVocabulary &vocab, const std::vector<uint64_t> &counts, const std::string &file_prefix, unsigned char order, PositiveProbWarn &warn, void *mem, std::size_t mem_size) {$/;"	f	class:lm::ngram::trie::SortedFiles
ConvertWAVData	HTKLib/HWave.c	/^ReturnStatus ConvertWAVData(Wave w, InputAction *ia)$/;"	f
Copy	HTKLVRec/kenlm/lm/filter/format.hh	/^  static void Copy(util::FilePiece &in, Output &out) {$/;"	f	struct:lm::ARPAFormat
Copy	HTKLVRec/kenlm/lm/filter/format.hh	/^  static void Copy(util::FilePiece &in, Output &out) {$/;"	f	struct:lm::CountFormat
CopyAdaptXForm	HTKLib/HAdapt.c	/^AdaptXForm *CopyAdaptXForm(MemHeap *x, AdaptXForm *xform)$/;"	f
CopyDColumn	HTKLib/HMath.c	/^static void CopyDColumn(DMatrix M, int k, DVector v) $/;"	f	file:
CopyDMatrix	HTKLib/HMath.c	/^void CopyDMatrix(DMatrix m1, DMatrix m2)$/;"	f
CopyDRow	HTKLib/HMath.c	/^static void CopyDRow(DMatrix M, int k, DVector v) $/;"	f	file:
CopyDVector	HTKLib/HMath.c	/^void CopyDVector(DVector v1, DVector v2)$/;"	f
CopyFiles	HLMTools/LGCopy.c	/^static void CopyFiles(void)$/;"	f	file:
CopyIntVec	HTKLib/HMath.c	/^void CopyIntVec(IntVec v1, IntVec v2)$/;"	f
CopyLabelList	HTKLib/HLabel.c	/^LabList* CopyLabelList(MemHeap *x, LabList* ll)$/;"	f
CopyLattice	HTKLib/HNet.c	/^void CopyLattice(Lattice *lat, Lattice *newlat, $/;"	f
CopyLinXForm	HTKLib/HAdapt.c	/^LinXForm *CopyLinXForm(MemHeap *x, LinXForm *xf)$/;"	f
CopyMatrix	HTKLib/HMath.c	/^void CopyMatrix(Matrix m1, Matrix m2)$/;"	f
CopyRemainingHistory	HTKLVRec/kenlm/lm/model.cc	/^void CopyRemainingHistory(const WordIndex *from, State &out_state) {$/;"	f	namespace:lm::ngram::detail::__anon53
CopyShortVec	HTKLib/HMath.c	/^void CopyShortVec(ShortVec v1, ShortVec v2)$/;"	f
CopyString	HTKLib/HMem.c	/^char *CopyString(MemHeap *x, char *s)$/;"	f
CopyToString	HTKLVRec/kenlm/util/string_piece.cc	/^void StringPiece::CopyToString(std::string* target) const {$/;"	f	class:StringPiece
CopyTranscription	HTKLib/HLabel.c	/^Transcription *CopyTranscription(MemHeap *x, Transcription *t)$/;"	f
CopyTriMat	HTKLib/HMath.c	/^void CopyTriMat(TriMat m1, TriMat m2)$/;"	f
CopyVector	HTKLib/HMath.c	/^void CopyVector(Vector v1, Vector v2)$/;"	f
CopyWordBuf	HTKTools/HDMan.c	/^void CopyWordBuf(DBuffer *s, DBuffer *t)$/;"	f
CopyXFormSet	HTKLib/HAdapt.c	/^XFormSet *CopyXFormSet(MemHeap *x, XFormSet *xfset)$/;"	f
CorpusCount	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^CorpusCount::CorpusCount(util::FilePiece &from, int vocab_write, uint64_t &token_count, WordIndex &type_count, std::vector<bool> &prune_words, const std::string& prune_vocab_filename, std::size_t entries_per_block, WarningAction disallowed_symbol)$/;"	f	class:lm::builder::CorpusCount
CorpusCount	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^class CorpusCount {$/;"	c	namespace:lm::builder
CorrA	HTKLib/HArc.h	/^typedef struct _CorrA CorrA;$/;"	t	typeref:struct:_CorrA
CorrN	HTKLib/HArc.h	/^typedef struct _CorrN CorrN; \/* for exact MPE. *\/$/;"	t	typeref:struct:_CorrN
CorrectArc	HTKLib/HFBLat.c	/^} CorrectArc;$/;"	t	typeref:struct:__anon100	file:
CorrectArcList	HTKLib/HFBLat.c	/^} CorrectArcList;$/;"	t	typeref:struct:_CorrectArcList	file:
Count	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    uint64_t &Count() { return Value().count; }$/;"	f	class:lm::builder::NGram
Count	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    uint64_t Count() const { return Value().count; }$/;"	f	class:lm::builder::NGram
CountAuxLabs	HTKLib/HLabel.c	/^int CountAuxLabs(LabList *ll, int i)$/;"	f
CountBatch	HTKLVRec/kenlm/lm/filter/count_io.hh	/^    explicit CountBatch(std::streamsize initial_read) $/;"	f	class:lm::CountBatch
CountBatch	HTKLVRec/kenlm/lm/filter/count_io.hh	/^class CountBatch {$/;"	c	namespace:lm
CountClassTotals	HLMLib/LModel.c	/^static void CountClassTotals(BackOffLM *lm)$/;"	f	file:
CountDefunctMix	HTKTools/HHEd.c	/^int CountDefunctMix(StreamElem *ste)$/;"	f
CountEntries	HLMLib/LModel.c	/^static void CountEntries(int lev, int nSize, FLEntry *tgtFE, int *nfe, int *nse)$/;"	f	file:
CountFormat	HTKLVRec/kenlm/lm/filter/format.hh	/^struct CountFormat {$/;"	s	namespace:lm
CountHits	HTKTools/HResults.c	/^void CountHits(int idx, int *nh, int *nf)$/;"	f
CountLabs	HTKLib/HLabel.c	/^int CountLabs(LabList *ll)$/;"	f
CountNonNullNodes	HTKLib/HNet.c	/^static int CountNonNullNodes(Lattice *lat)$/;"	f	file:
CountOutput	HTKLVRec/kenlm/lm/filter/count_io.hh	/^    explicit CountOutput(const char *name) : file_(util::CreateOrThrow(name)) {}$/;"	f	class:lm::CountOutput
CountOutput	HTKLVRec/kenlm/lm/filter/count_io.hh	/^class CountOutput : boost::noncopyable {$/;"	c	namespace:lm
CountText	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^void CountText(int text_file \/* input *\/, int vocab_file \/* output *\/, Master &master, uint64_t &token_count, std::string &text_file_name, std::vector<bool> &prune_words) {$/;"	f	namespace:lm::builder::__anon47
CounterFN	HTKLib/HShell.c	/^char * CounterFN(char *prefix, char* suffix, int count, int width, char *s)$/;"	f
Counts	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^    const std::vector<uint64_t> &Counts() const { return counts_; }$/;"	f	class:lm::interpolate::ARPAToStream
Counts	HTKLVRec/kenlm/lm/search_trie.cc	/^    const std::vector<uint64_t> &Counts() const {$/;"	f	class:lm::ngram::trie::__anon58::FindBlanks
CovAcc	HTKTools/HCompV.c	/^} CovAcc;$/;"	t	typeref:struct:__anon189	file:
CovDet	HTKLib/HMath.c	/^LogFloat CovDet(TriMat c)$/;"	f
CovInvert	HTKLib/HMath.c	/^LogFloat CovInvert(TriMat c, Matrix invc)$/;"	f
CovKind	HTKLib/HMath.h	/^} CovKind;$/;"	t	typeref:enum:__anon113
CovKind2Str	HTKLib/HModel.c	/^char *CovKind2Str(CovKind ckind, char *buf)$/;"	f
Covariance	HTKLib/HMath.h	/^} Covariance;$/;"	t	typeref:union:__anon114
CreateAccCache	HTKLib/HAdapt.c	/^static AccCache  *CreateAccCache(IntVec size,  int b)$/;"	f	file:
CreateAccStruct	HTKLib/HAdapt.c	/^static AccStruct *CreateAccStruct(MemHeap *x, AdaptXForm *xform, $/;"	f	file:
CreateAdaptXForm	HTKLib/HAdapt.c	/^AdaptXForm *CreateAdaptXForm(HMMSet *hset, char *xformName)$/;"	f
CreateAlpha	HTKLib/HFB.c	/^static void CreateAlpha(AlphaBeta *ab, HMMSet *hset, int Q)$/;"	f	file:
CreateAnodes	HTKLVRec/HLVNet.c	/^void CreateAnodes (MemHeap *heap, TLexNet *net)$/;"	f
CreateArc	HTKLib/HArc.c	/^HArc *CreateArc(MemHeap *mem, Lattice *lat, LArc *la, int start_time, int pos, int arcId, HArc *lastArc, float insPen, float lmScale, HMMSet *hset, ArcInfo *aInfo){ \/*Creates an arc.*\/$/;"	f
CreateBYnodes	HTKLVRec/HLVNet.c	/^void CreateBYnodes (MemHeap *heap, TLexNet *net)$/;"	f
CreateBaseAdaptXForm	HTKLib/HAdapt.c	/^static AdaptXForm *CreateBaseAdaptXForm(HMMSet *hset, char *xformName)$/;"	f	file:
CreateBaseTriMat	HTKLib/HAdapt.c	/^static void CreateBaseTriMat(MemHeap *x, MixPDF *mp, AdaptXForm *xform, int classIdx)$/;"	f	file:
CreateBestInfo	HTKLVRec/HDecode.c	/^BestInfo *CreateBestInfo (MemHeap *heap, char *fn, HTime frameDur)$/;"	f
CreateBestInfo	HTKLVRec/HDecode.mod.c	/^BestInfo *CreateBestInfo (MemHeap *heap, char *fn, HTime frameDur)$/;"	f
CreateBeta	HTKLib/HFB.c	/^static void CreateBeta(AlphaBeta *ab, int T)$/;"	f	file:
CreateBetaQ	HTKLib/HFB.c	/^static DVector *CreateBetaQ(MemHeap *x, int qLo,int qHi,int Q)$/;"	f	file:
CreateBlockTriMat	HTKLib/HAdapt.c	/^static TriMat *CreateBlockTriMat(MemHeap *x, IntVec blockSize)$/;"	f	file:
CreateBoNGram	HTKLVRec/HLVLM.c	/^FSLM_ngram *CreateBoNGram (MemHeap *heap, int vocSize, int counts[NSIZE])$/;"	f
CreateBoNGram	HTKLib/HLM.c	/^NGramLM *CreateBoNGram(LModel *lm,int vocSize, int counts[NSIZE])$/;"	f
CreateBoundary	HTKLVRec/HLVNet.c	/^TLexNode *CreateBoundary (MemHeap *heap, TLexNet *tnet, LabId labid, int modLayer, int weLayer)$/;"	f
CreateBuffer	HTKTools/HDMan.c	/^void CreateBuffer(char *dName, Boolean isInput)$/;"	f
CreateButtons	HTKTools/HSLab.c	/^void CreateButtons(void)$/;"	f
CreateCME	HTKLib/HModel.c	/^static MixtureElem *CreateCME(HMMSet *hset, int M)$/;"	f	file:
CreateChWtAcc	HTKTools/HSmooth.c	/^WALink CreateChWtAcc(MemHeap *x, int M)$/;"	f
CreateChains	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    void CreateChains(std::size_t remaining_mem, const std::vector<uint64_t> &count_bounds) {$/;"	f	class:lm::builder::__anon47::Master	file:
CreateChildNodes	HTKTools/HHEd.c	/^void CreateChildNodes(CoList *list, RNode *ch1, RNode *ch2, int vSize) $/;"	f
CreateClassMap	HLMLib/LCMap.c	/^void CreateClassMap(char *fn, ClassMap *c, WordMap *w)$/;"	f
CreateClusterLink	HTKTools/HHEd.c	/^CoList *CreateClusterLink(char *s, int state, int stream, int mix, $/;"	f
CreateCompLMLA	HTKLVRec/HLVNet.c	/^static void CreateCompLMLA (MemHeap *heap, LMlaTree *laTree, TLexNet *tnet)$/;"	f	file:
CreateDME	HTKLib/HModel.c	/^static ShortVec CreateDME(HMMSet *hset, int M)$/;"	f	file:
CreateDMatrix	HTKLib/HMem.c	/^DMatrix CreateDMatrix(MemHeap *x, int nrows,int ncols)$/;"	f
CreateDVector	HTKLib/HMem.c	/^DVector CreateDVector(MemHeap *x, int size)$/;"	f
CreateDecimalRepresentation	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^void DoubleToStringConverter::CreateDecimalRepresentation($/;"	f	class:double_conversion::DoubleToStringConverter
CreateDecoderInst	HTKLVRec/HLVRec.c	/^DecoderInst *CreateDecoderInst(HMMSet *hset, lm::base::Model *lm_kenlm, int nTok, Boolean latgen, $/;"	f
CreateExponentialRepresentation	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^void DoubleToStringConverter::CreateExponentialRepresentation($/;"	f	class:double_conversion::DoubleToStringConverter
CreateFOMTab	HTKTools/HResults.c	/^void CreateFOMTab(void)$/;"	f
CreateFoFTab	HLMLib/LGBase.c	/^FoFTab *CreateFoFTab(MemHeap *mem, int size, int N)$/;"	f
CreateGrid	HTKTools/HResults.c	/^void CreateGrid(void)$/;"	f
CreateHButton	HTKLib/HGraf.c	/^HButton *CreateHButton(HButton *btnlst, ButtonId btnid, int x, int y, int w, $/;"	f
CreateHButton	HTKLib/HGraf.null.c	/^HButton *CreateHButton(HButton *btnlst, ButtonId btnid, int x, int y, int w, $/;"	f
CreateHButton	HTKLib/HGraf_WIN32.c	/^HButton *CreateHButton(HButton *btnlst, ButtonId btnid, int x, int y, int w, $/;"	f
CreateHMM	HTKLib/HModel.c	/^static ReturnStatus CreateHMM(HMMSet *hset, LabId lId, LabId pId)$/;"	f	file:
CreateHMMSet	HTKLib/HModel.c	/^void CreateHMMSet(HMMSet *hset, MemHeap *heap, Boolean allowTMods)$/;"	f
CreateHParseNetwork	HTKTools/HParse.c	/^static HPNetwork CreateHParseNetwork(char *fname)$/;"	f	file:
CreateHashTable	HLMLib/LUtil.c	/^HashTab *CreateHashTable(int hashSize, char *description)$/;"	f
CreateHeap	HTKLib/HMem.c	/^void CreateHeap(MemHeap *x, char *name, HeapType type, size_t elemSize, $/;"	f
CreateIEModels	HTKLib/HNet.c	/^void CreateIEModels(Word thisWord,PronHolder *pInst,int p,int q,$/;"	f
CreateInputSet	HLMLib/LGBase.c	/^void CreateInputSet(MemHeap *mem, WordMap *wm, NGInputSet *inset)$/;"	f
CreateInsts	HTKLib/HFB.c	/^static int CreateInsts(FBInfo *fbInfo, AlphaBeta *ab, int Q, Transcription *tr)$/;"	f	file:
CreateIntVec	HTKLib/HMem.c	/^IntVec CreateIntVec(MemHeap *x,int size)$/;"	f
CreateJMacros	HTKTools/HHEd.c	/^void CreateJMacros(LabId rootMacId)$/;"	f
CreateJMat	HTKTools/HParse.c	/^static void CreateJMat(void)$/;"	f	file:
CreateJMixSet	HTKTools/HHEd.c	/^MixtureElem * CreateJMixSet(void)$/;"	f
CreateLM	HTKLVRec/HLVLM.c	/^FSLM *CreateLM (MemHeap *heap, char *fn, char *startWord, char *endWord, Vocab *vocab)$/;"	f
CreateLMCache	HTKLVRec/HLVRec-LM.c	/^static LMCache *CreateLMCache (DecoderInst *dec, MemHeap *heap)$/;"	f	file:
CreateLMfromLat	HTKLVRec/HLVLM.c	/^FSLM *CreateLMfromLat (MemHeap *heap, char *latfn, Lattice *lat, Vocab *vocab)$/;"	f
CreateLabObj	HTKTools/HSLab.c	/^Label *CreateLabObj(LabList *ll, LabId labid, long st, long en)$/;"	f
CreateLabel	HTKLib/HLabel.c	/^LLink CreateLabel(MemHeap *x, int maxAux)$/;"	f
CreateLabelList	HTKLib/HLabel.c	/^LabList* CreateLabelList(MemHeap *x, int maxAuxLab)$/;"	f
CreateLattice	HTKLib/HRec.c	/^static Lattice *CreateLattice(MemHeap *heap,TokenSet *res,HTime framedur)$/;"	f	file:
CreateLexNet	HTKLVRec/HLVNet.c	/^LexNet *CreateLexNet (MemHeap *heap, Vocab *voc, HMMSet *hset, $/;"	f
CreateLexNet_S	HTKLVRec/HLVNet.c	/^LexNet *CreateLexNet_S (MemHeap *heap, Vocab *voc, HMMSet *hset, char *startWord, char *endWord)$/;"	f
CreateLinXForm	HTKLib/HAdapt.c	/^static LinXForm *CreateLinXForm(MemHeap *x,int vsize,IntVec blockSize)$/;"	f	file:
CreateLinkSet	HTKTools/HParse.c	/^LinkSet *CreateLinkSet(int size)$/;"	f
CreateListorMap	HLMLib/LWMap.c	/^static void CreateListorMap(char *fn, WordMap *wm, int freeSlots, Boolean isMap)$/;"	f	file:
CreateMInfo	HTKLib/HAdapt.c	/^static MInfo *CreateMInfo(MemHeap *x, MixPDF *mp, AdaptXForm *xform)$/;"	f	file:
CreateMatBigram	HTKLib/HLM.c	/^MatBiLM *CreateMatBigram(LModel *lm,int nw)$/;"	f
CreateMatrix	HTKLib/HMem.c	/^Matrix CreateMatrix(MemHeap *x, int nrows, int ncols)$/;"	f
CreateMixes	HTKTools/HInit.c	/^IntVec *CreateMixes(MemHeap *x,int segLen)$/;"	f
CreateMonoList	HTKTools/HSmooth.c	/^void CreateMonoList(void)$/;"	f
CreateMuAcc	HTKLib/HTrain.c	/^static MuAcc *CreateMuAcc(MemHeap *x, int vSize, int nPara)$/;"	f	file:
CreateNGBuffer	HLMLib/LGBase.c	/^NGBuffer *CreateNGBuffer(MemHeap *mem, int N, int size, char *fn, WordMap *wm)$/;"	f
CreateNode	HTKTools/HParse.c	/^Link CreateNode(LabId name, Link *chain, int maxSucc, int maxPred)$/;"	f
CreateObsCache	HTKLib/HAdapt.c	/^static ObsCache *CreateObsCache(MemHeap *heap, ObsCache **headoc, int size)$/;"	f	file:
CreateOjsprob	HTKLib/HFB.c	/^static float *** CreateOjsprob(MemHeap *x, int N, int S)$/;"	f	file:
CreateOqprob	HTKLib/HFB.c	/^static float ****CreateOqprob(MemHeap *x, int qLo,int qHi)$/;"	f	file:
CreateOrThrow	HTKLVRec/kenlm/util/file.cc	/^int CreateOrThrow(const char *name) {$/;"	f	namespace:util
CreateOtprob	HTKLib/HFB.c	/^static void CreateOtprob(AlphaBeta *ab, int T)$/;"	f	file:
CreateOutPCache	HTKLVRec/HLVRec-outP.c	/^static OutPCache *CreateOutPCache (MemHeap *heap, HMMSet *hset, int block)$/;"	f	file:
CreatePlotBuf	HTKTools/HSLab.c	/^void CreatePlotBuf(int size)$/;"	f
CreatePreComp	HTKLib/HTrain.c	/^static PreComp *CreatePreComp(MemHeap *x)$/;"	f	file:
CreateRegAcc	HTKLib/HAdapt.c	/^static RegAcc *CreateRegAcc(MemHeap *x, MixPDF *mp, AdaptXForm *xform)$/;"	f	file:
CreateRegNode	HTKLib/HModel.c	/^static RegNode *CreateRegNode(MemHeap *m, int nodeId)$/;"	f	file:
CreateRegTreeNode	HTKTools/HHEd.c	/^RNode *CreateRegTreeNode(CoList *list, int vSize) $/;"	f
CreateReverseLookup	HLMLib/LModel.c	/^void CreateReverseLookup(FLEntry *fes)$/;"	f
CreateRuleSet	HLMTools/LGPrep.c	/^void CreateRuleSet(RuleSet *rset)$/;"	f
CreateSE	HTKLib/HModel.c	/^static StreamElem *CreateSE(HMMSet *hset, int S)$/;"	f	file:
CreateSEIndex	HTKLib/HRec.c	/^static void CreateSEIndex(PSetInfo *psi,HLink hmm)$/;"	f	file:
CreateSILnodes	HTKLVRec/HLVNet.c	/^void CreateSILnodes (MemHeap *heap, TLexNet *net)$/;"	f
CreateSMatrix	HTKLib/HMem.c	/^Matrix CreateSMatrix(MemHeap *x, int nrows,int ncols)$/;"	f
CreateSTriMat	HTKLib/HMem.c	/^STriMat CreateSTriMat(MemHeap *x,int size)$/;"	f
CreateSVector	HTKLib/HMem.c	/^Vector CreateSVector(MemHeap *x, int size)$/;"	f
CreateSegStore	HTKLib/HTrain.c	/^SegStore CreateSegStore(MemHeap *x, Observation obs, int segLen)$/;"	f
CreateSeqMat	HTKTools/HInit.c	/^Sequence ** CreateSeqMat(void)$/;"	f
CreateSequence	HTKLib/HTrain.c	/^Sequence CreateSequence(MemHeap *x, int blkSize)$/;"	f
CreateSet	HTKLib/HUtil.c	/^IntSet CreateSet(int size)$/;"	f
CreateShortVec	HTKLib/HMem.c	/^ShortVec CreateShortVec(MemHeap *x,int size)$/;"	f
CreateSrcExt	HTKLib/HParm.c	/^HParmSrcDef CreateSrcExt(Ptr xInfo, ParmKind pk, int size, HTime sampPeriod, $/;"	f
CreateStartEnd	HTKLVRec/HLVNet.c	/^void CreateStartEnd (MemHeap *heap, TLexNet *tnet)$/;"	f
CreateSubWindows	HTKTools/HSLab.c	/^void CreateSubWindows(void)$/;"	f
CreateTME	HTKLib/HModel.c	/^static Vector CreateTME(HMMSet *hset, int M)$/;"	f	file:
CreateTMRecs	HTKTools/HHEd.c	/^void CreateTMRecs(void)$/;"	f
CreateTrAcc	HTKLib/HFB.c	/^static TrAcc *CreateTrAcc(MemHeap *x, int numStates)$/;"	f	file:
CreateTrAcc	HTKLib/HTrain.c	/^static TrAcc *CreateTrAcc(MemHeap *x, int numStates, int nPara)$/;"	f	file:
CreateTraceOcc	HTKLib/HFB.c	/^static void CreateTraceOcc(AlphaBeta *ab, UttInfo *utt)$/;"	f	file:
CreateTranscription	HTKLib/HLabel.c	/^Transcription *CreateTranscription(MemHeap *x)$/;"	f
CreateTree	HTKTools/HHEd.c	/^Tree *CreateTree(ILink ilist,LabId baseId,int state)$/;"	f
CreateTreeNode	HTKTools/HHEd.c	/^Node *CreateTreeNode(CLink clist, Node *parent)$/;"	f
CreateTriMat	HTKLib/HMem.c	/^TriMat CreateTriMat(MemHeap *x,int size)$/;"	f
CreateVQNode	HTKLib/HVQ.c	/^VQNode CreateVQNode(short vqidx, short nid, short lid, short rid, $/;"	f
CreateVQTab	HTKLib/HVQ.c	/^VQTable CreateVQTab(char *tabFN, short magic, TreeType type,$/;"	f
CreateVaAcc	HTKLib/HTrain.c	/^static VaAcc *CreateVaAcc(MemHeap *x, int vSize, CovKind ck, int nPara)$/;"	f	file:
CreateVector	HTKLib/HMem.c	/^Vector CreateVector(MemHeap *x, int size)$/;"	f
CreateWIModels	HTKLib/HNet.c	/^void CreateWIModels(PronHolder *pInst,int p,int q,$/;"	f
CreateWStore	HTKTools/HSmooth.c	/^void CreateWStore(void)$/;"	f
CreateWave	HTKLib/HWave.c	/^static Wave CreateWave(MemHeap *x, FileFormat fmt)$/;"	f	file:
CreateWordList	HLMLib/LWMap.c	/^void CreateWordList(char *fn, WordMap *w, int freeSlots)$/;"	f
CreateWordMap	HLMLib/LWMap.c	/^void CreateWordMap(char *fn, WordMap *w, int freeSlots)$/;"	f
CreateWtAcc	HTKLib/HFB.c	/^static WtAcc *CreateWtAcc(MemHeap *x, int nMix)$/;"	f	file:
CreateWtAcc	HTKLib/HTrain.c	/^static WtAcc *CreateWtAcc(MemHeap *x, int nMix, int nPara)$/;"	f	file:
CreateWtStore	HTKTools/HSmooth.c	/^void CreateWtStore(MemHeap *x)$/;"	f
CreateX1Model	HTKLib/HNet.c	/^static void CreateX1Model(PronHolder *pInst,int p, int q,$/;"	f	file:
CreateXEModels	HTKLib/HNet.c	/^static void CreateXEModels(PronHolder *pInst,int p, int q,$/;"	f	file:
CreateXFormInfo	HTKLib/HAdapt.c	/^static XFormInfo *CreateXFormInfo(MemHeap *x)$/;"	f	file:
CreateXFormMacro	HTKLib/HModel.c	/^void CreateXFormMacro(HMMSet *hset,AdaptXForm *xform, char* macroname)$/;"	f
CreateZnodes	HTKLVRec/HLVNet.c	/^void CreateZnodes (MemHeap *heap, TLexNet *net)$/;"	f
Create_kenlm	HTKLVRec/HDecode.c	/^Model* Create_kenlm(const char* file){$/;"	f
Current	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    Sentence Current() const {$/;"	f	class:lm::phrase::detail::Arc
Current	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    Sentence Current() const {$/;"	f	class:lm::phrase::detail::Vertex
Current	HTKLVRec/kenlm/util/read_compressed.cc	/^    ReadBase *Current(ReadCompressed &thunk) { return thunk.internal_.get(); }$/;"	f	class:util::ReadBase
Current	HTKLVRec/kenlm/util/stream/sort.hh	/^        const void *Current() const { return current_; }$/;"	f	class:util::stream::MergeQueue::Entry
CurrentColour	HTKLib/HGraf_WIN32.c	/^static COLORREF CurrentColour = RGB(0,0,0);$/;"	v	file:
CurrentFont	HTKLib/HGraf.c	/^static XFontStruct  *DefaultFont, *CurrentFont, *FontInfo[NO_OF_FONTS];$/;"	v	file:
Cut offs	HTKBook/hlmfund.tex	/^\\subsubsection{Cut-offs}$/;"	b
CutToMaxSignificantDigits	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static void CutToMaxSignificantDigits(Vector<const char> buffer,$/;"	f	namespace:double_conversion
CutoffCount	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    uint64_t CutoffCount() const {$/;"	f	class:lm::builder::NGram
D	HTKLib/HAdapt.c	/^   DVector *K, D;$/;"	m	struct:__anon85	file:
D	HTKTools/HSmooth.c	/^float D(float l, WALink wa, int M)$/;"	f
DARK_BLUE	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
DARK_BROWN	HTKLib/HGraf.h	/^                LIGHT_BLUE, DARK_GREEN, LIGHT_GREEN, DARK_BROWN, LIGHT_BROWN, $/;"	e	enum:_HColour
DARK_GREEN	HTKLib/HGraf.h	/^                LIGHT_BLUE, DARK_GREEN, LIGHT_GREEN, DARK_BROWN, LIGHT_BROWN, $/;"	e	enum:_HColour
DARK_GREY	HTKLib/HGraf.h	/^                LIGHT_GREY, GREY, DARK_GREY, BLACK};$/;"	e	enum:_HColour
DBLCX_FMT	HTKLib/esig_asc.c	75;"	d	file:
DBLCX_W	HTKLib/esig_asc.c	74;"	d	file:
DBLCX_WFMT	HTKLib/esig_asc.c	76;"	d	file:
DBL_FMT	HTKLib/esig_asc.c	43;"	d	file:
DBL_QUOTE	HTKLib/HShell.h	81;"	d
DBL_W	HTKLib/esig_asc.c	42;"	d	file:
DBL_WFMT	HTKLib/esig_asc.c	44;"	d	file:
DBUFLEN	HTKLib/HNet.c	889;"	d	file:
DBuffer	HTKTools/HDMan.c	/^}DBuffer;$/;"	t	typeref:struct:__anon195	file:
DCSaved	HTKLib/HGraf_WIN32.c	/^static HDC DCSaved;               \/* to store memDC when saving Metafile *\/$/;"	v	file:
DC_ABSOLUTE	HLMLib/LModel.h	/^   DC_KATZ, DC_ABSOLUTE, DC_LINEAR, DC_LAST$/;"	e	enum:__anon9
DC_KATZ	HLMLib/LModel.h	/^   DC_KATZ, DC_ABSOLUTE, DC_LINEAR, DC_LAST$/;"	e	enum:__anon9
DC_LAST	HLMLib/LModel.h	/^   DC_KATZ, DC_ABSOLUTE, DC_LINEAR, DC_LAST$/;"	e	enum:__anon9
DC_LINEAR	HLMLib/LModel.h	/^   DC_KATZ, DC_ABSOLUTE, DC_LINEAR, DC_LAST$/;"	e	enum:__anon9
DDistance	HTKTools/HHEd.c	/^float DDistance(StreamElem *s1, StreamElem *s2)$/;"	f
DEBUG_LABEL_NET	HTKLVRec/HLVNet.c	55;"	d	file:
DEFCON	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon191	file:
DEFCON	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon200	file:
DEF_ABS_COEF	HLMLib/LPCalc.c	502;"	d	file:
DEF_CUTOFF	HLMLib/LPCalc.h	44;"	d
DEF_DCTYPE	HLMLib/LPCalc.h	48;"	d
DEF_ENDWORD	HLMLib/LModel.h	73;"	d
DEF_FONTSIZE	HTKLib/HGraf_WIN32.c	40;"	d	file:
DEF_KRANGE	HLMLib/LPCalc.h	43;"	d
DEF_LMPTYPE	HLMLib/LPCalc.h	47;"	d
DEF_NCLUST	HTKTools/HQuant.c	57;"	d	file:
DEF_SAVEFMT	HLMLib/LPCalc.h	46;"	d
DEF_SNR	HTKLib/HParm.c	2404;"	d	file:
DEF_STARTWORD	HLMLib/LModel.h	72;"	d
DEF_TG_COEF	HLMLib/LPCalc.c	519;"	d	file:
DEF_UNIFLOOR	HLMLib/LPCalc.h	45;"	d
DEF_UNKNOWNID	HLMLib/LCMap.h	44;"	d
DEF_UNKNOWNNAME	HLMLib/LCMap.h	43;"	d
DELDEF	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon191	file:
DELETEP	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon191	file:
DELETEW	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon191	file:
DELETE_OP	HTKTools/HSLab.c	/^   CREATE_OP, DELETE_OP, CHANGE_OP$/;"	e	enum:__anon210	file:
DELKEY	HTKLib/HGraf.h	/^               ENTERKEY, DELKEY, ESCKEY};$/;"	e	enum:_KeyType
DELLEV	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon200	file:
DELSOURCE	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon191	file:
DELTAWINDOW	HTKLib/HParm.c	/^   DELTAWINDOW,   \/* Window size for 1st diffs *\/$/;"	e	enum:__anon142	file:
DESTDIR	Makefile	/^DESTDIR =$/;"	m
DFACTOR	HTKTools/HMMIRest.c	/^static float DFACTOR = 2.0;         \/* not a config, a constant used in estimating$/;"	v	file:
DIAG	HTKTools/HResults.c	/^enum _Direction{DIAG,VERT,HOR,NIL};$/;"	e	enum:_Direction	file:
DIAGC	HTKLib/HMath.h	/^   DIAGC,         \/* diagonal covariance *\/$/;"	e	enum:__anon113
DIAGCOV	HTKLib/HModel.c	/^   DIAGCOV,  FULLCOV, XFORMCOV,$/;"	e	enum:__anon117	file:
DIR_BACKW	HTKLVRec/HLVNet.c	1730;"	d	file:
DIR_FORW	HTKLVRec/HLVNet.c	1729;"	d	file:
DISALLOW_COPY_AND_ASSIGN	HTKLVRec/kenlm/util/double-conversion/utils.h	112;"	d
DISALLOW_IMPLICIT_CONSTRUCTORS	HTKLVRec/kenlm/util/double-conversion/utils.h	124;"	d
DISCRETE	HTKLib/HParm.h	/^      DISCRETE,                        \/* Discrete VQ symbols (shorts) *\/$/;"	e	enum:_BaseParmKind
DISCRETEHS	HTKLib/HModel.h	/^enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};$/;"	e	enum:_HSetKind
DISTFILES	Makefile	/^DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DIST_COMMON	Makefile	/^DIST_COMMON =  README ChangeLog Makefile.am \\$/;"	m
DLOGSCALE	HTKLib/HModel.h	56;"	d
DLOGZERO	HTKLib/HModel.h	57;"	d
DLUDecompose	HTKLib/HMath.c	/^static Boolean DLUDecompose(DMatrix a, int *perm, int *sign)$/;"	f	file:
DLinSolve	HTKLib/HMath.c	/^static void DLinSolve(DMatrix a, int *perm, double *b)$/;"	f	file:
DMat2Mat	HTKLib/HMath.c	/^void DMat2Mat(DMatrix m1, Matrix m2)$/;"	f
DMatCofact	HTKLib/HMath.c	/^double DMatCofact(DMatrix c, int r, DVector cofact)$/;"	f
DMatDet	HTKLib/HMath.c	/^double DMatDet(DMatrix c)$/;"	f
DMatInvert	HTKLib/HMath.c	/^double DMatInvert(DMatrix c, DMatrix invc)$/;"	f
DMatrix	HTKLib/HMem.h	/^typedef double **DMatrix;  \/* double matrix[1..nrows][1..ncols] *\/$/;"	t
DMatrixElemSize	HTKLib/HMem.c	/^size_t DMatrixElemSize(int nrows,int ncols)$/;"	f
DOT	HTKLib/esignal.h	60;"	d
DOT_CHUNK	HLMLib/LPMerge.c	76;"	d	file:
DOUBLE	HTKLib/esignal.h	66;"	d
DOUBLEFFT	HTKLib/HParm.c	/^   DOUBLEFFT,     \/* Use twice the required FFT size *\/$/;"	e	enum:__anon142	file:
DOUBLE_COMPLEX	HTKLib/esignal.h	75;"	d
DOUBLE_CONVERSION_BIGNUM_DTOA_H_	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.h	29;"	d
DOUBLE_CONVERSION_BIGNUM_H_	HTKLVRec/kenlm/util/double-conversion/bignum.h	29;"	d
DOUBLE_CONVERSION_CACHED_POWERS_H_	HTKLVRec/kenlm/util/double-conversion/cached-powers.h	29;"	d
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS	HTKLVRec/kenlm/util/double-conversion/utils.h	62;"	d
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS	HTKLVRec/kenlm/util/double-conversion/utils.h	66;"	d
DOUBLE_CONVERSION_CORRECT_DOUBLE_OPERATIONS	HTKLVRec/kenlm/util/double-conversion/utils.h	68;"	d
DOUBLE_CONVERSION_DIY_FP_H_	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	29;"	d
DOUBLE_CONVERSION_DOUBLE_CONVERSION_H_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	29;"	d
DOUBLE_CONVERSION_DOUBLE_H_	HTKLVRec/kenlm/util/double-conversion/ieee.h	29;"	d
DOUBLE_CONVERSION_FAST_DTOA_H_	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.h	29;"	d
DOUBLE_CONVERSION_FIXED_DTOA_H_	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.h	29;"	d
DOUBLE_CONVERSION_STRTOD_H_	HTKLVRec/kenlm/util/double-conversion/strtod.h	29;"	d
DOUBLE_CONVERSION_UTILS_H_	HTKLVRec/kenlm/util/double-conversion/utils.h	29;"	d
DOutP	HTKLib/HModel.c	/^static LogFloat DOutP(Vector x, int vecSize, MixPDF *mp)$/;"	f	file:
DP	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon199	file:
DPROB	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon117	file:
DProb2Short	HTKLib/HModel.c	/^short DProb2Short(float p)$/;"	f
DURATION	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon117	file:
DUR_KEY	HTKLib/HUtil.c	/^   TRANSP_KEY, STATE_KEY, DUR_KEY, WEIGHTS_KEY,$/;"	e	enum:__anon168	file:
DVector	HTKLib/HMem.h	/^typedef double *DVector;   \/* double vector[1..size]   *\/$/;"	t
DVectorElemSize	HTKLib/HMem.c	/^size_t DVectorElemSize(int size){ return (size+1)*sizeof(double);}$/;"	f
DVectorSize	HTKLib/HMem.c	/^int DVectorSize(DVector v)$/;"	f
Data	HTKLVRec/kenlm/lm/trie_sort.cc	/^    const void *Data() const { return inner_.Data(); }$/;"	f	class:lm::ngram::trie::__anon60::PartialViewProxy
Data	HTKLVRec/kenlm/lm/trie_sort.cc	/^    void *Data() { return inner_.Data(); }$/;"	f	class:lm::ngram::trie::__anon60::PartialViewProxy
Data	HTKLVRec/kenlm/lm/trie_sort.hh	/^    const void *Data() const { return data_.get(); }$/;"	f	class:lm::ngram::trie::RecordReader
Data	HTKLVRec/kenlm/lm/trie_sort.hh	/^    void *Data() { return data_.get(); }$/;"	f	class:lm::ngram::trie::RecordReader
Data	HTKLVRec/kenlm/util/sized_iterator.hh	/^    const void *Data() const { return inner_.Data(); }$/;"	f	class:util::SizedProxy
Data	HTKLVRec/kenlm/util/sized_iterator.hh	/^    const void *Data() const { return ptr_; }$/;"	f	class:util::SizedInnerIterator
Data	HTKLVRec/kenlm/util/sized_iterator.hh	/^    void *Data() { return inner_.Data(); }$/;"	f	class:util::SizedProxy
Data	HTKLVRec/kenlm/util/sized_iterator.hh	/^    void *Data() { return ptr_; }$/;"	f	class:util::SizedInnerIterator
Data Preparation Tools	HTKBook/htkoview.tex	/^\\subsection{Data Preparation Tools}$/;"	b
DeRefAlign	HTKLib/HRec.c	/^static void DeRefAlign(Align *align)$/;"	f	file:
DeRefPathPrev	HTKLib/HRec.c	/^static void DeRefPathPrev(Path *path)$/;"	f	file:
DeactivateNode	HTKLVRec/HLVRec.c	/^static void DeactivateNode (DecoderInst *dec, LexNode *ln)$/;"	f	file:
DebugMsg	HTKLib/esignal.h	298;"	d
DebugMsg	HTKLib/esignal.h	303;"	d
DebugMsgFunc	HTKLib/esignal.c	/^void    (*DebugMsgFunc)(char *msg);$/;"	v
DebugMsgLevel	HTKLib/esignal.c	/^int     DebugMsgLevel;$/;"	v
DebugPrint	HTKLib/esignal.c	/^DebugPrint(char *msg)$/;"	f
Debug_Check_LMhashtab	HTKLVRec/HLVLM.c	/^void Debug_Check_LMhashtab(FSLM_ngram *nglm)$/;"	f
Debug_Check_Score	HTKLVRec/HLVRec-misc.c	/^void Debug_Check_Score (DecoderInst *dec)$/;"	f
Debug_DumpNet	HTKLVRec/HLVRec-misc.c	/^void Debug_DumpNet (LexNet *net)$/;"	f
DecUse	HTKLib/HMem.c	/^void DecUse(Ptr m)$/;"	f
Decode	HTKLVRec/kenlm/lm/quantize.hh	/^        float Decode(std::size_t off) const { return begin_[off]; }$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
DecodeCommands	HTKTools/HSLab.c	/^void DecodeCommands(void)$/;"	f
DecodeIMuLaw	HTKLib/HWave.c	/^static void DecodeIMuLaw(Wave w)$/;"	f	file:
DecodeKeyPress	HTKLib/HGraf.c	/^static void DecodeKeyPress(XKeyEvent *xkev, HEventRec *hev)$/;"	f	file:
DecoderInst	HTKLVRec/HLVRec.h	/^typedef struct _DecoderInst DecoderInst;  \/* contains all state information about one instance$/;"	t	typeref:struct:_DecoderInst
DecompressShortPack	HTKLib/HWave.c	/^void DecompressShortPack(Wave w)$/;"	f
DecreaseBase	HTKLVRec/kenlm/util/mmap.hh	/^    void DecreaseBase(uint64_t by) {$/;"	f	class:util::Rolling
Dedupe	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^typedef util::ProbingHashTable<DedupeEntry, DedupeHash, DedupeEquals> Dedupe;$/;"	t	namespace:lm::builder::__anon43	file:
DedupeEntry	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^struct DedupeEntry {$/;"	s	namespace:lm::builder::__anon43	file:
DedupeEquals	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    explicit DedupeEquals(std::size_t order) : size_(order * sizeof(WordIndex)) {}$/;"	f	class:lm::builder::__anon43::DedupeEquals
DedupeEquals	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^class DedupeEquals : public std::binary_function<const WordIndex *, const WordIndex *, bool> {$/;"	c	namespace:lm::builder::__anon43	file:
DedupeHash	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    explicit DedupeHash(std::size_t order) : size_(order * sizeof(WordIndex)) {}$/;"	f	class:lm::builder::__anon43::DedupeHash
DedupeHash	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^class DedupeHash : public std::unary_function<const WordIndex *, bool> {$/;"	c	namespace:lm::builder::__anon43	file:
DedupeMultiplier	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^float CorpusCount::DedupeMultiplier(std::size_t order) {$/;"	f	class:lm::builder::CorpusCount
DeepSwap	HTKLVRec/kenlm/util/joint_sort.hh	/^    void DeepSwap(JointIter &other) {$/;"	f	class:util::detail::JointIter
DefaultFont	HTKLib/HGraf.c	/^static XFontStruct  *DefaultFont, *CurrentFont, *FontInfo[NO_OF_FONTS];$/;"	v	file:
DefaultLazy	HTKLVRec/kenlm/util/stream/sort.hh	/^    std::size_t DefaultLazy() {$/;"	f	class:util::stream::Sort
DefineContext	HTKTools/HLEd.c	/^void DefineContext(LabId name, LabId *def, int nDefs)$/;"	f
DefineContexts	HTKLib/HNet.c	/^static int DefineContexts(HMMSetCxtInfo *hci)$/;"	f	file:
DefineSubNet	HTKTools/HParse.c	/^static void DefineSubNet(LabId name, Link entryNode, Link exitNode, Link chain)$/;"	f	file:
DelDefOp	HTKTools/HDMan.c	/^void DelDefOp(WordBuf *wb, LabId *args)$/;"	f
DelPron	HTKLib/HDict.c	/^void DelPron(Vocab *voc, Word word, Pron pron)$/;"	f
DelQualifiers	HTKLib/HParm.c	/^static void DelQualifiers(float *data, IOConfig cf)$/;"	f	file:
DelWord	HTKLib/HDict.c	/^void DelWord(Vocab *voc, Word word)$/;"	f
DeleteClass	HLMLib/LCMap.c	/^void DeleteClass(ClassMap *c, int clndx)$/;"	f
DeleteColumn	HTKLib/HParm.c	/^static void DeleteColumn(float *data, int nUsed, int si, int d)$/;"	f	file:
DeleteHeap	HTKLib/HMem.c	/^void DeleteHeap(MemHeap *x)$/;"	f
DeleteItem	HTKLib/HTrain.c	/^void DeleteItem(Sequence seq, int i)$/;"	f
DeleteLabObj	HTKTools/HSLab.c	/^void DeleteLabObj(LabList *ll, LLink q)$/;"	f
DeleteLabel	HTKLib/HLabel.c	/^void DeleteLabel(LLink item)$/;"	f
DeleteLevel	HTKTools/HLEd.c	/^void DeleteLevel(Transcription *ltr,int lev)$/;"	f
DeleteLink	HTKTools/HParse.c	/^static void DeleteLink(Link x, LinkSet *ls)$/;"	f	file:
DeleteMacro	HTKLib/HModel.c	/^void DeleteMacro(HMMSet *hset, MLink p)$/;"	f
DeleteMacroStruct	HTKLib/HModel.c	/^void DeleteMacroStruct(HMMSet *hset, char type, Ptr structure)$/;"	f
DeleteOp	HTKTools/HLEd.c	/^int DeleteOp(LabList *ll,LabId *args)$/;"	f
DeletePhoneOp	HTKTools/HDMan.c	/^void DeletePhoneOp(WordBuf *wb, LabId *args)$/;"	f
DeleteSourceOp	HTKTools/HDMan.c	/^int DeleteSourceOp(WordBuf *wb, LabId *args)$/;"	f
DeleteVRecInfo	HTKLib/HRec.c	/^void DeleteVRecInfo(VRecInfo *vri)$/;"	f
DeleteWordOp	HTKTools/HDMan.c	/^void DeleteWordOp(WordBuf *wb, LabId *args)$/;"	f
Depth	HTKLib/HArc.c	/^float Depth(ArcInfo *aInfo, Boolean All){$/;"	f
DetachInst	HTKLib/HRec.c	/^static void DetachInst(NetNode *node)$/;"	f	file:
DetectCompressedMagic	HTKLVRec/kenlm/util/read_compressed.cc	/^bool ReadCompressed::DetectCompressedMagic(const void *from_void) {$/;"	f	class:util::ReadCompressed
DetectMagic	HTKLVRec/kenlm/util/read_compressed.cc	/^MagicResult DetectMagic(const void *from_void, std::size_t length) {$/;"	f	namespace:util::__anon79
DiagApplyMat2TXForm	HTKLib/HAdapt.c	/^static void DiagApplyMat2TXForm(LinXForm *linXForm, Matrix m, Vector v)$/;"	f	file:
DictEntry	HTKLib/HDict.h	/^} DictEntry;$/;"	t	typeref:struct:_DictEntry
DictFilter	HTKLib/HShell.h	/^   DictFilter,      \/* Dictionary file input via HDict *\/$/;"	e	enum:__anon153
DictOFilter	HTKLib/HShell.h	/^   DictOFilter,     \/* Dictionary file output via HDict *\/$/;"	e	enum:__anon153
Dictionary and Language Model	HTKBook/exampsys.tex	/^\\subsection{Dictionary and Language Model}$/;"	b
DigitGen	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^static bool DigitGen(DiyFp low,$/;"	f	namespace:double_conversion
DigitGenCounted	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^static bool DigitGenCounted(DiyFp w,$/;"	f	namespace:double_conversion
Direction	HTKTools/HResults.c	/^typedef enum _Direction Direction;$/;"	t	typeref:enum:_Direction	file:
DisconNode	HTKTools/HParse.c	/^static Boolean DisconNode(Link p)$/;"	f	file:
Discount	HTKLVRec/kenlm/lm/builder/discount.hh	/^struct Discount {$/;"	s	namespace:lm::builder
DiscountConfig	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^struct DiscountConfig {$/;"	s	namespace:lm::builder
DiscountInfo	HLMLib/LModel.h	/^} DiscountInfo;$/;"	t	typeref:union:__anon11
DiscountType	HLMLib/LModel.h	/^} DiscountType;$/;"	t	typeref:enum:__anon9
DiskFlush	HTKLVRec/kenlm/lm/trie_sort.cc	/^FILE *DiskFlush(const void *mem_begin, const void *mem_end, const std::string &temp_prefix) {$/;"	f	namespace:lm::ngram::trie::__anon60
DispatchARPAInput	HTKLVRec/kenlm/lm/filter/format.hh	/^    DispatchARPAInput(Filter &filter, Output &output) : B(filter, output) {}$/;"	f	class:lm::DispatchARPAInput
DispatchARPAInput	HTKLVRec/kenlm/lm/filter/format.hh	/^template <class Filter, class Output> class DispatchARPAInput : public DispatchInput<Filter, Output> {$/;"	c	namespace:lm
DispatchBuild	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <> void HashedSearch<BackoffValue>::DispatchBuild(util::FilePiece &f, const std::vector<uint64_t> &counts, const Config &config, const ProbingVocabulary &vocab, PositiveProbWarn &warn) {$/;"	f	class:lm::ngram::detail::HashedSearch
DispatchBuild	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <> void HashedSearch<RestValue>::DispatchBuild(util::FilePiece &f, const std::vector<uint64_t> &counts, const Config &config, const ProbingVocabulary &vocab, PositiveProbWarn &warn) {$/;"	f	class:lm::ngram::detail::HashedSearch
DispatchInput	HTKLVRec/kenlm/lm/filter/format.hh	/^    DispatchInput(Filter &filter, Output &output) : filter_(filter), output_(output) {}$/;"	f	class:lm::DispatchInput
DispatchInput	HTKLVRec/kenlm/lm/filter/format.hh	/^template <class Filter, class Output> class DispatchInput {$/;"	c	namespace:lm
DisplayNGramFile	HLMTools/LGList.c	/^void DisplayNGramFile(char *fn)$/;"	f
Dispose	HTKLib/HMem.c	/^void Dispose(MemHeap *x, void *p)$/;"	f
Distance	HTKLib/HTrain.c	/^static float Distance(Vector v1, Vector v2)$/;"	f	file:
Distance	HTKTools/HHEd.c	/^float Distance(Vector v1, Vector v2) $/;"	f
DivModPowerOf2	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^  int DivModPowerOf2(int power) {$/;"	f	class:double_conversion::UInt128
Divergence	HTKTools/HHEd.c	/^float Divergence(StreamElem *s1, StreamElem *s2)$/;"	f
DivideModuloIntBignum	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^uint16_t Bignum::DivideModuloIntBignum(const Bignum& other) {$/;"	f	class:double_conversion::Bignum
DiyFp	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  DiyFp() : f_(0), e_(0) {}$/;"	f	class:double_conversion::DiyFp
DiyFp	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  DiyFp(uint64_t f, int e) : f_(f), e_(e) {}$/;"	f	class:double_conversion::DiyFp
DiyFp	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^class DiyFp {$/;"	c	namespace:double_conversion
DiyFpStrtod	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static bool DiyFpStrtod(Vector<const char> buffer,$/;"	f	namespace:double_conversion
DiyFpToUint64	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static uint64_t DiyFpToUint64(DiyFp diy_fp) {$/;"	f	class:double_conversion::Double
Do8_16	HTKLib/HWave.c	/^               Do8_16  = 64,    \/* 8 bit PCM expansion needed *\/$/;"	e	enum:__anon172	file:
DoALAW	HTKLib/HWave.c	/^               DoALAW  = 32,    \/* 8 bit A-Law expansion needed *\/$/;"	e	enum:__anon172	file:
DoAbout	HTKTools/HSLab.c	/^void DoAbout(void)$/;"	f
DoAdjustLabel	HTKTools/HSLab.c	/^Boolean DoAdjustLabel(void)$/;"	f
DoAlignment	HTKTools/HVite.c	/^void DoAlignment(void)$/;"	f
DoAllMixUpdates	HTKLib/HFBLat.c	/^void DoAllMixUpdates(int t){$/;"	f
DoBSWAP	HTKLib/HWave.c	/^               DoBSWAP  = 2,     \/* byte swap needed *\/$/;"	e	enum:__anon172	file:
DoCMV	HTKTools/HCompV.c	/^static Boolean DoCMV = FALSE;            \/* switch from old HCompV to CMV *\/$/;"	v	file:
DoCVT	HTKLib/HWave.c	/^typedef enum { DoCVT    = 1,     \/* input conversion needed *\/$/;"	e	enum:__anon172	file:
DoChangeLabStr	HTKTools/HSLab.c	/^void DoChangeLabStr(void)$/;"	f
DoCompare	HTKTools/HResults.c	/^void DoCompare(void)$/;"	f
DoCompareNIST	HTKTools/HResults.c	/^void DoCompareNIST(void)$/;"	f
DoCorrectness	HTKLib/HExactMPE.c	/^float DoCorrectness(FBLatInfo *fbInfo, MemHeap *mem, ArcInfo *ai, float prune, $/;"	f
DoDelLab	HTKTools/HSLab.c	/^Boolean DoDelLab(void)$/;"	f
DoEdit	HTKTools/HHEd.c	/^void DoEdit(char * editFn)$/;"	f
DoEditLabel	HTKTools/HSLab.c	/^Boolean DoEditLabel(void)$/;"	f
DoExactCorrectness	HTKLib/HExactMPE.c	/^void DoExactCorrectness(FBLatInfo *fbInfo, Lattice *lat){$/;"	f
DoForwardBackward	HTKTools/HERest.c	/^void DoForwardBackward(FBInfo *fbInfo, UttInfo *utt, char * datafn, char * datafn2)$/;"	f
DoIncLabSet	HTKTools/HSLab.c	/^void DoIncLabSet(void)$/;"	f
DoIncScale	HTKTools/HSLab.c	/^void DoIncScale(void)$/;"	f
DoIncVolume	HTKTools/HSLab.c	/^void DoIncVolume(void)$/;"	f
DoLCtxt	HTKTools/HLEd.c	/^int DoLCtxt(LabList *ll,int nArgs,LabId *args)$/;"	f
DoLabel	HTKTools/HSLab.c	/^Boolean DoLabel(Boolean useLabStr)$/;"	f
DoLoad	HTKTools/HSLab.c	/^Boolean DoLoad(void)$/;"	f
DoMULAW	HTKLib/HWave.c	/^               DoMULAW  = 16,    \/* 8 bit Mu-Law expansion needed *\/$/;"	e	enum:__anon172	file:
DoMark	HTKTools/HSLab.c	/^Boolean DoMark(int *markA, int *markB)$/;"	f
DoMatch	HTKLib/HShell.c	/^Boolean DoMatch(char *s, char *p)$/;"	f
DoMixUpdate	HTKLib/HFBLat.c	/^void DoMixUpdate(MixPDF *mp, int s, float Lr, float meescale, int t){  $/;"	f
DoNewLabSet	HTKTools/HSLab.c	/^void DoNewLabSet(void)$/;"	f
DoOnlineAdaptation	HTKTools/HVite.c	/^int DoOnlineAdaptation(Lattice *lat, ParmBuf pbuf, int nFrames)$/;"	f
DoPause	HTKTools/HSLab.c	/^BtnId DoPause(void)$/;"	f
DoPlay	HTKTools/HSLab.c	/^void DoPlay(void)$/;"	f
DoPreComps	HTKLib/HTrain.c	75;"	d	file:
DoRCtxt	HTKTools/HLEd.c	/^int DoRCtxt(LabList *ll,int nArgs,LabId *args)$/;"	f
DoRecognition	HTKLVRec/HDecode.c	/^void DoRecognition (DecoderInst *dec, char *fn)$/;"	f
DoRecognition	HTKLVRec/HDecode.mod.c	/^void DoRecognition (DecoderInst *dec, char *fn)$/;"	f
DoRecognition	HTKTools/HVite.c	/^void DoRecognition(void)$/;"	f
DoRecord	HTKTools/HSLab.c	/^void DoRecord(short *data)$/;"	f
DoRestore	HTKTools/HSLab.c	/^void DoRestore(void)$/;"	f
DoSHORT	HTKLib/HWave.c	/^               DoSHORT  = 8,     \/* SHORTEN decompression needed *\/$/;"	e	enum:__anon172	file:
DoSPACK	HTKLib/HWave.c	/^               DoSPACK  = 4,     \/* SHORT PACK decompression needed *\/$/;"	e	enum:__anon172	file:
DoSTEREO	HTKLib/HWave.c	/^               DoSTEREO = 128     \/* Convert stereo to mono*\/ $/;"	e	enum:__anon172	file:
DoSave	HTKTools/HSLab.c	/^void DoSave(void)$/;"	f
DoScrollLeft	HTKTools/HSLab.c	/^void DoScrollLeft(void)$/;"	f
DoScrollRight	HTKTools/HSLab.c	/^void DoScrollRight(void)$/;"	f
DoSelectLabel	HTKTools/HSLab.c	/^Boolean DoSelectLabel(void)$/;"	f
DoSpecial	HTKTools/HSLab.c	/^void DoSpecial(void)$/;"	f
DoTCtxt	HTKTools/HLEd.c	/^int DoTCtxt(LabList *ll,int nArgs,LabId *args)$/;"	f
DoTraceBack	HTKTools/HInit.c	/^void DoTraceBack(int segLen, IntVec states, int thisState)$/;"	f
DoUnMark	HTKTools/HSLab.c	/^void DoUnMark(int markA, int markB)$/;"	f
DoZoomIn	HTKTools/HSLab.c	/^Boolean DoZoomIn(void)$/;"	f
DoZoomOut	HTKTools/HSLab.c	/^Boolean DoZoomOut(void)$/;"	f
DoesMatch	HTKTools/HParse.c	/^static int DoesMatch(LabId s, LabId snet)$/;"	f	file:
DoingFourthAcc	HTKLib/HFBLat.c	/^static Boolean DoingFourthAcc=FALSE;    \/* Indicate currently it is doing MPE with MMI prior *\/$/;"	v	file:
DontBhiksha	HTKLVRec/kenlm/lm/bhiksha.cc	/^DontBhiksha::DontBhiksha(const void * \/*base*\/, uint64_t \/*max_offset*\/, uint64_t max_next, const Config &\/*config*\/) : $/;"	f	class:lm::ngram::trie::DontBhiksha
DontBhiksha	HTKLVRec/kenlm/lm/bhiksha.hh	/^class DontBhiksha {$/;"	c	namespace:lm::ngram::trie
DontQuantize	HTKLVRec/kenlm/lm/quantize.hh	/^    DontQuantize() {}$/;"	f	class:lm::ngram::DontQuantize
DontQuantize	HTKLVRec/kenlm/lm/quantize.hh	/^class DontQuantize {$/;"	c	namespace:lm::ngram
Double	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  Double() : d64_(0) {}$/;"	f	class:double_conversion::Double
Double	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  explicit Double(DiyFp diy_fp)$/;"	f	class:double_conversion::Double
Double	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  explicit Double(double d) : d64_(double_to_uint64(d)) {}$/;"	f	class:double_conversion::Double
Double	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  explicit Double(uint64_t d64) : d64_(d64) {}$/;"	f	class:double_conversion::Double
Double	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^class Double {$/;"	c	namespace:double_conversion
Double	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    void Double(void *new_base, bool clear_new = true) {$/;"	f	class:util::ProbingHashTable
DoubleChunk	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  typedef uint64_t DoubleChunk;$/;"	t	class:double_conversion::Bignum
DoubleComplex	HTKLib/esignal.h	/^typedef struct {double	real, imag;}	DoubleComplex;$/;"	t	typeref:struct:__anon182
DoubleIfNeeded	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    void DoubleIfNeeded() {$/;"	f	class:util::AutoProbing
DoubleSec	HTKLVRec/kenlm/util/usage.cc	/^double DoubleSec(const struct timespec &tv) {$/;"	f	namespace:util::__anon83
DoubleSec	HTKLVRec/kenlm/util/usage.cc	/^double DoubleSec(const struct timeval &tv) {$/;"	f	namespace:util::__anon83
DoubleSec	HTKLVRec/kenlm/util/usage.cc	/^double DoubleSec(time_t tv) {$/;"	f	namespace:util::__anon83
DoubleStrtod	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static bool DoubleStrtod(Vector<const char> trimmed,$/;"	f	namespace:double_conversion
DoubleTo	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    std::size_t DoubleTo() const {$/;"	f	class:util::ProbingHashTable
DoubleToAscii	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^void DoubleToStringConverter::DoubleToAscii(double v,$/;"	f	class:double_conversion::DoubleToStringConverter
DoubleToStringConverter	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  DoubleToStringConverter(int flags,$/;"	f	class:double_conversion::DoubleToStringConverter
DoubleToStringConverter	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^class DoubleToStringConverter {$/;"	c	namespace:double_conversion
DownMix	HTKTools/HHEd.c	/^void DownMix(char *hname, StreamElem *ste, int maxMix, Boolean inPlace)$/;"	f
DownMixSingle	HTKTools/HHEd.c	/^void DownMixSingle(StreamElem *ste,Boolean inPlace)$/;"	f
DownTree	HTKTools/HHEd.c	/^void DownTree(Node *node,Node **array) $/;"	f
Drag	HTKTools/HSLab.c	/^void Drag(void)$/;"	f
DrawRectWin	HTKTools/HSLab.c	/^void DrawRectWin(RectWin *win)$/;"	f
DtoaMode	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  enum DtoaMode {$/;"	g	class:double_conversion::DoubleToStringConverter
DtoaToBignumDtoaMode	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^static BignumDtoaMode DtoaToBignumDtoaMode($/;"	f	namespace:double_conversion
DumpAccs	HTKLib/HTrain.c	/^FILE * DumpAccs(HMMSet *hset, char *fname, UPDSet uFlags, int n){ return DumpAccsParallel(hset,fname,n,uFlags,0); }$/;"	f
DumpAccsParallel	HTKLib/HTrain.c	/^FILE * DumpAccsParallel(HMMSet *hset, char *fname, int n, UPDSet uFlags, int index)$/;"	f
DumpClusterMap	HTKLib/HTrain.c	/^static void DumpClusterMap(void)$/;"	f	file:
DumpGrid	HTKTools/HResults.c	/^void DumpGrid(void)$/;"	f
DumpMarker	HTKLib/HTrain.c	/^static void DumpMarker(FILE *f)$/;"	f	file:
DumpMuAcc	HTKLib/HTrain.c	/^static void DumpMuAcc(FILE *f, MuAcc *ma)$/;"	f	file:
DumpPName	HTKLib/HTrain.c	/^static void DumpPName(FILE *f, char *pname)$/;"	f	file:
DumpPhoneTable	HLMTools/HLMCopy.c	/^static void DumpPhoneTable(Vocab *src, Vocab *tgt) {$/;"	f	file:
DumpSeparateFiles	HTKLVRec/kenlm/lm/builder/print.hh	/^    static void DumpSeparateFiles(const VocabReconstitute &vocab, const std::string &file_base, util::stream::Chains &chains) {$/;"	f	class:lm::builder::Print
DumpStream	HTKLVRec/kenlm/lm/builder/print.hh	/^    void DumpStream(NGramStream &stream, util::FakeOFStream &to) {$/;"	f	class:lm::builder::Print
DumpTrAcc	HTKLib/HTrain.c	/^static void DumpTrAcc(FILE *f, TrAcc *ta)$/;"	f	file:
DumpVaAcc	HTKLib/HTrain.c	/^static void DumpVaAcc(FILE *f, VaAcc *va, CovKind ck)$/;"	f	file:
DumpWtAcc	HTKLib/HTrain.c	/^static void DumpWtAcc(FILE *f, WtAcc *wa)$/;"	f	file:
DupHMM	HTKTools/HHEd.c	/^HMMDef *DupHMM(HMMDef *src)$/;"	f
DupMacro	HTKTools/HHEd.c	/^void DupMacro(MLink ml,LabId labid)$/;"	f
DupMixPDF	HTKTools/HHEd.c	/^MixPDF *DupMixPDF(MixPDF *s, Boolean frc)$/;"	f
DupOrThrow	HTKLVRec/kenlm/util/file.cc	/^int DupOrThrow(int fd) {$/;"	f	namespace:util
DupSMatrix	HTKTools/HHEd.c	/^SMatrix DupSMatrix(SMatrix m)$/;"	f
DupSTriMat	HTKTools/HHEd.c	/^STriMat DupSTriMat(STriMat m)$/;"	f
DupSVector	HTKTools/HHEd.c	/^SVector DupSVector(SVector v)$/;"	f
DupState	HTKTools/HHEd.c	/^StateInfo *DupState(StateInfo *si, Boolean frc)$/;"	f
DupStream	HTKTools/HHEd.c	/^MixtureElem *DupStream(StreamElem *ste)$/;"	f
DuplicateCommand	HTKTools/HHEd.c	/^void DuplicateCommand(void)$/;"	f
DuplicatePron	HTKTools/HDMan.c	/^void DuplicatePron(WordBuf *wb, int i)$/;"	f
DurKind	HTKLib/HModel.h	/^typedef enum _DurKind DurKind;$/;"	t	typeref:enum:_DurKind
DurKind2Str	HTKLib/HModel.c	/^char *DurKind2Str(DurKind dkind, char *buf)$/;"	f
Durbin	HTKLib/HSigP.c	/^static float Durbin(Vector k, Vector thisA, Vector r, float E, int order)$/;"	f	file:
E	HTKTools/HMMIRest.c	/^static float E = 2.0;               \/* constant used in BW updatel *\/$/;"	v	file:
EArcId	HTKLib/HNet.h	/^typedef struct larc_e *EArcId;$/;"	t	typeref:struct:larc_e
EDOP_DELETE	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon200	file:
EDR1	HTKLib/esignal.h	103;"	d
EDR2	HTKLib/esignal.h	104;"	d
EMINARG	HLMLib/LModel.h	63;"	d
EMIT_POSITIVE_EXPONENT_SIGN	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    EMIT_POSITIVE_EXPONENT_SIGN = 1,$/;"	e	enum:double_conversion::DoubleToStringConverter::Flags
EMIT_TRAILING_DECIMAL_POINT	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    EMIT_TRAILING_DECIMAL_POINT = 2,$/;"	e	enum:double_conversion::DoubleToStringConverter::Flags
EMIT_TRAILING_ZERO_AFTER_POINT	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    EMIT_TRAILING_ZERO_AFTER_POINT = 4,$/;"	e	enum:double_conversion::DoubleToStringConverter::Flags
ENDHMM	HTKLib/HModel.c	/^   BEGINHMM, USEMAC, ENDHMM, NUMMIXES, $/;"	e	enum:__anon117	file:
ENORMALISE	HTKLib/HParm.c	/^   ENORMALISE,    \/* Normalise log energy *\/$/;"	e	enum:__anon142	file:
ENTERKEY	HTKLib/HGraf.h	/^               ENTERKEY, DELKEY, ESCKEY};$/;"	e	enum:_KeyType
EOF	HTKLVRec/kenlm/util/getopt.c	16;"	d	file:
EOFSYM	HTKLib/HModel.c	/^   MACRO, EOFSYM, NULLSYM   \/* Special Syms - not literals *\/$/;"	e	enum:__anon117	file:
EOFSYM	HTKTools/HParse.c	/^             EOFSYM};$/;"	e	enum:_Symbol	file:
EQSYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
ERR	HTKLVRec/kenlm/util/getopt.c	17;"	d	file:
ESCALE	HTKLib/HParm.c	/^   ESCALE,        \/* Log energy scale factor *\/$/;"	e	enum:__anon142	file:
ESCAPE	HTKTools/HParse.c	1297;"	d	file:
ESCAPE_CHAR	HTKLib/HShell.h	82;"	d
ESCKEY	HTKLib/HGraf.h	/^               ENTERKEY, DELKEY, ESCKEY};$/;"	e	enum:_KeyType
ESIG	HTKLib/HWave.h	/^	ESIG,              \/* used for both wave and parm files *\/$/;"	e	enum:__anon181
ESIGFieldList	HTKLib/HWave.c	/^static FieldList  ESIGFieldList;  $/;"	v	file:
ESPS	HTKLib/HWave.h	/^        ESPS,              \/* used for both wave and parm files *\/$/;"	e	enum:__anon181
ESPS Label Files	HTKBook/labels.tex	/^\\subsection{ESPS Label Files}$/;"	b
EXACTCORR_PRUNE	HTKLib/HExactMPE.c	/^static float EXACTCORR_PRUNE= -8.5 \/*0.0002*\/; $/;"	v	file:
EXITSTATUS	HTKTools/HMMIRest.c	31;"	d	file:
EXP10MINARG	HLMLib/LModel.h	51;"	d
EXPAND	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon200	file:
EXPENSIVE	HTKLVRec/kenlm/lm/config.hh	/^  enum ARPALoadComplain {ALL, EXPENSIVE, NONE};$/;"	e	enum:lm::ngram::Config::ARPALoadComplain
EcmaScriptConverter	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^const DoubleToStringConverter& DoubleToStringConverter::EcmaScriptConverter() {$/;"	f	class:double_conversion::DoubleToStringConverter
EdError	HTKLib/HUtil.c	/^static void EdError(char *s)$/;"	f	file:
EdOp	HTKTools/HDMan.c	/^              NOCMD} EdOp;$/;"	t	typeref:enum:__anon191	file:
EdOp	HTKTools/HLEd.c	/^} EdOp;$/;"	t	typeref:enum:__anon200	file:
EditAndMerge	HTKTools/HDMan.c	/^void EditAndMerge(void)$/;"	f
EditCmd	HTKTools/HDMan.c	/^}EditCmd;$/;"	t	typeref:struct:__anon192	file:
EditCmd	HTKTools/HLEd.c	/^}EditCmd;$/;"	t	typeref:struct:__anon201	file:
EditFile	HTKTools/HLEd.c	/^void EditFile(char *labfn)$/;"	f
EditTransMat	HTKTools/HHEd.c	/^void EditTransMat(Boolean adding)$/;"	f
EditWordBuf	HTKTools/HDMan.c	/^void EditWordBuf(DBuffer *db)$/;"	f
EdrRead	HTKLib/esig_edr.c	/^EdrRead(void    *data,$/;"	f	file:
EdrReadArray	HTKLib/esig_edr.c	/^EdrReadArray(Array      *data,$/;"	f	file:
EdrReadBool	HTKLib/esig_edr.c	/^EdrReadBool(Bool    *data,$/;"	f	file:
EdrReadChar	HTKLib/esig_edr.c	/^EdrReadChar(char *data,$/;"	f	file:
EdrReadDouble	HTKLib/esig_edr.c	/^EdrReadDouble(double    *data,$/;"	f	file:
EdrReadDoubleComplex	HTKLib/esig_edr.c	/^EdrReadDoubleComplex(DoubleComplex  *data,$/;"	f	file:
EdrReadFloat	HTKLib/esig_edr.c	/^EdrReadFloat(float  *data,$/;"	f	file:
EdrReadFloatComplex	HTKLib/esig_edr.c	/^EdrReadFloatComplex(FloatComplex    *data,$/;"	f	file:
EdrReadLong	HTKLib/esig_edr.c	/^EdrReadLong(long    *data,$/;"	f	file:
EdrReadLongComplex	HTKLib/esig_edr.c	/^EdrReadLongComplex(LongComplex  *data,$/;"	f	file:
EdrReadSchar	HTKLib/esig_edr.c	/^EdrReadSchar(Schar  *data,$/;"	f	file:
EdrReadScharComplex	HTKLib/esig_edr.c	/^EdrReadScharComplex(ScharComplex    *data,$/;"	f	file:
EdrReadShort	HTKLib/esig_edr.c	/^EdrReadShort(short  *data,$/;"	f	file:
EdrReadShortComplex	HTKLib/esig_edr.c	/^EdrReadShortComplex(ShortComplex    *data,$/;"	f	file:
EdrReadUchar	HTKLib/esig_edr.c	/^EdrReadUchar(Uchar  *data,$/;"	f	file:
EdrReadUlong	HTKLib/esig_edr.c	/^EdrReadUlong(Ulong *data,$/;"	f	file:
EdrReadUshort	HTKLib/esig_edr.c	/^EdrReadUshort(Ushort *data,$/;"	f	file:
EdrReadWchar	HTKLib/esig_edr.c	/^EdrReadWchar(Wchar      *data,$/;"	f	file:
EdrRecordSize	HTKLib/esig_edr.c	/^EdrRecordSize(FieldList list,$/;"	f
EdrTypeSize	HTKLib/esig_edr.c	/^EdrTypeSize(int type,           \/* numeric data-type code *\/$/;"	f
EdrWrite	HTKLib/esig_edr.c	/^EdrWrite(void   *data,$/;"	f	file:
EdrWriteArray	HTKLib/esig_edr.c	/^EdrWriteArray(Array     *data,$/;"	f	file:
EdrWriteBool	HTKLib/esig_edr.c	/^EdrWriteBool(Bool   *data,$/;"	f	file:
EdrWriteChar	HTKLib/esig_edr.c	/^EdrWriteChar(char *data,$/;"	f	file:
EdrWriteDouble	HTKLib/esig_edr.c	/^EdrWriteDouble(double   *data,$/;"	f	file:
EdrWriteDoubleComplex	HTKLib/esig_edr.c	/^EdrWriteDoubleComplex(DoubleComplex *data,$/;"	f	file:
EdrWriteFloat	HTKLib/esig_edr.c	/^EdrWriteFloat(float     *data,$/;"	f	file:
EdrWriteFloatComplex	HTKLib/esig_edr.c	/^EdrWriteFloatComplex(FloatComplex   *data,$/;"	f	file:
EdrWriteLong	HTKLib/esig_edr.c	/^EdrWriteLong(long       *data,$/;"	f	file:
EdrWriteLongComplex	HTKLib/esig_edr.c	/^EdrWriteLongComplex(LongComplex *data,$/;"	f	file:
EdrWriteSchar	HTKLib/esig_edr.c	/^EdrWriteSchar(Schar     *data,$/;"	f	file:
EdrWriteScharComplex	HTKLib/esig_edr.c	/^EdrWriteScharComplex(ScharComplex   *data,$/;"	f	file:
EdrWriteShort	HTKLib/esig_edr.c	/^EdrWriteShort(short     *data,$/;"	f	file:
EdrWriteShortComplex	HTKLib/esig_edr.c	/^EdrWriteShortComplex(ShortComplex   *data,$/;"	f	file:
EdrWriteUchar	HTKLib/esig_edr.c	/^EdrWriteUchar(Uchar     *data,$/;"	f	file:
EdrWriteUlong	HTKLib/esig_edr.c	/^EdrWriteUlong(Ulong *data,$/;"	f	file:
EdrWriteUshort	HTKLib/esig_edr.c	/^EdrWriteUshort(Ushort *data,$/;"	f	file:
EdrWriteWchar	HTKLib/esig_edr.c	/^EdrWriteWchar(Wchar     *data,$/;"	f	file:
Embedded Model Reestimation htool HERest	HTKBook/train.tex	/^\\subsection{Embedded Model Reestimation (\\htool{HERest})}$/;"	b
Empty	HTKLVRec/kenlm/lm/filter/format.hh	/^    bool Empty() { return actual_ == 0; }$/;"	f	class:lm::InputBuffer
Empty	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    bool Empty() const {$/;"	f	class:lm::phrase::detail::Arc
Empty	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    bool Empty() const {$/;"	f	class:lm::phrase::detail::Vertex
Empty	HTKLVRec/kenlm/util/stream/sort.hh	/^    bool Empty() const {$/;"	f	class:util::stream::MergeQueue
EmptyBuffer	HTKLib/HParm.c	/^ParmBuf EmptyBuffer(MemHeap *x, int size, Observation o, BufferInfo info)$/;"	f
EmptyMixPDF	HTKLib/HModel.c	/^static MixPDF *EmptyMixPDF(HMMSet *hset, int vSize, int s)$/;"	f	file:
Encode	HTKLVRec/kenlm/lm/quantize.hh	/^        uint64_t Encode(float value, size_t reserved) const {$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
EncodeBackoff	HTKLVRec/kenlm/lm/quantize.hh	/^        uint64_t EncodeBackoff(float value) const {$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
EncodeProb	HTKLVRec/kenlm/lm/quantize.hh	/^        uint64_t EncodeProb(float value) const {$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
EndHMMScan	HTKLib/HUtil.c	/^void EndHMMScan(HMMScanState *hss)$/;"	f
EndLength	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^void ARPAOutput::EndLength(unsigned int length) {$/;"	f	class:lm::ARPAOutput
EndLength	HTKLVRec/kenlm/lm/filter/format.hh	/^    void EndLength(unsigned int length) {$/;"	f	class:lm::DispatchARPAInput
EndLength	HTKLVRec/kenlm/lm/filter/format.hh	/^    void EndLength(unsigned int length) {$/;"	f	class:lm::MultipleARPAOutput
EndOfFileException	HTKLVRec/kenlm/util/file.cc	/^EndOfFileException::EndOfFileException() throw() {$/;"	f	class:util::EndOfFileException
EndOfFileException	HTKLVRec/kenlm/util/file.hh	/^class EndOfFileException : public Exception {$/;"	c	namespace:util
EndOfWord	HTKLib/HArc.h	216;"	d
EndOfWord	HTKLib/HExactMPE.c	94;"	d	file:
EndOfWord	HTKLib/HFBLat.c	134;"	d	file:
EndSentence	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    WordIndex EndSentence() const { return end_sentence_; }$/;"	f	class:lm::base::Vocabulary
EnsureCapacity	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  void EnsureCapacity(int size) {$/;"	f	class:double_conversion::Bignum
EnsureRemaining	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    void EnsureRemaining(std::size_t amount) {$/;"	f	class:util::FakeOFStream
Enter	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    void Enter(unsigned order_minus_1, NGram &gram) {$/;"	f	class:lm::builder::__anon46::Callback
Entry	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef EntryT Entry;$/;"	t	class:util::AutoProbing
Entry	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef EntryT Entry;$/;"	t	class:util::ProbingHashTable
Entry	HTKLVRec/kenlm/util/stream/sort.hh	/^        Entry() {}$/;"	f	class:util::stream::MergeQueue::Entry
Entry	HTKLVRec/kenlm/util/stream/sort.hh	/^        Entry(void *base, int fd, uint64_t offset, uint64_t amount, std::size_t buf_size) {$/;"	f	class:util::stream::MergeQueue::Entry
Entry	HTKLVRec/kenlm/util/stream/sort.hh	/^    class Entry {$/;"	c	class:util::stream::MergeQueue
Entry	HTKLVRec/kenlm/util/stream/sort.hh	/^    struct Entry {$/;"	s	class:util::stream::Offsets
EntryCompare	HTKLVRec/kenlm/lm/trie_sort.hh	/^    explicit EntryCompare(unsigned char order) : order_(order) {}$/;"	f	class:lm::ngram::trie::EntryCompare
EntryCompare	HTKLVRec/kenlm/lm/trie_sort.hh	/^class EntryCompare : public std::binary_function<const void*, const void*, bool> {$/;"	c	namespace:lm::ngram::trie
EntrySize	HTKLVRec/kenlm/lm/trie_sort.hh	/^    std::size_t EntrySize() const { return entry_size_; }$/;"	f	class:lm::ngram::trie::RecordReader
EntrySize	HTKLVRec/kenlm/util/sized_iterator.hh	/^    std::size_t EntrySize() const { return size_; }$/;"	f	class:util::SizedInnerIterator
EntrySize	HTKLVRec/kenlm/util/stream/chain.hh	/^    std::size_t EntrySize() const {$/;"	f	class:util::stream::Chain
EnumerateVocab	HTKLVRec/kenlm/lm/enumerate_vocab.hh	/^    EnumerateVocab() {}$/;"	f	class:lm::EnumerateVocab
EnumerateVocab	HTKLVRec/kenlm/lm/enumerate_vocab.hh	/^class EnumerateVocab {$/;"	c	namespace:lm
Equal	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static bool Equal(const Bignum& a, const Bignum& b) {$/;"	f	class:double_conversion::Bignum
Equal	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef EqualT Equal;$/;"	t	class:util::AutoProbing
Equal	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef EqualT Equal;$/;"	t	class:util::ProbingHashTable
EqualKind	HTKLib/HParm.c	/^static Boolean EqualKind(ParmKind a, ParmKind b)$/;"	f	file:
Equiv	HLMTools/LPlex.c	/^typedef struct _Equiv Equiv;          \/* list of equivalent labels *\/$/;"	t	typeref:struct:_Equiv	file:
Equiv	HTKTools/HResults.c	/^typedef struct _Equiv Equiv;          \/* list of equivalent labels *\/$/;"	t	typeref:struct:_Equiv	file:
EquivHMM	HTKTools/HHEd.c	/^Boolean EquivHMM(HMMDef *a, HMMDef *b)$/;"	f
EquivMix	HTKTools/HHEd.c	/^Boolean EquivMix(MixPDF *a, MixPDF *b)$/;"	f
EquivState	HTKTools/HHEd.c	/^Boolean EquivState(StateInfo *a, StateInfo *b, int S)$/;"	f
EquivStream	HTKTools/HHEd.c	/^Boolean EquivStream(StreamElem *a, StreamElem *b)$/;"	f
ErrnoException	HTKLVRec/kenlm/util/exception.cc	/^ErrnoException::ErrnoException() throw() : errno_(errno) {$/;"	f	class:util::ErrnoException
ErrnoException	HTKLVRec/kenlm/util/exception.hh	/^class ErrnoException : public Exception {$/;"	c	namespace:util
Error	HTKLVRec/kenlm/util/exception.hh	/^    int Error() const throw() { return errno_; }$/;"	f	class:util::ErrnoException
ErsatzPRead	HTKLVRec/kenlm/util/file.cc	/^void ErsatzPRead(int fd, void *to_void, std::size_t size, uint64_t off) {$/;"	f	namespace:util
ErsatzPWrite	HTKLVRec/kenlm/util/file.cc	/^void ErsatzPWrite(int fd, const void *from_void, std::size_t size, uint64_t off) {$/;"	f	namespace:util
ErsatzProgress	HTKLVRec/kenlm/util/ersatz_progress.cc	/^ErsatzProgress::ErsatzProgress() : current_(0), next_(std::numeric_limits<uint64_t>::max()), complete_(next_), out_(NULL) {}$/;"	f	class:util::ErsatzProgress
ErsatzProgress	HTKLVRec/kenlm/util/ersatz_progress.cc	/^ErsatzProgress::ErsatzProgress(uint64_t complete, std::ostream *to, const std::string &message) $/;"	f	class:util::ErsatzProgress
ErsatzProgress	HTKLVRec/kenlm/util/ersatz_progress.hh	/^class ErsatzProgress {$/;"	c	namespace:util
EstCMLLRXForm	HTKLib/HAdapt.c	/^static void EstCMLLRXForm(AccStruct *accs, LinXForm *xf)$/;"	f	file:
EstMLLRCovXForm	HTKLib/HAdapt.c	/^static void EstMLLRCovXForm(AccStruct *accs, LinXForm *xf)$/;"	f	file:
EstMLLRDiagCovXForm	HTKLib/HAdapt.c	/^static void EstMLLRDiagCovXForm(AccStruct *accs, LinXForm *xf, LinXForm *dxf)$/;"	f	file:
EstMLLRMeanXForm	HTKLib/HAdapt.c	/^static void EstMLLRMeanXForm(AccStruct *accs, LinXForm *xf)$/;"	f	file:
EstSemiTXForm	HTKLib/HAdapt.c	/^static void EstSemiTXForm(AdaptXForm *xform, AccStruct *accs, LinXForm *xf, IntVec classes)$/;"	f	file:
EstXForm	HTKLib/HAdapt.c	/^static void EstXForm(AccStruct *accs, AdaptXForm *xform, IntVec classes)$/;"	f	file:
EstimateModel	HTKTools/HInit.c	/^void EstimateModel(void)$/;"	f
EstimatePower	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^static int EstimatePower(int exponent) {$/;"	f	namespace:double_conversion
Evaluate	HTKLVRec/kenlm/lm/filter/phrase.cc	/^bool Union::Evaluate() {$/;"	f	class:lm::phrase::Union
Evaluate	HTKLVRec/kenlm/lm/filter/phrase.cc	/^template <class Output> void Multiple::Evaluate(const StringPiece &line, Output &output) {$/;"	f	class:lm::phrase::Multiple
ExactCorrectness	HTKLib/HFBLat.c	/^static Boolean ExactCorrectness=FALSE; \/*IMPORTANT*\/         \/* Do 'exact' version of MPE\/MWE, not using approximation.  This is slightly better for$/;"	v	file:
Exception	HTKLVRec/kenlm/util/exception.cc	/^Exception::Exception() throw() {}$/;"	f	class:util::Exception
Exception	HTKLVRec/kenlm/util/exception.cc	/^Exception::Exception(const Exception &from) : std::exception() {$/;"	f	class:util::Exception
Exception	HTKLVRec/kenlm/util/exception.hh	/^class Exception : public std::exception {$/;"	c	namespace:util
ExceptionTag	HTKLVRec/kenlm/util/exception.hh	/^    template <class T> struct ExceptionTag {$/;"	s	class:util::Exception
Exists	HLMTools/LAdapt.c	/^Boolean Exists(char *fn)$/;"	f
Exists	HLMTools/LBuild.c	/^Boolean Exists(char *fn)$/;"	f
Exists	HLMTools/LGPrep.c	/^Boolean Exists(char *fn)$/;"	f
Exit	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    void Exit(unsigned, const NGram &) const {}$/;"	f	class:lm::builder::__anon46::Callback
Exit	HTKLib/HShell.c	/^void Exit(int exitcode)$/;"	f
ExpandLattice	HTKLib/HNet.c	/^static void ExpandLattice(Lattice *newlat, int nNodes, int nArcs)$/;"	f	file:
ExpandMultiLevelLattice	HTKLib/HNet.c	/^Lattice *ExpandMultiLevelLattice(MemHeap *heap, Lattice *lat, Vocab *voc)$/;"	f
ExpandOp	HTKTools/HLEd.c	/^int ExpandOp(LabList *ll)$/;"	f
ExpandSubNetDefs	HTKTools/HParse.c	/^static void ExpandSubNetDefs(Link *chain)$/;"	f	file:
ExpandWordModel	HTKTools/HParse.c	/^void ExpandWordModel(Vocab *voc, Link p, Link history)$/;"	f
ExpandWordNet	HTKLib/HNet.c	/^Network *ExpandWordNet(MemHeap *heap,Lattice *lat,Vocab *voc,HMMSet *hset)$/;"	f
ExpandedLatticeSize	HTKLib/HNet.c	/^static void ExpandedLatticeSize(Lattice *lat, int *nNodes,int *nArcs)$/;"	f	file:
ExplainObservation	HTKLib/HParm.c	/^void ExplainObservation(Observation *o, int itemsPerLine)$/;"	f
Exponent	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  int Exponent() const {$/;"	f	class:double_conversion::Double
Exponent	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  int Exponent() const {$/;"	f	class:double_conversion::Single
ExportNMV	HTKTools/HCompV.c	/^void ExportNMV(SpkrAccListItem *sal, char *OutDirName, char *tgtPKStr) $/;"	f
ExtFile	HTKLib/HShell.c	/^}ExtFile;$/;"	t	typeref:struct:__anon150	file:
ExtendAux	HTKLib/HLabel.c	/^static void ExtendAux(MemHeap *x, LabList *ll, int n)$/;"	f	file:
ExtendLeft	HTKLVRec/kenlm/lm/left.hh	/^    bool ExtendLeft(const ChartState &in, unsigned char &next_use, unsigned char extend_length, const float *back_in, float *back_out) {$/;"	f	class:lm::ngram::RuleScore
ExtendLeft	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> FullScoreReturn GenericModel<Search, VocabularyT>::ExtendLeft($/;"	f	class:lm::ngram::detail::GenericModel
ExtendLoop	HTKLVRec/kenlm/lm/partial.hh	/^template <class Model> ExtendReturn ExtendLoop($/;"	f	namespace:lm::ngram
ExtendReturn	HTKLVRec/kenlm/lm/partial.hh	/^struct ExtendReturn {$/;"	s	namespace:lm::ngram
Extends	HTKLVRec/kenlm/lm/search_trie.cc	/^    bool Extends(unsigned char order, const WordIndex *words) {$/;"	f	class:lm::ngram::trie::__anon58::BackoffMessages
ExternTypeSize	HTKLib/esignal.c	/^ExternTypeSize(int type,$/;"	f
ExtnOf	HTKLib/HShell.c	/^char * ExtnOf(char *fn, char *s)$/;"	f
ExtractNonRolling	HTKLVRec/kenlm/util/mmap.cc	/^void *Rolling::ExtractNonRolling(scoped_memory &out, uint64_t index, std::size_t size) {$/;"	f	class:util::Rolling
ExtractObservation	HTKLib/HParm.c	/^static void ExtractObservation(float *fp, Observation *o)$/;"	f	file:
FA	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon199	file:
FAIL	HTKLib/HShell.h	/^typedef enum {FAIL=-1, SUCCESS=0} ReturnStatus;$/;"	e	enum:__anon151
FALSE	HTKLib/HShell.h	/^typedef enum {FALSE=0, TRUE=1} Boolean;$/;"	e	enum:__anon152
FALSE	HTKLib/HShell.h	89;"	d
FALSE	HTKLib/esignal.h	49;"	d
FALSE_dup	HTKLib/HParm.h	/^   FALSE_dup=FALSE, \/*  0 *\/$/;"	e	enum:__anon146
FAST_DTOA_PRECISION	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.h	/^  FAST_DTOA_PRECISION$/;"	e	enum:double_conversion::FastDtoaMode
FAST_DTOA_SHORTEST	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.h	/^  FAST_DTOA_SHORTEST,$/;"	e	enum:double_conversion::FastDtoaMode
FAST_DTOA_SHORTEST_SINGLE	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.h	/^  FAST_DTOA_SHORTEST_SINGLE,$/;"	e	enum:double_conversion::FastDtoaMode
FAVec	HTKTools/HResults.c	/^typedef int FAVec[10];$/;"	t	file:
FBANK	HTKLib/HParm.h	/^      FBANK,                           \/* Log Filter Bank *\/$/;"	e	enum:_BaseParmKind
FBFile	HTKLib/HFB.c	/^Boolean FBFile(FBInfo *fbInfo, UttInfo *utt, char * datafn)$/;"	f
FBInfo	HTKLib/HFB.h	/^} FBInfo;$/;"	t	typeref:struct:__anon99
FBLatAddLattice	HTKLib/HFBLat.c	/^void FBLatAddLattice (FBLatInfo *fbInfo, Lattice *lat){  \/* add this lattice, $/;"	f
FBLatClearUp	HTKLib/HFBLat.c	/^void FBLatClearUp(FBLatInfo *fbInfo){  $/;"	f
FBLatFirstPass	HTKLib/HFBLat.c	/^void FBLatFirstPass(FBLatInfo *_fbInfo, FileFormat dff, char * datafn, char *datafn2, Lattice *MPECorrLat){$/;"	f
FBLatInfo	HTKLib/HFBLat.h	/^} FBLatInfo;$/;"	t	typeref:struct:__anon102
FBLatSecondPass	HTKLib/HFBLat.c	/^void FBLatSecondPass(FBLatInfo *_fbInfo, int num_index, int den_index){$/;"	f
FBLatSetAccScale	HTKLib/HFBLat.c	/^void FBLatSetAccScale(FBLatInfo *fbInfo, float AccScale){ \/*scale accumulators by this amount. *\/$/;"	f
FBank2ASpec	HTKLib/HSigP.c	/^void FBank2ASpec (Vector fbank, Vector as, Vector eql, float compressFact, $/;"	f
FBank2C0	HTKLib/HSigP.c	/^float FBank2C0(Vector fbank)$/;"	f
FBank2MFCC	HTKLib/HSigP.c	/^void FBank2MFCC(Vector fbank, Vector c, int n)$/;"	f
FBank2MelSpec	HTKLib/HSigP.c	/^void FBank2MelSpec(Vector fbank)$/;"	f
FBankInfo	HTKLib/HSigP.h	/^}FBankInfo;$/;"	t	typeref:struct:__anon159
FBinfo	HTKLib/HLat.h	/^} FBinfo;$/;"	t	typeref:struct:FBlnodeInfo
FBlnodeInfo	HTKLib/HLat.h	/^typedef struct FBlnodeInfo {$/;"	s
FC	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon199	file:
FClose	HTKLib/HShell.c	/^void FClose(FILE *f, Boolean isPipe)$/;"	f
FD	HTKLVRec/kenlm/util/file.hh	/^    int FD() const { return fd_; }$/;"	f	class:util::FDException
FDException	HTKLVRec/kenlm/util/file.cc	/^FDException::FDException(int fd) throw() : fd_(fd), name_guess_(NameFromFD(fd)) {$/;"	f	class:util::FDException
FDException	HTKLVRec/kenlm/util/file.hh	/^class FDException : public ErrnoException {$/;"	c	namespace:util
FDOpenOrThrow	HTKLVRec/kenlm/util/file.cc	/^std::FILE *FDOpenOrThrow(scoped_fd &file) {$/;"	f	namespace:util
FDOpenReadOrThrow	HTKLVRec/kenlm/util/file.cc	/^std::FILE *FDOpenReadOrThrow(scoped_fd &file) {$/;"	f	namespace:util
FFT	HTKLib/HSigP.c	/^void FFT(Vector s, int invert)$/;"	f
FFTbased	HTKLib/HParm.c	/^typedef enum { FFTbased, LPCbased, VQbased} CodeStyle;$/;"	e	enum:__anon140	file:
FIELD_ORDER	HTKLib/esignal.h	98;"	d
FIND	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon200	file:
FINITE	HTKTools/HMMIRest.c	64;"	d	file:
FIXED	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    FIXED,$/;"	e	enum:double_conversion::DoubleToStringConverter::DtoaMode
FIXLABSTR	HTKTools/HSLab.c	1338;"	d	file:
FItem	HLMTools/LGList.c	/^} FItem;$/;"	t	typeref:struct:fitem	file:
FLEntry	HLMLib/LModel.h	/^} FLEntry;$/;"	t	typeref:struct:_FLEntry
FLOAT	HTKLib/esignal.h	67;"	d
FLOATARG	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	e	enum:__anon158
FLOAT_COMPLEX	HTKLib/esignal.h	76;"	d
FLOAT_MAX	HTKTools/HHEd.c	59;"	d	file:
FLOAT_TO_NGLM_PROB	HTKLVRec/HLVLM.h	124;"	d
FLOAT_TO_NGLM_PROB	HTKLVRec/HLVLM.h	132;"	d
FLTCX_FMT	HTKLib/esig_asc.c	79;"	d	file:
FLTCX_W	HTKLib/esig_asc.c	78;"	d	file:
FLTCX_WFMT	HTKLib/esig_asc.c	80;"	d	file:
FLT_FIELD	HTKLib/HNet.c	/^typedef enum {UNK_FIELD, STR_FIELD, INT_FIELD, FLT_FIELD} LatFieldType;$/;"	e	enum:__anon136	file:
FLT_FMT	HTKLib/esig_asc.c	47;"	d	file:
FLT_TO_LOG10	HLMLib/LModel.h	57;"	d
FLT_W	HTKLib/esig_asc.c	46;"	d	file:
FLT_WFMT	HTKLib/esig_asc.c	48;"	d	file:
FMakeTemp	HTKLVRec/kenlm/util/file.cc	/^std::FILE *FMakeTemp(const StringPiece &base) {$/;"	f	namespace:util
FONT1	HTKLib/HGraf.c	153;"	d	file:
FONT2	HTKLib/HGraf.c	154;"	d	file:
FONT3	HTKLib/HGraf.c	155;"	d	file:
FONTNAME	HTKLib/HGraf_WIN32.c	/^static char *FONTNAME = "Helvetica";$/;"	v	file:
FONTS_AVAILABLE	HTKLib/HGraf.c	135;"	d	file:
FOURTHWINDOW	HTKLib/HParm.c	/^   FOURTHWINDOW,$/;"	e	enum:__anon142	file:
FOpen	HTKLib/HShell.c	/^FILE *FOpen(char *fname, IOFilter filter, Boolean *isPipe)$/;"	f
FOutP	HTKLib/HModel.c	/^static LogFloat FOutP(Vector x, int vecSize, MixPDF *mp)$/;"	f	file:
FRAMEDUR	HTKLib/HArc.c	/^static float FRAMEDUR = 0; $/;"	v	file:
FRead	HLMLib/LModel.c	/^static size_t FRead(void *ptr, size_t size, size_t nitems, Source *src)$/;"	f	file:
FSLM	HTKLVRec/HLVLM.h	/^typedef struct _FSLM FSLM;$/;"	t	typeref:struct:_FSLM
FSLMType	HTKLVRec/HLVLM.h	/^typedef enum {fslm_ngram, fslm_latlm, kenlm} FSLMType;$/;"	t	typeref:enum:__anon35
FSLM_LatArc	HTKLVRec/HLVLM.h	/^} FSLM_LatArc;$/;"	t	typeref:struct:_FSLM_LatArc
FSLM_LatNode	HTKLVRec/HLVLM.h	/^typedef struct _FSLM_LatNode  FSLM_LatNode;$/;"	t	typeref:struct:_FSLM_LatNode
FSLM_latlm	HTKLVRec/HLVLM.h	/^typedef struct _FSLM_latlm FSLM_latlm;$/;"	t	typeref:struct:_FSLM_latlm
FSLM_ngram	HTKLVRec/HLVLM.h	/^typedef struct _FSLM_ngram FSLM_ngram;$/;"	t	typeref:struct:_FSLM_ngram
FSyncOrThrow	HTKLVRec/kenlm/util/file.cc	/^void FSyncOrThrow(int fd) {$/;"	f	namespace:util
FULLC	HTKLib/HMath.h	/^   FULLC,         \/* inverse full rank covariance *\/$/;"	e	enum:__anon113
FULLCOV	HTKLib/HModel.c	/^   DIAGCOV,  FULLCOV, XFORMCOV,$/;"	e	enum:__anon117	file:
FUNCW	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon191	file:
FV	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon199	file:
FVTransModels	HTKLVRec/HDecode.c	/^void FVTransModels (HMMSet *hset, BlockMatrix transMat)$/;"	f
FVTransModels	HTKLVRec/HDecode.mod.c	/^void FVTransModels (HMMSet *hset, BlockMatrix transMat)$/;"	f
FVec2Spectrum	HTKLib/HSigP.c	/^void FVec2Spectrum (float fzero, Vector f, Vector s)$/;"	f
FWORD	HTKLib/HMem.c	41;"	d	file:
FZERO	HTKLib/HMath.c	683;"	d	file:
FZeroMean	HTKLib/HSigP.c	/^void FZeroMean(float *data, int vSize, int n, int step)$/;"	f
FakeOFStream	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    explicit FakeOFStream(int out = -1, std::size_t buffer_size = 1048576)$/;"	f	class:util::FakeOFStream
FakeOFStream	HTKLVRec/kenlm/util/fake_ofstream.hh	/^class FakeOFStream {$/;"	c	namespace:util
FakeSEModelAlign	HTKLVRec/HLVRec-traceback.c	/^void FakeSEModelAlign(Lattice *lat, LArc *la)$/;"	f
FakeSEpath	HTKLVRec/HLVRec-traceback.c	/^AltWordendHyp *FakeSEpath (DecoderInst *dec, RelToken *tok, Boolean useLM)$/;"	f
FastDtoa	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^bool FastDtoa(double v,$/;"	f	namespace:double_conversion
FastDtoaMode	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.h	/^enum FastDtoaMode {$/;"	g	namespace:double_conversion
FastFixedDtoa	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^bool FastFixedDtoa(double v,$/;"	f	namespace:double_conversion
FastMakeNode	HTKLVRec/kenlm/lm/search_hashed.hh	/^    bool FastMakeNode(const WordIndex *begin, const WordIndex *end, Node &node) const {$/;"	f	class:lm::ngram::detail::HashedSearch
FastMakeNode	HTKLVRec/kenlm/lm/search_trie.hh	/^    bool FastMakeNode(const WordIndex *begin, const WordIndex *end, Node &node) const {$/;"	f	class:lm::ngram::trie::TrieSearch
Fast_LMLA_LMState	HTKLVRec/HLVLM.c	/^LMState Fast_LMLA_LMState (FSLM *lm, LMState src)$/;"	f
Fast_LMLA_LMState_kenlm	HTKLVRec/HLVLM.c	/^LMState Fast_LMLA_LMState_kenlm (FSLM *lm, lm::ngram::State src)$/;"	f
FieldArrayLength	HTKLib/esignal.c	/^FieldArrayLength(FieldSpec **fields)$/;"	f	file:
FieldItem	HLMTools/LGPrep.c	/^} FieldItem;$/;"	t	typeref:union:__anon28	file:
FieldLength	HTKLib/esignal.c	/^FieldLength(FieldSpec *field)$/;"	f
FieldList	HTKLib/esignal.h	/^typedef FieldSpec	    **FieldList;$/;"	t
FieldListLength	HTKLib/esignal.c	/^FieldListLength(FieldList list)$/;"	f
FieldOp	HLMTools/LGPrep.c	/^} FieldOp;$/;"	t	typeref:enum:__anon27	file:
FieldOrder	HTKLib/esignal.c	/^FieldOrder(FieldList list)$/;"	f
FieldSpec	HTKLib/esignal.h	/^struct FieldSpec {$/;"	s
FieldSpec	HTKLib/esignal.h	/^typedef struct FieldSpec    FieldSpec;$/;"	t	typeref:struct:FieldSpec
FieldVec	HLMTools/LGPrep.c	/^} FieldVec;$/;"	t	typeref:struct:__anon30	file:
File	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^    const std::string &File() const throw() { return file_name_; }$/;"	f	class:lm::ARPAOutputException
File	HTKLVRec/kenlm/util/stream/sort.hh	/^    int File() const { return log_; }$/;"	f	class:util::stream::Offsets
FileBuffer	HTKLVRec/kenlm/util/stream/io.hh	/^    explicit FileBuffer(int fd) : file_(fd) {}$/;"	f	class:util::stream::FileBuffer
FileBuffer	HTKLVRec/kenlm/util/stream/io.hh	/^class FileBuffer {$/;"	c	namespace:util::stream
FileBytes	HTKLib/HWave.c	/^static long FileBytes(FILE *f, Wave w)$/;"	f	file:
FileExists	HTKTools/HSLab.c	/^Boolean FileExists(char *fn, char *fmode)$/;"	f
FileFormat	HTKLib/HWave.h	/^} FileFormat;$/;"	t	typeref:enum:__anon181
FileName	HTKLVRec/kenlm/util/file_piece.hh	/^    const std::string &FileName() const { return file_name_; }$/;"	f	class:util::FilePiece
FileOpenException	HTKLVRec/kenlm/util/exception.hh	/^	FileOpenException() throw() {}$/;"	f	class:util::FileOpenException
FileOpenException	HTKLVRec/kenlm/util/exception.hh	/^class FileOpenException : public Exception {$/;"	c	namespace:util
FilePiece	HTKLVRec/kenlm/util/file_piece.cc	/^FilePiece::FilePiece(const char *name, std::ostream *show_progress, std::size_t min_buffer) : $/;"	f	class:util::FilePiece
FilePiece	HTKLVRec/kenlm/util/file_piece.cc	/^FilePiece::FilePiece(int fd, const char *name, std::ostream *show_progress, std::size_t min_buffer) : $/;"	f	class:util::FilePiece
FilePiece	HTKLVRec/kenlm/util/file_piece.cc	/^FilePiece::FilePiece(std::istream &stream, const char *name, std::size_t min_buffer) :$/;"	f	class:util::FilePiece
FilePiece	HTKLVRec/kenlm/util/file_piece.hh	/^class FilePiece {$/;"	c	namespace:util
Fill	HTKLVRec/kenlm/lm/filter/thread.hh	/^    InputBuffer &Fill(uint64_t sequence) {$/;"	f	class:lm::ThreadBatch
FillBufFromChannel	HTKLib/HParm.c	/^static void FillBufFromChannel(ParmBuf pbuf,int minRows)$/;"	f	file:
FillBufferFromAudio	HTKLib/HAudio.c	/^static void FillBufferFromAudio(AudioIn a,int min)$/;"	f	file:
FillDigits32	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^static void FillDigits32(uint32_t number, Vector<char> buffer, int* length) {$/;"	f	namespace:double_conversion
FillDigits32FixedLength	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^static void FillDigits32FixedLength(uint32_t number, int requested_length,$/;"	f	namespace:double_conversion
FillDigits64	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^static void FillDigits64(uint64_t number, Vector<char> buffer, int* length) {$/;"	f	namespace:double_conversion
FillDigits64FixedLength	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^static void FillDigits64FixedLength(uint64_t number, int requested_length,$/;"	f	namespace:double_conversion
FillFractionals	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^static void FillFractionals(uint64_t fractionals, int exponent,$/;"	f	namespace:double_conversion
FillInputs	HTKTools/HDMan.c	/^Boolean FillInputs(Boolean *valid)$/;"	f
FillPredJM	HTKTools/HParse.c	/^static void FillPredJM(int numElements, SplitName *trilist)$/;"	f	file:
FillSuccJM	HTKTools/HParse.c	/^static void FillSuccJM(int numElements, SplitName *trilist)$/;"	f	file:
Filter	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^    typedef FilterT Filter;$/;"	t	class:lm::ContextFilter
FilterLevel	HTKLib/HLabel.c	/^static void FilterLevel(Transcription *t, int lev)$/;"	f	file:
FilterNGram	HLMLib/LPCalc.c	/^Boolean FilterNGram(NGInputSet *inSet, UInt *gram, float *count, int nSize)$/;"	f
FilterSet	HTKLib/HShell.c	/^static Boolean FilterSet(IOFilter filter, char *s)$/;"	f	file:
FilterWorker	HTKLVRec/kenlm/lm/filter/thread.hh	/^    FilterWorker(const Filter &filter, util::PCQueue<Request> &done) : filter_(filter), done_(done) {}$/;"	f	class:lm::FilterWorker
FilterWorker	HTKLVRec/kenlm/lm/filter/thread.hh	/^template <class Batch, class Filter> class FilterWorker {$/;"	c	namespace:lm
Finalize	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  char* Finalize() {$/;"	f	class:double_conversion::StringBuilder
Find	HTKLVRec/kenlm/lm/trie.cc	/^template <class Bhiksha> util::BitAddress BitPackedMiddle<Bhiksha>::Find(WordIndex word, NodeRange &range, uint64_t &pointer) const {$/;"	f	class:lm::ngram::trie::BitPackedMiddle
Find	HTKLVRec/kenlm/lm/trie.cc	/^util::BitAddress BitPackedLongest::Find(WordIndex word, const NodeRange &range) const {$/;"	f	class:lm::ngram::trie::BitPackedLongest
Find	HTKLVRec/kenlm/lm/trie.hh	/^    UnigramPointer Find(WordIndex word, NodeRange &next) const {$/;"	f	class:lm::ngram::trie::Unigram
Find	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class Key> bool Find(const Key key, ConstIterator &out) const {$/;"	f	class:util::AutoProbing
Find	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class Key> bool Find(const Key key, ConstIterator &out) const {$/;"	f	class:util::ProbingHashTable
Find	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    StringPiece Find(const StringPiece &in) const {$/;"	f	class:util::AnyCharacter
Find	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    StringPiece Find(const StringPiece &in) const {$/;"	f	class:util::AnyCharacterLast
Find	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    StringPiece Find(const StringPiece &in) const {$/;"	f	class:util::BoolCharacter
Find	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    StringPiece Find(const StringPiece &in) const {$/;"	f	class:util::MultiCharacter
Find	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    StringPiece Find(const StringPiece &in) const {$/;"	f	class:util::SingleCharacter
FindAcc	HTKTools/HLEd.c	/^} FindAcc;$/;"	t	typeref:struct:_FindAcc	file:
FindAddSubLNode	HTKLib/HLat.c	/^static SubLNode *FindAddSubLNode (MemHeap *heap, LNode *ln, LMState lmstate, int *nsln)$/;"	f	file:
FindAddTLCN	HTKLVRec/HLVNet.c	/^TLexConNode *FindAddTLCN (MemHeap *heap, TLexNet *net, int layerId, int *n, TLexConNode *lcnHashTab[], LabId lc, LabId rc)$/;"	f
FindAddTLexNode	HTKLVRec/HLVNet.c	/^TLexNode *FindAddTLexNode (MemHeap *heap, TLexNet *net, int layerId, int *n, TLexNode *lnHashTab[], LexNodeType type , HLink hmm)$/;"	f
FindBaseModel	HTKTools/HHEd.c	/^HLink FindBaseModel(HMMSet *hset,LabId id,baseType type)$/;"	f
FindBestMixes	HTKTools/HInit.c	/^void FindBestMixes(int segNum, int segLen, IntVec states, IntVec *mixes)$/;"	f
FindBestSplit	HTKTools/HHEd.c	/^Node *FindBestSplit(Node *first, float threshold)$/;"	f
FindBestTerminal	HTKTools/HHEd.c	/^RegNode *FindBestTerminal(RegNode *t, float *score, int vSize, RegNode *best) $/;"	f
FindBitPacked	HTKLVRec/kenlm/lm/trie.cc	/^bool FindBitPacked(const void *base, uint64_t key_mask, uint8_t key_bits, uint8_t total_bits, uint64_t begin_index, uint64_t end_index, const uint64_t max_vocab, const uint64_t key, uint64_t &at_index) {$/;"	f	namespace:lm::ngram::trie::__anon59
FindBlanks	HTKLVRec/kenlm/lm/search_trie.cc	/^    FindBlanks(unsigned char order, const ProbBackoff *unigrams, SRISucks &messages)$/;"	f	class:lm::ngram::trie::__anon58::FindBlanks
FindBlanks	HTKLVRec/kenlm/lm/search_trie.cc	/^class FindBlanks {$/;"	c	namespace:lm::ngram::trie::__anon58	file:
FindButton	HTKLib/HGraf.c	/^HButton *FindButton(HButton *btnlst, ButtonId key)$/;"	f
FindButton	HTKLib/HGraf.null.c	/^HButton *FindButton(HButton *btnlst, ButtonId key)$/;"	f
FindButton	HTKLib/HGraf_WIN32.c	/^HButton *FindButton(HButton *btnlst, ButtonId key)$/;"	f
FindCentres	HTKLib/HTrain.c	/^static void FindCentres(int a, int b)$/;"	f	file:
FindConfEntry	HTKLib/HShell.c	/^static ConfigEntry *FindConfEntry(char *user, char *name)$/;"	f	file:
FindConfParm	HTKLib/HShell.c	/^static int FindConfParm(ConfParam **list,int size,char *name,ConfKind kind)$/;"	f	file:
FindContexts_s	HTKLVRec/HLVNet.c	/^void FindContexts_s (HMMSet *hset, STLexNode *n)$/;"	f
FindCovariance	HTKLib/HTrain.c	/^static void FindCovariance(int n)$/;"	f	file:
FindDelimiterOrEOF	HTKLVRec/kenlm/util/file_piece.cc	/^const char *FilePiece::FindDelimiterOrEOF(const bool *delim)  {$/;"	f	class:util::FilePiece
FindDifference	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^const WordIndex* FindDifference(const NGram &full, const NGram &lower_last) {$/;"	f	namespace:lm::builder::__anon42
FindFE	HLMLib/LModel.c	/^FLEntry *FindFE(FLEntry *fptr, int lo, int hi, LM_Id key)$/;"	f
FindField	HTKLib/esignal.c	/^FindField(FieldList list,       \/* field list *\/$/;"	f
FindHMM	HTKLVRec/HLVNet.c	/^HLink FindHMM (HMMSet *hset, LabId id)$/;"	f
FindHMMLink	HTKLVRec/HLVNet.c	/^TLexLink *FindHMMLink (TLexNode *ln, HLink hmm)$/;"	f
FindItemBlock	HTKLib/HTrain.c	/^static IBLink FindItemBlock(Sequence seq, int i, int *j)$/;"	f	file:
FindLContext	HTKLib/HNet.c	/^static int FindLContext(HMMSetCxtInfo *hci,PronHolder *p,int pos,int lc)$/;"	f	file:
FindLatArc	HTKLVRec/HLVLM.c	/^FSLM_LatArc *FindLatArc (FSLM_LatArc *low, FSLM_LatArc *hi, PronId pronId)$/;"	f
FindLatEnd	HTKLib/HNet.c	/^NodeId FindLatEnd(Lattice *lat)$/;"	f
FindLatStart	HTKLib/HNet.c	/^NodeId FindLatStart(Lattice *lat)$/;"	f
FindLexNetLab	HTKLVRec/HDecode.c	/^BestInfo *FindLexNetLab (MemHeap *heap, LexNode *ln, LLink ll, HTime frameDur)$/;"	f
FindLexNetLab	HTKLVRec/HDecode.mod.c	/^BestInfo *FindLexNetLab (MemHeap *heap, LexNode *ln, LLink ll, HTime frameDur)$/;"	f
FindLoopBegin	HTKTools/HParse.c	/^Link FindLoopBegin(Link *hd)$/;"	f
FindLoopEnd	HTKTools/HParse.c	/^Link FindLoopEnd(Link *tl)$/;"	f
FindLower	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <class Value> void FindLower($/;"	f	namespace:lm::ngram::__anon57
FindMLFStr	HTKLib/HLabel.c	/^static Boolean FindMLFStr(char *s, char **st, char **en)$/;"	f	file:
FindMLFType	HTKLib/HLabel.c	/^static MLFDefType FindMLFType(char *s, char **en)$/;"	f	file:
FindMMF	HTKLib/HModel.c	/^static MILink FindMMF(HMMSet *hset, char *fname, Boolean ignorePath)$/;"	f	file:
FindMacroName	HTKLib/HModel.c	/^MLink FindMacroName(HMMSet *hset, char type, LabId id)$/;"	f
FindMacroStruct	HTKLib/HModel.c	/^MLink FindMacroStruct(HMMSet *hset, char type, Ptr structure)$/;"	f
FindMinLatArc	HTKLVRec/HLVLM.c	/^FSLM_LatArc *FindMinLatArc (FSLM_LatArc *low, FSLM_LatArc *hi, PronId minPron)$/;"	f
FindMinSEntry	HTKLVRec/HLVLM.c	/^SEntry *FindMinSEntry (SEntry *se, int nse, PronId minPron)$/;"	f
FindMinSEntryP	HTKLVRec/HLVLM.c	/^static SEntry *FindMinSEntryP (SEntry *low, SEntry *hi, PronId minPron)$/;"	f	file:
FindModel	HTKLib/HNet.c	/^static HLink FindModel(HMMSetCxtInfo *hci,int lc,LabId name,int rc)$/;"	f	file:
FindNode	HTKLib/HModel.c	/^static RegNode *FindNode(RegNode *n, RegNode *r, int id)$/;"	f	file:
FindNodeTypes	HTKTools/HParse.c	/^void FindNodeTypes(HPNetwork *theNet)$/;"	f
FindOp	HTKTools/HLEd.c	/^void FindOp(LabList *ll,LabId *args)$/;"	f
FindOrInsert	HTKLVRec/kenlm/lm/vocab.hh	/^    WordIndex FindOrInsert(const StringPiece &word) {$/;"	f	class:lm::ngram::GrowableVocab
FindOrInsert	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class T> bool FindOrInsert(const T &t, MutableIterator &out) {$/;"	f	class:util::AutoProbing
FindOrInsert	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class T> bool FindOrInsert(const T &t, MutableIterator &out) {$/;"	f	class:util::ProbingHashTable
FindProtoModel	HTKTools/HHEd.c	/^HLink FindProtoModel(LabId model)$/;"	f
FindRContext	HTKLib/HNet.c	/^static int FindRContext(HMMSetCxtInfo *hci,PronHolder *p,int pos,int rc)$/;"	f	file:
FindSE	HLMLib/LModel.c	/^SMEntry *FindSE(SMEntry *sptr, int lo, int hi, LM_Id key)$/;"	f
FindSE1	HLMLib/LModel.c	/^static SMEntry *FindSE1(SMEntry *sptr, int lo, int hi, LM_Id key, int *fcen)$/;"	f	file:
FindSEntry	HTKLVRec/HLVLM.c	/^static SEntry *FindSEntry (SEntry *se, PronId pronId, int l, int h)$/;"	f	file:
FindSEntry	HTKLib/HLM.c	/^static SEntry *FindSEntry (SEntry *se, lmId pronId, int l, int h)$/;"	f	file:
FindSpans	HTKLib/HParm.c	/^static void FindSpans(short span[12], ParmKind k, int size)$/;"	f	file:
FindStateOrder	HTKLib/HFB.c	/^void FindStateOrder(HLink hmm,IntVec so,int s,int *d)$/;"	f
FindStringPiece	HTKLVRec/kenlm/util/string_piece_hash.hh	/^template <class T> typename T::const_iterator FindStringPiece(const T &t, const StringPiece &key) {$/;"	f
FindStringPiece	HTKLVRec/kenlm/util/string_piece_hash.hh	/^template <class T> typename T::iterator FindStringPiece(T &t, const StringPiece &key) {$/;"	f
FindTriphone	HTKLVRec/HLVNet.c	/^HLink FindTriphone (HMMSet *hset, LabId a, LabId b, LabId c)$/;"	f
FindVQNode	HTKLib/HVQ.c	/^static VQNode FindVQNode(VQNode *list, short nid)$/;"	f	file:
FindVQTable	HTKLib/HVQ.c	/^static VQTable FindVQTable(char * tabFN, short magic)$/;"	f	file:
FindWordNode	HTKLib/HNet.c	/^static NetNode *FindWordNode(MemHeap *heap,Pron pron,$/;"	f	file:
Finish	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^void ARPAOutput::Finish() {$/;"	f	class:lm::ARPAOutput
Finish	HTKLVRec/kenlm/lm/filter/format.hh	/^    void Finish() { B::output_.Finish(); }$/;"	f	class:lm::DispatchARPAInput
Finish	HTKLVRec/kenlm/lm/filter/format.hh	/^    void Finish() {$/;"	f	class:lm::MultipleARPAOutput
Finish	HTKLVRec/kenlm/lm/left.hh	/^    float Finish() {$/;"	f	class:lm::ngram::RuleScore
Finish	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    void Finish() {$/;"	f	class:util::FakeOFStream
FinishFile	HTKLVRec/kenlm/lm/binary_format.cc	/^void BinaryFormat::FinishFile(const Config &config, ModelType model_type, unsigned int search_version, const std::vector<uint64_t> &counts) {$/;"	f	class:lm::ngram::BinaryFormat
Finished	HTKLVRec/kenlm/util/ersatz_progress.hh	/^    void Finished() {$/;"	f	class:util::ErsatzProgress
Finished	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^void MultiProgress::Finished() {$/;"	f	class:util::stream::MultiProgress
FinishedAdding	HTKLVRec/kenlm/lm/search_trie.cc	/^    void FinishedAdding() {$/;"	f	class:lm::ngram::trie::__anon58::BackoffMessages	file:
FinishedAppending	HTKLVRec/kenlm/util/stream/sort.hh	/^    void FinishedAppending() {$/;"	f	class:util::stream::Offsets
FinishedInserting	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    void FinishedInserting() {}$/;"	f	class:util::ProbingHashTable
FinishedLoading	HTKLVRec/kenlm/lm/bhiksha.cc	/^void ArrayBhiksha::FinishedLoading(const Config &config) {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
FinishedLoading	HTKLVRec/kenlm/lm/bhiksha.hh	/^    void FinishedLoading(const Config &\/*config*\/) {}$/;"	f	class:lm::ngram::trie::DontBhiksha
FinishedLoading	HTKLVRec/kenlm/lm/quantize.cc	/^void SeparatelyQuantize::FinishedLoading(const Config &config) {$/;"	f	class:lm::ngram::SeparatelyQuantize
FinishedLoading	HTKLVRec/kenlm/lm/quantize.hh	/^    void FinishedLoading(const Config &) {}$/;"	f	class:lm::ngram::DontQuantize
FinishedLoading	HTKLVRec/kenlm/lm/trie.cc	/^template <class Bhiksha> void BitPackedMiddle<Bhiksha>::FinishedLoading(uint64_t next_end, const Config &config) {$/;"	f	class:lm::ngram::trie::BitPackedMiddle
FinishedLoading	HTKLVRec/kenlm/lm/vocab.cc	/^void ProbingVocabulary::FinishedLoading() {$/;"	f	class:lm::ngram::ProbingVocabulary
FinishedLoading	HTKLVRec/kenlm/lm/vocab.cc	/^void SortedVocabulary::FinishedLoading(ProbBackoff *reorder_vocab) {$/;"	f	class:lm::ngram::SortedVocabulary
FinishedLoading	HTKLVRec/kenlm/lm/vocab.hh	/^    template <class Weights> void FinishedLoading(Weights * \/*reorder_vocab*\/) {$/;"	f	class:lm::ngram::ProbingVocabulary
FirstCombine	HTKLVRec/kenlm/lm/trie_sort.cc	/^struct FirstCombine {$/;"	s	namespace:lm::ngram::trie::__anon60	file:
FirstComponent	HTKLib/esignal.c	/^FirstComponent(char *name)$/;"	f	file:
FirstIntersection	HTKLVRec/kenlm/util/multi_intersection.hh	/^template <class Iterator, class Less> boost::optional<typename std::iterator_traits<Iterator>::value_type> FirstIntersection(std::vector<boost::iterator_range<Iterator> > &sets, const Less less) {$/;"	f	namespace:util
FirstIntersection	HTKLVRec/kenlm/util/multi_intersection.hh	/^template <class Iterator> boost::optional<typename std::iterator_traits<Iterator>::value_type> FirstIntersection(std::vector<boost::iterator_range<Iterator> > &sets) {$/;"	f	namespace:util
FirstIntersectionSorted	HTKLVRec/kenlm/util/multi_intersection.hh	/^template <class Iterator, class Less> boost::optional<typename std::iterator_traits<Iterator>::value_type> FirstIntersectionSorted(std::vector<boost::iterator_range<Iterator> > &sets, const Less &less = std::less<typename std::iterator_traits<Iterator>::value_type>()) {$/;"	f	namespace:util::detail
FixAllGConsts	HTKLib/HModel.c	/^void FixAllGConsts(HMMSet *hset)$/;"	f
FixBadLat	HTKLib/HLat.c	/^void FixBadLat (Lattice *lat)$/;"	f
FixDefunctMix	HTKTools/HHEd.c	/^void FixDefunctMix(char *hname,StreamElem *ste, int n)$/;"	f
FixDet	HTKLib/HAdapt.c	/^static void FixDet(LinXForm *xf)$/;"	f	file:
FixDiagGConst	HTKLib/HModel.c	/^void FixDiagGConst(MixPDF *mp)$/;"	f
FixFullGConst	HTKLib/HModel.c	/^void FixFullGConst(MixPDF *mp, LogFloat ldet)$/;"	f
FixGConsts	HTKLib/HModel.c	/^void FixGConsts(HLink hmm)$/;"	f
FixHMMForICrit	HTKTools/HMMIRest.c	/^static void FixHMMForICrit(){$/;"	f	file:
FixInvDiagGConst	HTKLib/HModel.c	/^void FixInvDiagGConst(MixPDF *mp)$/;"	f
FixLLTGConst	HTKLib/HModel.c	/^void FixLLTGConst(MixPDF *mp)$/;"	f
FixLabIdxs	HTKTools/HCopy.c	/^void FixLabIdxs(int nlabs)$/;"	f
FixLatTimes	HTKLib/HArc.c	/^void FixLatTimes(Lattice *lat){ \/*Makes it so that the sum of phone lengths equals the length of each word.*\/$/;"	f
FixOptions	HTKTools/HCopy.c	/^void FixOptions(void)$/;"	f
FixOrphanMacros	HTKLib/HModel.c	/^void FixOrphanMacros(HMMSet *hset)$/;"	f
FixPronProbs	HTKLib/HLat.c	/^void FixPronProbs (Lattice *lat, Vocab *voc)$/;"	f
FixSVD	HTKLib/HMath.c	/^static void FixSVD(DVector d, DMatrix U, DMatrix V)$/;"	f	file:
FixSemiTiedStats	HTKLib/HAdapt.c	/^static void FixSemiTiedStats(HMMSet *hset)$/;"	f	file:
FixTLoopEnds	HTKTools/HParse.c	/^static void FixTLoopEnds(int numElements, Link *hd, Link *tl, Link a, Link b)                 $/;"	f	file:
FixTiedGConsts	HTKLib/HModel.c	/^void FixTiedGConsts(HMMSet *hset)$/;"	f
FixTransForICrit	HTKTools/HMMIRest.c	/^static void FixTransForICrit(float Tau, Boolean THREEACCS){$/;"	f	file:
FixWeights	HTKTools/HHEd.c	/^void FixWeights(MixtureElem *me, HMMDef *owner, StreamElem *ste)$/;"	f
FixWeightsForICrit	HTKTools/HMMIRest.c	/^static void FixWeightsForICrit(float Tau, Boolean THREEACCS){$/;"	f	file:
FixedArray	HTKLVRec/kenlm/util/fixed_array.hh	/^    FixedArray() $/;"	f	class:util::FixedArray
FixedArray	HTKLVRec/kenlm/util/fixed_array.hh	/^    FixedArray(const FixedArray &from) {$/;"	f	class:util::FixedArray
FixedArray	HTKLVRec/kenlm/util/fixed_array.hh	/^    explicit FixedArray(std::size_t limit) {$/;"	f	class:util::FixedArray
FixedArray	HTKLVRec/kenlm/util/fixed_array.hh	/^template <class T> class FixedArray {$/;"	c	namespace:util
FixedWidthParameters	HTKLVRec/kenlm/lm/binary_format.hh	/^struct FixedWidthParameters {$/;"	s	namespace:lm::ngram
FixupMultiply10	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^static void FixupMultiply10(int estimated_power, bool is_even,$/;"	f	namespace:double_conversion
Flags	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  enum Flags {$/;"	g	class:double_conversion::DoubleToStringConverter
Flags	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  enum Flags {$/;"	g	class:double_conversion::StringToDoubleConverter
FlatCluster	HTKLib/HTrain.c	/^ClusterSet *FlatCluster(MemHeap *x, Sequence vpool, int nc, $/;"	f
FloatComplex	HTKLib/esignal.h	/^typedef struct {float	real, imag;}	FloatComplex;$/;"	t	typeref:struct:__anon183
FloatEnc	HTKLVRec/kenlm/util/bit_packing.hh	/^typedef union { float f; uint32_t i; } FloatEnc;$/;"	t	namespace:util	typeref:union:util::__anon65
FloatSize	HTKLVRec/kenlm/util/bit_packing.cc	/^typedef StaticCheck<sizeof(float) == 4>::StaticAssertionPassed FloatSize;$/;"	t	namespace:util::__anon64	file:
FloorAverageCommand	HTKTools/HHEd.c	/^void FloorAverageCommand(void)$/;"	f
FloorDProbs	HTKLib/HMap.c	/^static void FloorDProbs(ShortVec mixes, int M, float floor)$/;"	f	file:
FloorDProbs	HTKTools/HERest.c	/^void FloorDProbs(ShortVec mixes, int M, float floor)$/;"	f
FloorDProbs	HTKTools/HMMIRest.c	/^void FloorDProbs(ShortVec mixes, int M, float floor)$/;"	f
FloorDProbs	HTKTools/HRest.c	/^void FloorDProbs(ShortVec mixes, int M, float floor)$/;"	f
FloorDProbs	HTKTools/HSmooth.c	/^void FloorDProbs(ShortVec mixes, int M, float floor)$/;"	f
FloorMixes	HTKLib/HMap.c	/^static void FloorMixes(MixtureElem *mixes, int M, float floor)$/;"	f	file:
FloorMixes	HTKTools/HERest.c	/^void FloorMixes(HMMSet *hset, MixtureElem *mixes, int M, float floor)$/;"	f
FloorMixes	HTKTools/HMMIRest.c	/^void FloorMixes(MixtureElem *mixes, int M, float floor)$/;"	f
FloorMixes	HTKTools/HRest.c	/^void FloorMixes(MixtureElem *mixes, int M, float floor)$/;"	f
FloorMixtures	HTKLib/HMap.c	/^static void FloorMixtures(HSetKind hskind, StreamElem *ste, int M, float floor)$/;"	f	file:
FloorTMMixes	HTKLib/HMap.c	/^static void FloorTMMixes(Vector mixes, int M, float floor)$/;"	f	file:
FloorTMMixes	HTKTools/HERest.c	/^void FloorTMMixes(Vector mixes, int M, float floor)$/;"	f
FloorTMMixes	HTKTools/HMMIRest.c	/^void FloorTMMixes(Vector mixes, int M, float floor)$/;"	f
FloorTMMixes	HTKTools/HRest.c	/^void FloorTMMixes(Vector mixes, int M, float floor)$/;"	f
FloorTMMixes	HTKTools/HSmooth.c	/^void FloorTMMixes(Vector mixes, int M,float floor)$/;"	f
FloorVars	HTKTools/HERest.c	/^void FloorVars(HMMSet *hset1, int s){$/;"	f
FloorVars	HTKTools/HMMIRest.c	/^void FloorVars(HMMSet *hset1, int s){$/;"	f
FloorVectorCommand	HTKTools/HHEd.c	/^void FloorVectorCommand(void)$/;"	f
FltCKind	HTKLib/HShell.h	/^   FltCKind,            \/* float value *\/$/;"	e	enum:__anon155
Flush	HTKLVRec/kenlm/lm/filter/format.hh	/^    template <class Output> void Flush(Output &output) {$/;"	f	class:lm::BinaryOutputBuffer
Flush	HTKLVRec/kenlm/lm/filter/format.hh	/^    template <class Output> void Flush(Output &output) {$/;"	f	class:lm::MultipleOutputBuffer
Flush	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    void Flush() const {}$/;"	f	class:lm::phrase::Multiple
Flush	HTKLVRec/kenlm/lm/filter/thread.hh	/^    template <class RealOutput> void Flush(RealOutput &output) {$/;"	f	class:lm::ThreadBatch
Flush	HTKLVRec/kenlm/lm/filter/thread.hh	/^    void Flush() {$/;"	f	class:lm::Controller
Flush	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    void Flush() const {}$/;"	f	class:lm::vocab::Multiple
Flush	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^    void Flush() const {}$/;"	f	class:lm::BinaryFilter
Flush	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^    void Flush() const {}$/;"	f	class:lm::ContextFilter
Flush	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    void Flush() {$/;"	f	class:util::FakeOFStream
FlushInput	HTKLVRec/kenlm/lm/filter/thread.hh	/^    void FlushInput() {$/;"	f	class:lm::Controller
FoFTab	HLMLib/LGBase.h	/^} FoFTab;$/;"	t	typeref:struct:__anon6
FontInfo	HTKLib/HGraf.c	/^static XFontStruct  *DefaultFont, *CurrentFont, *FontInfo[NO_OF_FONTS];$/;"	v	file:
FontNm	HTKLib/HGraf.c	/^static char *FontNm[NO_OF_FONTS] = {$/;"	v	file:
FontSize	HTKLib/HGraf.c	/^static int FontSize[NO_OF_FONTS] = {8, 9, 10, 12, 14, 15, 16, 19, 20, 24};$/;"	v	file:
ForceDiagC	HTKLib/HUtil.c	/^void ForceDiagC(HMMSet *hset)$/;"	f
ForcePKind	HTKLib/HParm.c	/^static ParmKind ForcePKind = ANON; \/* force to output a customized parm kind to make older versions$/;"	v	file:
FormChunk	HTKLib/HWave.c	/^} FormChunk;$/;"	t	typeref:struct:__anon177	file:
Format2Str	HTKLib/HWave.c	/^char *Format2Str(FileFormat format)$/;"	f
FormatLoadException	HTKLVRec/kenlm/lm/lm_exception.cc	/^FormatLoadException::FormatLoadException() throw() {}$/;"	f	class:lm::FormatLoadException
FormatLoadException	HTKLVRec/kenlm/lm/lm_exception.hh	/^class FormatLoadException : public LoadException {$/;"	c	namespace:lm
FormatTranscription	HTKLib/HRec.c	/^void FormatTranscription(Transcription *trans,HTime frameDur,$/;"	f
Found	HTKLVRec/kenlm/lm/quantize.hh	/^        bool Found() const { return address_.base != NULL; }$/;"	f	class:lm::ngram::SeparatelyQuantize::LongestPointer
Found	HTKLVRec/kenlm/lm/quantize.hh	/^        bool Found() const { return address_.base != NULL; }$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
Found	HTKLVRec/kenlm/lm/quantize.hh	/^        bool Found() const {$/;"	f	class:lm::ngram::DontQuantize::LongestPointer
Found	HTKLVRec/kenlm/lm/quantize.hh	/^        bool Found() const {$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
Found	HTKLVRec/kenlm/lm/search_hashed.hh	/^    bool Found() const {$/;"	f	class:lm::ngram::detail::LongestPointer
Found	HTKLVRec/kenlm/lm/trie.hh	/^    bool Found() const { return to_ != NULL; }$/;"	f	class:lm::ngram::trie::UnigramPointer
Found	HTKLVRec/kenlm/lm/value.hh	/^    bool Found() const { return to_ != 0; }$/;"	f	class:lm::ngram::GenericProbingProxy
Found	HTKLVRec/kenlm/lm/value.hh	/^    bool Found() const { return to_ != 0; }$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
FramesInAudio	HTKLib/HAudio.c	/^int FramesInAudio(AudioIn a)$/;"	f
FramesInChannel	HTKLib/HParm.c	/^static int FramesInChannel(ParmBuf pbuf,int chType)$/;"	f	file:
FramesInParm	HTKLib/HParm.c	/^static int FramesInParm(ParmBuf pbuf)$/;"	f	file:
FramesInWave	HTKLib/HWave.c	/^int FramesInWave(Wave w)$/;"	f
FreeAll	HTKLVRec/kenlm/util/pool.cc	/^void Pool::FreeAll() {$/;"	f	class:util::Pool
FreeAxisNames	HTKLib/esignal.c	/^FreeAxisNames(char  **axis_names,$/;"	f
FreeClusterSet	HTKLib/HTrain.c	/^void FreeClusterSet(ClusterSet *cs)$/;"	f
FreeDMatrix	HTKLib/HMem.c	/^void FreeDMatrix(MemHeap *x, DMatrix m)$/;"	f
FreeDVector	HTKLib/HMem.c	/^void FreeDVector(MemHeap *x, DVector v)$/;"	f
FreeFieldList	HTKLib/esignal.c	/^FreeFieldList(FieldList list)$/;"	f
FreeFieldSpec	HTKLib/esignal.c	/^FreeFieldSpec(FieldSpec *spec)$/;"	f
FreeGrid	HTKTools/HResults.c	/^void FreeGrid(void)$/;"	f
FreeIntVec	HTKLib/HMem.c	/^void FreeIntVec(MemHeap *x,IntVec v)$/;"	f
FreeItems	HTKLib/HUtil.c	/^void FreeItems(ILink *list)$/;"	f
FreeJMat	HTKTools/HParse.c	/^static void FreeJMat(void)$/;"	f	file:
FreeLMCache	HTKLVRec/HLVRec-LM.c	/^static void FreeLMCache (LMCache *cache)$/;"	f	file:
FreeLattice	HTKLib/HNet.c	/^void FreeLattice(Lattice *lat)$/;"	f
FreeLinkSet	HTKTools/HParse.c	/^static void FreeLinkSet(LinkSet *p)$/;"	f	file:
FreeMatrix	HTKLib/HMem.c	/^void FreeMatrix(MemHeap *x, Matrix m)$/;"	f
FreeMiddles	HTKLVRec/kenlm/lm/search_trie.hh	/^    void FreeMiddles() {$/;"	f	class:lm::ngram::trie::TrieSearch
FreeNetwork	HTKTools/HParse.c	/^void FreeNetwork(HPNetwork *network)$/;"	f
FreeNode	HTKTools/HParse.c	/^static void FreeNode(Link p)$/;"	f	file:
FreePSetInfo	HTKLib/HRec.c	/^void FreePSetInfo(PSetInfo *psi)$/;"	f
FreeSMatrix	HTKLib/HMem.c	/^void FreeSMatrix(MemHeap *x, Matrix m)$/;"	f
FreeSTriMat	HTKLib/HMem.c	/^void FreeSTriMat(MemHeap *x,STriMat m)$/;"	f
FreeSVector	HTKLib/HMem.c	/^void FreeSVector(MemHeap *x, Vector v)$/;"	f
FreeSet	HTKLib/HUtil.c	/^void FreeSet(IntSet s)$/;"	f
FreeShortVec	HTKLib/HMem.c	/^void FreeShortVec(MemHeap *x,ShortVec v)$/;"	f
FreeSubNetDefs	HTKTools/HParse.c	/^static void FreeSubNetDefs(void)$/;"	f	file:
FreeTriMat	HTKLib/HMem.c	/^void FreeTriMat(MemHeap *x,TriMat m)$/;"	f
FreeVector	HTKLib/HMem.c	/^void FreeVector(MemHeap *x, Vector v)$/;"	f
FreezeOptions	HTKLib/HModel.c	/^static ReturnStatus FreezeOptions(HMMSet *hset)$/;"	f	file:
FromMax	HTKLVRec/kenlm/util/bit_packing.hh	/^  void FromMax(uint64_t max_value) {$/;"	f	struct:util::BitsMask
Full	HTKLVRec/kenlm/lm/trie_sort.hh	/^    FILE *Full(unsigned char order) {$/;"	f	class:lm::ngram::trie::SortedFiles
FullCovarCommand	HTKTools/HHEd.c	/^void FullCovarCommand(void)$/;"	f
FullInvGConst	HTKLib/HVQ.c	/^static float FullInvGConst(TriMat ic)$/;"	f	file:
FullPrint	HTKLVRec/kenlm/lm/ngram_query.hh	/^struct FullPrint : public BasicPrint {$/;"	s	namespace:lm::ngram
FullScore	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> FullScoreReturn GenericModel<Search, VocabularyT>::FullScore(const State &in_state, const WordIndex new_word, State &out_state) const {$/;"	f	class:lm::ngram::detail::GenericModel
FullScore	HTKLVRec/kenlm/lm/wrappers/nplm.cc	/^FullScoreReturn Model::FullScore(const State &from, const WordIndex new_word, State &out_state) const {$/;"	f	class:lm::np::Model
FullScoreForgotState	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> FullScoreReturn GenericModel<Search, VocabularyT>::FullScoreForgotState(const WordIndex *context_rbegin, const WordIndex *context_rend, const WordIndex new_word, State &out_state) const {$/;"	f	class:lm::ngram::detail::GenericModel
FullScoreForgotState	HTKLVRec/kenlm/lm/wrappers/nplm.cc	/^FullScoreReturn Model::FullScoreForgotState(const WordIndex *context_rbegin, const WordIndex *context_rend, const WordIndex new_word, State &out_state) const {$/;"	f	class:lm::np::Model
FullScoreReturn	HTKLVRec/kenlm/lm/return.hh	/^struct FullScoreReturn {$/;"	s	namespace:lm
FullestCluster	HTKLib/HTrain.c	/^static int FullestCluster(void)$/;"	f	file:
Function	HTKBook/HTKRef/HCopy.tex	/^\\subsection{Function}$/;"	b
Function	HTKBook/HTKRef/HHEd.tex	/^\\subsection{Function}$/;"	b
FunctionWordOp	HTKTools/HDMan.c	/^void FunctionWordOp(WordBuf *wb, LabId *args)$/;"	f
G	HTKLib/HAdapt.c	/^   DMatrix *G;$/;"	m	struct:__anon85	file:
GAMMAD	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	e	enum:_DurKind
GB	HTKLib/HParm.c	/^Boolean GB(char *s){Boolean b; GetConfBool(cParm,nParm,s,&b); return b;}$/;"	f
GCONST	HTKLib/HModel.c	/^   MEAN, VARIANCE, INVCOVAR, XFORM, GCONST,$/;"	e	enum:__anon117	file:
GCOPY	HTKLib/HGraf.h	/^enum _XferMode {GCOPY, GOR, GXOR, GINVERT};$/;"	e	enum:_XferMode
GC_ALTPATH_PREV	HTKLVRec/HLVRec-GC.c	51;"	d	file:
GDUR	HTKLib/HModel.c	/^   NDUR, PDUR, GDUR, RELDUR, GENDUR,$/;"	e	enum:__anon117	file:
GDistance	HTKTools/HHEd.c	/^float GDistance(int s, StreamElem *s1, StreamElem *s2)$/;"	f
GEND	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	e	enum:_DurKind
GENDUR	HTKLib/HModel.c	/^   NDUR, PDUR, GDUR, RELDUR, GENDUR,$/;"	e	enum:__anon117	file:
GF	HTKLib/HParm.c	/^double  GF(char *s){double d;  GetConfFlt(cParm,nParm,s,&d); return d;}$/;"	f
GFLink	HLMLib/LGBase.h	/^typedef struct gramfile *GFLink;$/;"	t	typeref:struct:gramfile
GHOST_ARC	HTKLib/HArc.h	126;"	d
GI	HTKLib/HParm.c	/^int     GI(char *s){int i;     GetConfInt(cParm,nParm,s,&i); return i;}$/;"	f
GINVERT	HTKLib/HGraf.h	/^enum _XferMode {GCOPY, GOR, GXOR, GINVERT};$/;"	e	enum:_XferMode
GLOBAL	HTKLib/esignal.h	89;"	d
GOR	HTKLib/HGraf.h	/^enum _XferMode {GCOPY, GOR, GXOR, GINVERT};$/;"	e	enum:_XferMode
GQ	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon199	file:
GRAM2TEXT	HLMLib/LPCalc.c	390;"	d	file:
GRAM_HDR	HLMLib/LUtil.h	/^   NO_HDR, WMAP_HDR, CMAP_HDR, GRAM_HDR, LFOF_HDR$/;"	e	enum:__anon19
GREY	HTKLib/HGraf.h	/^                LIGHT_GREY, GREY, DARK_GREY, BLACK};$/;"	e	enum:_HColour
GS	HTKLib/HParm.c	/^char *GS(char *s){static char b[MAXFNAMELEN]; GetConfStr(cParm,nParm,s,b); return b;}$/;"	f
GSIZE	HLMLib/LGBase.h	42;"	d
GSTP	HTKLib/HGraf.c	305;"	d	file:
GSTP	HTKLib/HGraf_WIN32.c	264;"	d	file:
GXOR	HTKLib/HGraf.h	/^enum _XferMode {GCOPY, GOR, GXOR, GINVERT};$/;"	e	enum:_XferMode
GZException	HTKLVRec/kenlm/util/read_compressed.cc	/^GZException::GZException() throw() {}$/;"	f	class:util::GZException
GZException	HTKLVRec/kenlm/util/read_compressed.hh	/^class GZException : public CompressedException {$/;"	c	namespace:util
GZIP_ENV	Makefile	/^GZIP_ENV = --best$/;"	m
GZip	HTKLVRec/kenlm/util/read_compressed.cc	/^    GZip(const void *base, std::size_t amount) {$/;"	f	class:util::__anon79::GZip
GZip	HTKLVRec/kenlm/util/read_compressed.cc	/^class GZip {$/;"	c	namespace:util::__anon79	file:
GarbageCollectPaths	HTKLVRec/HLVRec-GC.c	/^static void GarbageCollectPaths (DecoderInst *dec)$/;"	f	file:
GatherStats	HTKTools/HLStats.c	/^void GatherStats(Transcription *t)$/;"	f
GaussDeviate	HTKLib/HMath.c	/^float GaussDeviate(float mu, float sigma)$/;"	f
GenAdaptXForm	HTKLib/HAdapt.c	/^Boolean GenAdaptXForm(HMMSet *hset, AdaptXForm* xform)$/;"	f
GenCepWin	HTKLib/HSigP.c	/^static void GenCepWin (int cepLiftering, int count)$/;"	f	file:
GenClassXForm	HTKLib/HAdapt.c	/^static Boolean GenClassXForm(BaseClass *bclass, AdaptXForm *xform)$/;"	f	file:
GenHamWindow	HTKLib/HSigP.c	/^static void GenHamWindow (int frameSize)$/;"	f	file:
GenSent	HTKTools/HSGen.c	/^int GenSent(int snum)$/;"	f
GenSentences	HTKTools/HSGen.c	/^void  GenSentences(char * latfn, char * dicfn)$/;"	f
GenXForm	HTKLib/HAdapt.c	/^void GenXForm(RegNode *node, AdaptXForm *xform, IntVec classes)$/;"	f
General Principles of MLFs	HTKBook/labels.tex	/^\\subsection{General Principles of MLFs}$/;"	b
GenerateCountedDigits	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^static void GenerateCountedDigits(int count, int* decimal_point,$/;"	f	namespace:double_conversion
GenerateDict	HTKTools/HParse.c	/^void GenerateDict(HPNetwork *theNet,Vocab *voc) $/;"	f
GenerateLattice	HTKTools/HParse.c	/^static Lattice* GenerateLattice(HPNetwork *theNet, Vocab *voc)$/;"	f	file:
GenerateModel	HLMLib/LPCalc.c	/^BackOffLM *GenerateModel(MemHeap *heap, BuildInfo *bi)$/;"	f
GenerateShortestDigits	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,$/;"	f	namespace:double_conversion
GenericModel	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> GenericModel<Search, VocabularyT>::GenericModel(const char *file, const Config &init_config) : backing_(init_config) {$/;"	f	class:lm::ngram::detail::GenericModel
GenericModel	HTKLVRec/kenlm/lm/model.hh	/^template <class Search, class VocabularyT> class GenericModel : public base::ModelFacade<GenericModel<Search, VocabularyT>, State, VocabularyT> {$/;"	c	namespace:lm::ngram::detail
GenericProbingProxy	HTKLVRec/kenlm/lm/value.hh	/^    GenericProbingProxy() : to_(0) {}$/;"	f	class:lm::ngram::GenericProbingProxy
GenericProbingProxy	HTKLVRec/kenlm/lm/value.hh	/^    explicit GenericProbingProxy(const Weights &to) : to_(&to) {}$/;"	f	class:lm::ngram::GenericProbingProxy
GenericProbingProxy	HTKLVRec/kenlm/lm/value.hh	/^template <class Weights> class GenericProbingProxy {$/;"	c	namespace:lm::ngram
GenericStreams	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    GenericStreams() {}$/;"	f	class:util::stream::GenericStreams
GenericStreams	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    GenericStreams(const ChainPositions &positions) {$/;"	f	class:util::stream::GenericStreams
GenericStreams	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^template <class T> class GenericStreams : public util::FixedArray<T> {$/;"	c	namespace:util::stream
GenericTrieUnigramProxy	HTKLVRec/kenlm/lm/value.hh	/^    GenericTrieUnigramProxy() : to_(0) {}$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
GenericTrieUnigramProxy	HTKLVRec/kenlm/lm/value.hh	/^    explicit GenericTrieUnigramProxy(const Weights &to) : to_(&to) {}$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
GenericTrieUnigramProxy	HTKLVRec/kenlm/lm/value.hh	/^template <class Weights> class GenericTrieUnigramProxy {$/;"	c	namespace:lm::ngram
Get	HTKLVRec/kenlm/lm/builder/discount.hh	/^  float Get(uint64_t count) const {$/;"	f	struct:lm::builder::Discount
Get	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    const void *Get() const { return stream_.Get(); }$/;"	f	class:lm::builder::NGramStream
Get	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    void *Get() { return stream_.Get(); }$/;"	f	class:lm::builder::NGramStream
Get	HTKLVRec/kenlm/util/stream/block.hh	/^    const void *Get() const { return mem_; }$/;"	f	class:util::stream::Block
Get	HTKLVRec/kenlm/util/stream/block.hh	/^    void *Get() { return mem_; }$/;"	f	class:util::stream::Block
Get	HTKLVRec/kenlm/util/stream/stream.hh	/^    const void *Get() const { return current_; }$/;"	f	class:util::stream::Stream
Get	HTKLVRec/kenlm/util/stream/stream.hh	/^    void *Get() { return current_; }$/;"	f	class:util::stream::Stream
GetAEntry	HTKTools/HLStats.c	/^AEntry *GetAEntry(int in[ASIZE],Boolean create)$/;"	f
GetAIFFHeaderInfo	HTKLib/HWave.c	/^static long GetAIFFHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetAIStatus	HTKLib/HAudio.c	/^AudioInStatus GetAIStatus(AudioIn a)$/;"	f
GetAInfo	HTKLib/HAdapt.c	/^static AInfo *GetAInfo(MixPDF *mp)$/;"	f	file:
GetALIENHeaderInfo	HTKLib/HWave.c	/^static long GetALIENHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetAdaptKind	HTKLib/HAdapt.c	/^static AdaptKind GetAdaptKind(AdaptXForm *xform)$/;"	f	file:
GetAdaptXForm	HTKLib/HModel.c	/^static AdaptXForm* GetAdaptXForm(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetAlpha	HTKLib/HAdapt.c	/^static double GetAlpha(DMatrix invgmat,DVector kmat,double occ, DVector cofact)$/;"	f	file:
GetAlpha	HTKLib/HUtil.c	/^static char *GetAlpha(char *s)$/;"	f	file:
GetAlphaLike	HTKLib/HAdapt.c	/^static double GetAlphaLike(double a, double b, double c, double alpha)$/;"	f	file:
GetAudio	HTKLib/HAudio.c	/^void GetAudio(AudioIn a, int nFrames, float *buf)$/;"	f
GetAuxCase	HTKLib/HLabel.c	/^LLink GetAuxCase(LabList *ll, LabId id, int n, int i)$/;"	f
GetAuxLabN	HTKLib/HLabel.c	/^LLink GetAuxLabN(LabList *ll, int n, int i)$/;"	f
GetBaseClass	HTKLib/HAdapt.c	/^static BaseClass* GetBaseClass(HMMSet *hset,AdaptXForm *xform)$/;"	f	file:
GetBaseClass	HTKLib/HModel.c	/^static BaseClass* GetBaseClass(HMMSet *hset,Source *src, Token *tok)$/;"	f	file:
GetBestCorrectness	HTKLib/HExactMPE.c	/^Boolean GetBestCorrectness \/*step correctness by 1 phone.*\/$/;"	f
GetBias	HTKLib/HModel.c	/^static SVector GetBias(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetBlank	HTKLVRec/kenlm/lm/search_trie.cc	/^    ProbBackoff GetBlank(unsigned char total_order, unsigned char order, const WordIndex *indices) {$/;"	f	class:lm::ngram::trie::__anon58::SRISucks
GetBlockSize	HTKLib/HAdapt.c	/^static IntVec GetBlockSize(AdaptXForm *xform, int classIdx)$/;"	f	file:
GetBufferInfo	HTKLib/HParm.c	/^void GetBufferInfo(ParmBuf pbuf, BufferInfo *info)$/;"	f
GetCRCCFrame	HTKLib/HParm.c	/^static Boolean GetCRCCFrame(ParmBuf pbuf,void *data,int n,int s,Boolean bSwap)$/;"	f	file:
GetCachedPowerForBinaryExponentRange	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^void PowersOfTenCache::GetCachedPowerForBinaryExponentRange($/;"	f	class:double_conversion::PowersOfTenCache
GetCachedPowerForDecimalExponent	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^void PowersOfTenCache::GetCachedPowerForDecimalExponent(int requested_exponent,$/;"	f	class:double_conversion::PowersOfTenCache
GetCase	HTKLib/HLabel.c	/^LLink GetCase(LabList *ll, LabId id, int n)$/;"	f
GetCh	HTKLib/HShell.c	/^int GetCh(Source *src)$/;"	f
GetChain	HTKLVRec/kenlm/util/stream/chain.hh	/^    const Chain &GetChain() const { return *chain_; }$/;"	f	class:util::stream::ChainPosition
GetChkedFlt	HTKLib/HShell.c	/^float GetChkedFlt(float min, float max, char * swtname)$/;"	f
GetChkedInt	HTKLib/HShell.c	/^int GetChkedInt(int min, int max, char * swtname)$/;"	f
GetChkedLong	HTKLib/HShell.c	/^long GetChkedLong(long min, long max, char * swtname)$/;"	f
GetClassEntry	HLMLib/LCMap.c	/^ClassEntry *GetClassEntry(ClassMap *c, int clndx)$/;"	f
GetClassMembers	HLMLib/LCMap.c	/^void GetClassMembers(ClassMap *c, int clndx, int *words)$/;"	f
GetConfBool	HTKLib/HShell.c	/^Boolean GetConfBool(ConfParam **list,int size,char *name, Boolean *b)$/;"	f
GetConfFlt	HTKLib/HShell.c	/^Boolean GetConfFlt(ConfParam **list,int size,char *name, double *fval)$/;"	f
GetConfInt	HTKLib/HShell.c	/^Boolean GetConfInt(ConfParam **list,int size,char *name, int *ival)$/;"	f
GetConfStr	HTKLib/HShell.c	/^Boolean GetConfStr(ConfParam **list,int size,char *name,char *str)$/;"	f
GetConfig	HTKLib/HShell.c	/^int GetConfig(char *user, Boolean incGlob, ConfParam **list, int max)$/;"	f
GetContext	HTKTools/HLEd.c	/^LabId *GetContext(LabId name)$/;"	f
GetContextList	HTKTools/HDMan.c	/^LabId *GetContextList(LabId id, DBuffer *db)$/;"	f
GetCovar	HTKLib/HModel.c	/^static STriMat GetCovar(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetCurrentVol	HTKLib/HAudio.c	/^float GetCurrentVol(AudioIn a)$/;"	f
GetDelegate	HTKLVRec/kenlm/util/sized_iterator.hh	/^    const Delegate &GetDelegate() const { return delegate_; }$/;"	f	class:util::SizedCompare
GetDiscreteWeights	HTKLib/HModel.c	/^ReturnStatus GetDiscreteWeights(Source *src, Token *tok, int M, ShortVec dpdf)$/;"	f
GetDumpFile	HTKLib/HTrain.c	/^static FILE * GetDumpFile(char *name, int n)$/;"	f	file:
GetDuration	HTKLib/HModel.c	/^static SVector GetDuration(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetEQLab	HLMTools/LPlex.c	/^static LabId GetEQLab(LabId id)$/;"	f	file:
GetESIGHeaderInfo	HTKLib/HWave.c	/^static long GetESIGHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetElem	HTKLib/HMem.c	/^static void *GetElem(BlockP p, size_t elemSize, HeapType type)$/;"	f	file:
GetFOM	HTKTools/HResults.c	/^float GetFOM(int idx)$/;"	f
GetField	HTKLib/esignal.c	/^GetField(FieldList  list,       \/* field list *\/$/;"	f	file:
GetFieldOrdering	HTKLib/esignal.c	/^GetFieldOrdering(FieldList  list,$/;"	f
GetFieldValue	HTKLib/HNet.c	/^static LatFieldType GetFieldValue(char *buf, Source *src, int buflen)$/;"	f	file:
GetFileNameExt	HTKLib/HShell.c	/^Boolean GetFileNameExt(char *logfn, char *actfn, long *st, long *en)$/;"	f
GetFinalError	HTKLib/HFBLat.c	/^float GetFinalError(float curr_total, float curr_corr, Boolean hyp_is_sil){  \/* re the "CALCASERROR" option, other version of approx MPE. *\/$/;"	f
GetFindAccumulator	HTKTools/HLEd.c	/^int *GetFindAccumulator(LabId *pat)$/;"	f
GetFloat	HTKLib/HLM.c	/^static float GetFloat(Boolean bin)$/;"	f	file:
GetFltArg	HTKLib/HShell.c	/^float GetFltArg(void)$/;"	f
GetFltField	HTKLib/HNet.c	/^static double GetFltField(char ntype,char del,char *vbuf,Source *src)$/;"	f	file:
GetFrameFromChannel	HTKLib/HParm.c	/^static int GetFrameFromChannel(ParmBuf pbuf,int chType,void *vp)$/;"	f	file:
GetHCIContext	HTKLib/HNet.c	/^int GetHCIContext(HMMSetCxtInfo *hci,LabId labid)$/;"	f
GetHCIModel	HTKLib/HNet.c	/^HLink GetHCIModel(HMMSetCxtInfo *hci,int lc,LabId name,int rc)$/;"	f
GetHMMDef	HTKLib/HModel.c	/^static ReturnStatus GetHMMDef(HMMSet *hset, Source *src, Token *tok,$/;"	f	file:
GetHMMSetCxtInfo	HTKLib/HNet.c	/^HMMSetCxtInfo *GetHMMSetCxtInfo(HMMSet *hset, Boolean frcCxtInd)$/;"	f
GetHTKHeaderInfo	HTKLib/HWave.c	/^static long GetHTKHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetHashCounts	HTKLib/HModel.c	/^static void GetHashCounts(MLink * mtab,int size, int *min, int *max,$/;"	f	file:
GetHeader	HTKLVRec/kenlm/lm/builder/output.hh	/^    const HeaderInfo &GetHeader() const { return header_; }$/;"	f	class:lm::builder::Output
GetHeader	HTKLVRec/kenlm/lm/builder/output.hh	/^inline const HeaderInfo &OutputHook::GetHeader() const {$/;"	f	class:lm::builder::OutputHook
GetHeaderStr	HLMLib/LUtil.c	/^static void GetHeaderStr(char *s, char *buf)$/;"	f	file:
GetHitRate	HTKTools/HResults.c	/^float GetHitRate(int idx, int FAperHour)$/;"	f
GetHook	HTKLib/HMem.c	/^Ptr GetHook(Ptr m)$/;"	f
GetInLine	HLMLib/LModel.c	/^static char *GetInLine(Source *src,char *buf)$/;"	f	file:
GetInLine	HTKLib/HLM.c	/^static char *GetInLine(char *buf)$/;"	f	file:
GetInputObs	HTKLib/HFB.c	/^void GetInputObs( UttInfo *utt, int t, HSetKind hsKind )$/;"	f
GetInputXForm	HTKLib/HModel.c	/^InputXForm* GetInputXForm(HMMSet *hset, Source *src, Token *tok)$/;"	f
GetInsetGram	HLMLib/LGBase.c	/^static void GetInsetGram(NGInputSet *inset, NGram ng, float *wt)$/;"	f	file:
GetInt	HTKLib/HLM.c	/^static int GetInt(void)$/;"	f	file:
GetInt	HTKLib/HUtil.c	/^static int GetInt(int lo, int hi)$/;"	f	file:
GetIntArg	HTKLib/HShell.c	/^int GetIntArg(void)$/;"	f
GetIntEnvVar	HTKLib/HShell.c	/^Boolean GetIntEnvVar(char *envVar, int *value)$/;"	f
GetIntField	HTKLib/HNet.c	/^static int GetIntField(char ntype,char del,char *vbuf,Source *src)$/;"	f	file:
GetItem	HTKLib/HTrain.c	/^Ptr GetItem(Sequence seq, int i)$/;"	f
GetKey	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  Key GetKey() const { return key; }$/;"	f	struct:lm::builder::__anon43::DedupeEntry
GetKey	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  uint64_t GetKey() const { return key; }$/;"	f	struct:lm::builder::__anon43::VocabEntry
GetKey	HTKLVRec/kenlm/lm/search_hashed.hh	/^  uint64_t GetKey() const {$/;"	f	struct:lm::ngram::detail::ProbEntry
GetKey	HTKLVRec/kenlm/lm/value.hh	/^    Key GetKey() const { return key; }$/;"	f	struct:lm::ngram::RestValue::ProbingEntry
GetKey	HTKLVRec/kenlm/lm/value.hh	/^    uint64_t GetKey() const { return key; }$/;"	f	struct:lm::ngram::BackoffValue::ProbingEntry
GetKey	HTKLVRec/kenlm/lm/vocab.hh	/^  uint64_t GetKey() const { return key; }$/;"	f	struct:lm::ngram::ProbingVocabularyEntry
GetKey	HTKLVRec/kenlm/util/joint_sort.hh	/^      const typename std::iterator_traits<KeyIter>::value_type &GetKey() const { return key; }$/;"	f	struct:util::detail::JointProxy::__anon74
GetKey	HTKLVRec/kenlm/util/joint_sort.hh	/^    typename std::iterator_traits<KeyIter>::reference GetKey() const {$/;"	f	class:util::detail::JointProxy
GetKey	HTKLib/HUtil.c	/^static Keyword GetKey(void)$/;"	f	file:
GetLMEntry	HTKLVRec/HLVLM.c	/^static void GetLMEntry (FSLM_ngram *nglm, Source *src, Boolean bin, int n, LMId *ndx, $/;"	f	file:
GetLMHdrInt	HLMLib/LUtil.c	/^Boolean GetLMHdrInt(char *name, int *value, LMFileHdr hdr)$/;"	f
GetLMHdrStr	HLMLib/LUtil.c	/^char * GetLMHdrStr(char *name, LMFileHdr hdr, Boolean ucase)$/;"	f
GetLMProb	HTKLib/HLM.c	/^float GetLMProb(LModel *lm, LabId prid[NSIZE], LabId wdid)$/;"	f
GetLMWord	HTKLVRec/HLVLM.c	/^static void GetLMWord (Source *src, char *buf, Boolean raw)$/;"	f	file:
GetLabDistance	HTKTools/HSLab.c	/^LLink GetLabDistance(LabList *ll, long t, long st, long en, Boolean *isStart)$/;"	f
GetLabId	HTKLib/HLabel.c	/^LabId GetLabId(char *name, Boolean insert)$/;"	f
GetLabN	HTKLib/HLabel.c	/^LLink GetLabN(LabList *ll, int n)$/;"	f
GetLabT	HTKTools/HSLab.c	/^LLink GetLabT(LabList *ll, long t)$/;"	f
GetLabelList	HTKLib/HLabel.c	/^LabList* GetLabelList(Transcription *t, int n)$/;"	f
GetLattice	HTKLib/HLat.c	/^Lattice *GetLattice (char *fn, char *path, char *ext,$/;"	f
GetLinXForm	HTKLib/HModel.c	/^static LinXForm* GetLinXForm(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetLine	HTKLib/esignal.c	/^GetLine(char    *buf,$/;"	f	file:
GetLong	HTKLib/esignal.c	/^GetLong(long    *val,$/;"	f	file:
GetLongArg	HTKLib/HShell.c	/^long GetLongArg(void)$/;"	f
GetLowestNegError	HTKLib/HFBLat.c	/^float GetLowestNegError(int tStart, int tEnd, int tCurr, float curr_corr, float curr_total,  CorrectArcList **correctArc, int iphone, int *compute_count, Boolean hyp_is_sil){$/;"	f
GetMEIndex	HLMLib/LWMap.c	/^int GetMEIndex(WordMap *wm, int ndx)$/;"	f
GetMInfo	HTKLib/HAdapt.c	/^static MInfo *GetMInfo(MixPDF *mp)$/;"	f	file:
GetMLFFile	HTKLib/HLabel.c	/^FILE *GetMLFFile(int fidx)$/;"	f
GetMLFTable	HTKLib/HLabel.c	/^MLFEntry *GetMLFTable(void)$/;"	f
GetMLLRDiagCov	HTKLib/HAdapt.c	/^AdaptXForm *GetMLLRDiagCov(AdaptXForm *xform)$/;"	f
GetMMIAccMix	HTKTools/HMMIRest.c	/^static void GetMMIAccMix(int stream, MixPDF *mp)$/;"	f	file:
GetMacroHook	HTKLib/HUtil.c	/^Ptr GetMacroHook(MLink ml)$/;"	f
GetMacroUse	HTKLib/HUtil.c	/^int GetMacroUse(MLink ml)$/;"	f
GetMean	HTKLib/HModel.c	/^static SVector GetMean(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetMixPDF	HTKLib/HModel.c	/^static MixPDF *GetMixPDF(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetMixPDFInfo	HTKLib/HModel.c	/^static void GetMixPDFInfo(HMMSet *hset, HMMDef *hmm, MixtureElem *tme, int *state, int *stream, int *comp)$/;"	f	file:
GetMixture	HTKLib/HModel.c	/^static ReturnStatus GetMixture(HMMSet *hset,Source *src,Token *tok,int M,MixtureElem *spdf)$/;"	f	file:
GetNEntry	HTKLVRec/HLVLM.c	/^NEntry *GetNEntry (FSLM_ngram *nglm, LMId ndx[NSIZE], Boolean create)$/;"	f
GetNEntry	HTKLib/HLM.c	/^NEntry *GetNEntry(NGramLM *nglm,lmId ndx[NSIZE],Boolean create)$/;"	f
GetNGramAddress	HLMLib/LModel.c	/^void *GetNGramAddress(BackOffLM *lm, NameId *words, int nSize)$/;"	f
GetNGramProb	HLMLib/LModel.c	/^float GetNGramProb(BackOffLM *lm, NameId *words, int nSize)$/;"	f
GetNGramProbVecSE	HLMLib/LModel.c	/^float *GetNGramProbVecSE(BackOffLM *lm, int *nId, int nSize, FLEntry *parent)$/;"	f
GetNGramProbs	HLMLib/LModel.c	/^void GetNGramProbs(BackOffLM *lm, UInt *nId, int nSize, SMEntry *seBuf, int seBufSize)$/;"	f
GetNISTHeaderInfo	HTKLib/HWave.c	/^static long GetNISTHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetNISTIVal	HTKLib/HWave.c	/^static int GetNISTIVal(FILE *f)$/;"	f	file:
GetNISTSVal	HTKLib/HWave.c	/^static void GetNISTSVal(FILE *f, char *s)$/;"	f	file:
GetNISTToken	HTKLib/HWave.c	/^static char * GetNISTToken(FILE *f,char *buf)$/;"	f	file:
GetNOHEADHeaderInfo	HTKLib/HWave.c	/^static long GetNOHEADHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetNameId	HLMLib/LUtil.c	/^NameId GetNameId(HashTab *htab, char *name, Boolean insert)$/;"	f
GetNextArg	HTKLib/HShell.c	/^static char * GetNextArg(Boolean step)$/;"	f	file:
GetNextFieldName	HTKLib/HNet.c	/^static char *GetNextFieldName(char *buf, char *del, Source *src)$/;"	f	file:
GetNextNGram	HLMLib/LGBase.c	/^Boolean GetNextNGram(NGInputSet *inset, NGram ng, float *count, int N)$/;"	f
GetNoContextPhone	HTKLib/HFBLat.c	/^int GetNoContextPhone(LabId phone, int *nStates_quinphone\/*actually,number of HMMs per phone*\/, int *state_quinphone, HArc *a, int *frame_end){ $/;"	f
GetNode	HTKLib/HVQ.c	/^static VQNode GetNode(Source *src, CovKind ck, short width)$/;"	f	file:
GetNode	HTKTools/HHEd.c	/^static Node *GetNode(Node *node,int n)$/;"	f	file:
GetNonSpace	HTKLib/esig_asc.c	/^GetNonSpace(FILE *file)$/;"	f	file:
GetNumPhones	HTKLib/HExactMPE.c	/^int GetNumPhones(LArc *larc){ \/*returns num phones in a word...*\/$/;"	f
GetOGIHeaderInfo	HTKLib/HWave.c	/^static long GetOGIHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetObsCache	HTKLib/HAdapt.c	/^static ObsCache *GetObsCache(MixPDF *mp)$/;"	f	file:
GetOption	HTKLib/HModel.c	/^static ReturnStatus GetOption(HMMSet *hset, Source *src, Token *tok, int *nState)$/;"	f	file:
GetOptions	HTKLib/HModel.c	/^static ReturnStatus GetOptions(HMMSet *hset, Source *src, Token *tok, int *nState)$/;"	f	file:
GetPAAccCache	HTKLib/HAdapt.c	/^static AccCache *GetPAAccCache(MixPDF *mp)$/;"	f	file:
GetPAInfo	HTKLib/HAdapt.c	/^static AInfo *GetPAInfo(MixPDF *mp)$/;"	f	file:
GetPAObsCache	HTKLib/HAdapt.c	/^static ObsCache *GetPAObsCache(MixPDF *mp)$/;"	f	file:
GetParm	HTKLib/HParm.c	/^static int GetParm(ParmBuf pbuf,int nFrame,void *data)$/;"	f	file:
GetPart	HTKTools/HLEd.c	/^LabId GetPart(LabId id, int n)$/;"	f
GetProb	HLMTools/LPlex.c	/^static double GetProb(LabId *wlab, int nSize)$/;"	f	file:
GetProb	HTKLVRec/HLVLM.c	/^static LogFloat GetProb(Source *src, Boolean bin)$/;"	f	file:
GetRNode	HTKTools/HHEd.c	/^static RNode *GetRNode(RegNode *n) $/;"	f	file:
GetRawAudio	HTKLib/HAudio.c	/^void GetRawAudio(AudioIn a, int nSamples, short *buf)$/;"	f
GetRegAcc	HTKLib/HAdapt.c	/^static RegAcc *GetRegAcc(MixPDF *mp)$/;"	f	file:
GetRegTree	HTKLib/HAdapt.c	/^static RegTree* GetRegTree(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
GetRegTree	HTKLib/HModel.c	/^static RegTree *GetRegTree(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetRegionAB	HTKTools/HSLab.c	/^Boolean GetRegionAB(int *pa, int *pb)$/;"	f
GetReplayBuf	HTKLib/HAudio.c	/^int GetReplayBuf(AudioIn a, int nSamples, short *buf)$/;"	f
GetRowLike	HTKLib/HAdapt.c	/^static double GetRowLike(DMatrix gmat,DVector kmat, DVector cofact, double occ, DVector w)$/;"	f	file:
GetSCRIBEHeaderInfo	HTKLib/HWave.c	/^static long GetSCRIBEHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetSDES1HeaderInfo	HTKLib/HWave.c	/^static long GetSDES1HeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetSUNAU8HeaderInfo	HTKLib/HWave.c	/^static long GetSUNAU8HeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetSWeights	HTKLib/HModel.c	/^static SVector GetSWeights(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetSampleFromBuffer	HTKLib/HAudio.c	/^static short GetSampleFromBuffer(AudioIn a)$/;"	f	file:
GetScribeLab	HTKLib/HLabel.c	/^static ScribeLab GetScribeLab(Source *src)$/;"	f	file:
GetSegObs	HTKLib/HTrain.c	/^Observation GetSegObs(SegStore ss, int i, int j)$/;"	f
GetSemiTiedLike	HTKLib/HAdapt.c	/^static double GetSemiTiedLike(AccStruct *accs, LinXForm *xf)$/;"	f	file:
GetSemiTiedTotCov	HTKLib/HAdapt.c	/^static void GetSemiTiedTotCov(AdaptXForm *xform, IntVec classes, TriMat totCov, Vector totMean)$/;"	f	file:
GetShortPackBlock	HTKLib/HWave.c	/^static int GetShortPackBlock(char **inData, short **outData)$/;"	f	file:
GetSpeaker	HTKTools/HResults.c	/^Spkr *GetSpeaker(void)$/;"	f
GetSplitThresh	HTKLib/HAdapt.c	/^static float GetSplitThresh(AdaptXForm *xform)$/;"	f	file:
GetSrcString	HLMLib/LWMap.c	/^Boolean GetSrcString(Source *src, char *s, Boolean htkEsc)$/;"	f
GetState	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> void GenericModel<Search, VocabularyT>::GetState(const WordIndex *context_rbegin, const WordIndex *context_rend, State &out_state) const {$/;"	f	class:lm::ngram::detail::GenericModel
GetStateInfo	HTKLib/HModel.c	/^static StateInfo *GetStateInfo(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetStrArg	HTKLib/HShell.c	/^char * GetStrArg(void)$/;"	f
GetStream	HTKLib/HModel.c	/^static ReturnStatus GetStream(HMMSet *hset, Source *src, Token *tok,$/;"	f	file:
GetString	HTKTools/HSLab.c	/^Boolean GetString(RectWin *win, char *str, short minlen, short maxlen)$/;"	f
GetStructure	HTKLib/HModel.c	/^static Ptr GetStructure(HMMSet *hset, Source *src, char type)$/;"	f	file:
GetSubLat	HTKLib/HNet.c	/^static Lattice *GetSubLat(LabId subLatId,Lattice *subLat)$/;"	f	file:
GetSwtArg	HTKLib/HShell.c	/^char * GetSwtArg(void)$/;"	f
GetTIMITHeaderInfo	HTKLib/HWave.c	/^static long GetTIMITHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetTables	HTKLVRec/kenlm/lm/quantize.hh	/^    const Bins *GetTables(unsigned char order_minus_2) const { return tables_[order_minus_2]; }$/;"	f	class:lm::ngram::SeparatelyQuantize
GetTiedMixtures	HTKLib/HModel.c	/^ReturnStatus GetTiedMixtures(HMMSet *hset, Source *src, Token *tok, $/;"	f
GetTiedWeights	HTKLib/HModel.c	/^ReturnStatus GetTiedWeights(Source *src, Token *tok, int M, Vector tpdf)$/;"	f
GetTimes	HTKLib/HFBLat.c	/^void GetTimes(LArc *larc, int i, int *start, int *end){ \/* get start & end times for a lattice arc.  Frame$/;"	f
GetToken	HTKLib/HModel.c	/^static ReturnStatus GetToken(Source *src, Token *tok)$/;"	f	file:
GetTrSym	HTKLib/HLabel.c	/^static void GetTrSym(Source *src, Boolean htk)$/;"	f	file:
GetTransMat	HTKLib/HModel.c	/^static SMatrix GetTransMat(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetTransform	HTKLib/HModel.c	/^static SMatrix GetTransform(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetTreeVector	HTKTools/HHEd.c	/^static void GetTreeVector(RegNode **nVec, RegNode *t) $/;"	f	file:
GetUse	HTKLib/HMem.c	/^int  GetUse(Ptr m)$/;"	f
GetVQ	HTKLib/HVQ.c	/^void GetVQ(VQTable vqTab, int numS, Vector *fv, short *vq)$/;"	f
GetVal	HTKLib/HVQ.c	/^static short GetVal(Source *src, short lo, short hi, char *item)$/;"	f	file:
GetVariance	HTKLib/HModel.c	/^static SVector GetVariance(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetVecSizeClass	HTKLib/HAdapt.c	/^static int GetVecSizeClass(BaseClass *bclass, int classIdx)$/;"	f	file:
GetVocabFD	HTKLVRec/kenlm/lm/builder/output.hh	/^    int GetVocabFD() const { return vocab_fd_; }$/;"	f	class:lm::builder::Output
GetVocabFD	HTKLVRec/kenlm/lm/builder/output.hh	/^inline int OutputHook::GetVocabFD() const {$/;"	f	class:lm::builder::OutputHook
GetVocabulary	HTKLVRec/kenlm/lm/facade.hh	/^    const Vocabulary &GetVocabulary() const { return *static_cast<const Vocabulary*>(&BaseVocabulary()); }$/;"	f	class:lm::base::ModelFacade
GetWAVHeaderInfo	HTKLib/HWave.c	/^static long GetWAVHeaderInfo(FILE *f, Wave w, InputAction *ia)$/;"	f	file:
GetWall	HTKLVRec/kenlm/util/usage.cc	/^Wall GetWall() {$/;"	f	namespace:util::__anon83
GetWave	HTKLib/HWave.c	/^void GetWave(Wave w, int nFrames, float *buf)$/;"	f
GetWaveDirect	HTKLib/HWave.c	/^short *GetWaveDirect(Wave w, long *nSamples)$/;"	f
GetWavePtrPos	HTKTools/HSLab.c	/^Boolean GetWavePtrPos(void)$/;"	f
GetWdBeginNum	HTKTools/HParse.c	/^int GetWdBeginNum(Link p)$/;"	f
GetWinKind	HTKTools/HSLab.c	/^WinKind GetWinKind(HEventRec hev)$/;"	f
GetWord	HTKLib/HDict.c	/^Word GetWord(Vocab *voc, LabId wordName, Boolean insert)$/;"	f
GetWordClassEntry	HLMLib/LCMap.c	/^ClassEntry *GetWordClassEntry(ClassMap *c, int wdndx)$/;"	f
GetXFormMacros	HTKLib/HModel.c	/^static ReturnStatus GetXFormMacros(HMMSet *hset, Source *src, Token *tok, int fidx)$/;"	f	file:
GetXFormSet	HTKLib/HModel.c	/^static XFormSet* GetXFormSet(HMMSet *hset, Source *src, Token *tok)$/;"	f	file:
GetXFormStream	HTKLib/HAdapt.c	/^static int GetXFormStream(AdaptXForm *xform, IntVec classes, IntVec streams)$/;"	f	file:
GiveDimMixD	HTKTools/HMMIRest.c	/^float GiveDimMixD(MixPDF *mp, int k, int priortype){$/;"	f
GiveMixD	HTKTools/HMMIRest.c	/^float GiveMixD(MixPDF *mp, int stream, int priortype){$/;"	f
Givens	HTKLib/HMath.c	/^static void Givens(double x, double y, double *c, double *s)$/;"	f	file:
GoNextHMM	HTKLib/HUtil.c	/^Boolean GoNextHMM(HMMScanState *hss)$/;"	f
GoNextMix	HTKLib/HUtil.c	/^Boolean GoNextMix(HMMScanState *hss, Boolean noSkip)$/;"	f
GoNextState	HTKLib/HUtil.c	/^Boolean GoNextState(HMMScanState *hss, Boolean noSkip)$/;"	f
GoNextStream	HTKLib/HUtil.c	/^Boolean GoNextStream(HMMScanState *hss, Boolean noSkip)$/;"	f
Gram	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    void Gram(unsigned \/*order_minus_1*\/, float full_backoff, ProbBackoff &out) const {$/;"	f	class:lm::builder::__anon46::OutputProbBackoff
Gram	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    void Gram(unsigned order_minus_1, float full_backoff, ProbBackoff &out) {$/;"	f	class:lm::builder::__anon46::OutputQ
Gram	HTKLVRec/kenlm/lm/search_trie.cc	/^  Gram(const WordIndex *in_begin, unsigned char order) : begin(in_begin), end(in_begin + order) {}$/;"	f	struct:lm::ngram::trie::__anon58::Gram
Gram	HTKLVRec/kenlm/lm/search_trie.cc	/^struct Gram {$/;"	s	namespace:lm::ngram::trie::__anon58	file:
GramEntry	HTKTools/HBuild.c	/^}GramEntry;$/;"	t	typeref:struct:_GramEntry	file:
GramFile	HLMLib/LGBase.h	/^}GramFile;$/;"	t	typeref:struct:gramfile
Greater	HTKLVRec/kenlm/util/stream/sort.hh	/^        explicit Greater(const Compare &compare) : compare_(compare) {}$/;"	f	class:util::stream::MergeQueue::Greater
Greater	HTKLVRec/kenlm/util/stream/sort.hh	/^    class Greater : public std::binary_function<const Entry &, const Entry &, bool> {$/;"	c	class:util::stream::MergeQueue
Grisu3	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^static bool Grisu3(double v,$/;"	f	namespace:double_conversion
Grisu3Counted	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^static bool Grisu3Counted(double v,$/;"	f	namespace:double_conversion
GrowForSearch	HTKLVRec/kenlm/lm/binary_format.cc	/^void *BinaryFormat::GrowForSearch(std::size_t memory_size, std::size_t vocab_pad, void *&vocab_base) {$/;"	f	class:lm::ngram::BinaryFormat
GrowableVocab	HTKLVRec/kenlm/lm/vocab.hh	/^    template <class NewWordConstruct> GrowableVocab(WordIndex initial_size, const NewWordConstruct &new_word_construct = NewWordAction())$/;"	f	class:lm::ngram::GrowableVocab
GrowableVocab	HTKLVRec/kenlm/lm/vocab.hh	/^template <class NewWordAction = NoOpUniqueWords> class GrowableVocab {$/;"	c	namespace:lm::ngram
GuardLarge	HTKLVRec/kenlm/util/file.cc	/^std::size_t GuardLarge(std::size_t size) {$/;"	f	namespace:util::__anon68
GuessPhysicalMemory	HTKLVRec/kenlm/util/usage.cc	/^uint64_t GuessPhysicalMemory() {$/;"	f	namespace:util
GwGw	HLMTools/Cluster.c	/^static int         GwGw, gGw, Gwg, gg;      \/* Special-case class counts *\/$/;"	v	file:
Gwg	HLMTools/Cluster.c	/^static int         GwGw, gGw, Gwg, gg;      \/* Special-case class counts *\/$/;"	v	file:
HASACCS	HTKLib/HParm.h	61;"	d
HASCOMPX	HTKLib/HParm.h	62;"	d
HASCRCC	HTKLib/HParm.h	64;"	d
HASDELTA	HTKLib/HParm.h	60;"	d
HASENERGY	HTKLib/HParm.h	58;"	d
HASH1	HTKLVRec/HLVNet.c	211;"	d	file:
HASH2	HTKLVRec/HLVNet.c	212;"	d	file:
HASHSIZE	HTKLib/HLabel.c	135;"	d	file:
HASH_PROBING	HTKLVRec/kenlm/lm/model_type.hh	/^const ModelType HASH_PROBING = PROBING;$/;"	m	namespace:lm::ngram
HASNULLE	HTKLib/HParm.h	59;"	d
HASTHIRD	HTKLib/HParm.h	67;"	d
HASVQ	HTKLib/HParm.h	66;"	d
HASZEROC	HTKLib/HParm.h	65;"	d
HASZEROM	HTKLib/HParm.h	63;"	d
HAS_BOWT	HLMLib/LModel.h	66;"	d
HAUDIO	HTKLib/HWave.h	/^        HAUDIO,            \/* Direct Audio Input *\/$/;"	e	enum:__anon181
HA_IN_LINE	HTKLib/HAudio.h	42;"	d
HA_IN_MIC	HTKLib/HAudio.h	41;"	d
HA_IN_NONE	HTKLib/HAudio.h	40;"	d
HA_OUT_LINE	HTKLib/HAudio.h	37;"	d
HA_OUT_NONE	HTKLib/HAudio.h	34;"	d
HA_OUT_PHONES	HTKLib/HAudio.h	36;"	d
HA_OUT_SPEAKER	HTKLib/HAudio.h	35;"	d
HArc	HTKLib/HArc.h	/^typedef struct _Arc HArc;$/;"	t	typeref:struct:_Arc
HButton	HTKLib/HGraf.h	/^} HButton;$/;"	t	typeref:struct:_HButton
HCI_CXT_BLOCKSIZE	HTKLib/HNet.c	1736;"	d	file:
HColour	HTKLib/HGraf.h	/^typedef enum _HColour HColour;  \/* implementations may map these onto grey *\/$/;"	t	typeref:enum:_HColour
HCopyArea	HTKLib/HGraf.c	/^void HCopyArea(int srcx, int srcy, int width, int height, int destx, int desty)$/;"	f
HCopyArea	HTKLib/HGraf.null.c	/^void HCopyArea(int srcx, int srcy, int width, int height, int destx, int desty)$/;"	f
HCopyArea	HTKLib/HGraf_WIN32.c	/^void HCopyArea(int srcx, int srcy, int width, int height, int destx, int desty)$/;"	f
HDrawArc	HTKLib/HGraf.c	/^void HDrawArc(int x0, int y0, int x1, int y1, int stAngle, int arcAngle)$/;"	f
HDrawArc	HTKLib/HGraf.null.c	/^void HDrawArc(int x0, int y0, int x1, int y1, int stAngle, int arcAngle)$/;"	f
HDrawArc	HTKLib/HGraf_WIN32.c	/^void HDrawArc(int x0, int y0, int x1, int y1, int stAngle, int arcAngle)$/;"	f
HDrawImage	HTKLib/HGraf.c	/^void HDrawImage(unsigned char *p, int x, int y, int width, int height)$/;"	f
HDrawImage	HTKLib/HGraf.null.c	/^void HDrawImage(unsigned char *p, int x, int y, int width, int height)$/;"	f
HDrawImage	HTKLib/HGraf_WIN32.c	/^void HDrawImage(unsigned char *p, int x, int y, int width, int height)$/;"	f
HDrawLine	HTKLib/HGraf.c	/^void HDrawLine(int x0, int y0, int x1, int y1)$/;"	f
HDrawLine	HTKLib/HGraf.null.c	/^void HDrawLine(int x0, int y0, int x1, int y1)$/;"	f
HDrawLine	HTKLib/HGraf_WIN32.c	/^void HDrawLine(int x0, int y0, int x1, int y1)$/;"	f
HDrawLines	HTKLib/HGraf.c	/^void HDrawLines(HPoint *points, int n)$/;"	f
HDrawLines	HTKLib/HGraf.null.c	/^void HDrawLines(HPoint *points, int n)$/;"	f
HDrawLines	HTKLib/HGraf_WIN32.c	/^void HDrawLines(HPoint *points, int n)$/;"	f
HDrawRectangle	HTKLib/HGraf.c	/^void HDrawRectangle(int x0, int y0, int x1, int y1)$/;"	f
HDrawRectangle	HTKLib/HGraf.null.c	/^void HDrawRectangle(int x0, int y0, int x1, int y1)$/;"	f
HDrawRectangle	HTKLib/HGraf_WIN32.c	/^void HDrawRectangle(int x0, int y0, int x1, int y1)$/;"	f
HDumpGraf	HTKLib/HGraf.c	/^void HDumpGraf(char *fname)$/;"	f
HDumpGraf	HTKLib/HGraf.null.c	/^void HDumpGraf(char *fname)$/;"	f
HDumpGraf	HTKLib/HGraf_WIN32.c	/^void HDumpGraf(char *fname)$/;"	f
HEADER	HTKLVRec/Makefile	/^HEADER = HLVLM.h  HLVModel.h  HLVNet.h  HLVRec.h config.h$/;"	m
HEIGHT	HTKTools/HSLab.c	79;"	d	file:
HEndSpoolGraf	HTKLib/HGraf_WIN32.c	/^void HEndSpoolGraf()$/;"	f
HError	HTKLib/HShell.c	/^void HError(int errcode, char *message, ...)$/;"	f
HEvent	HTKLib/HGraf.h	/^typedef enum _HEvent HEvent;$/;"	t	typeref:enum:_HEvent
HEventRec	HTKLib/HGraf.h	/^} HEventRec;$/;"	t	typeref:struct:__anon103
HEventsPending	HTKLib/HGraf.c	/^int HEventsPending(void)$/;"	f
HEventsPending	HTKLib/HGraf.null.c	/^int HEventsPending(void)$/;"	f
HEventsPending	HTKLib/HGraf_WIN32.c	/^int HEventsPending(void)$/;"	f
HFieldList	HTKLib/HWave.h	/^typedef struct FieldSpec **HFieldList;$/;"	t	typeref:struct:FieldSpec
HFillArc	HTKLib/HGraf.c	/^void HFillArc(int x0,int y0,int x1,int y1,int stAngle,int arcAngle)$/;"	f
HFillArc	HTKLib/HGraf.null.c	/^void HFillArc(int x0,int y0,int x1,int y1,int stAngle,int arcAngle)$/;"	f
HFillArc	HTKLib/HGraf_WIN32.c	/^void HFillArc(int x0,int y0,int x1,int y1,int stAngle,int arcAngle)$/;"	f
HFillPolygon	HTKLib/HGraf.c	/^void HFillPolygon(HPoint *points, int n)$/;"	f
HFillPolygon	HTKLib/HGraf.null.c	/^void HFillPolygon(HPoint *points, int n)$/;"	f
HFillPolygon	HTKLib/HGraf_WIN32.c	/^void HFillPolygon(HPoint *points, int n)$/;"	f
HFillRectangle	HTKLib/HGraf.c	/^void HFillRectangle(int x0, int y0, int x1, int y1)$/;"	f
HFillRectangle	HTKLib/HGraf.null.c	/^void HFillRectangle(int x0, int y0, int x1, int y1)$/;"	f
HFillRectangle	HTKLib/HGraf_WIN32.c	/^void HFillRectangle(int x0, int y0, int x1, int y1)$/;"	f
HFlush	HTKLib/HGraf.c	/^void HFlush(void)$/;"	f
HFlush	HTKLib/HGraf.null.c	/^void HFlush(void)$/;"	f
HFlush	HTKLib/HGraf_WIN32.c	/^void HFlush(void)$/;"	f
HGWinFunc	HTKLib/HGraf_WIN32.c	/^LRESULT CALLBACK HGWinFunc(HWND WindowHandle, unsigned int msg, WPARAM wParam, LPARAM lParam)$/;"	f
HGetEvent	HTKLib/HGraf.c	/^HEventRec HGetEvent(Boolean anyEvent, void (*action)(void))$/;"	f
HGetEvent	HTKLib/HGraf.null.c	/^HEventRec HGetEvent(Boolean anyEvent, void (*action)(void))$/;"	f
HGetEvent	HTKLib/HGraf_WIN32.c	/^HEventRec HGetEvent(Boolean anyEvent, void (*action)(void))$/;"	f
HGetKeyType	HTKLib/HGraf_WIN32.c	/^KeyType HGetKeyType(char c)$/;"	f
HIFREQ	HTKLib/HParm.c	/^   HIFREQ,        \/* Hi Fbank frequency *\/$/;"	e	enum:__anon142	file:
HK	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon199	file:
HKEYPRESS	HTKLib/HGraf.h	/^              HKEYPRESS,   \/* key pressed *\/$/;"	e	enum:_HEvent
HKEYRELEASE	HTKLib/HGraf.h	/^              HKEYRELEASE, \/* key released *\/$/;"	e	enum:_HEvent
HLAT_ACLIKE	HTKLib/HNet.h	81;"	d
HLAT_ALABS	HTKLib/HNet.h	77;"	d
HLAT_ALDUR	HTKLib/HNet.h	84;"	d
HLAT_ALIGN	HTKLib/HNet.h	83;"	d
HLAT_ALLIKE	HTKLib/HNet.h	85;"	d
HLAT_DEFAULT	HTKLib/HNet.h	94;"	d
HLAT_LBIN	HTKLib/HNet.h	78;"	d
HLAT_LMLIKE	HTKLib/HNet.h	82;"	d
HLAT_NOSORT	HTKLib/HNet.h	89;"	d
HLAT_NOSUBS	HTKLib/HNet.h	90;"	d
HLAT_PRLIKE	HTKLib/HNet.h	86;"	d
HLAT_PRON	HTKLib/HNet.h	80;"	d
HLAT_SHARC	HTKLib/HNet.h	92;"	d
HLAT_TAGS	HTKLib/HNet.h	87;"	d
HLAT_TIMES	HTKLib/HNet.h	79;"	d
HLIBS	HLMTools/Makefile	/^HLIBS   = 	$(hlib)\/HTKLib.a $(llib)\/HLMLib.a$/;"	m
HLIBS	HTKLib/Makefile	/^HLIBS = ${exec_prefix}\/lib\/HTKLib.a$/;"	m
HLMLIB	Makefile	/^HLMLIB  = HLMLib$/;"	m
HLMTOOLS	Makefile	/^HLMTOOLS = HLMTools$/;"	m
HLVMODEL_BLOCK_BASE	HTKLVRec/HLVModel.h	135;"	d
HLVMODEL_BLOCK_GCONST	HTKLVRec/HLVModel.h	138;"	d
HLVMODEL_BLOCK_GCONST_OFFSET	HTKLVRec/HLVModel.h	136;"	d
HLVMODEL_BLOCK_INVVAR_OFFSET	HTKLVRec/HLVModel.h	143;"	d
HLVMODEL_BLOCK_MEAN_OFFSET	HTKLVRec/HLVModel.h	142;"	d
HLVMODEL_BLOCK_MIXW	HTKLVRec/HLVModel.h	139;"	d
HLVMODEL_BLOCK_MIXW_OFFSET	HTKLVRec/HLVModel.h	137;"	d
HLVMODEL_BLOCK_MPDF	HTKLVRec/HLVModel.h	141;"	d
HLVMODEL_BLOCK_NMIX	HTKLVRec/HLVModel.h	140;"	d
HLVMODEL_VEC_ALIGN	HTKLVRec/HLVModel.h	95;"	d
HLVMODEL_VEC_PAD	HTKLVRec/HLVModel.h	96;"	d
HLink	HTKLib/HModel.h	/^typedef HMMDef * HLink;$/;"	t
HMError	HTKLib/HModel.c	/^static void HMError(Source *src, char *message)$/;"	f	file:
HMMDef	HTKLib/HModel.h	/^} HMMDef;$/;"	t	typeref:struct:__anon128
HMMDefFilter	HTKLib/HShell.h	/^   HMMDefFilter,    \/* HMM definition files input via HModel *\/$/;"	e	enum:__anon153
HMMDefOFilter	HTKLib/HShell.h	/^   HMMDefOFilter,   \/* HMM definition files output via HModel *\/$/;"	e	enum:__anon153
HMMListFilter	HTKLib/HShell.h	/^   HMMListFilter,   \/* HMM lists input via HModel *\/$/;"	e	enum:__anon153
HMMListOFilter	HTKLib/HShell.h	/^   HMMListOFilter,  \/* HMM lists output via HModel *\/$/;"	e	enum:__anon153
HMMPhysName	HTKLib/HUtil.c	/^char *HMMPhysName(HMMSet *hset,HLink hmm)$/;"	f
HMMSETID	HTKLib/HModel.c	/^   HMMSETID=119,$/;"	e	enum:__anon117	file:
HMMScanState	HTKLib/HUtil.h	/^}HMMScanState;$/;"	t	typeref:struct:__anon169
HMMSet	HTKLib/HModel.h	/^} HMMSet;$/;"	t	typeref:struct:_HMMSet
HMMSetCxtInfo	HTKLib/HNet.h	/^HMMSetCxtInfo;$/;"	t	typeref:struct:hmmsetcxtinfo
HMOUSEDOWN	HTKLib/HGraf.h	/^enum _HEvent {HMOUSEDOWN,  \/* (left) mouse button pressed *\/$/;"	e	enum:_HEvent
HMOUSEMOVE	HTKLib/HGraf.h	/^              HMOUSEMOVE,  \/* mouse has moved *\/$/;"	e	enum:_HEvent
HMOUSEUP	HTKLib/HGraf.h	/^              HMOUSEUP,    \/* (left) mouse button released *\/$/;"	e	enum:_HEvent
HMousePos	HTKLib/HGraf.c	/^Boolean HMousePos(int *x, int *y)$/;"	f
HMousePos	HTKLib/HGraf.null.c	/^Boolean HMousePos(int *x, int *y)$/;"	f
HMousePos	HTKLib/HGraf_WIN32.c	/^Boolean HMousePos(int *x, int *y)$/;"	f
HOR	HTKTools/HResults.c	/^enum _Direction{DIAG,VERT,HOR,NIL};$/;"	e	enum:_Direction	file:
HPNetwork	HTKTools/HParse.c	/^} HPNetwork;$/;"	t	typeref:struct:__anon204	file:
HParmSrcDef	HTKLib/HParm.h	/^typedef struct hparmsrcdef *HParmSrcDef;$/;"	t	typeref:struct:hparmsrcdef
HParmSrcDefRec	HTKLib/HParm.c	/^} HParmSrcDefRec;$/;"	t	typeref:struct:hparmsrcdef	file:
HPlotVector	HTKLib/HGraf.c	/^void HPlotVector(int x0, int y0, int x1, int y1, Vector v, int st, int en, float ymax, float ymin)$/;"	f
HPlotVector	HTKLib/HGraf.null.c	/^void HPlotVector(int x0, int y0, int x1, int y1, Vector v, int st, int en, float ymax, float ymin)$/;"	f
HPlotVector	HTKLib/HGraf_WIN32.c	/^void HPlotVector(int x0, int y0, int x1, int y1, Vector v, int st, int en, float ymax, float ymin)$/;"	f
HPoint	HTKLib/HGraf.h	/^} HPoint;$/;"	t	typeref:struct:__anon104
HPrintf	HTKLib/HGraf.c	/^void HPrintf(int x, int y, char *format, ...)$/;"	f
HPrintf	HTKLib/HGraf.null.c	/^void HPrintf(int x, int y, char *format, ...)$/;"	f
HPrintf	HTKLib/HGraf_WIN32.c	/^void HPrintf(int x, int y, char *format, ...)$/;"	f
HREDRAW	HTKLib/HGraf.h	/^              HREDRAW      \/* window damaged *\/$/;"	e	enum:_HEvent
HRError	HTKLib/HShell.c	/^void HRError(int errcode, char *message, ...)$/;"	f
HSLAB_INFO	HTKTools/HSLab.c	71;"	d	file:
HSLabCmd	HTKTools/HSLab.c	/^   HSLabCmd, HSLabRun$/;"	e	enum:__anon214	file:
HSLabRun	HTKTools/HSLab.c	/^   HSLabCmd, HSLabRun$/;"	e	enum:__anon214	file:
HSetColour	HTKLib/HGraf.c	/^void HSetColour(HColour c)$/;"	f
HSetColour	HTKLib/HGraf.null.c	/^void HSetColour(HColour c)$/;"	f
HSetColour	HTKLib/HGraf_WIN32.c	/^void HSetColour(HColour c)$/;"	f
HSetFontSize	HTKLib/HGraf.c	/^void HSetFontSize(int size)$/;"	f
HSetFontSize	HTKLib/HGraf.null.c	/^void HSetFontSize(int size)$/;"	f
HSetFontSize	HTKLib/HGraf_WIN32.c	/^void HSetFontSize(int size)$/;"	f
HSetGrey	HTKLib/HGraf.c	/^void HSetGrey(int g)$/;"	f
HSetGrey	HTKLib/HGraf.null.c	/^void HSetGrey(int g)$/;"	f
HSetGrey	HTKLib/HGraf_WIN32.c	/^void HSetGrey(int g)$/;"	f
HSetKind	HTKLib/HModel.h	/^typedef enum _HSetKind HSetKind;$/;"	t	typeref:enum:_HSetKind
HSetLineWidth	HTKLib/HGraf.c	/^void HSetLineWidth(int w)$/;"	f
HSetLineWidth	HTKLib/HGraf.null.c	/^void HSetLineWidth(int w)$/;"	f
HSetLineWidth	HTKLib/HGraf_WIN32.c	/^void HSetLineWidth(int w)$/;"	f
HSetXMode	HTKLib/HGraf.c	/^void HSetXMode(XferMode m)$/;"	f
HSetXMode	HTKLib/HGraf.null.c	/^void HSetXMode(XferMode m)$/;"	f
HSetXMode	HTKLib/HGraf_WIN32.c	/^void HSetXMode(XferMode m)$/;"	f
HSlabCmdType	HTKTools/HSLab.c	/^} HSlabCmdType;$/;"	t	typeref:enum:__anon214	file:
HSpoolGraf	HTKLib/HGraf.c	/^void HSpoolGraf(char *fname)$/;"	f
HSpoolGraf	HTKLib/HGraf.null.c	/^void HSpoolGraf(char *fname)$/;"	f
HSpoolGraf	HTKLib/HGraf_WIN32.c	/^void HSpoolGraf(char *fname)$/;"	f
HTK	HTKLib/HWave.h	/^        HTK,               \/* used for both wave and parm files *\/$/;"	e	enum:__anon181
HTK Label Files	HTKBook/labels.tex	/^\\subsection{HTK Label Files}$/;"	b
HTK in Depth	HTKBook/htkbook-pdf.tex	/^\\part{HTK in Depth}$/;"	p
HTK in Depth	HTKBook/htkbook.tex	/^\\part{HTK in Depth}$/;"	p
HTKBOOK	Makefile	/^HTKBOOK = HTKBook$/;"	m
HTKLIB	HTKLVRec/Makefile	/^HTKLIB  = 	$(inc)\/HTKLib.a $/;"	m
HTKLIB	HTKLVRec/Makefile	/^HTKLIB = $(inc)\/HTKLiblv.a$/;"	m
HTKLIB	HTKTools/Makefile	/^HTKLIB = $(inc)\/HTKLib.a $/;"	m
HTKLIB	Makefile	/^HTKLIB  = HTKLib$/;"	m
HTKTOOLS	Makefile	/^HTKTOOLS = HTKTools$/;"	m
HTKhdr	HTKLib/HWave.c	/^} HTKhdr;$/;"	t	typeref:struct:__anon180	file:
HTextHeight	HTKLib/HGraf.c	/^int HTextHeight(char *str)$/;"	f
HTextHeight	HTKLib/HGraf.null.c	/^int HTextHeight(char *str)$/;"	f
HTextHeight	HTKLib/HGraf_WIN32.c	/^int HTextHeight(char *str)$/;"	f
HTextWidth	HTKLib/HGraf.c	/^int HTextWidth(char *str)$/;"	f
HTextWidth	HTKLib/HGraf.null.c	/^int HTextWidth(char *str)$/;"	f
HTextWidth	HTKLib/HGraf_WIN32.c	/^int HTextWidth(char *str)$/;"	f
HTime	HTKLib/HShell.h	/^typedef double HTime;      \/* time in 100ns units *\/$/;"	t
H_EOF	HTKTools/HParse.c	1299;"	d	file:
Ham	HTKLib/HSigP.c	/^void Ham (Vector s)$/;"	f
Handle1PhonePron	HTKLVRec/HLVNet.c	/^void Handle1PhonePron (MemHeap *heap, TLexNet *net, Pron pron)$/;"	f
HandleError	HTKLVRec/kenlm/util/read_compressed.cc	/^    void HandleError(int value) {$/;"	f	class:util::__anon79::BZip	file:
HandleError	HTKLVRec/kenlm/util/read_compressed.cc	/^    void HandleError(lzma_ret value) {$/;"	f	class:util::__anon79::XZip	file:
HandleSpSkipLayer	HTKLVRec/HLVRec-propagate.c	/^void HandleSpSkipLayer (DecoderInst *dec, LexNodeInst *inst)$/;"	f
HandleSpecialValues	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^bool DoubleToStringConverter::HandleSpecialValues($/;"	f	class:double_conversion::DoubleToStringConverter
HandleStrerror	HTKLVRec/kenlm/util/exception.cc	/^const char *HandleStrerror(const char *ret, const char * \/*buf*\/) {$/;"	f	namespace:util::__anon67
HandleStrerror	HTKLVRec/kenlm/util/exception.cc	/^const char *HandleStrerror(int ret, const char *buf) {$/;"	f	namespace:util::__anon67
HandleWordend	HTKLVRec/HLVRec-propagate.c	/^static void HandleWordend (DecoderInst *dec, LexNode *ln)$/;"	f	file:
Handler	HTKLVRec/kenlm/util/thread_pool.hh	/^    typedef HandlerT Handler;$/;"	t	class:util::ThreadPool
Handler	HTKLVRec/kenlm/util/thread_pool.hh	/^    typedef HandlerT Handler;$/;"	t	class:util::Worker
HardAssign	HTKLib/HAdapt.c	/^Boolean HardAssign(AdaptXForm *xform)$/;"	f
HasAccs	HTKLib/HParm.c	/^Boolean HasAccs(ParmKind kind)  {return (Boolean)((kind & HASACCS) != 0);}$/;"	f
HasCompx	HTKLib/HParm.c	/^Boolean HasCompx(ParmKind kind) {return (Boolean)((kind & HASCOMPX) != 0);}$/;"	f
HasConfParm	HTKLib/HShell.c	/^Boolean HasConfParm(ConfParam **list, int size, char *name)$/;"	f
HasCrcc	HTKLib/HParm.c	/^Boolean HasCrcc(ParmKind kind)  {return (Boolean)((kind & HASCRCC) != 0);}$/;"	f
HasDelta	HTKLib/HParm.c	/^Boolean HasDelta(ParmKind kind) {return (Boolean)((kind & HASDELTA) != 0);}$/;"	f
HasDuplicate	HTKTools/HDMan.c	/^Boolean HasDuplicate(DBuffer *db, int pronNum)$/;"	f
HasEnergy	HTKLib/HParm.c	/^Boolean HasEnergy(ParmKind kind){return (Boolean)((kind & HASENERGY) != 0);}$/;"	f
HasExtension	HTKLVRec/kenlm/lm/blank.hh	/^inline bool HasExtension(const float &backoff) {$/;"	f	namespace:lm::ngram
HasMacros	HTKLib/HModel.c	/^Boolean HasMacros(HMMSet *hset, char * types)$/;"	f
HasNulle	HTKLib/HParm.c	/^Boolean HasNulle(ParmKind kind) {return (Boolean)((kind & HASNULLE) != 0);}$/;"	f
HasThird	HTKLib/HParm.c	/^Boolean HasThird(ParmKind kind) {return (Boolean)((kind & HASTHIRD) != 0);}$/;"	f
HasVQ	HTKLib/HParm.c	/^Boolean HasVQ(ParmKind kind)    {return (Boolean)((kind & HASVQ) != 0);}$/;"	f
HasZeroc	HTKLib/HParm.c	/^Boolean HasZeroc(ParmKind kind) {return (Boolean)((kind & HASZEROC) != 0);}$/;"	f
HasZerom	HTKLib/HParm.c	/^Boolean HasZerom(ParmKind kind) {return (Boolean)((kind & HASZEROM) != 0);}$/;"	f
Hash	HLMLib/LUtil.c	/^static unsigned Hash(char *name, int hashSize)$/;"	f	file:
Hash	HTKLVRec/kenlm/lm/filter/phrase.hh	/^typedef uint64_t Hash;$/;"	t	namespace:lm::phrase
Hash	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef HashT Hash;$/;"	t	class:util::AutoProbing
Hash	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef HashT Hash;$/;"	t	class:util::ProbingHashTable
Hash	HTKLib/HLabel.c	/^static unsigned Hash(char *name)$/;"	f	file:
Hash	HTKLib/HModel.c	/^static unsigned Hash(char *name)$/;"	f	file:
HashBufferEntry	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^struct HashBufferEntry : public BufferEntry {$/;"	s	namespace:lm::builder::__anon45	file:
HashForVocab	HTKLVRec/kenlm/lm/vocab.cc	/^uint64_t HashForVocab(const char *str, std::size_t len) {$/;"	f	namespace:lm::ngram::detail
HashForVocab	HTKLVRec/kenlm/lm/vocab.hh	/^inline uint64_t HashForVocab(const StringPiece &str) {$/;"	f	namespace:lm::ngram::detail
HashGamma	HTKLVRec/kenlm/lm/builder/hash_gamma.hh	/^struct HashGamma {$/;"	s	namespace:lm::builder
HashTab	HLMLib/LUtil.h	/^} HashTab;$/;"	t	typeref:struct:__anon20
HashedSearch	HTKLVRec/kenlm/lm/search_hashed.hh	/^template <class Value> class HashedSearch {$/;"	c	namespace:lm::ngram::detail
Have	HTKLVRec/kenlm/lm/builder/output.hh	/^    bool Have(HookType hook_type) const {$/;"	f	class:lm::builder::Output
HdrField	HLMLib/LUtil.c	/^} HdrField;$/;"	t	typeref:struct:hdrField	file:
HeadInfo	HTKTools/HList.c	/^}HeadInfo;$/;"	t	typeref:struct:__anon202	file:
HeadMerge	HTKTools/HParse.c	/^void HeadMerge(Link a, Link b)$/;"	f
HeaderInfo	HTKLVRec/kenlm/lm/builder/header_info.hh	/^  HeaderInfo() {}$/;"	f	struct:HeaderInfo
HeaderInfo	HTKLVRec/kenlm/lm/builder/header_info.hh	/^  HeaderInfo(const std::string& input_file_in, uint64_t token_count_in, const std::vector<uint64_t> &counts_pruned_in)$/;"	f	struct:HeaderInfo
HeaderInfo	HTKLVRec/kenlm/lm/builder/header_info.hh	/^struct HeaderInfo {$/;"	s
HeaderKind	HLMLib/LUtil.c	/^static LMHdrKind HeaderKind(char *s,int l)$/;"	f	file:
HeapType	HTKLib/HMem.h	/^typedef enum{MHEAP, MSTAK, CHEAP} HeapType;$/;"	t	typeref:enum:__anon115
HeaviestMix	HTKTools/HHEd.c	/^int HeaviestMix(char *hname, MixtureElem *me, int M)$/;"	f
HexCharOfValue	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^static char HexCharOfValue(int value) {$/;"	f	namespace:double_conversion
HexCharValue	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^static int HexCharValue(char c) {$/;"	f	namespace:double_conversion
HholdTrCols	HTKLib/HMath.c	/^static void HholdTrCols(DMatrix M, int i0, int j0, $/;"	f	file:
HholdTrRows	HTKLib/HMath.c	/^static void HholdTrRows(DMatrix M, int i0, int j0, DVector hh, double beta)$/;"	f	file:
HholdVec	HTKLib/HMath.c	/^static void HholdVec(DVector tmp, int i0, int size,$/;"	f	file:
HighestInput	HTKTools/HDMan.c	/^LabId HighestInput(void)$/;"	f
HookType	HTKLVRec/kenlm/lm/builder/output.hh	/^enum HookType {$/;"	g	namespace:lm::builder
I	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    InnerIterator &I() { return p_.Inner(); }$/;"	f	class:util::ProxyIterator
I	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    const InnerIterator &I() const { return p_.Inner(); }$/;"	f	class:util::ProxyIterator
IBLink	HTKLib/HTrain.h	/^typedef struct _ItemBlock *IBLink;$/;"	t	typeref:struct:_ItemBlock
IDOutP	HTKLib/HModel.c	/^LogFloat IDOutP(Vector x, int vecSize, MixPDF *mp)$/;"	f
IFILL	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon200	file:
IFillOp	HTKTools/HLEd.c	/^int IFillOp(LabList *ll,LabId *args)$/;"	f
ILink	HTKLib/HModel.h	/^typedef struct _ItemRec *ILink;$/;"	t	typeref:struct:_ItemRec
IMULAW	HTKLib/HWave.c	/^   IMULAW       \/* Interleaved 8 bit u-law *\/$/;"	e	enum:_CompressType	file:
INCLUDED	HTKLib/esignal.h	93;"	d
INIT_CNE	HLMLib/LModel.c	390;"	d	file:
INIT_XPOS	HTKTools/HSLab.c	76;"	d	file:
INIT_YPOS	HTKTools/HSLab.c	77;"	d	file:
INPUTXFORM	HTKLib/HModel.c	/^   NUMCLASSES, ADAPTKIND, PREQUAL, INPUTXFORM,$/;"	e	enum:__anon117	file:
INSTALL	HLMLib/Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL	HLMTools/Makefile	/^INSTALL = 	\/usr\/bin\/install -c$/;"	m
INSTALL	HTKLVRec/Makefile	/^INSTALL = 	\/usr\/bin\/install -c$/;"	m
INSTALL	HTKLib/Makefile	/^INSTALL= \/usr\/bin\/install -c$/;"	m
INSTALL	HTKTools/Makefile	/^INSTALL = 	\/usr\/bin\/install -c$/;"	m
INSTALL	Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = ${INSTALL} $(AM_INSTALL_PROGRAM_FLAGS)$/;"	m
INSTALL_SCRIPT	Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INTARG	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	e	enum:__anon158
INT_FIELD	HTKLib/HNet.c	/^typedef enum {UNK_FIELD, STR_FIELD, INT_FIELD, FLT_FIELD} LatFieldType;$/;"	e	enum:__anon136	file:
INT_LMID	HLMLib/LModel.h	67;"	d
INVCOVAR	HTKLib/HModel.c	/^   MEAN, VARIANCE, INVCOVAR, XFORM, GCONST,$/;"	e	enum:__anon117	file:
INVDIAGC	HTKLib/HMath.h	/^   INVDIAGC,      \/* inverse diagonal covariance *\/$/;"	e	enum:__anon113
INVDIAGCOV	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon117	file:
IOConfParm	HTKLib/HParm.c	/^}IOConfParm;$/;"	t	typeref:enum:__anon142	file:
IOConfig	HTKLib/HParm.c	/^typedef IOConfigRec *IOConfig;$/;"	t	file:
IOConfigRec	HTKLib/HParm.c	/^}IOConfigRec;$/;"	t	typeref:struct:__anon141	file:
IOFilter	HTKLib/HShell.h	/^}IOFilter;$/;"	t	typeref:enum:__anon153
IO_WIN	HTKTools/HSLab.c	/^   WAVE_WIN, LAB_WIN, IO_WIN, NO_WIN $/;"	e	enum:__anon207	file:
IPat	HTKTools/HHEd.c	/^}IPat;$/;"	t	typeref:struct:_IPat	file:
IREFC	HTKLib/HParm.h	/^      IREFC,                           \/* Ref Coef in 16 bit form *\/$/;"	e	enum:_BaseParmKind
ISIL	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon200	file:
IS_SEN	HLMTools/LPlex.c	610;"	d	file:
IS_SST	HLMTools/LPlex.c	609;"	d	file:
IS_UNK	HLMTools/LPlex.c	608;"	d	file:
ISilOp	HTKTools/HLEd.c	/^int ISilOp(LabList *ll,LabId *args)$/;"	f
ISmoothTau	HTKTools/HMMIRest.c	/^static float ISmoothTau = 0.0;        \/* I-smoothing: a h-crit-like thing.  Set to 100 for MMI or 50 for MPE, or 25 for MWE. *\/$/;"	v	file:
ISmoothTauTrans	HTKTools/HMMIRest.c	/^static float ISmoothTauTrans = 0.0;$/;"	v	file:
ISmoothTauTransSet	HTKTools/HMMIRest.c	/^static Boolean ISmoothTauTransSet=FALSE;$/;"	v	file:
ISmoothTauWeights	HTKTools/HMMIRest.c	/^static float ISmoothTauWeights = 0.0;$/;"	v	file:
ISmoothTauWeightsSet	HTKTools/HMMIRest.c	/^static Boolean ISmoothTauWeightsSet=FALSE;$/;"	v	file:
IStreamReader	HTKLVRec/kenlm/util/read_compressed.cc	/^    explicit IStreamReader(std::istream &stream) : stream_(stream) {}$/;"	f	class:util::__anon79::IStreamReader
IStreamReader	HTKLVRec/kenlm/util/read_compressed.cc	/^class IStreamReader : public ReadBase {$/;"	c	namespace:util::__anon79	file:
Ideal	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class T> MutableIterator Ideal(const T &t) {$/;"	f	class:util::ProbingHashTable
Ident	HTKTools/HParse.c	/^typedef char Ident[MAXIDENT+1];$/;"	t	file:
Identity	HTKLVRec/kenlm/util/exception.hh	/^      typedef T Identity;$/;"	t	struct:util::Exception::ExceptionTag
IdentityAccessor	HTKLVRec/kenlm/util/sorted_uniform.hh	/^template <class T> class IdentityAccessor {$/;"	c	namespace:util
IdentityHash	HTKLVRec/kenlm/util/probing_hash_table.hh	/^struct IdentityHash {$/;"	s	namespace:util
IgnoredType	HTKLVRec/kenlm/util/file.cc	/^typedef CheckOffT<sizeof(off_t)>::True IgnoredType;$/;"	t	namespace:util::__anon70	file:
ImmDef	HTKLib/HLabel.h	/^}ImmDef;$/;"	t	typeref:struct:__anon109
In	HTKLVRec/kenlm/util/thread_pool.hh	/^    PCQueue<Request> &In() { return in_; }$/;"	f	class:util::ThreadPool
InContext	HTKTools/HLEd.c	/^Boolean InContext(LLink l, LabId *lc, LabId *rc, LabId item)$/;"	f
InSamples	HTKLib/HAudio.c	/^static int InSamples(AudioIn a)$/;"	f	file:
InSet	HLMTools/LGPrep.c	/^Boolean InSet(SetDef *wset, LabId wdid)$/;"	f
InUse	HTKLib/HFBLat.h	/^  Boolean InUse; \/* FALSE if stacks are cleared and lattices empty. *\/$/;"	m	struct:__anon102
IncLabStr	HTKTools/HSLab.c	/^void IncLabStr(void)$/;"	f
IncSumSqr	HTKTools/HHEd.c	/^void IncSumSqr(StateInfo *si, Boolean ans, AccSum *no, AccSum *yes, int l)$/;"	f
IncUse	HTKLib/HMem.c	/^void IncUse(Ptr m)$/;"	f
IncreaseBase	HTKLVRec/kenlm/util/mmap.hh	/^    void IncreaseBase(uint64_t by) {$/;"	f	class:util::Rolling
Increment	HTKLVRec/kenlm/util/stream/sort.hh	/^        bool Increment(int fd, std::size_t buf_size, std::size_t entry_size) {$/;"	f	class:util::stream::MergeQueue::Entry
IndependentLeft	HTKLVRec/kenlm/lm/value.hh	/^    bool IndependentLeft() const {$/;"	f	class:lm::ngram::GenericProbingProxy
Index	HTKLVRec/kenlm/lm/neural/wordvecs.hh	/^    WordIndex Index(StringPiece str) const { return vocab_.Index(str); }$/;"	f	class:lm::neural::WordVecs
Index	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    virtual WordIndex Index(const char *str) const {$/;"	f	class:lm::base::Vocabulary
Index	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    virtual WordIndex Index(const std::string &str) const {$/;"	f	class:lm::base::Vocabulary
Index	HTKLVRec/kenlm/lm/vocab.hh	/^    WordIndex Index(const StringPiece &str) const {$/;"	f	class:lm::ngram::GrowableVocab
Index	HTKLVRec/kenlm/lm/vocab.hh	/^    WordIndex Index(const StringPiece &str) const {$/;"	f	class:lm::ngram::ProbingVocabulary
Index	HTKLVRec/kenlm/lm/vocab.hh	/^    WordIndex Index(const StringPiece &str) const {$/;"	f	class:lm::ngram::SortedVocabulary
Index	HTKLVRec/kenlm/lm/wrappers/nplm.cc	/^WordIndex Vocabulary::Index(const std::string &str) const {$/;"	f	class:lm::np::Vocabulary
Index	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^    WordIndex Index(const StringPiece &str) const {$/;"	f	class:lm::np::Vocabulary
Index	HTKTools/HResults.c	/^int Index(LabId labid)$/;"	f
Infinity	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static double Infinity() {$/;"	f	class:double_conversion::Double
Infinity	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static float Infinity() {$/;"	f	class:double_conversion::Single
InfoPrinted	HTKLib/HShell.c	/^Boolean InfoPrinted(void)$/;"	f
Init	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    void Init(const util::stream::ChainPosition &position) {$/;"	f	class:lm::builder::NGramStream
Init	HTKLVRec/kenlm/lm/facade.hh	/^    void Init(const State &begin_sentence, const State &null_context, const Vocabulary &vocab, unsigned char order) {$/;"	f	class:lm::base::ModelFacade
Init	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Init(std::size_t entry_size) {$/;"	f	class:lm::ngram::trie::__anon58::BackoffMessages
Init	HTKLVRec/kenlm/lm/trie.hh	/^    void Init(void *base, uint8_t quant_bits, uint64_t max_vocab) {$/;"	f	class:lm::ngram::trie::BitPackedLongest
Init	HTKLVRec/kenlm/lm/trie.hh	/^    void Init(void *start) {$/;"	f	class:lm::ngram::trie::Unigram
Init	HTKLVRec/kenlm/lm/trie_sort.cc	/^void RecordReader::Init(FILE *file, std::size_t entry_size) {$/;"	f	class:lm::ngram::trie::RecordReader
Init	HTKLVRec/kenlm/util/fixed_array.hh	/^    void Init(std::size_t count) {$/;"	f	class:util::FixedArray
Init	HTKLVRec/kenlm/util/mmap.hh	/^    void Init(void *data) {$/;"	f	class:util::Rolling
Init	HTKLVRec/kenlm/util/stream/chain.cc	/^void Link::Init(const ChainPosition &position) {$/;"	f	class:util::stream::Link
Init	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    void Init(const ChainPositions &positions) {$/;"	f	class:util::stream::GenericStreams
Init	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    void Init(const ChainPositions &positions, std::size_t limit) {$/;"	f	class:util::stream::GenericStreams
Init	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^inline void ChainPositions::Init(Chains &chains) {$/;"	f	class:util::stream::ChainPositions
Init	HTKLVRec/kenlm/util/stream/stream.hh	/^    void Init(const ChainPosition &position) {$/;"	f	class:util::stream::Stream
InitAdapt	HTKLib/HAdapt.c	/^void InitAdapt (XFInfo *xfinfo) $/;"	f
InitAlpha	HTKLib/HFB.c	/^static void InitAlpha(AlphaBeta *ab, int *start, int *end, $/;"	f	file:
InitArc	HTKLib/HArc.c	/^void InitArc(void)$/;"	f
InitAudi	HTKLib/HAudio.c	/^static void InitAudi(AudioIn a, HTime *sampPeriod)$/;"	f	file:
InitAudio	HTKLib/HAudio.c	/^void InitAudio(void)$/;"	f
InitAudo	HTKLib/HAudio.c	/^static void InitAudo(AudioOut a, HTime *sampPeriod)$/;"	f	file:
InitBar	HTKTools/HSLab.c	/^static void InitBar(BarType *bar, int x_ofs, HColour fg, int range, char *str)$/;"	f	file:
InitBuildInfo	HLMLib/LPCalc.c	/^void InitBuildInfo(BuildInfo *bi)$/;"	f
InitCMLLRXForm	HTKLib/HAdapt.c	/^static void InitCMLLRXForm(AccStruct *accs, DVector W, DVector bias)$/;"	f	file:
InitCMap	HLMLib/LCMap.c	/^void InitCMap(void)$/;"	f
InitClustering	HTKLib/HTrain.c	/^static void InitClustering(MemHeap *x, Sequence vpool, int nc,$/;"	f	file:
InitConMat	HTKTools/HResults.c	/^void InitConMat(void)$/;"	f
InitDecoderInst	HTKLVRec/HLVRec.c	/^void InitDecoderInst (DecoderInst *dec, LexNet *net, HTime sampRate, LogFloat beamWidth, $/;"	f
InitDict	HTKLib/HDict.c	/^void InitDict(void)$/;"	f
InitExactMPE	HTKLib/HExactMPE.c	/^void InitExactMPE(void)$/;"	f
InitFB	HTKLib/HFB.c	/^void InitFB(void)$/;"	f
InitFBLat	HTKLib/HFBLat.c	/^void InitFBLat(void)$/;"	f
InitFBank	HTKLib/HSigP.c	/^FBankInfo InitFBank(MemHeap *x, int frameSize, long sampPeriod, int numChans,$/;"	f
InitForAdjust	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    void InitForAdjust(util::stream::Sort<SuffixOrder, AddCombiner> &ngrams, WordIndex types) {$/;"	f	class:lm::builder::__anon47::Master
InitGBase	HLMLib/LGBase.c	/^void InitGBase(void)$/;"	f
InitGCs	HTKLib/HGraf.c	/^static void InitGCs(void)$/;"	f	file:
InitGlobals	HTKLib/HGraf.c	/^static void InitGlobals(void)$/;"	f	file:
InitGlobals	HTKLib/HGraf_WIN32.c	/^static void InitGlobals(void)$/;"	f	file:
InitGraf	HTKLib/HGraf.c	/^void InitGraf(void)$/;"	f
InitGraf	HTKLib/HGraf.null.c	/^void InitGraf(void)$/;"	f
InitGraf	HTKLib/HGraf_WIN32.c	/^void InitGraf(void)$/;"	f
InitHMMSet	HTKLib/HModel.c	/^static ReturnStatus InitHMMSet(HMMSet *hset, char *fname, Boolean isSingle)$/;"	f	file:
InitIdentity	HTKLib/HMath.c	/^static void InitIdentity(DMatrix A) $/;"	f	file:
InitLM	HTKLib/HLM.c	/^void InitLM(void)$/;"	f
InitLMlaTree	HTKLVRec/HLVNet.c	/^static void InitLMlaTree(LexNet *net, TLexNet *tnet)$/;"	f	file:
InitLModel	HLMLib/LModel.c	/^void InitLModel(void)$/;"	f
InitLUtil	HLMLib/LUtil.c	/^void InitLUtil(void)$/;"	f
InitLVLM	HTKLVRec/HLVLM.c	/^void InitLVLM (void)$/;"	f
InitLVModel	HTKLVRec/HLVModel.c	/^void InitLVModel(void)$/;"	f
InitLVNet	HTKLVRec/HLVNet.c	/^void InitLVNet(void)$/;"	f
InitLVRec	HTKLVRec/HLVRec.c	/^void InitLVRec(void)$/;"	f
InitLabel	HTKLib/HLabel.c	/^void InitLabel(void)$/;"	f
InitLat	HTKLib/HLat.c	/^void InitLat(void)$/;"	f
InitMap	HTKLib/HMap.c	/^void InitMap(void)$/;"	f
InitMath	HTKLib/HMath.c	/^void InitMath(void)$/;"	f
InitMem	HTKLib/HMem.c	/^void InitMem(void)$/;"	f
InitModel	HTKLib/HModel.c	/^void InitModel(void)$/;"	f
InitNet	HTKLib/HNet.c	/^void InitNet(void)$/;"	f
InitPCalc	HLMLib/LPCalc.c	/^void InitPCalc(void)$/;"	f
InitPLP	HTKLib/HSigP.c	/^void InitPLP (FBankInfo info, int lpcOrder, Vector eql, DMatrix cm)$/;"	f
InitPMerge	HLMLib/LPMerge.c	/^void InitPMerge(void)$/;"	f
InitPSetInfo	HTKLib/HRec.c	/^PSetInfo *InitPSetInfo(HMMSet *hset)$/;"	f
InitParm	HTKLib/HParm.c	/^ReturnStatus InitParm(void)$/;"	f
InitPhonePost	HTKLVRec/HLVRec-misc.c	/^void InitPhonePost (DecoderInst *dec)$/;"	f
InitPronHolders	HTKLib/HNet.c	/^static int InitPronHolders(Network *net,Lattice *lat,HMMSetCxtInfo *hci,$/;"	f	file:
InitPruneStats	HTKLib/HFB.c	/^static void InitPruneStats(AlphaBeta *ab)$/;"	f	file:
InitRec	HTKLib/HRec.c	/^void InitRec(void)$/;"	f
InitRectWin	HTKTools/HSLab.c	/^void InitRectWin(RectWin *win, float x, float y, float w, float h, $/;"	f
InitRegTree	HTKTools/HHEd.c	/^RegTree *InitRegTree(HMMSet *hset, int *vSize, ILink ilist) $/;"	f
InitScan	HTKTools/HParse.c	/^static void InitScan(char *fname)$/;"	f	file:
InitScanner	HTKLib/HModel.c	/^ReturnStatus InitScanner(char *fname, Source *src, Token *tok, HMMSet *hset)$/;"	f
InitSegStore	HTKTools/HInit.c	/^void InitSegStore(BufferInfo *info)$/;"	f
InitSegStore	HTKTools/HRest.c	/^void InitSegStore(BufferInfo *info)$/;"	f
InitSemiTiedDet	HTKLib/HAdapt.c	/^static double InitSemiTiedDet(BaseClass *bclass, IntVec classes)$/;"	f	file:
InitSemiTiedFR	HTKLib/HAdapt.c	/^static void InitSemiTiedFR(AdaptXForm *xform, LinXForm *xf, IntVec classes, TriMat totCov)$/;"	f	file:
InitSemiTiedVars	HTKLib/HAdapt.c	/^static void InitSemiTiedVars(AdaptXForm *xform, IntVec classes, TriMat totCov)$/;"	f	file:
InitShell	HTKLib/HShell.c	/^ReturnStatus InitShell(int argc, char *argv[], char *ver, char *sccs)$/;"	f
InitShiftReg	HLMTools/LGPrep.c	/^void InitShiftReg(ShiftReg *sr, int size, char *fn)$/;"	f
InitSigP	HTKLib/HSigP.c	/^void InitSigP(void)$/;"	f
InitSource	HTKLib/HShell.c	/^ReturnStatus InitSource(char *fname, Source *src,  IOFilter filter)$/;"	f
InitSpkrAcc	HTKTools/HCompV.c	/^SpkrAcc *InitSpkrAcc(void)$/;"	f
InitSpotLists	HTKTools/HResults.c	/^void InitSpotLists(void)$/;"	f
InitStats	HTKTools/HLStats.c	/^void InitStats(char *listFn)$/;"	f
InitStreamVars	HTKTools/HQuant.c	/^void InitStreamVars(void)$/;"	f
InitSubNetDefs	HTKTools/HParse.c	/^static void InitSubNetDefs(void)$/;"	f	file:
InitSymNames	HTKLib/HModel.c	/^void InitSymNames(void)$/;"	f
InitTMixRecs	HTKLib/HModel.c	/^void InitTMixRecs(HMMSet *hset, int s, int M)$/;"	f
InitTargetModel	HLMLib/LPCalc.c	/^static BackOffLM *InitTargetModel(MemHeap *heap, BuildInfo *bi)$/;"	f	file:
InitTargetModel	HLMLib/LPMerge.c	/^static BackOffLM *InitTargetModel(MemHeap *heap, int nSize, WordMap *wList)$/;"	f	file:
InitTrScan	HTKLib/HLabel.c	/^static void InitTrScan(void)$/;"	f	file:
InitTrain	HTKLib/HTrain.c	/^void InitTrain(void)$/;"	f
InitTreeAccs	HTKTools/HHEd.c	/^void InitTreeAccs(StateElem *se, int l)$/;"	f
InitUtil	HTKLib/HUtil.c	/^void InitUtil(void)$/;"	f
InitUttInfo	HTKLib/HFB.c	/^void InitUttInfo( UttInfo *utt, Boolean twoFiles )$/;"	f
InitUttObservations	HTKLib/HFB.c	/^void InitUttObservations(UttInfo *utt, HMMSet *al_hset, $/;"	f
InitVQ	HTKLib/HVQ.c	/^void InitVQ(void)$/;"	f
InitVRecInfo	HTKLib/HRec.c	/^VRecInfo *InitVRecInfo(PSetInfo *psi,int nToks,Boolean models,Boolean states)$/;"	f
InitVocab	HTKLib/HDict.c	/^void InitVocab(Vocab *voc)$/;"	f
InitWMap	HLMLib/LWMap.c	/^void InitWMap(void)$/;"	f
InitWave	HTKLib/HWave.c	/^void InitWave(void)$/;"	f
InitWithDummy	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    void InitWithDummy(const ChainPositions &positions) {$/;"	f	class:util::stream::GenericStreams
InitWordInfo	HTKTools/HLStats.c	/^void InitWordInfo(WordInfo *w, LabId id, Cntr *pCntr)$/;"	f
InitWordMap	HLMTools/LGPrep.c	/^void InitWordMap(void)$/;"	f
InitXFormScanner	HTKLib/HModel.c	/^static char *InitXFormScanner(HMMSet *hset, char *macroname, char *fname,$/;"	f	file:
InitialProbabilities	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^void InitialProbabilities($/;"	f	namespace:lm::builder
InitialProbabilities	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^void InitialProbabilities(const std::vector<uint64_t> &counts, const std::vector<uint64_t> &counts_pruned, const std::vector<Discount> &discounts, Master &master, Sorts<SuffixOrder> &primary,$/;"	f	namespace:lm::builder::__anon47
InitialProbabilitiesConfig	HTKLVRec/kenlm/lm/builder/initial_probabilities.hh	/^struct InitialProbabilitiesConfig {$/;"	s	namespace:lm::builder
InitialScaledStartValues	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^static void InitialScaledStartValues(uint64_t significand,$/;"	f	namespace:double_conversion
InitialScaledStartValuesNegativeExponentNegativePower	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^static void InitialScaledStartValuesNegativeExponentNegativePower($/;"	f	namespace:double_conversion
InitialScaledStartValuesNegativeExponentPositivePower	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^static void InitialScaledStartValuesNegativeExponentPositivePower($/;"	f	namespace:double_conversion
InitialScaledStartValuesPositiveExponent	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^static void InitialScaledStartValuesPositiveExponent($/;"	f	namespace:double_conversion
Initialise	HLMTools/LAdapt.c	/^void Initialise(void)$/;"	f
Initialise	HLMTools/LBuild.c	/^void Initialise(BuildInfo *bi)$/;"	f
Initialise	HLMTools/LFoF.c	/^void Initialise(void)$/;"	f
Initialise	HLMTools/LGCopy.c	/^static void Initialise(void)$/;"	f	file:
Initialise	HLMTools/LGPrep.c	/^void Initialise(void)$/;"	f
Initialise	HLMTools/LMerge.c	/^void Initialise(void) $/;"	f
Initialise	HLMTools/LPlex.c	/^static void Initialise(void)$/;"	f	file:
Initialise	HTKLVRec/HDecode.c	/^DecoderInst *Initialise (void)$/;"	f
Initialise	HTKLVRec/HDecode.mod.c	/^DecoderInst *Initialise (void)$/;"	f
Initialise	HTKTools/HCompV.c	/^void Initialise(void)$/;"	f
Initialise	HTKTools/HDMan.c	/^void Initialise(void)$/;"	f
Initialise	HTKTools/HERest.c	/^void Initialise(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, char *hmmListFn)$/;"	f
Initialise	HTKTools/HHEd.c	/^void Initialise(char *hmmListFn)$/;"	f
Initialise	HTKTools/HInit.c	/^void Initialise(void)$/;"	f
Initialise	HTKTools/HLEd.c	/^void Initialise(void)$/;"	f
Initialise	HTKTools/HMMIRest.c	/^void Initialise(char *hmmListFn)$/;"	f
Initialise	HTKTools/HQuant.c	/^void Initialise(char *datafn)$/;"	f
Initialise	HTKTools/HResults.c	/^void Initialise(char * listfn)$/;"	f
Initialise	HTKTools/HSLab.c	/^void Initialise(void)$/;"	f
Initialise	HTKTools/HSmooth.c	/^void Initialise(char *hmmListFn)$/;"	f
Initialise	HTKTools/HVite.c	/^void Initialise(void)$/;"	f
Initialise1	HTKTools/HRest.c	/^void Initialise1(void)$/;"	f
Initialise2	HTKTools/HRest.c	/^void Initialise2(void)$/;"	f
InitialiseFBInfo	HTKLib/HFBLat.c	/^void InitialiseFBInfo(FBLatInfo *fbInfo,$/;"	f
InitialiseForBack	HTKLib/HFB.c	/^void InitialiseForBack(FBInfo *fbInfo, MemHeap *x, HMMSet *hset, UPDSet uset, $/;"	f
InitialiseMerge	HLMLib/LPMerge.c	/^static void InitialiseMerge(MemHeap *heap, MergeInfo *mi)$/;"	f	file:
Initialize	HTKLVRec/kenlm/util/file_piece.cc	/^void FilePiece::Initialize(const char *name, std::ostream *show_progress, std::size_t min_buffer) {$/;"	f	class:util::FilePiece
InitializeBinary	HTKLVRec/kenlm/lm/binary_format.cc	/^void BinaryFormat::InitializeBinary(int fd, ModelType model_type, unsigned int search_version, Parameters &params) {$/;"	f	class:lm::ngram::BinaryFormat
InitializeFromARPA	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> void GenericModel<Search, VocabularyT>::InitializeFromARPA(int fd, const char *file, const Config &config) {$/;"	f	class:lm::ngram::detail::GenericModel
InitializeFromARPA	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <class Value> void HashedSearch<Value>::InitializeFromARPA(const char * \/*file*\/, util::FilePiece &f, const std::vector<uint64_t> &counts, const Config &config, ProbingVocabulary &vocab, BinaryFormat &backing) {$/;"	f	class:lm::ngram::detail::HashedSearch
InitializeFromARPA	HTKLVRec/kenlm/lm/search_trie.cc	/^template <class Quant, class Bhiksha> void TrieSearch<Quant, Bhiksha>::InitializeFromARPA(const char *file, util::FilePiece &f, std::vector<uint64_t> &counts, const Config &config, SortedVocabulary &vocab, BinaryFormat &backing) {$/;"	f	class:lm::ngram::trie::TrieSearch
InitializeNoRead	HTKLVRec/kenlm/util/file_piece.cc	/^void FilePiece::InitializeNoRead(const char *name, std::size_t min_buffer) {$/;"	f	class:util::FilePiece
InlineBits	HTKLVRec/kenlm/lm/bhiksha.cc	/^uint8_t ArrayBhiksha::InlineBits(uint64_t max_offset, uint64_t max_next, const Config &config) {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
InlineBits	HTKLVRec/kenlm/lm/bhiksha.hh	/^    static uint8_t InlineBits(uint64_t \/*max_offset*\/, uint64_t max_next, const Config &\/*config*\/) {$/;"	f	class:lm::ngram::trie::DontBhiksha
InlineBits	HTKLVRec/kenlm/lm/bhiksha.hh	/^    uint8_t InlineBits() const { return next_.bits; }$/;"	f	class:lm::ngram::trie::DontBhiksha
InlineBits	HTKLVRec/kenlm/lm/bhiksha.hh	/^    uint8_t InlineBits() const { return next_inline_.bits; }$/;"	f	class:lm::ngram::trie::ArrayBhiksha
Inner	HTKLVRec/kenlm/lm/trie_sort.cc	/^    InnerIterator &Inner() { return inner_; }$/;"	f	class:lm::ngram::trie::__anon60::PartialViewProxy	file:
Inner	HTKLVRec/kenlm/lm/trie_sort.cc	/^    const InnerIterator &Inner() const { return inner_; } $/;"	f	class:lm::ngram::trie::__anon60::PartialViewProxy	file:
Inner	HTKLVRec/kenlm/util/joint_sort.hh	/^    InnerIterator &Inner() { return inner_; }$/;"	f	class:util::detail::JointProxy
Inner	HTKLVRec/kenlm/util/joint_sort.hh	/^    const InnerIterator &Inner() const { return inner_; }$/;"	f	class:util::detail::JointProxy
Inner	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    const InnerIterator &Inner() { return p_.Inner(); }$/;"	f	class:util::ProxyIterator
Inner	HTKLVRec/kenlm/util/sized_iterator.hh	/^    InnerIterator &Inner() { return inner_; }$/;"	f	class:util::SizedProxy
Inner	HTKLVRec/kenlm/util/sized_iterator.hh	/^    const InnerIterator &Inner() const { return inner_; }$/;"	f	class:util::SizedProxy
InnerIterator	HTKLVRec/kenlm/lm/trie_sort.cc	/^    typedef util::SizedInnerIterator InnerIterator;$/;"	t	class:lm::ngram::trie::__anon60::PartialViewProxy	file:
InnerIterator	HTKLVRec/kenlm/util/joint_sort.hh	/^    typedef JointIter<KeyIter, ValueIter> InnerIterator;$/;"	t	class:util::detail::JointProxy
InnerIterator	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    typedef typename Proxy::InnerIterator InnerIterator;$/;"	t	class:util::ProxyIterator
InnerIterator	HTKLVRec/kenlm/util/sized_iterator.hh	/^    typedef SizedInnerIterator InnerIterator;$/;"	t	class:util::SizedProxy
InputAction	HTKLib/HWave.c	/^}InputAction;$/;"	t	typeref:enum:__anon172	file:
InputBuffer	HTKLVRec/kenlm/lm/filter/format.hh	/^    InputBuffer() : actual_(0) {}$/;"	f	class:lm::InputBuffer
InputBuffer	HTKLVRec/kenlm/lm/filter/format.hh	/^class InputBuffer {$/;"	c	namespace:lm
InputXForm	HTKLib/HModel.h	/^} InputXForm;$/;"	t	typeref:struct:__anon134
InputXFormCommand	HTKTools/HHEd.c	/^void InputXFormCommand()$/;"	f
InsCorrectness	HTKLib/HExactMPE.c	/^static float InsCorrectness = -1;   \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
InsCorrectness	HTKLib/HFBLat.c	/^static float InsCorrectness = -1;                            \/* Correctness of an inserted phone.  Can be tuned, it affects recognition insertion rate.$/;"	v	file:
Insert	HTKLVRec/kenlm/lm/trie.cc	/^template <class Bhiksha> util::BitAddress BitPackedMiddle<Bhiksha>::Insert(WordIndex word) {$/;"	f	class:lm::ngram::trie::BitPackedMiddle
Insert	HTKLVRec/kenlm/lm/trie.cc	/^util::BitAddress BitPackedLongest::Insert(WordIndex index) {$/;"	f	class:lm::ngram::trie::BitPackedLongest
Insert	HTKLVRec/kenlm/lm/vocab.cc	/^WordIndex ProbingVocabulary::Insert(const StringPiece &str) {$/;"	f	class:lm::ngram::ProbingVocabulary
Insert	HTKLVRec/kenlm/lm/vocab.cc	/^WordIndex SortedVocabulary::Insert(const StringPiece &str) {$/;"	f	class:lm::ngram::SortedVocabulary
Insert	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class T> MutableIterator Insert(const T &t) {$/;"	f	class:util::AutoProbing
Insert	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class T> MutableIterator Insert(const T &t) {$/;"	f	class:util::ProbingHashTable
InsertIndex	HTKLVRec/kenlm/lm/trie.hh	/^    uint64_t InsertIndex() const {$/;"	f	class:lm::ngram::trie::BitPacked
InspectAddr	HTKLVRec/kenlm/util/scoped.cc	/^void *InspectAddr(void *addr, std::size_t requested, const char *func_name) {$/;"	f	namespace:util::__anon80
InstallColours	HTKLib/HGraf.c	/^static void InstallColours(void)$/;"	f	file:
InstallColours	HTKLib/HGraf_WIN32.c	/^static void InstallColours(void)$/;"	f	file:
InstallFonts	HTKLib/HGraf.c	/^static void InstallFonts(void)$/;"	f	file:
IntCKind	HTKLib/HShell.h	/^   IntCKind,            \/* integer value - coercable to float *\/$/;"	e	enum:__anon155
IntSet	HTKLib/HUtil.h	/^}IntSet;$/;"	t	typeref:struct:__anon170
IntVec	HTKLib/HMem.h	/^typedef int   *IntVec;     \/* int vector[1..size] *\/$/;"	t
IntVecElemSize	HTKLib/HMem.c	/^size_t IntVecElemSize(int size) { return (size+1)*sizeof(int); }$/;"	f
IntVecSize	HTKLib/HMem.c	/^int IntVecSize(IntVec v)$/;"	f
InternTypeSize	HTKLib/esignal.c	/^InternTypeSize(int type         \/* numeric data_type code *\/ )$/;"	f
InternalDict	HTKLib/HNet.c	/^static Boolean InternalDict(Vocab *voc,HMMSetCxtInfo *hci)$/;"	f	file:
InternalSeek	HTKLVRec/kenlm/util/file.cc	/^void InternalSeek(int fd, int64_t off, int whence) {$/;"	f	namespace:util::__anon70
InternalUnRest	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> float GenericModel<Search, VocabularyT>::InternalUnRest(const uint64_t *pointers_begin, const uint64_t *pointers_end, unsigned char first_length) const {$/;"	f	class:lm::ngram::detail::GenericModel
Interpolate	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^Interpolate::Interpolate(uint64_t vocab_size, const util::stream::ChainPositions &backoffs, const std::vector<uint64_t>& prune_thresholds, bool prune_vocab, bool output_q)$/;"	f	class:lm::builder::Interpolate
Interpolate	HTKLVRec/kenlm/lm/builder/interpolate.hh	/^class Interpolate {$/;"	c	namespace:lm::builder
Interpolate	HTKTools/HSmooth.c	/^void Interpolate(void)$/;"	f
InterpolateProbabilities	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^void InterpolateProbabilities(const std::vector<uint64_t> &counts, Master &master, Sorts<SuffixOrder> &primary, util::FixedArray<util::stream::FileBuffer> &gammas) {$/;"	f	namespace:lm::builder::__anon47
Intersect	HTKTools/HSLab.c	/^Boolean Intersect(long a, long b, long a1, long b1)$/;"	f
InvDiagGConst	HTKLib/HVQ.c	/^static float InvDiagGConst(Vector iv)$/;"	f	file:
InvSVD	HTKLib/HMath.c	/^void InvSVD(DMatrix A, DMatrix U, DVector W, DMatrix V, DMatrix Result)$/;"	f
InvertRegion	HTKTools/HSLab.c	/^void InvertRegion(RectWin *win, int a, int b)$/;"	f
IsAnInClass	HLMLib/LCMap.c	/^Boolean IsAnInClass(ClassMap *c, int clndx)$/;"	f
IsBinaryFormat	HTKLVRec/kenlm/lm/binary_format.cc	/^bool IsBinaryFormat(int fd) {$/;"	f	namespace:lm::ngram
IsClamped	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^bool Bignum::IsClamped() const {$/;"	f	class:double_conversion::Bignum
IsClassMember	HLMLib/LCMap.c	/^Boolean IsClassMember(ClassMap *c, int clndx, int wdndx)$/;"	f
IsCommentChar	HTKTools/HDMan.c	/^Boolean IsCommentChar(int c)$/;"	f
IsDenormal	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  bool IsDenormal() const {$/;"	f	class:double_conversion::Double
IsDenormal	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  bool IsDenormal() const {$/;"	f	class:double_conversion::Single
IsDotLine	HTKLib/HLabel.c	/^static Boolean IsDotLine(char *s)$/;"	f	file:
IsEntirelyWhiteSpace	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^bool IsEntirelyWhiteSpace(const StringPiece &line) {$/;"	f	namespace:lm
IsEntirelyWhiteSpace	HTKLVRec/kenlm/lm/read_arpa.cc	/^bool IsEntirelyWhiteSpace(const StringPiece &line) {$/;"	f	namespace:lm::__anon56
IsFullSet	HTKLib/HUtil.c	/^Boolean IsFullSet(IntSet s)$/;"	f
IsHCIContextInd	HTKLib/HNet.c	/^Boolean IsHCIContextInd(HMMSetCxtInfo *hci,LabId labid)$/;"	f
IsHit	HTKTools/HResults.c	/^Boolean IsHit(LLink t)$/;"	f
IsInIdList	HTKTools/HDMan.c	/^Boolean IsInIdList(LabId id, LabId *idlist)$/;"	f
IsInIdList	HTKTools/HLEd.c	/^Boolean IsInIdList(LabId id, LabId *idlist)$/;"	f
IsInRect	HTKLib/HGraf.c	/^Boolean IsInRect(int x, int y, int x0, int y0, int x1, int y1)$/;"	f
IsInRect	HTKLib/HGraf.null.c	/^Boolean IsInRect(int x, int y, int x0, int y0, int x1, int y1)$/;"	f
IsInRect	HTKLib/HGraf_WIN32.c	/^Boolean IsInRect(int x, int y, int x0, int y0, int x1, int y1)$/;"	f
IsInRectWin	HTKTools/HSLab.c	/^Boolean IsInRectWin(RectWin *w, int x, int y)$/;"	f
IsInWin	HTKTools/HSLab.c	/^Boolean IsInWin(RectWin *w, int x, int y)$/;"	f
IsInfinite	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  bool IsInfinite() const {$/;"	f	class:double_conversion::Double
IsInfinite	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  bool IsInfinite() const {$/;"	f	class:double_conversion::Single
IsJoined	HTKTools/HParse.c	/^static Boolean IsJoined(int a, int b)$/;"	f	file:
IsLMScale	HTKLib/HArc.c	/^static Boolean IsLMScale = FALSE;$/;"	v	file:
IsLineEnd	HTKLVRec/kenlm/lm/filter/vocab.cc	/^bool IsLineEnd(std::istream &in) {$/;"	f	namespace:lm::vocab::__anon50
IsMLFFile	HTKLib/HLabel.c	/^Boolean IsMLFFile(char *fn)$/;"	f
IsMarked	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    bool IsMarked() const {$/;"	f	class:lm::builder::NGram
IsMember	HTKLib/HUtil.c	/^Boolean IsMember(IntSet s, int x)$/;"	f
IsNan	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  bool IsNan() const {$/;"	f	class:double_conversion::Double
IsNan	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  bool IsNan() const {$/;"	f	class:double_conversion::Single
IsNonSilArc	HTKLib/HExactMPE.c	/^Boolean IsNonSilArc(LArc *larc){ \/*returns TRUE if this word is non SENT_START etc. *\/$/;"	f
IsNumeric	HTKLib/HLabel.c	/^Boolean IsNumeric(char *s)$/;"	f
IsPassthrough	HTKLVRec/kenlm/util/mmap.hh	/^    bool IsPassthrough() const { return fd_ == -1; }$/;"	f	class:util::Rolling
IsRContextInd	HTKLib/HNet.c	/^static Boolean IsRContextInd(HMMSetCxtInfo *hci,PronHolder *p,int pos,int xlc)$/;"	f	file:
IsSame	HTKTools/HLEd.c	/^Boolean IsSame(LabId a, LabId b)$/;"	f
IsSeen	HTKLib/HModel.c	/^Boolean IsSeen(int flag)$/;"	f
IsSeenV	HTKLib/HMem.c	/^Boolean IsSeenV(Ptr m)$/;"	f
IsShared	HTKLib/HModel.c	/^static Boolean IsShared(HMMSet *hset)$/;"	f	file:
IsSilence	HTKLib/HArc.h	/^  Boolean IsSilence; \/* Probably just start & end. *\/$/;"	m	struct:_CorrN
IsSilence	HTKLib/HExactMPE.c	96;"	d	file:
IsSilence	HTKLib/HExactMPE.c	99;"	d	file:
IsSilence	HTKLib/HFBLat.c	136;"	d	file:
IsSilence	HTKLib/HFBLat.c	139;"	d	file:
IsSpecial	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  bool IsSpecial() const {$/;"	f	class:double_conversion::Double
IsSpecial	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  bool IsSpecial() const {$/;"	f	class:double_conversion::Single
IsStartOrEnd	HTKLib/HExactMPE.c	101;"	d	file:
IsStartOrEnd	HTKLib/HFBLat.c	141;"	d	file:
IsTag	HTKLVRec/kenlm/lm/filter/vocab.hh	/^inline bool IsTag(const StringPiece &value) {$/;"	f	namespace:lm::vocab
IsTriMat	HTKLib/HMem.c	/^Boolean IsTriMat(Matrix m)$/;"	f
IsVAXOrder	HTKLib/HAudio.c	/^static Boolean IsVAXOrder(void)$/;"	f	file:
IsVAXOrder	HTKLib/HShell.c	/^static Boolean IsVAXOrder(void)$/;"	f	file:
IsVBnd	HTKTools/HLEd.c	/^Boolean IsVBnd(LabId id)$/;"	f
IsWBnd	HTKTools/HLEd.c	/^Boolean IsWBnd(LabId id)$/;"	f
IsWave	HTKTools/HCopy.c	/^Boolean IsWave(char *srcFile)$/;"	f
IsWave	HTKTools/HList.c	/^Boolean IsWave(char *srcFile)$/;"	f
IsWd0Link	HTKLib/HNet.c	/^static Boolean IsWd0Link(NetLink *link)$/;"	f	file:
IsWdPen	HTKLib/HArc.c	/^static Boolean IsWdPen = FALSE;$/;"	v	file:
IsZero	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^  bool IsZero() const {$/;"	f	class:double_conversion::UInt128
ItemBlock	HTKLib/HTrain.h	/^}ItemBlock;$/;"	t	typeref:struct:_ItemBlock
ItemRec	HTKLib/HModel.h	/^}ItemRec;$/;"	t	typeref:struct:_ItemRec
JO	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon199	file:
Join	HTKLVRec/kenlm/util/thread_pool.hh	/^    void Join() {$/;"	f	class:util::Worker
JoinMatrix	HTKTools/HParse.c	/^typedef unsigned char **JoinMatrix; $/;"	t	file:
JoinNodes	HTKTools/HParse.c	/^void JoinNodes(Link a, Link b)$/;"	f
JoinSizeCommand	HTKTools/HHEd.c	/^void JoinSizeCommand(void)$/;"	f
JointIter	HTKLVRec/kenlm/util/joint_sort.hh	/^    JointIter() {}$/;"	f	class:util::detail::JointIter
JointIter	HTKLVRec/kenlm/util/joint_sort.hh	/^    JointIter(const KeyIter &key_iter, const ValueIter &value_iter) : key_(key_iter), value_(value_iter) {}$/;"	f	class:util::detail::JointIter
JointIter	HTKLVRec/kenlm/util/joint_sort.hh	/^template <class KeyIter, class ValueIter> class JointIter {$/;"	c	namespace:util::detail
JointOrder	HTKLVRec/kenlm/lm/builder/joint_order.hh	/^template <class Callback, class Compare> void JointOrder(const util::stream::ChainPositions &positions, Callback &callback) {$/;"	f	namespace:lm::builder
JointProxy	HTKLVRec/kenlm/util/joint_sort.hh	/^    JointProxy(const JointProxy<KeyIter, ValueIter> &other) : inner_(other.inner_) {}$/;"	f	class:util::detail::JointProxy
JointProxy	HTKLVRec/kenlm/util/joint_sort.hh	/^    JointProxy(const KeyIter &key_iter, const ValueIter &value_iter) : inner_(key_iter, value_iter) {}$/;"	f	class:util::detail::JointProxy
JointProxy	HTKLVRec/kenlm/util/joint_sort.hh	/^template <class KeyIter, class ValueIter> class JointProxy {$/;"	c	namespace:util::detail
JointSort	HTKLVRec/kenlm/util/joint_sort.hh	/^template <class KeyIter, class ValueIter, class Less> void JointSort(const KeyIter &key_begin, const KeyIter &key_end, const ValueIter &value_begin, const Less &less) {$/;"	f	namespace:util
JointSort	HTKLVRec/kenlm/util/joint_sort.hh	/^template <class KeyIter, class ValueIter> void JointSort(const KeyIter &key_begin, const KeyIter &key_end, const ValueIter &value_begin) {$/;"	f	namespace:util
K	HTKLib/HAdapt.c	/^   DVector *K, D;$/;"	m	struct:__anon85	file:
KENLMLIB	HTKLVRec/Makefile	/^KENLMLIB = .\/kenlm\/lm\/*.cc .\/kenlm\/util\/*.cc kenlm\/util\/double-conversion\/*.cc$/;"	m
KENLM_ORDER_MESSAGE	HTKLVRec/kenlm/lm/max_order.hh	10;"	d
Key	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  typedef WordIndex *Key;$/;"	t	struct:lm::builder::__anon43::DedupeEntry	file:
Key	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  typedef uint64_t Key;$/;"	t	struct:lm::builder::__anon43::VocabEntry	file:
Key	HTKLVRec/kenlm/lm/search_hashed.hh	/^  typedef uint64_t Key;$/;"	t	struct:lm::ngram::detail::ProbEntry
Key	HTKLVRec/kenlm/lm/trie.cc	/^    typedef uint64_t Key;$/;"	t	class:lm::ngram::trie::__anon59::KeyAccessor	file:
Key	HTKLVRec/kenlm/lm/value.hh	/^    typedef uint64_t Key;$/;"	t	struct:lm::ngram::BackoffValue::ProbingEntry
Key	HTKLVRec/kenlm/lm/value.hh	/^    typedef uint64_t Key;$/;"	t	struct:lm::ngram::RestValue::ProbingEntry
Key	HTKLVRec/kenlm/lm/vocab.hh	/^  typedef uint64_t Key;$/;"	t	struct:lm::ngram::ProbingVocabularyEntry
Key	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef typename Entry::Key Key;$/;"	t	class:util::AutoProbing
Key	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef typename Entry::Key Key;$/;"	t	class:util::ProbingHashTable
Key	HTKLVRec/kenlm/util/sorted_uniform.hh	/^    typedef T Key;$/;"	t	class:util::IdentityAccessor
KeyAccessor	HTKLVRec/kenlm/lm/trie.cc	/^    KeyAccessor(const void *base, uint64_t key_mask, uint8_t key_bits, uint8_t total_bits) $/;"	f	class:lm::ngram::trie::__anon59::KeyAccessor
KeyAccessor	HTKLVRec/kenlm/lm/trie.cc	/^class KeyAccessor {$/;"	c	namespace:lm::ngram::trie::__anon59	file:
KeyPressed	HTKLib/HShell.c	/^Boolean KeyPressed(int tWait)$/;"	f
KeyType	HTKLib/HGraf.h	/^typedef enum _KeyType KeyType;$/;"	t	typeref:enum:_KeyType
Keyword	HTKLib/HUtil.c	/^} Keyword;$/;"	t	typeref:enum:__anon168	file:
KillTimes	HTKTools/HLEd.c	/^void KillTimes(LabList *ll)$/;"	f
L	HTKTools/HMMIRest.c	/^static int L;                        \/* number of logical HMM's *\/$/;"	v	file:
L10MINARG	HLMLib/LModel.h	50;"	d
L10ZERO	HLMLib/LModel.h	49;"	d
L2F	HTKLib/HMath.c	/^double   L2F(LogDouble x)$/;"	f
LAB_BUF_LEN	HTKTools/HSLab.c	82;"	d	file:
LAB_WIN	HTKTools/HSLab.c	/^   WAVE_WIN, LAB_WIN, IO_WIN, NO_WIN $/;"	e	enum:__anon207	file:
LANGSYM	HTKTools/HParse.c	/^             RBRACESYM, LANGSYM, RANGSYM, LBRAKSYM, RBRAKSYM, $/;"	e	enum:_Symbol	file:
LASTCMD	HTKTools/HLEd.c	/^   LASTCMD$/;"	e	enum:__anon200	file:
LASTN	HLMLib/LGBase.c	583;"	d	file:
LATFB_MAX	HTKLib/HLat.h	/^typedef enum {LATFB_SUM, LATFB_MAX} LatFBType;$/;"	e	enum:__anon112
LATFB_SUM	HTKLib/HLat.h	/^typedef enum {LATFB_SUM, LATFB_MAX} LatFBType;$/;"	e	enum:__anon112
LAYER_A	HTKLVRec/HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAYER_AB	HTKLVRec/HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAYER_BY	HTKLVRec/HLVNet.h	/^   LAYER_BY=6, LAYER_WE=7, LAYER_YZ=8$/;"	e	enum:_LayerId
LAYER_SA	HTKLVRec/HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAYER_SIL	HTKLVRec/HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAYER_SIL_NTOK_SCALE	HTKLVRec/HLVRec.c	91;"	d	file:
LAYER_WE	HTKLVRec/HLVNet.h	/^   LAYER_BY=6, LAYER_WE=7, LAYER_YZ=8$/;"	e	enum:_LayerId
LAYER_YZ	HTKLVRec/HLVNet.h	/^   LAYER_BY=6, LAYER_WE=7, LAYER_YZ=8$/;"	e	enum:_LayerId
LAYER_Z	HTKLVRec/HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAYER_ZS	HTKLVRec/HLVNet.h	/^   LAYER_Z=0, LAYER_ZS=1, LAYER_SIL=2, LAYER_SA=3, LAYER_A=4, LAYER_AB=5,$/;"	e	enum:_LayerId
LAZY	HTKLVRec/kenlm/util/mmap.hh	/^  LAZY,$/;"	e	enum:util::__anon76
LAdd	HTKLib/HMath.c	/^LogDouble LAdd(LogDouble x, LogDouble y)$/;"	f
LAlign	HTKLib/HNet.h	/^LAlign;$/;"	t	typeref:struct:lalign
LAlignFromAltModpath	HTKLVRec/HLVRec-traceback.c	/^LAlign *LAlignFromAltModpath (DecoderInst *dec, MemHeap *heap,$/;"	f
LAlignFromModpath	HTKLVRec/HLVRec-traceback.c	/^LAlign *LAlignFromModpath (DecoderInst *dec, MemHeap *heap,$/;"	f
LArc	HTKLib/HNet.h	/^LArc;$/;"	t	typeref:struct:larc
LArcNumb	HTKLib/HNet.h	245;"	d
LArcTotLMLike	HTKLib/HNet.h	252;"	d
LArcTotLike	HTKLib/HNet.h	257;"	d
LArc_E	HTKLib/HNet.h	/^LArc_E;$/;"	t	typeref:struct:larc_e
LArc_S	HTKLib/HNet.h	/^LArc_S;$/;"	t	typeref:struct:larc_s
LBRACESYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
LBRAKSYM	HTKTools/HParse.c	/^             RBRACESYM, LANGSYM, RANGSYM, LBRAKSYM, RBRAKSYM, $/;"	e	enum:_Symbol	file:
LBUF_SIZE	HLMTools/LPlex.c	66;"	d	file:
LCMapFilter	HTKLib/HShell.h	/^   LCMapFilter,     \/* LM Class Map Input *\/$/;"	e	enum:__anon153
LCMapOFilter	HTKLib/HShell.h	/^   LCMapOFilter,    \/* LM Class Map Output *\/$/;"	e	enum:__anon153
LCPHONE	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon191	file:
LCPhoneOp	HTKTools/HDMan.c	/^void LCPhoneOp(WordBuf *wb)$/;"	f
LCTXT	HTKTools/HDMan.c	/^              LCTXT, RCTXT,$/;"	e	enum:__anon191	file:
LCTXT	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon200	file:
LCWORD	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon191	file:
LCase	HTKTools/HDMan.c	/^LabId LCase(LabId id)$/;"	f
LCtxtOp	HTKTools/HDMan.c	/^void LCtxtOp(WordBuf *wb, int nArgs,LabId *args)$/;"	f
LDFLAGS	HLMTools/Makefile	/^LDFLAGS = 	-L\/usr\/X11R6\/lib  $(HLIBS) -lm$/;"	m
LDFLAGS	HTKLVRec/Makefile	/^LDFLAGS = 	-L\/usr\/X11R6\/lib  -lm$/;"	m
LDFLAGS	HTKTools/Makefile	/^LDFLAGS = 	-L\/usr\/X11R6\/lib  -lm$/;"	m
LDFLAGS	Makefile	/^LDFLAGS = -L\/usr\/X11R6\/lib $/;"	m
LEGACY_CUHTK2_MLLR	HTKLVRec/config.h	68;"	d
LEVELSEP	HTKLib/HLabel.c	580;"	d	file:
LEX_CON_HASH_SIZE	HTKLVRec/HLVNet.h	128;"	d
LEX_MOD_HASH_SIZE	HTKLVRec/HLVNet.h	129;"	d
LFEED	HTKLib/HLabel.c	583;"	d	file:
LFOF_HDR	HLMLib/LUtil.h	/^   NO_HDR, WMAP_HDR, CMAP_HDR, GRAM_HDR, LFOF_HDR$/;"	e	enum:__anon19
LGramFilter	HTKLib/HShell.h	/^   LGramFilter,     \/* NGram Input via LGBase *\/$/;"	e	enum:__anon153
LGramOFilter	HTKLib/HShell.h	/^   LGramOFilter,    \/* NGram Output via LGBase *\/$/;"	e	enum:__anon153
LIBS	Makefile	/^LIBS = -lm -lX11 $/;"	m
LIGHT_BLUE	HTKLib/HGraf.h	/^                LIGHT_BLUE, DARK_GREEN, LIGHT_GREEN, DARK_BROWN, LIGHT_BROWN, $/;"	e	enum:_HColour
LIGHT_BROWN	HTKLib/HGraf.h	/^                LIGHT_BLUE, DARK_GREEN, LIGHT_GREEN, DARK_BROWN, LIGHT_BROWN, $/;"	e	enum:_HColour
LIGHT_GREEN	HTKLib/HGraf.h	/^                LIGHT_BLUE, DARK_GREEN, LIGHT_GREEN, DARK_BROWN, LIGHT_BROWN, $/;"	e	enum:_HColour
LIGHT_GREY	HTKLib/HGraf.h	/^                LIGHT_GREY, GREY, DARK_GREY, BLACK};$/;"	e	enum:_HColour
LINKCHUNKSIZE	HTKTools/HParse.c	274;"	d	file:
LINKEXTENTFACTOR	HTKTools/HParse.c	275;"	d	file:
LINXFORM	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon117	file:
LIST_BLOCKSIZE	HTKLVRec/HLVNet.c	53;"	d	file:
LLFInfo	HTKLib/HLat.c	/^typedef struct _LLFInfo LLFInfo;$/;"	t	typeref:struct:_LLFInfo	file:
LLTC	HTKLib/HMath.h	/^   LLTC,          \/* L' part of Choleski decomposition *\/$/;"	e	enum:__anon113
LLTCOV	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon117	file:
LLTCOVAR	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon117	file:
LLink	HTKLib/HLabel.h	/^typedef struct _Label *LLink;$/;"	t	typeref:struct:_Label
LMCACHE_NLA	HTKLVRec/HLVRec.h	258;"	d
LMCache	HTKLVRec/HLVRec.h	/^typedef struct _LMCache LMCache;$/;"	t	typeref:struct:_LMCache
LMCacheLA	HTKLVRec/HLVRec.h	/^typedef struct _LMCacheLA LMCacheLA;$/;"	t	typeref:struct:_LMCacheLA
LMCacheLookaheadProb	HTKLVRec/HLVRec-LM.c	/^static LMTokScore LMCacheLookaheadProb (DecoderInst *dec, LMState lmState, $/;"	f	file:
LMCacheLookaheadProb_kenlm	HTKLVRec/HLVRec-LM.c	/^static LMTokScore LMCacheLookaheadProb_kenlm (DecoderInst *dec, lm::ngram::State& lmState, int lmlaIdx, Boolean fastlmla)$/;"	f	file:
LMCacheState_hash	HTKLVRec/HLVRec-LM.c	/^static int LMCacheState_hash (LMState lmstate)$/;"	f	file:
LMCacheTransProb	HTKLVRec/HLVRec-LM.c	/^static LMTokScore LMCacheTransProb (DecoderInst *dec, FSLM *lm, $/;"	f	file:
LMCacheTransProb_kenlm	HTKLVRec/HLVRec-LM.c	/^static LMTokScore LMCacheTransProb_kenlm (DecoderInst *dec, lm::base::Model *lm_kenlm, lm::base::Vocabulary& vocab_kenlm,$/;"	f	file:
LMF_BINARY	HLMLib/LModel.h	/^  LMF_TEXT, LMF_BINARY, LMF_ULTRA, LMF_OTHER$/;"	e	enum:__anon7
LMF_OTHER	HLMLib/LModel.h	/^  LMF_TEXT, LMF_BINARY, LMF_ULTRA, LMF_OTHER$/;"	e	enum:__anon7
LMF_TEXT	HLMLib/LModel.h	/^  LMF_TEXT, LMF_BINARY, LMF_ULTRA, LMF_OTHER$/;"	e	enum:__anon7
LMF_ULTRA	HLMLib/LModel.h	/^  LMF_TEXT, LMF_BINARY, LMF_ULTRA, LMF_OTHER$/;"	e	enum:__anon7
LMFileFmt	HLMLib/LModel.h	/^} LMFileFmt;$/;"	t	typeref:enum:__anon7
LMFileHdr	HLMLib/LUtil.h	/^typedef struct lmFileHdrRec * LMFileHdr;     \/* Abstract type *\/       $/;"	t	typeref:struct:lmFileHdrRec
LMFileHdrRec	HLMLib/LUtil.c	/^}LMFileHdrRec;$/;"	t	typeref:struct:lmFileHdrRec	file:
LMHdrKind	HLMLib/LUtil.h	/^} LMHdrKind;$/;"	t	typeref:enum:__anon19
LMINMIX	HTKLib/HModel.h	53;"	d
LMId	HTKLVRec/config.h	/^typedef unsigned int LMId;$/;"	t
LMIdMapper	HTKLVRec/HLVLM.c	/^static LMId LMIdMapper(FSLM_ngram *nglm, char *w)$/;"	f	file:
LMInfo	HLMLib/LPMerge.h	/^} LMInfo;$/;"	t	typeref:struct:__anon18
LMInitial	HTKLVRec/HLVLM.c	/^LMState LMInitial (FSLM *lm)$/;"	f
LMLACacheEntry	HTKLVRec/HLVRec.h	/^typedef  struct _LMLACacheEntry LMLACacheEntry;$/;"	t	typeref:struct:_LMLACacheEntry
LMLA_CACHE_SIZE	HTKLVRec/HLVRec.h	190;"	d
LMLA_HASH	HTKLVRec/HLVRec.h	191;"	d
LMLA_nocache	HTKLVRec/HLVRec-LM.c	/^LMTokScore LMLA_nocache (DecoderInst *dec, LMState lmState, int lmlaIdx)$/;"	f
LMLookAhead	HTKLVRec/HLVLM.c	/^LogFloat LMLookAhead (FSLM *lm, LMState src, PronId minPron, PronId maxPron)$/;"	f
LMLookAhead_2gram	HTKLVRec/HLVLM.c	/^LogFloat LMLookAhead_2gram (FSLM *lm, LMState src, PronId minPron, PronId maxPron)$/;"	f
LMLookAhead_3gram	HTKLVRec/HLVLM.c	/^LogFloat LMLookAhead_3gram (FSLM *lm, LMState src, PronId minPron, PronId maxPron)$/;"	f
LMLookAhead_kenlm	HTKLVRec/HLVLM.c	/^LogFloat LMLookAhead_kenlm (DecoderInst* dec, lm::ngram::State& src, PronId minPron, PronId maxPron)$/;"	f
LMLookAhead_latlm	HTKLVRec/HLVLM.c	/^LogFloat LMLookAhead_latlm (FSLM *lm, LMState src, $/;"	f
LMLookAhead_ngram	HTKLVRec/HLVLM.c	/^LogFloat LMLookAhead_ngram (FSLM *lm, LMState src, PronId minPron, PronId maxPron)$/;"	f
LMNDX	HLMLib/LPCalc.c	116;"	d	file:
LMNodeCache	HTKLVRec/HLVRec.h	/^typedef struct _LMNodeCache LMNodeCache;$/;"	t	typeref:struct:_LMNodeCache
LMP_COUNT	HLMLib/LModel.h	/^  LMP_COUNT = 004,$/;"	e	enum:__anon8
LMP_FLOAT	HLMLib/LModel.h	/^  LMP_FLOAT = 002,$/;"	e	enum:__anon8
LMP_LOG	HLMLib/LModel.h	/^  LMP_LOG   = 001,$/;"	e	enum:__anon8
LMP_OTHER	HLMLib/LModel.h	/^  LMP_OTHER = 010$/;"	e	enum:__anon8
LMProbType	HLMLib/LModel.h	/^} LMProbType;$/;"	t	typeref:enum:__anon8
LMSCALE	HTKLib/HArc.c	/^static float LMSCALE = 0;$/;"	v	file:
LMState	HTKLVRec/HLVLM.h	/^typedef Ptr LMState;$/;"	t
LMState	HTKLib/HLM.h	/^typedef Ptr LMState;$/;"	t
LMTextFilter	HTKLib/HShell.h	/^   LMTextFilter,    \/* LM source text input via LGPrep *\/$/;"	e	enum:__anon153
LMTokScore	HTKLVRec/config.h	/^typedef LogFloat LMTokScore;$/;"	t
LMTrans	HTKLib/HLM.c	/^LogFloat LMTrans (LModel *lm, LMState src, LabId wdid, LMState *dest)$/;"	f
LMTrans2	HLMLib/LModel.c	/^LogFloat LMTrans2(LModel *LM, LMState src, LabId word, LMState *dest)$/;"	f
LMTransProb	HTKLVRec/HLVLM.c	/^LogFloat LMTransProb (FSLM *lm, LMState src, PronId pronid, LMState *dest)$/;"	f
LMTransProb_kenlm	HTKLVRec/HLVLM.c	/^LogFloat LMTransProb_kenlm(lm::base::Model lm_kenlm, lm::base::Vocabulary vocab_kenlm, lm::ngram::State& src, char* pWord,lm::ngram::State& dest)$/;"	f
LMTransProb_latlm	HTKLVRec/HLVLM.c	/^LogFloat LMTransProb_latlm (FSLM *lm, LMState src,$/;"	f
LMTransProb_ngram	HTKLVRec/HLVLM.c	/^LogFloat LMTransProb_ngram (FSLM *lm, LMState src, PronId pronid, LMState *dest)$/;"	f
LMType	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, hlmModel } LMType;$/;"	t	typeref:enum:__anon105
LMWordIndex	HTKLVRec/kenlm/lm/word_index.hh	/^typedef lm::WordIndex LMWordIndex;$/;"	t
LM_BHIKSHA_H	HTKLVRec/kenlm/lm/bhiksha.hh	14;"	d
LM_BINARY_FORMAT_H	HTKLVRec/kenlm/lm/binary_format.hh	2;"	d
LM_BLANK_H	HTKLVRec/kenlm/lm/blank.hh	2;"	d
LM_BUILDER_ADJUST_COUNTS_H	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	2;"	d
LM_BUILDER_CORPUS_COUNT_H	HTKLVRec/kenlm/lm/builder/corpus_count.hh	2;"	d
LM_BUILDER_DISCOUNT_H	HTKLVRec/kenlm/lm/builder/discount.hh	2;"	d
LM_BUILDER_HASH_GAMMA__	HTKLVRec/kenlm/lm/builder/hash_gamma.hh	2;"	d
LM_BUILDER_HEADER_INFO_H	HTKLVRec/kenlm/lm/builder/header_info.hh	2;"	d
LM_BUILDER_INITIAL_PROBABILITIES_H	HTKLVRec/kenlm/lm/builder/initial_probabilities.hh	2;"	d
LM_BUILDER_INTERPOLATE_H	HTKLVRec/kenlm/lm/builder/interpolate.hh	2;"	d
LM_BUILDER_JOINT_ORDER_H	HTKLVRec/kenlm/lm/builder/joint_order.hh	2;"	d
LM_BUILDER_NGRAM_H	HTKLVRec/kenlm/lm/builder/ngram.hh	2;"	d
LM_BUILDER_NGRAM_STREAM_H	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	2;"	d
LM_BUILDER_OUTPUT_H	HTKLVRec/kenlm/lm/builder/output.hh	2;"	d
LM_BUILDER_PIPELINE_H	HTKLVRec/kenlm/lm/builder/pipeline.hh	2;"	d
LM_BUILDER_PRINT_H	HTKLVRec/kenlm/lm/builder/print.hh	2;"	d
LM_BUILDER_SORT_H	HTKLVRec/kenlm/lm/builder/sort.hh	2;"	d
LM_COMMA	HTKLVRec/kenlm/lm/model.hh	130;"	d
LM_CONFIG_H	HTKLVRec/kenlm/lm/config.hh	2;"	d
LM_ENUMERATE_VOCAB_H	HTKLVRec/kenlm/lm/enumerate_vocab.hh	2;"	d
LM_FACADE_H	HTKLVRec/kenlm/lm/facade.hh	2;"	d
LM_FILTER_ARPA_IO_H	HTKLVRec/kenlm/lm/filter/arpa_io.hh	2;"	d
LM_FILTER_COUNT_IO_H	HTKLVRec/kenlm/lm/filter/count_io.hh	2;"	d
LM_FILTER_FORMAT_H	HTKLVRec/kenlm/lm/filter/format.hh	2;"	d
LM_FILTER_PHRASE_H	HTKLVRec/kenlm/lm/filter/phrase.hh	2;"	d
LM_FILTER_PHRASE_METHOD	HTKLVRec/kenlm/lm/filter/phrase.hh	13;"	d
LM_FILTER_THREAD_H	HTKLVRec/kenlm/lm/filter/thread.hh	2;"	d
LM_FILTER_VOCAB_H	HTKLVRec/kenlm/lm/filter/vocab.hh	2;"	d
LM_FILTER_WRAPPER_H	HTKLVRec/kenlm/lm/filter/wrapper.hh	2;"	d
LM_INDEX	HLMLib/LModel.h	70;"	d
LM_Id	HLMLib/LModel.h	/^typedef UInt   LM_Id;       \/* 4-byte ID for large models *\/$/;"	t
LM_Id	HLMLib/LModel.h	/^typedef UShort LM_Id;       \/* 2-byte ID for normal models *\/$/;"	t
LM_LEFT_H	HTKLVRec/kenlm/lm/left.hh	39;"	d
LM_LM_EXCEPTION_H	HTKLVRec/kenlm/lm/lm_exception.hh	2;"	d
LM_MAX_ORDER_H	HTKLVRec/kenlm/lm/max_order.hh	2;"	d
LM_MODEL_H	HTKLVRec/kenlm/lm/model.hh	2;"	d
LM_MODEL_TYPE_H	HTKLVRec/kenlm/lm/model_type.hh	2;"	d
LM_NAME_MODEL	HTKLVRec/kenlm/lm/model.hh	131;"	d
LM_NEURAL_WORDVECS_H	HTKLVRec/kenlm/lm/neural/wordvecs.hh	2;"	d
LM_NGRAM_INT	HTKLVRec/config.h	42;"	d
LM_NGRAM_QUERY_H	HTKLVRec/kenlm/lm/ngram_query.hh	2;"	d
LM_NSIZE	HLMLib/LModel.h	47;"	d
LM_PARTIAL_H	HTKLVRec/kenlm/lm/partial.hh	2;"	d
LM_Prob	HLMLib/LModel.h	/^typedef UShort LM_Prob;     \/* 2-byte compressed probability *\/$/;"	t
LM_Prob	HLMLib/LModel.h	/^typedef float  LM_Prob;     \/* 4-byte probability\/count *\/$/;"	t
LM_QUANTIZE_H	HTKLVRec/kenlm/lm/quantize.hh	2;"	d
LM_READ_ARPA_H	HTKLVRec/kenlm/lm/read_arpa.hh	2;"	d
LM_RETURN_H	HTKLVRec/kenlm/lm/return.hh	2;"	d
LM_SEARCH_HASHED_H	HTKLVRec/kenlm/lm/search_hashed.hh	2;"	d
LM_SEARCH_TRIE_H	HTKLVRec/kenlm/lm/search_trie.hh	2;"	d
LM_SIZES_H	HTKLVRec/kenlm/lm/sizes.hh	2;"	d
LM_STATE_H	HTKLVRec/kenlm/lm/state.hh	2;"	d
LM_TRIE_H	HTKLVRec/kenlm/lm/trie.hh	2;"	d
LM_TRIE_SORT_H	HTKLVRec/kenlm/lm/trie_sort.hh	4;"	d
LM_TXT_BINARY	HLMLib/LModel.h	82;"	d
LM_TXT_OTHER	HLMLib/LModel.h	84;"	d
LM_TXT_TEXT	HLMLib/LModel.h	81;"	d
LM_TXT_ULTRA	HLMLib/LModel.h	83;"	d
LM_TYPES_DEFINED	HLMLib/LGBase.h	50;"	d
LM_TYPES_DEFINED	HLMLib/LModel.h	97;"	d
LM_VALUE_BUILD_H	HTKLVRec/kenlm/lm/value_build.hh	2;"	d
LM_VALUE_H	HTKLVRec/kenlm/lm/value.hh	2;"	d
LM_VIRTUAL_INTERFACE_H	HTKLVRec/kenlm/lm/virtual_interface.hh	2;"	d
LM_VOCAB_H	HTKLVRec/kenlm/lm/vocab.hh	2;"	d
LM_WEIGHTS_H	HTKLVRec/kenlm/lm/weights.hh	2;"	d
LM_WORD_INDEX_H	HTKLVRec/kenlm/lm/word_index.hh	3;"	d
LM_WRAPPERS_NPLM_H	HTKLVRec/kenlm/lm/wrappers/nplm.hh	2;"	d
LMlaNode	HTKLVRec/HLVNet.h	/^} LMlaNode;$/;"	t	typeref:struct:_LMlaNode
LMlaTree	HTKLVRec/HLVNet.h	/^typedef struct _LMlaTree LMlaTree;$/;"	t	typeref:struct:_LMlaTree
LModel	HTKLib/HLM.h	/^} LModel;$/;"	t	typeref:struct:lmodel
LN10	HLMLib/LModel.h	52;"	d
LN10	HTKLVRec/HLVLM.c	/^const double LN10 = 2.30258509299404568;    \/* Defined to save recalculating it *\/$/;"	v
LN10	HTKLib/HLM.c	53;"	d	file:
LNGCX_FMT	HTKLib/esig_asc.c	83;"	d	file:
LNGCX_W	HTKLib/esig_asc.c	82;"	d	file:
LNGCX_WFMT	HTKLib/esig_asc.c	84;"	d	file:
LNG_FMT	HTKLib/esig_asc.c	51;"	d	file:
LNG_W	HTKLib/esig_asc.c	50;"	d	file:
LNG_WFMT	HTKLib/esig_asc.c	52;"	d	file:
LN_CON	HTKLVRec/HLVNet.h	/^  LN_WORDEND, LN_CON, LN_MODEL$/;"	e	enum:_LexNodeType
LN_MODEL	HTKLVRec/HLVNet.h	/^  LN_WORDEND, LN_CON, LN_MODEL$/;"	e	enum:_LexNodeType
LN_WORDEND	HTKLVRec/HLVNet.h	/^  LN_WORDEND, LN_CON, LN_MODEL$/;"	e	enum:_LexNodeType
LNode	HTKLib/HNet.h	/^LNode;$/;"	t	typeref:struct:lnode
LNodeBw	HTKLib/HLat.h	57;"	d
LNodeFw	HTKLib/HLat.h	56;"	d
LNodeStats	HTKLib/HLat.c	864;"	d	file:
LOADFIDX	HTKLib/HModel.c	67;"	d	file:
LOFREQ	HTKLib/HParm.c	/^   LOFREQ,        \/* Lo Fbank frequency *\/$/;"	e	enum:__anon142	file:
LOG10_TO_FLT	HLMLib/LModel.h	54;"	d
LOGDET	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon117	file:
LOG_NATURAL	HLMLib/LModel.h	61;"	d
LONG	HTKLib/esignal.h	68;"	d
LONG_COMPLEX	HTKLib/esignal.h	77;"	d
LOpen	HTKLib/HLabel.c	/^Transcription *LOpen(MemHeap *x, char * fname, FileFormat fmt)$/;"	f
LPARSYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
LPC	HTKLib/HParm.h	/^      LPC,LPREFC,LPCEPSTRA,LPDELCEP,   \/* LP-based Coefficients *\/$/;"	e	enum:_BaseParmKind
LPC2Cepstrum	HTKLib/HSigP.c	/^void LPC2Cepstrum (Vector a, Vector c)$/;"	f
LPC2RefC	HTKLib/HSigP.c	/^void LPC2RefC(Vector a, Vector k)$/;"	f
LPCEPSTRA	HTKLib/HParm.h	/^      LPC,LPREFC,LPCEPSTRA,LPDELCEP,   \/* LP-based Coefficients *\/$/;"	e	enum:_BaseParmKind
LPCORDER	HTKLib/HParm.c	/^   LPCORDER,      \/* LPC order *\/      $/;"	e	enum:__anon142	file:
LPCbased	HTKLib/HParm.c	/^typedef enum { FFTbased, LPCbased, VQbased} CodeStyle;$/;"	e	enum:__anon140	file:
LPDELCEP	HTKLib/HParm.h	/^      LPC,LPREFC,LPCEPSTRA,LPDELCEP,   \/* LP-based Coefficients *\/$/;"	e	enum:_BaseParmKind
LPREFC	HTKLib/HParm.h	/^      LPC,LPREFC,LPCEPSTRA,LPDELCEP,   \/* LP-based Coefficients *\/$/;"	e	enum:_BaseParmKind
LS	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon199	file:
LSBLOCK	HTKTools/HParse.c	280;"	d	file:
LSMALL	HTKLib/HMath.h	43;"	d
LSave	HTKLib/HLabel.c	/^ReturnStatus LSave(char *fname, Transcription *t, FileFormat fmt)$/;"	f
LSub	HTKLib/HMath.c	/^LogDouble LSub(LogDouble x, LogDouble y)$/;"	f
LT	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon199	file:
LTBNDX	HLMLib/LWMap.c	143;"	d	file:
LTRISYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
LTriStrip	HTKLib/HLabel.c	/^void LTriStrip(Boolean enab)$/;"	f
LUDecompose	HTKLib/HMath.c	/^static Boolean LUDecompose(Matrix a, int *perm, int *sign)$/;"	f	file:
LVREC	Makefile	/^LVREC = HTKLVRec$/;"	m
LWMapFilter	HTKLib/HShell.h	/^   LWMapFilter,     \/* LM Word Map Input via LWMap *\/$/;"	e	enum:__anon153
LWMapOFilter	HTKLib/HShell.h	/^   LWMapOFilter,    \/* LM Word Map Output via LWMap *\/$/;"	e	enum:__anon153
LZERO	HTKLib/HMath.h	42;"	d
L_VERSION	HTKLib/HNet.h	73;"	d
LabId	HTKLib/HLabel.h	/^typedef NameCell *LabId;   \/* Internal representation of names *\/$/;"	t
LabList	HTKLib/HLabel.h	/^}LabList;$/;"	t	typeref:struct:_LabList
Label	HTKLib/HLabel.h	/^}Label; \/* NB: head and tail of every list are dummy sentinels *\/$/;"	t	typeref:struct:_Label
LabelInternal	HTKTools/HParse.c	/^void LabelInternal(Link p)$/;"	f
LabelsFilter	HTKLib/HShell.h	/^   LabelsFilter,    \/* Label files input via HLabel *\/$/;"	e	enum:__anon153
LabelsOFilter	HTKLib/HShell.h	/^   LabelsOFilter,   \/* Label files output via HLabel *\/$/;"	e	enum:__anon153
LambdaOpt	HTKTools/HSmooth.c	/^float LambdaOpt(StreamElem *ste, int M)$/;"	f
LangModFilter	HTKLib/HShell.h	/^   LangModFilter,   \/* language model files input via HLM *\/$/;"	e	enum:__anon153
LangModOFilter	HTKLib/HShell.h	/^   LangModOFilter,  \/* language model files output via HLM *\/$/;"	e	enum:__anon153
Language Modelling	HTKBook/htkbook-pdf.tex	/^\\part{Language Modelling}$/;"	p
Language Modelling	HTKBook/htkbook.tex	/^\\part{Language Modelling}$/;"	p
LatAttachInfo	HTKLib/HLat.c	/^void LatAttachInfo (MemHeap *heap, size_t size, Lattice *lat)$/;"	f
LatCheck	HTKLib/HLat.c	/^void LatCheck (Lattice *lat)$/;"	f
LatDetachInfo	HTKLib/HLat.c	/^void LatDetachInfo (MemHeap *heap, Lattice *lat)$/;"	f
LatEndNode	HTKLib/HLat.c	/^LNode *LatEndNode (Lattice *lat)$/;"	f
LatExpand	HTKLib/HLat.c	/^Lattice *LatExpand (MemHeap *heap, Lattice *lat, LModel *lm)$/;"	f
LatFBType	HTKLib/HLat.h	/^typedef enum {LATFB_SUM, LATFB_MAX} LatFBType;$/;"	t	typeref:enum:__anon112
LatFieldType	HTKLib/HNet.c	/^typedef enum {UNK_FIELD, STR_FIELD, INT_FIELD, FLT_FIELD} LatFieldType;$/;"	t	typeref:enum:__anon136	file:
LatFindBest	HTKLib/HLat.c	/^Transcription *LatFindBest (MemHeap *heap, Lattice *lat, int N)$/;"	f
LatFormat	HTKLib/HNet.h	/^typedef int LatFormat;      \/* Format of lattice. Formed by oring flags *\/$/;"	t
LatForwBackw	HTKLib/HLat.c	/^LogDouble LatForwBackw (Lattice *lat, LatFBType type)$/;"	f
LatFromPaths	HTKLib/HRec.c	/^static void LatFromPaths(Path *path,int *ln,Lattice *lat)$/;"	f	file:
LatInLat	HTKLib/HArc.c	/^Boolean LatInLat(Lattice *numLat, Lattice *denLat){$/;"	f
LatInLatRec	HTKLib/HArc.c	/^Boolean LatInLatRec(LNode *n1, LNode *n2){$/;"	f
LatLMTrans	HTKLib/HLat.c	/^static LogFloat  LatLMTrans (LModel *lm, LMState src, LabId wordId, LMState *dest)$/;"	f	file:
LatMask_Denominator	HTKTools/HMMIRest.c	/^static char *LatMask_Denominator = NULL;$/;"	v	file:
LatMask_Numerator	HTKTools/HMMIRest.c	/^static char *LatMask_Numerator   = NULL;$/;"	v	file:
LatPrune	HTKLib/HLat.c	/^Lattice *LatPrune (MemHeap *heap, Lattice *lat, LogDouble thresh, float arcsPerSec)$/;"	f
LatSetBoundaryWords	HTKLib/HLat.c	/^void LatSetBoundaryWords (char *start, char *end, char  *startLM, char *endLM)$/;"	f
LatSetScores	HTKLib/HLat.c	/^void LatSetScores (Lattice *lat)$/;"	f
LatStartNode	HTKLib/HLat.c	/^LNode *LatStartNode (Lattice *lat)$/;"	f
LatTopSort	HTKLib/HLat.c	/^Boolean LatTopSort (Lattice *lat, LNode **topOrder)$/;"	f
LatTopSortVisit	HTKLib/HLat.c	/^void LatTopSortVisit (LNode *ln, int *time)$/;"	f
LatTraceBack	HTKLVRec/HLVRec-traceback.c	/^Lattice *LatTraceBack (MemHeap *heap, DecoderInst *dec)$/;"	f
LatTraceBackCount	HTKLVRec/HLVRec-traceback.c	/^static void LatTraceBackCount (DecoderInst *dec, WordendHyp *path, int *nnodes, int *nlinks)$/;"	f	file:
Lattice	HTKLib/HNet.h	/^Lattice;$/;"	t	typeref:struct:lattice
LatticeFromLabels	HTKLib/HNet.c	/^Lattice *LatticeFromLabels(LabList *ll,LabId bnd,Vocab *voc,MemHeap *heap)$/;"	f
LayerId	HTKLVRec/HLVNet.h	/^} LayerId;$/;"	t	typeref:enum:_LayerId
LayerStats	HTKLVRec/HLVRec-misc.c	/^typedef struct _LayerStats LayerStats;$/;"	t	typeref:struct:_LayerStats	file:
Left	HTKLVRec/kenlm/lm/state.hh	/^struct Left {$/;"	s	namespace:lm::ngram
LeftTriCxt	HTKTools/HLEd.c	/^LabId LeftTriCxt(LLink l)$/;"	f
Length	HTKLVRec/kenlm/lm/state.hh	/^    unsigned char Length() const { return length; }$/;"	f	class:lm::ngram::State
Less	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static bool Less(const Bignum& a, const Bignum& b) {$/;"	f	class:double_conversion::Bignum
LessEqual	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static bool LessEqual(const Bignum& a, const Bignum& b) {$/;"	f	class:double_conversion::Bignum
LessWrapper	HTKLVRec/kenlm/util/joint_sort.hh	/^    explicit LessWrapper(const Less &less) : less_(less) {}$/;"	f	class:util::detail::LessWrapper
LessWrapper	HTKLVRec/kenlm/util/joint_sort.hh	/^template <class Proxy, class Less> class LessWrapper : public std::binary_function<const typename Proxy::value_type &, const typename Proxy::value_type &, bool> {$/;"	c	namespace:util::detail
LexNet	HTKLVRec/HLVNet.h	/^} LexNet;$/;"	t	typeref:struct:_LexNet
LexNode	HTKLVRec/HLVNet.h	/^typedef struct _LexNode LexNode;$/;"	t	typeref:struct:_LexNode
LexNodeInst	HTKLVRec/HLVNet.h	/^typedef struct _LexNodeInst LexNodeInst;        \/* structure defined in HLVRec *\/$/;"	t	typeref:struct:_LexNodeInst
LexNodeType	HTKLVRec/HLVNet.h	/^} LexNodeType;$/;"	t	typeref:enum:_LexNodeType
LikeToWord	HTKLib/HRec.c	/^static LogFloat LikeToWord(NetNode *node)$/;"	f	file:
LinSolve	HTKLib/HMath.c	/^static void LinSolve(Matrix a, int *perm, float *b)$/;"	f	file:
LinTranQuaProd	HTKLib/HMath.c	/^void LinTranQuaProd(Matrix Prod, Matrix A, Matrix C)$/;"	f
LinXForm	HTKLib/HModel.h	/^} LinXForm;$/;"	t	typeref:struct:__anon132
Line	HTKLVRec/kenlm/lm/filter/format.hh	/^    struct Line {$/;"	s	class:lm::InputBuffer
Line	HTKLVRec/kenlm/lm/ngram_query.hh	/^  void Line(uint64_t oov, float total) const {$/;"	f	struct:lm::ngram::BasicPrint
LineInput	HTKLVRec/kenlm/util/stream/line_input.hh	/^class LineInput {$/;"	c	namespace:util::stream
LineWidth	HTKLib/HGraf_WIN32.c	/^static int LineWidth = 1;$/;"	v	file:
Link	HTKLVRec/kenlm/util/stream/chain.cc	/^Link::Link() : in_(NULL), out_(NULL), poisoned_(true) {}$/;"	f	class:util::stream::Link
Link	HTKLVRec/kenlm/util/stream/chain.cc	/^Link::Link(const ChainPosition &position) : in_(NULL) {$/;"	f	class:util::stream::Link
Link	HTKLVRec/kenlm/util/stream/chain.hh	/^class Link {$/;"	c	namespace:util::stream
Link	HTKTools/HParse.c	/^typedef struct _Node *Link;$/;"	t	typeref:struct:_Node	file:
LinkEquiv	HLMTools/LPlex.c	/^static void LinkEquiv(void)$/;"	f	file:
LinkSet	HTKTools/HParse.c	/^} LinkSet;$/;"	t	typeref:struct:__anon203	file:
ListFinds	HTKTools/HLEd.c	/^void ListFinds(void)$/;"	f
ListNewPhones	HTKTools/HDMan.c	/^void ListNewPhones(void)$/;"	f
ListParms	HTKTools/HList.c	/^void ListParms(char *src)$/;"	f
ListSpeech	HTKTools/HList.c	/^void ListSpeech(char *src)$/;"	f
ListWavefromAudio	HTKTools/HList.c	/^void ListWavefromAudio(void)$/;"	f
ListWavefromFile	HTKTools/HList.c	/^void ListWavefromFile(char *src)$/;"	f
LoadASet	HTKTools/HSmooth.c	/^int LoadASet(LabId x)$/;"	f
LoadAccs	HTKLib/HTrain.c	/^Source LoadAccs(HMMSet *hset, char *fname, UPDSet uFlags){ return LoadAccsParallel(hset,fname,uFlags,0); }$/;"	f
LoadAccsParallel	HTKLib/HTrain.c	/^Source LoadAccsParallel(HMMSet *hset, char *fname, UPDSet uFlags, int index)$/;"	f
LoadAllMacros	HTKLib/HModel.c	/^static ReturnStatus LoadAllMacros(HMMSet *hset, char *fname, short fidx)$/;"	f	file:
LoadBaseClass	HTKLib/HModel.c	/^BaseClass *LoadBaseClass(HMMSet *hset, char* macroname, char *fname)$/;"	f
LoadBiGrams	HLMTools/Cluster.c	/^static void LoadBiGrams()$/;"	f	file:
LoadBinary	HTKLVRec/kenlm/lm/binary_format.cc	/^void *BinaryFormat::LoadBinary(std::size_t size) {$/;"	f	class:lm::ngram::BinaryFormat
LoadCMeanVector	HTKLib/HParm.c	/^static void LoadCMeanVector( MemHeap* x , IOConfig cf , char* fname )$/;"	f	file:
LoadClass	HLMLib/LCMap.c	/^static void LoadClass(ClassMap *cm, Source *src, LabId clname, int clndx, $/;"	f	file:
LoadData	HTKLib/HFB.c	/^void LoadData(HMMSet *hset, UttInfo *utt, FileFormat dff, $/;"	f
LoadData	HTKLib/HWave.c	/^static ReturnStatus LoadData(FILE *f, Wave w, long fBytes)$/;"	f	file:
LoadData	HTKTools/HSLab.c	/^void LoadData(void)$/;"	f
LoadESPSLabels	HTKLib/HLabel.c	/^static void LoadESPSLabels(MemHeap *x, Transcription *t, Source *src)$/;"	f	file:
LoadException	HTKLVRec/kenlm/lm/lm_exception.cc	/^LoadException::LoadException() throw() {}$/;"	f	class:lm::LoadException
LoadException	HTKLVRec/kenlm/lm/lm_exception.hh	/^class LoadException : public util::Exception {$/;"	c	namespace:lm
LoadFVTrans	HTKLVRec/HDecode.c	/^void LoadFVTrans (char *fn, BlockMatrix *transMat)$/;"	f
LoadFVTrans	HTKLVRec/HDecode.mod.c	/^void LoadFVTrans (char *fn, BlockMatrix *transMat)$/;"	f
LoadFile	HTKTools/HCompV.c	/^void LoadFile(char *fn)$/;"	f
LoadFile	HTKTools/HInit.c	/^void LoadFile(char *fn)$/;"	f
LoadFile	HTKTools/HQuant.c	/^void LoadFile(char *fn)$/;"	f
LoadFile	HTKTools/HRest.c	/^void LoadFile(char *fn)$/;"	f
LoadFiles	HTKTools/HSLab.c	/^void LoadFiles(void)$/;"	f
LoadHMMSet	HTKLib/HModel.c	/^ReturnStatus LoadHMMSet(HMMSet *hset, char *hmmDir, char *hmmExt)$/;"	f
LoadHTKLabels	HTKLib/HLabel.c	/^static void LoadHTKLabels(MemHeap *x, Transcription *t, Source *src)$/;"	f	file:
LoadHTKList	HTKLib/HLabel.c	/^static LabList * LoadHTKList(MemHeap *x, Source *src, int alt)$/;"	f	file:
LoadInputXForm	HTKLib/HModel.c	/^InputXForm *LoadInputXForm(HMMSet *hset, char* macroname, char *fname)$/;"	f
LoadLabs	HTKLib/HFB.c	/^void LoadLabs(UttInfo *utt, FileFormat lff, char * datafn, $/;"	f
LoadLabs	HTKTools/HSLab.c	/^void LoadLabs(void)$/;"	f
LoadLangModel	HLMLib/LModel.c	/^BackOffLM *LoadLangModel(char *fn, WordMap *wl, float gramScale,$/;"	f
LoadLattice	HTKTools/HBuild.c	/^Lattice *LoadLattice(MemHeap *latHeap, char *latFn, Vocab *voc,$/;"	f
LoadMacroFiles	HTKLib/HModel.c	/^static ReturnStatus LoadMacroFiles(HMMSet *hset)$/;"	f	file:
LoadMapData	HLMLib/LCMap.c	/^static void LoadMapData(Source *src, ClassMap *cm, int entries)$/;"	f	file:
LoadMapData	HLMLib/LWMap.c	/^static void LoadMapData(Source *src, WordMap *wm)$/;"	f	file:
LoadMasterFile	HTKLib/HLabel.c	/^void LoadMasterFile(char *fname)$/;"	f
LoadMat	HTKLib/HParm.c	/^static void LoadMat (MemHeap *x, IOConfig cf)  \/*static??*\/$/;"	f	file:
LoadMethod	HTKLVRec/kenlm/util/mmap.hh	/^} LoadMethod;$/;"	t	namespace:util	typeref:enum:util::__anon76
LoadMuAcc	HTKLib/HTrain.c	/^static void LoadMuAcc(Source *src, MuAcc *ma, int vSize)$/;"	f	file:
LoadNGram	HLMLib/LModel.c	/^static int LoadNGram(Source *src, int nSize, BackOffLM *lm, int *itran)$/;"	f	file:
LoadOneXForm	HTKLib/HModel.c	/^AdaptXForm *LoadOneXForm(HMMSet *hset, char* macroname, char *fname)$/;"	f
LoadPhoneList	HTKTools/HDMan.c	/^void LoadPhoneList(void)$/;"	f
LoadQuestion	HTKTools/HHEd.c	/^void LoadQuestion(char *qName, ILink ilist, char *pattern)$/;"	f
LoadRegTree	HTKLib/HModel.c	/^RegTree *LoadRegTree(HMMSet *hset, char* macroname, char *fname)$/;"	f
LoadSCRIBELabels	HTKLib/HLabel.c	/^static void LoadSCRIBELabels(MemHeap *x, Transcription *t, Source *src)$/;"	f	file:
LoadSSet	HTKTools/HSmooth.c	/^void LoadSSet(int i, int s)$/;"	f
LoadSegment	HTKLib/HTrain.c	/^void LoadSegment(SegStore ss, HTime start, HTime end, ParmBuf pbuf)$/;"	f
LoadSideXForm	HTKLib/HParm.c	/^static AdaptXForm *LoadSideXForm(IOConfig cf, char *fname) $/;"	f	file:
LoadStatsCommand	HTKTools/HHEd.c	/^void LoadStatsCommand(void)$/;"	f
LoadStatsFile	HTKLib/HUtil.c	/^void LoadStatsFile(char *statfile,HMMSet *hset,Boolean otrace)$/;"	f
LoadTIMITLabels	HTKLib/HLabel.c	/^static void LoadTIMITLabels(MemHeap *x, Transcription *t, Source *src)$/;"	f	file:
LoadTrAcc	HTKLib/HTrain.c	/^static void LoadTrAcc(Source *src, TrAcc *ta, int numStates)$/;"	f	file:
LoadTransLabs	HTKTools/HCopy.c	/^Transcription *LoadTransLabs(char *src)$/;"	f
LoadTree	HTKTools/HHEd.c	/^Tree *LoadTree(char *name,Source *src)$/;"	f
LoadTreesCommand	HTKTools/HHEd.c	/^void LoadTreesCommand(void)$/;"	f
LoadUltraNGrams	HLMLib/LModel.c	/^static void LoadUltraNGrams(Source *src, BackOffLM *lm)$/;"	f	file:
LoadUniGrams	HLMTools/Cluster.c	/^static void LoadUniGrams()$/;"	f	file:
LoadUnigram	HLMLib/LModel.c	/^static int LoadUnigram(Source *src, BackOffLM *lm, int *itran)$/;"	f	file:
LoadVQTab	HTKLib/HVQ.c	/^VQTable LoadVQTab(char *tabFN, short magic)$/;"	f
LoadVaAcc	HTKLib/HTrain.c	/^static void LoadVaAcc(Source *src, VaAcc *va, int vSize, CovKind ck)$/;"	f	file:
LoadVarScale	HTKLib/HParm.c	/^static void LoadVarScale (MemHeap *x, IOConfig cf)$/;"	f	file:
LoadVarScaleVector	HTKLib/HParm.c	/^static void LoadVarScaleVector(MemHeap* x, IOConfig cf, char *fname)$/;"	f	file:
LoadVirtual	HTKLVRec/kenlm/lm/model.cc	/^base::Model *LoadVirtual(const char *file_name, const Config &config, ModelType model_type) {$/;"	f	namespace:lm::ngram
LoadWordList	HTKTools/HDMan.c	/^void LoadWordList(void)$/;"	f
LoadWtAcc	HTKLib/HTrain.c	/^static void LoadWtAcc(Source *src, WtAcc *wa, int numMixtures)$/;"	f	file:
LoadedBinary	HTKLVRec/kenlm/lm/vocab.cc	/^void ProbingVocabulary::LoadedBinary(bool have_words, int fd, EnumerateVocab *to, uint64_t offset) {$/;"	f	class:lm::ngram::ProbingVocabulary
LoadedBinary	HTKLVRec/kenlm/lm/vocab.cc	/^void SortedVocabulary::LoadedBinary(bool have_words, int fd, EnumerateVocab *to, uint64_t offset) {$/;"	f	class:lm::ngram::SortedVocabulary
LogDouble	HTKLib/HMath.h	/^typedef double LogDouble;$/;"	t
LogFloat	HTKLib/HMath.h	/^typedef float  LogFloat;   \/* types just to signal log values *\/$/;"	t
LongComplex	HTKLib/esignal.h	/^typedef struct {long	real, imag;}	LongComplex;$/;"	t	typeref:struct:__anon184
LongProd	HTKLib/esignal.c	/^LongProd(int     n,$/;"	f
LongVal	HTKLib/esignal.c	/^LongVal(void *src, int type, long *dest)$/;"	f	file:
Longest	HTKLVRec/kenlm/lm/search_hashed.hh	/^    typedef util::ProbingHashTable<ProbEntry, util::IdentityHash> Longest;$/;"	t	class:lm::ngram::detail::HashedSearch
Longest	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Longest(const void * \/*data*\/) {$/;"	f	class:lm::ngram::trie::__anon58::FindBlanks
Longest	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Longest(const void *data) {$/;"	f	class:lm::ngram::trie::__anon58::WriteEntries
Longest	HTKLVRec/kenlm/lm/search_trie.hh	/^    typedef trie::BitPackedLongest Longest;$/;"	t	class:lm::ngram::trie::TrieSearch
LongestBits	HTKLVRec/kenlm/lm/quantize.hh	/^    static uint8_t LongestBits(const Config &\/*config*\/) { return 31; }$/;"	f	class:lm::ngram::DontQuantize
LongestBits	HTKLVRec/kenlm/lm/quantize.hh	/^    static uint8_t LongestBits(const Config &config) { return config.prob_bits; }$/;"	f	class:lm::ngram::SeparatelyQuantize
LongestPointer	HTKLVRec/kenlm/lm/quantize.hh	/^        LongestPointer() : address_(NULL, 0) {}$/;"	f	class:lm::ngram::DontQuantize::LongestPointer
LongestPointer	HTKLVRec/kenlm/lm/quantize.hh	/^        LongestPointer() : address_(NULL, 0) {}$/;"	f	class:lm::ngram::SeparatelyQuantize::LongestPointer
LongestPointer	HTKLVRec/kenlm/lm/quantize.hh	/^        LongestPointer(const SeparatelyQuantize &quant, const util::BitAddress &address) : table_(&quant.LongestTable()), address_(address) {}$/;"	f	class:lm::ngram::SeparatelyQuantize::LongestPointer
LongestPointer	HTKLVRec/kenlm/lm/quantize.hh	/^        explicit LongestPointer(const DontQuantize &\/*quant*\/, util::BitAddress address) : address_(address) {}$/;"	f	class:lm::ngram::DontQuantize::LongestPointer
LongestPointer	HTKLVRec/kenlm/lm/quantize.hh	/^    class LongestPointer {$/;"	c	class:lm::ngram::DontQuantize
LongestPointer	HTKLVRec/kenlm/lm/quantize.hh	/^    class LongestPointer {$/;"	c	class:lm::ngram::SeparatelyQuantize
LongestPointer	HTKLVRec/kenlm/lm/search_hashed.hh	/^    LongestPointer() : to_(NULL) {}$/;"	f	class:lm::ngram::detail::LongestPointer
LongestPointer	HTKLVRec/kenlm/lm/search_hashed.hh	/^    explicit LongestPointer(const float &to) : to_(&to) {}$/;"	f	class:lm::ngram::detail::LongestPointer
LongestPointer	HTKLVRec/kenlm/lm/search_hashed.hh	/^    typedef ::lm::ngram::detail::LongestPointer LongestPointer;$/;"	t	class:lm::ngram::detail::HashedSearch
LongestPointer	HTKLVRec/kenlm/lm/search_hashed.hh	/^class LongestPointer {$/;"	c	namespace:lm::ngram::detail
LongestPointer	HTKLVRec/kenlm/lm/search_trie.hh	/^    typedef typename Quant::LongestPointer LongestPointer;$/;"	t	class:lm::ngram::trie::TrieSearch
LongestTable	HTKLVRec/kenlm/lm/quantize.hh	/^    const Bins &LongestTable() const { return longest_; }$/;"	f	class:lm::ngram::SeparatelyQuantize
Lookup	HTKLVRec/kenlm/lm/builder/print.hh	/^    const char *Lookup(WordIndex index) const {$/;"	f	class:lm::builder::VocabReconstitute
Lookup	HTKLVRec/kenlm/lm/search_hashed.hh	/^        const typename Value::Weights &Lookup(WordIndex index) const {$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Lookup	HTKLVRec/kenlm/lm/trie.hh	/^    const ProbBackoff &Lookup(WordIndex index) const { return unigram_[index].weights; }$/;"	f	class:lm::ngram::trie::Unigram
Lookup	HTKLVRec/kenlm/lm/vocab.hh	/^    typedef util::AutoProbing<ProbingVocabularyEntry, util::IdentityHash> Lookup;$/;"	t	class:lm::ngram::GrowableVocab
Lookup	HTKLVRec/kenlm/lm/vocab.hh	/^    typedef util::ProbingHashTable<ProbingVocabularyEntry, util::IdentityHash> Lookup;$/;"	t	class:lm::ngram::ProbingVocabulary
LookupLongest	HTKLVRec/kenlm/lm/search_hashed.hh	/^    LongestPointer LookupLongest(WordIndex word, const Node &node) const {$/;"	f	class:lm::ngram::detail::HashedSearch
LookupLongest	HTKLVRec/kenlm/lm/search_trie.hh	/^    LongestPointer LookupLongest(WordIndex word, const Node &node) const {$/;"	f	class:lm::ngram::trie::TrieSearch
LookupMiddle	HTKLVRec/kenlm/lm/search_hashed.hh	/^    MiddlePointer LookupMiddle(unsigned char order_minus_2, WordIndex word, Node &node, bool &independent_left, uint64_t &extend_pointer) const {$/;"	f	class:lm::ngram::detail::HashedSearch
LookupMiddle	HTKLVRec/kenlm/lm/search_trie.hh	/^    MiddlePointer LookupMiddle(unsigned char order_minus_2, WordIndex word, Node &node, bool &independent_left, uint64_t &extend_left) const {$/;"	f	class:lm::ngram::trie::TrieSearch
LookupPiece	HTKLVRec/kenlm/lm/builder/print.hh	/^    StringPiece LookupPiece(WordIndex index) const {$/;"	f	class:lm::builder::VocabReconstitute
LookupTable	HLMLib/LWMap.h	/^} LookupTable;$/;"	t	typeref:struct:__anon22
LookupUnigram	HTKLVRec/kenlm/lm/search_hashed.hh	/^    UnigramPointer LookupUnigram(WordIndex word, Node &next, bool &independent_left, uint64_t &extend_left) const {$/;"	f	class:lm::ngram::detail::HashedSearch
LookupUnigram	HTKLVRec/kenlm/lm/search_trie.hh	/^    UnigramPointer LookupUnigram(WordIndex word, Node &next, bool &independent_left, uint64_t &extend_left) const {$/;"	f	class:lm::ngram::trie::TrieSearch
LowerBound	HTKLVRec/kenlm/lm/filter/phrase.cc	/^void Arc::LowerBound(const Sentence to) {$/;"	f	class:lm::phrase::detail::Arc
LowerBound	HTKLVRec/kenlm/lm/filter/phrase.cc	/^void Vertex::LowerBound(const Sentence to) {$/;"	f	class:lm::phrase::detail::Vertex
LowerBoundaryIsCloser	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  bool LowerBoundaryIsCloser() const {$/;"	f	class:double_conversion::Double
LowerBoundaryIsCloser	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  bool LowerBoundaryIsCloser() const {$/;"	f	class:double_conversion::Single
LowerRestBuild	HTKLVRec/kenlm/lm/value_build.cc	/^template <class Model> LowerRestBuild<Model>::LowerRestBuild(const Config &config, unsigned int order, const typename Model::Vocabulary &vocab) {$/;"	f	class:lm::ngram::LowerRestBuild
LowerRestBuild	HTKLVRec/kenlm/lm/value_build.hh	/^template <class Model> class LowerRestBuild {$/;"	c	namespace:lm::ngram
M	HTKLib/HUtil.h	/^   int M;            \/* num mixtures *\/$/;"	m	struct:__anon169
MACHASHSIZE	HTKLib/HModel.h	50;"	d
MACHEPS	HTKLib/HMath.c	682;"	d	file:
MACH_CALL	HTKLVRec/kenlm/util/pcqueue.hh	27;"	d
MACRO	HTKLib/HModel.c	/^   MACRO, EOFSYM, NULLSYM   \/* Special Syms - not literals *\/$/;"	e	enum:__anon117	file:
MAGIC	HTKLib/esignal.h	54;"	d
MAKEINFO	Makefile	/^MAKEINFO = @MAKEINFO@$/;"	m
MALLOC_ALLOCATED	HTKLVRec/kenlm/util/mmap.hh	/^    typedef enum {MMAP_ALLOCATED, ARRAY_ALLOCATED, MALLOC_ALLOCATED, NONE_ALLOCATED} Alloc;$/;"	e	enum:util::scoped_memory::__anon75
MAPENTRY	HLMLib/LWMap.h	/^typedef struct MAPENTRY {  \/* word map entry *\/$/;"	s
MAPUpdateModels	HTKLib/HMap.c	/^void MAPUpdateModels(HMMSet *hset, UPDSet uFlags)$/;"	f
MAP_ENTRY	HLMLib/LWMap.c	231;"	d	file:
MAP_ENTRY	HLMTools/LGCopy.c	321;"	d	file:
MARKED_ALTPATH_P	HTKLVRec/HLVRec-GC.c	48;"	d	file:
MARKED_MODPATH_P	HTKLVRec/HLVRec-GC.c	56;"	d	file:
MARKED_PATH_P	HTKLVRec/HLVRec-GC.c	41;"	d	file:
MARK_ALTPATH	HTKLVRec/HLVRec-GC.c	47;"	d	file:
MARK_ALTPATH_MASK	HTKLVRec/HLVRec-GC.c	46;"	d	file:
MARK_MODPATH	HTKLVRec/HLVRec-GC.c	55;"	d	file:
MARK_MODPATH_MASK	HTKLVRec/HLVRec-GC.c	54;"	d	file:
MARK_PATH	HTKLVRec/HLVRec-GC.c	40;"	d	file:
MARK_PATH_MASK	HTKLVRec/HLVRec-GC.c	39;"	d	file:
MATTRAN	HTKLib/HParm.c	/^   MATTRAN,$/;"	e	enum:__anon142	file:
MATTRANFN	HTKLib/HParm.c	/^   MATTRANFN,     \/* File name for MatTran file *\/$/;"	e	enum:__anon142	file:
MAUVE	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
MAX	HTKLib/HArc.c	74;"	d	file:
MAX	HTKLib/HExactMPE.c	90;"	d	file:
MAX	HTKLib/HFBLat.c	72;"	d	file:
MAX	HTKTools/HHEd.c	5313;"	d	file:
MAX	HTKTools/HMMIRest.c	61;"	d	file:
MAXARGS	HTKTools/HDMan.c	61;"	d	file:
MAXARGS	HTKTools/HLEd.c	60;"	d	file:
MAXBLOCKOBS	HTKLVRec/config.h	63;"	d
MAXCONMATSIZE	HTKTools/HResults.c	1165;"	d	file:
MAXCONS	HTKTools/HDMan.c	65;"	d	file:
MAXDICTS	HTKTools/HDMan.c	64;"	d	file:
MAXEFS	HTKLib/HShell.c	70;"	d	file:
MAXFNAMELEN	HTKLib/HShell.h	76;"	d
MAXGLOBS	HTKLib/HShell.h	78;"	d
MAXIDENT	HTKTools/HParse.c	276;"	d	file:
MAXINF	HLMLib/LGBase.h	44;"	d
MAXIV	HTKTools/HLEd.c	62;"	d	file:
MAXIW	HTKTools/HLEd.c	61;"	d	file:
MAXLATDEPTH	HTKLib/HNet.c	407;"	d	file:
MAXLATS	HTKLib/HArc.h	163;"	d
MAXMLFS	HTKLib/HLabel.c	115;"	d	file:
MAXMONOPHONES	HTKTools/HSmooth.c	39;"	d	file:
MAXNG	HLMLib/LGBase.h	43;"	d
MAXPHONES	HTKLib/HDict.h	35;"	d
MAXPRONS	HTKTools/HDMan.c	63;"	d	file:
MAXPVOC	HTKTools/HDMan.c	66;"	d	file:
MAXSTRLEN	HTKLib/HShell.h	75;"	d
MAXSYMLEN	HLMLib/LModel.c	120;"	d	file:
MAXSYMLEN	HTKLib/HModel.c	391;"	d	file:
MAXTIME	HTKTools/HCopy.c	107;"	d	file:
MAXVAR	HTKLib/HUtil.c	406;"	d	file:
MAXVQNODES	HTKLib/HVQ.c	36;"	d	file:
MAX_AMPL	HTKTools/HSLab.c	87;"	d	file:
MAX_ATTR	HTKLib/esig_asc.c	1080;"	d	file:
MAX_ATTR	HTKLib/esig_asc.c	1175;"	d	file:
MAX_COLOURS	HTKLib/HGraf.h	51;"	d
MAX_DEPTH	HTKLib/HNet.c	2459;"	d	file:
MAX_FIELDS	HLMTools/LGPrep.c	72;"	d	file:
MAX_FILES	HLMTools/LPlex.c	67;"	d	file:
MAX_FLD_DEPTH	HTKLib/esig_asc.c	36;"	d	file:
MAX_GC	HTKLib/HGraf.c	80;"	d	file:
MAX_GREYS	HTKLib/HGraf.h	50;"	d
MAX_INT	HTKLib/HParm.c	485;"	d	file:
MAX_INT	HTKLib/HWave.c	46;"	d	file:
MAX_ITEMS	HLMTools/LGPrep.c	73;"	d	file:
MAX_ITER	HTKTools/HHEd.c	61;"	d	file:
MAX_LAB_LEN	HTKTools/HSLab.c	81;"	d	file:
MAX_LM	HLMTools/LPlex.c	64;"	d	file:
MAX_LMID	HTKLVRec/HLVLM.h	95;"	d
MAX_LMID	HTKLib/HLM.h	46;"	d
MAX_LMODEL	HLMLib/LPMerge.h	43;"	d
MAX_NGRAM_FILES	HLMTools/LAdapt.c	109;"	d	file:
MAX_OOV	HLMTools/LPlex.c	63;"	d	file:
MAX_PB_SIZE	HTKLib/HParm.c	484;"	d	file:
MAX_POINT	HTKLib/HGraf_WIN32.c	41;"	d	file:
MAX_SETS	HLMTools/LGPrep.c	74;"	d	file:
MAX_STACK	HTKLib/HMath.c	686;"	d	file:
MAX_TEST	HLMTools/LPlex.c	65;"	d	file:
MAX_TOKS	HTKLib/HRec.h	32;"	d
MAX_TYPE_LEN	HTKLib/esignal.h	85;"	d
MAX_ZOOM	HTKTools/HSLab.c	74;"	d	file:
MD	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon199	file:
MEAN	HTKLib/HModel.c	/^   MEAN, VARIANCE, INVCOVAR, XFORM, GCONST,$/;"	e	enum:__anon117	file:
MEANBASE	HTKLib/HModel.h	/^enum _BaseClassKind {MIXBASE, MEANBASE, COVBASE};$/;"	e	enum:_BaseClassKind
MEAN_KEY	HTKLib/HUtil.c	/^   MIX_KEY, MEAN_KEY, STREAM_KEY, COV_KEY$/;"	e	enum:__anon168	file:
MEASURESIL	HTKLib/HParm.c	/^   MEASURESIL,    \/* Measure Background Silence *\/$/;"	e	enum:__anon142	file:
MELSPEC	HTKLib/HParm.h	/^      MELSPEC,                         \/* Mel-Freq Spectrum (Linear) *\/$/;"	e	enum:_BaseParmKind
MERGE	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon200	file:
MERGEP	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon191	file:
MFCC	HTKLib/HParm.h	/^      MFCC,                            \/* Mel-Freq Cepstra *\/$/;"	e	enum:_BaseParmKind
MHEAP	HTKLib/HMem.h	/^typedef enum{MHEAP, MSTAK, CHEAP} HeapType;$/;"	e	enum:__anon115
MILink	HTKLib/HModel.h	/^typedef struct _MMFInfo *MILink;$/;"	t	typeref:struct:_MMFInfo
MIN	HTKLib/HArc.c	75;"	d	file:
MIN	HTKLib/HExactMPE.c	89;"	d	file:
MIN	HTKLib/HFBLat.c	73;"	d	file:
MIN	HTKTools/HHEd.c	5314;"	d	file:
MIN	HTKTools/HMMIRest.c	62;"	d	file:
MINDLOGP	HTKLib/HModel.h	55;"	d
MINEARG	HTKLib/HMath.h	44;"	d
MINLARG	HTKLib/HMath.h	45;"	d
MINMIX	HTKLib/HModel.h	52;"	d
MINPRONPROB	HTKLib/HDict.h	38;"	d
MINVAR	HTKLib/HUtil.c	405;"	d	file:
MIN_AMPL	HTKTools/HSLab.c	86;"	d	file:
MIN_BOWT	HLMLib/LModel.h	68;"	d
MIN_PB_SIZE	HTKLib/HParm.c	483;"	d	file:
MIN_PROB	HLMLib/LModel.c	219;"	d	file:
MIXBASE	HTKLib/HModel.h	/^enum _BaseClassKind {MIXBASE, MEANBASE, COVBASE};$/;"	e	enum:_BaseClassKind
MIXER_DEV	HTKLib/HAudio.c	127;"	d	file:
MIXTURE	HTKLib/HModel.c	/^   STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,$/;"	e	enum:__anon117	file:
MIX_KEY	HTKLib/HUtil.c	/^   MIX_KEY, MEAN_KEY, STREAM_KEY, COV_KEY$/;"	e	enum:__anon168	file:
MIX_UPDATE_SHARING	HTKLib/HTrain.h	235;"	d
MInfo	HTKLib/HAdapt.c	/^} MInfo;$/;"	t	typeref:struct:__anon86	file:
MLF Examples	HTKBook/labels.tex	/^\\subsection{MLF Examples}$/;"	b
MLF Search	HTKBook/labels.tex	/^\\subsection{MLF Search}$/;"	b
MLFCHUNKSIZE	HTKLib/HLabel.c	114;"	d	file:
MLFDef	HTKLib/HLabel.h	/^}MLFDef;$/;"	t	typeref:union:__anon110
MLFDefType	HTKLib/HLabel.h	/^typedef enum _MLFDefType MLFDefType;$/;"	t	typeref:enum:_MLFDefType
MLFEntry	HTKLib/HLabel.h	/^}MLFEntry;$/;"	t	typeref:struct:_MLFEntry
MLFHash	HTKLib/HLabel.c	/^static unsigned MLFHash(char *s)$/;"	f	file:
MLFPatType	HTKLib/HLabel.h	/^typedef enum _MLFPatType MLFPatType;$/;"	t	typeref:enum:_MLFPatType
MLF_FULL	HTKLib/HLabel.h	/^   MLF_IMMEDIATE, MLF_SIMPLE, MLF_FULL$/;"	e	enum:_MLFDefType
MLF_IMMEDIATE	HTKLib/HLabel.h	/^   MLF_IMMEDIATE, MLF_SIMPLE, MLF_FULL$/;"	e	enum:_MLFDefType
MLF_SIMPLE	HTKLib/HLabel.h	/^   MLF_IMMEDIATE, MLF_SIMPLE, MLF_FULL$/;"	e	enum:_MLFDefType
MLL	HLMTools/LLink.c	90;"	d	file:
MLLRCOV	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	e	enum:_XFormKind
MLLRMEAN	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	e	enum:_XFormKind
MLLRVAR	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	e	enum:_XFormKind
MLUpdateModels	HTKTools/HERest.c	/^void MLUpdateModels(HMMSet *hset, UPDSet uFlags)$/;"	f
ML_MODE	HTKTools/HMMIRest.c	/^static Boolean ML_MODE = FALSE;     \/* when only one set of accs are supplied. *\/$/;"	v	file:
ML_PARTS	HTKLib/HParm.c	/^   ML_PARTS=10$/;"	e	enum:__anon145	file:
ML_SIL_EN	HTKLib/HParm.c	/^   ML_SIL_EN=3,$/;"	e	enum:__anon145	file:
ML_SIL_ST	HTKLib/HParm.c	/^   ML_SIL_ST=2,$/;"	e	enum:__anon145	file:
ML_SP_EN	HTKLib/HParm.c	/^   ML_SP_EN=9,$/;"	e	enum:__anon145	file:
ML_SP_ST	HTKLib/HParm.c	/^   ML_SP_ST=8,$/;"	e	enum:__anon145	file:
MLink	HTKLib/HModel.h	/^typedef struct _MacroDef *MLink;$/;"	t	typeref:struct:_MacroDef
MM	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon199	file:
MMAPI_AUDIO	HTKLib/HAudio.c	62;"	d	file:
MMAPI_AUDIO	HTKLib/HAudio.c	69;"	d	file:
MMAPI_BUFFER_COUNT	HTKLib/HAudio.c	169;"	d	file:
MMAPI_BUFFER_DURATION	HTKLib/HAudio.c	168;"	d	file:
MMAP_ALLOCATED	HTKLVRec/kenlm/util/mmap.hh	/^    typedef enum {MMAP_ALLOCATED, ARRAY_ALLOCATED, MALLOC_ALLOCATED, NONE_ALLOCATED} Alloc;$/;"	e	enum:util::scoped_memory::__anon75
MMFIDMASK	HTKLib/HModel.c	/^   CLASS, XFORMWGTSET, CLASSXFORM, MMFIDMASK, PARAMETERS,$/;"	e	enum:__anon117	file:
MMFInfo	HTKLib/HModel.h	/^} MMFInfo;$/;"	t	typeref:struct:_MMFInfo
MMIPrior	HTKTools/HMMIRest.c	/^static Boolean MMIPrior = FALSE;    \/* use MMI prior as I-smoothing prior *\/$/;"	v	file:
MMITauI	HTKTools/HMMIRest.c	/^static float MMITauI = 0.0;        \/* I-smoothing tau for MMI prior in MPE training *\/$/;"	v	file:
MMP_NBINS	HTKLVRec/HLVRec-propagate.c	1447;"	d	file:
MMapShift	HTKLVRec/kenlm/util/file_piece.cc	/^void FilePiece::MMapShift(uint64_t desired_begin) {$/;"	f	class:util::FilePiece
MODALIGN	HTKLVRec/config.h	57;"	d
MODALIGN	HTKLVRec/config.h	60;"	d
MOutP	HTKLib/HModel.c	/^LogFloat MOutP(Vector x, MixPDF *mp)$/;"	f
MPE	HTKLib/HFBLat.h	/^  Boolean MPE;  \/* currently doing MPE\/MWE, this may change from call to call$/;"	m	struct:__anon102
MPE	HTKTools/HMMIRest.c	/^static Boolean MPE = FALSE;         \/* when we are doing MPE\/MWE. *\/$/;"	v	file:
MPEFileLength	HTKLib/HFBLat.h	/^  int MPEFileLength;$/;"	m	struct:__anon102
MPEStoreML	HTKTools/HMMIRest.c	/^static Boolean MPEStoreML=FALSE;   \/*  Set TRUE if we need to accumulate ML stats while doing MPE. *\/$/;"	v	file:
MPEStruct	HTKLib/HArc.h	/^} MPEStruct;$/;"	t	typeref:struct:_MPEStruct
MPE_GetFileLen	HTKLib/HFBLat.c	/^int MPE_GetFileLen(Lattice *lat){$/;"	f
MRound	HTKLib/HMem.c	/^size_t MRound(size_t size)$/;"	f
MSTAK	HTKLib/HMem.h	/^typedef enum{MHEAP, MSTAK, CHEAP} HeapType;$/;"	e	enum:__anon115
MSolve	HTKLib/HMath.c	/^static void MSolve(DMatrix L, int i, DVector x, DVector y)$/;"	f	file:
MT	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon199	file:
MU	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon199	file:
MacroDef	HTKLib/HModel.h	/^} MacroDef;$/;"	t	typeref:struct:_MacroDef
MagicResult	HTKLVRec/kenlm/util/read_compressed.cc	/^enum MagicResult {$/;"	g	namespace:util::__anon79	file:
Make	HTKLVRec/kenlm/lm/vocab.hh	/^  static ProbingVocabularyEntry Make(uint64_t key, WordIndex value) {$/;"	f	struct:lm::ngram::ProbingVocabularyEntry
MakeBins	HTKLVRec/kenlm/lm/quantize.cc	/^void MakeBins(std::vector<float> &values, float *centers, uint32_t bins) {$/;"	f	namespace:lm::ngram::__anon55
MakeDictionary	HLMTools/HLMCopy.c	/^void MakeDictionary(char *fn,dictList *dicts,Vocab *wlist)$/;"	f
MakeFN	HTKLib/HShell.c	/^char * MakeFN(char *fn, char *path, char *ext, char *s)$/;"	f
MakeFindAccumulator	HTKTools/HLEd.c	/^void MakeFindAccumulator(LabId *pat)$/;"	f
MakeGraph	HTKLVRec/kenlm/lm/filter/phrase.cc	/^detail::Vertex &ConditionCommon::MakeGraph() {$/;"	f	class:lm::phrase::detail::ConditionCommon
MakeHMMSet	HTKLib/HModel.c	/^ReturnStatus MakeHMMSet(HMMSet *hset, char *fname)$/;"	f
MakeHashTab	HTKLib/HModel.c	/^void ** MakeHashTab(HMMSet *hset, int size)$/;"	f
MakeHashes	HTKLVRec/kenlm/lm/filter/phrase.hh	/^template <class Iterator> void MakeHashes(Iterator i, const Iterator &end, std::vector<Hash> &hashes) {$/;"	f	namespace:lm::phrase::detail
MakeHeaderInfo	HTKLib/HWave.c	/^static ReturnStatus MakeHeaderInfo(FILE *f, int hdrSize, Wave w)$/;"	f	file:
MakeIOConfig	HTKLib/HParm.c	/^static IOConfig MakeIOConfig(MemHeap *x,ChannelInfo *chan)$/;"	f	file:
MakeIntoMacrosCommand	HTKTools/HHEd.c	/^void MakeIntoMacrosCommand(void)$/;"	f
MakeNewClass	HLMLib/LCMap.c	/^ClassEntry *MakeNewClass(ClassMap *c, LabId id, int clndx, Boolean inClass)$/;"	f
MakeObservation	HTKLib/HParm.c	/^Observation MakeObservation(MemHeap *x, short *swidth, $/;"	f
MakeOneHMM	HTKLib/HModel.c	/^ReturnStatus MakeOneHMM(HMMSet *hset, char *hname)$/;"	f
MakePredLinks	HTKTools/HParse.c	/^static void MakePredLinks(int numElements, LinkSet *asucc)$/;"	f	file:
MakeSuccLinks	HTKTools/HParse.c	/^static void MakeSuccLinks(int numElements, LinkSet *asucc)$/;"	f	file:
MakeTemp	HTKLVRec/kenlm/util/file.cc	/^int MakeTemp(const StringPiece &base) {$/;"	f	namespace:util
MakeTraceBack	HTKTools/HInit.c	/^void MakeTraceBack(int segLen)$/;"	f
MakeTriCommand	HTKTools/HHEd.c	/^void MakeTriCommand(void)$/;"	f
MakeTriId	HTKTools/HDMan.c	/^LabId MakeTriId(LabId l, LabId c, LabId r)$/;"	f
MakeTriId	HTKTools/HLEd.c	/^LabId MakeTriId(LabId l, LabId c, LabId r)$/;"	f
MakeTriList	HTKTools/HParse.c	/^static SplitName* MakeTriList(int numElements, LinkSet *asucc)$/;"	f	file:
MakeTriLoop	HTKTools/HParse.c	/^static void MakeTriLoop(Link *hd, Link *tl)$/;"	f	file:
MakeTriSubNets	HTKTools/HParse.c	/^static void MakeTriSubNets(LinkSet *asucc, int numElements, $/;"	f	file:
MakeWtAccLists	HTKTools/HSmooth.c	/^void MakeWtAccLists()$/;"	f
MakeXGraf	HTKLib/HGraf.c	/^void MakeXGraf(char *wname, int x, int y, int w, int h, int bw)$/;"	f
MakeXGraf	HTKLib/HGraf.null.c	/^void MakeXGraf(char *wname, int x, int y, int w, int h, int bw)$/;"	f
MakeXGraf	HTKLib/HGraf_WIN32.c	/^void MakeXGraf(char *wname, int x, int y, int w, int h, int bw)$/;"	f
MallocException	HTKLVRec/kenlm/util/scoped.cc	/^MallocException::MallocException(std::size_t requested) throw() {$/;"	f	class:util::MallocException
MallocException	HTKLVRec/kenlm/util/scoped.hh	/^class MallocException : public ErrnoException {$/;"	c	namespace:util
MallocOrThrow	HTKLVRec/kenlm/util/scoped.cc	/^void *MallocOrThrow(std::size_t requested) {$/;"	f	namespace:util
MapAnonymous	HTKLVRec/kenlm/util/mmap.cc	/^void MapAnonymous(std::size_t size, util::scoped_memory &to) {$/;"	f	namespace:util
MapEntry	HLMLib/LWMap.h	/^} MapEntry;$/;"	t	typeref:struct:MAPENTRY
MapFile	HTKLVRec/kenlm/lm/binary_format.cc	/^void BinaryFormat::MapFile(void *&vocab_base, void *&search_base) {$/;"	f	class:lm::ngram::BinaryFormat
MapOrThrow	HTKLVRec/kenlm/util/mmap.cc	/^void *MapOrThrow(std::size_t size, bool for_write, int flags, bool prefault, int fd, uint64_t offset) {$/;"	f	namespace:util
MapRead	HTKLVRec/kenlm/util/mmap.cc	/^void MapRead(LoadMethod method, int fd, uint64_t offset, std::size_t size, scoped_memory &out) {$/;"	f	namespace:util
MapTreeName	HTKTools/HHEd.c	/^void MapTreeName(char *buf) {$/;"	f
MapZeroedWrite	HTKLVRec/kenlm/util/mmap.cc	/^void *MapZeroedWrite(const char *name, std::size_t size, scoped_fd &file) {$/;"	f	namespace:util
MapZeroedWrite	HTKLVRec/kenlm/util/mmap.cc	/^void *MapZeroedWrite(int fd, std::size_t size) {$/;"	f	namespace:util
Mark	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    void Mark() {$/;"	f	class:lm::builder::NGram
MarkAllProns	HTKLVRec/HLVNet.c	/^void MarkAllProns (Vocab *voc)$/;"	f
MarkAllWords	HTKLVRec/HLVNet.c	/^void MarkAllWords (Vocab *voc)$/;"	f
MarkAllWordsfromLat	HTKLVRec/HLVNet.c	/^void MarkAllWordsfromLat (Vocab *voc, Lattice *lat, Boolean silDict)$/;"	f
MarkBack	HTKLib/HRec.c	/^static void MarkBack(LNode *ln,int *nn)$/;"	f	file:
MarkExtends	HTKLVRec/kenlm/lm/value_build.hh	/^    bool MarkExtends(RestWeights &weights, const Prob &to) const {$/;"	f	class:lm::ngram::MaxRestBuild
MarkExtends	HTKLVRec/kenlm/lm/value_build.hh	/^    bool MarkExtends(RestWeights &weights, const RestWeights &to) const {$/;"	f	class:lm::ngram::MaxRestBuild
MarkExtends	HTKLVRec/kenlm/lm/value_build.hh	/^    template <class Second> bool MarkExtends(ProbBackoff &weights, const Second &) const {$/;"	f	class:lm::ngram::NoRestBuild
MarkExtends	HTKLVRec/kenlm/lm/value_build.hh	/^    template <class Second> bool MarkExtends(RestWeights &weights, const Second &) const {$/;"	f	class:lm::ngram::LowerRestBuild
MarkLower	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <class Build> void MarkLower($/;"	f	namespace:lm::ngram::__anon57
MarkModPath	HTKLVRec/HLVRec-GC.c	/^static void MarkModPath (ModendHyp *m)$/;"	f	file:
MarkPath	HTKLVRec/HLVRec-GC.c	/^static void MarkPath (WordendHyp *path)$/;"	f	file:
MarkPaths	HTKLib/HRec.c	/^static void MarkPaths(Path *path,int *nn,int *nl)$/;"	f	file:
MarkTokSet	HTKLVRec/HLVRec-GC.c	/^static void MarkTokSet (TokenSet *ts)$/;"	f	file:
MarkTree	HTKLib/HVQ.c	/^static void MarkTree(VQNode n, short *nid)$/;"	f	file:
MarkWordList	HLMLib/LWMap.c	/^void MarkWordList(WordMap *wl)$/;"	f
Mask	HTKLVRec/kenlm/lm/quantize.hh	/^        uint64_t Mask() const { return mask_; }$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
MaskMatch	HTKLib/HShell.c	/^Boolean MaskMatch(char *mask, char *spkr, char *str)$/;"	f
Master	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    explicit Master(PipelineConfig &config) $/;"	f	class:lm::builder::__anon47::Master
Master	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^class Master {$/;"	c	namespace:lm::builder::__anon47	file:
Mat2DMat	HTKLib/HMath.c	/^void Mat2DMat(Matrix m1,  DMatrix m2)$/;"	f
Mat2Tri	HTKLib/HMath.c	/^void Mat2Tri (Matrix m1,  TriMat m2)$/;"	f
MatBiLM	HTKLib/HLM.h	/^} MatBiLM;$/;"	t	typeref:struct:matbilm
MatCofact	HTKLib/HMath.c	/^double MatCofact(Matrix c, int r, Vector cofact)$/;"	f
MatDet	HTKLib/HMath.c	/^float MatDet(Matrix c)$/;"	f
MatInvert	HTKLib/HMath.c	/^float MatInvert(Matrix c, Matrix invc)$/;"	f
MatTran	HTKLib/HParm.c	/^   Matrix MatTran;            \/* Stores transformation matrix *\/ $/;"	m	struct:__anon141	file:
MatTranFN	HTKLib/HParm.c	/^   char *MatTranFN;           \/* points to the file name string *\/$/;"	m	struct:__anon141	file:
MatchCheck	HTKLVRec/kenlm/lm/binary_format.cc	/^void MatchCheck(ModelType model_type, unsigned int search_version, const Parameters &params) {$/;"	f	namespace:lm::ngram
MatchFiles	HTKTools/HResults.c	/^void MatchFiles(void)$/;"	f
MatchRecFiles	HTKTools/HResults.c	/^void MatchRecFiles(void)$/;"	f
MatchRule	HLMTools/LGPrep.c	/^Boolean MatchRule(RuleDef *r)$/;"	f
MatchSpotFiles	HTKTools/HResults.c	/^void MatchSpotFiles(void)$/;"	f
Matrix	HTKLib/HMem.h	/^typedef float **Matrix;    \/* matrix[1..nrows][1..ncols] *\/$/;"	t
MatrixElemSize	HTKLib/HMem.c	/^size_t MatrixElemSize(int nrows,int ncols)$/;"	f
MatrixIDFT	HTKLib/HSigP.c	/^float MatrixIDFT(Vector as, Vector ac, DMatrix cm)$/;"	f
MatrixMult	HTKLib/HAdapt.c	/^static void MatrixMult(Matrix m1, Matrix m2, Matrix m)$/;"	f	file:
Max	HTKLVRec/kenlm/util/double-conversion/utils.h	/^static T Max(T a, T b) {$/;"	f	namespace:double_conversion
MaxMixInS	HTKLib/HModel.c	/^int MaxMixInS(HLink hmm, int s)$/;"	f
MaxMixInSet	HTKLib/HModel.c	/^int MaxMixInSet(HMMSet *hset)$/;"	f
MaxMixInSetS	HTKLib/HModel.c	/^int MaxMixInSetS(HMMSet *hset, int s)$/;"	f
MaxMixtures	HTKLib/HModel.c	/^int MaxMixtures(HLink hmm)$/;"	f
MaxModelProb	HTKLib/HFB.c	/^static LogDouble MaxModelProb(AlphaBeta *ab, int q, int t, int minq)$/;"	f	file:
MaxRestBuild	HTKLVRec/kenlm/lm/value_build.hh	/^    MaxRestBuild() {}$/;"	f	class:lm::ngram::MaxRestBuild
MaxRestBuild	HTKLVRec/kenlm/lm/value_build.hh	/^class MaxRestBuild {$/;"	c	namespace:lm::ngram
MaxStatesInSet	HTKLib/HModel.c	/^int MaxStatesInSet(HMMSet *hset)$/;"	f
MaxTimesLabelled	HTKTools/HSLab.c	/^int MaxTimesLabelled(LabList *ll, long st, long en)$/;"	f
MaximumLazyInput	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    template <class Compare> void MaximumLazyInput(const std::vector<uint64_t> &counts, Sorts<Compare> &sorts) {$/;"	f	class:lm::builder::__anon47::Master
MeanRec	HTKLib/HParm.c	/^MeanRec;$/;"	t	typeref:struct:meanrec	file:
Mel	HTKLib/HSigP.c	/^float Mel(int k,float fres)$/;"	f
MelSpec2FBank	HTKLib/HSigP.c	/^void MelSpec2FBank(Vector melspec)$/;"	f
MemHeap	HTKLib/HMem.h	/^}MemHeap;$/;"	t	typeref:struct:__anon116
MemHeapRec	HTKLib/HMem.c	/^} MemHeapRec;$/;"	t	typeref:struct:_MemHeapRec	file:
MemUsage	HTKLVRec/kenlm/lm/vocab.hh	/^    static std::size_t MemUsage(WordIndex content) {$/;"	f	class:lm::ngram::GrowableVocab
MemUsage	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    static std::size_t MemUsage(std::size_t size, float multiplier = 1.5) {$/;"	f	class:util::AutoProbing
Merge	HTKLVRec/kenlm/util/stream/sort.hh	/^    std::size_t Merge(std::size_t lazy_memory) {$/;"	f	class:util::stream::Sort
MergeArcs	HTKLib/HLat.c	/^void MergeArcs(Lattice *lat, LArc *la1, LArc *la2)$/;"	f
MergeArcsForNode	HTKLib/HLat.c	/^void MergeArcsForNode(Lattice *lat, LNode *ln)$/;"	f
MergeCost	HTKTools/HHEd.c	/^float MergeCost(Node *a, Node *b, CLink atail)$/;"	f
MergeFE	HLMLib/LPMerge.c	/^static int MergeFE(MergeInfo *mi, FLEntry **context, FLEntry **srcFE, int lev) $/;"	f	file:
MergeGroups	HTKTools/HHEd.c	/^void MergeGroups(int i, int j, CLink *cvec, int N)$/;"	f
MergeInfo	HLMLib/LPMerge.c	/^} MergeInfo;$/;"	t	typeref:struct:__anon17	file:
MergeLatNodesArcs	HTKLib/HLat.c	/^Lattice *MergeLatNodesArcs(Lattice *lat, MemHeap *heap, Boolean mergeFwd)$/;"	f
MergeLatNodesBackw	HTKLib/HLat.c	/^void MergeLatNodesBackw(Lattice *lat, LNode *ln)$/;"	f
MergeLatNodesForw	HTKLib/HLat.c	/^void MergeLatNodesForw(Lattice *lat, LNode *ln)$/;"	f
MergeLeaves	HTKTools/HHEd.c	/^void MergeLeaves(Tree *tree, float threshold)$/;"	f
MergeLevels	HTKTools/HLEd.c	/^LabList *MergeLevels(Transcription *ltr)$/;"	f
MergeLinks	HTKTools/HParse.c	/^static LinkSet*  MergeLinks(LinkSet *from, LinkSet *to)$/;"	f	file:
MergeMix	HTKTools/HHEd.c	/^void MergeMix(StreamElem *ste,int p,int q, Boolean inPlace)$/;"	f
MergeModels	HLMLib/LPMerge.c	/^BackOffLM *MergeModels(MemHeap *heap, LMInfo *lmInfo, int nLModel, $/;"	f
MergeNode	HTKTools/HHEd.c	/^Boolean MergeNode(Node *node, float threshold)$/;"	f
MergeNodes	HTKLib/HLat.c	/^static LNode *MergeNodes(Lattice *lat, LNode *ln1, LNode *ln2)$/;"	f	file:
MergeOp	HTKTools/HLEd.c	/^int MergeOp(LabList *ll,int nArgs, LabId *args)$/;"	f
MergePhon	HTKTools/HDMan.c	/^void MergePhon(Pronunciation *p, int nArgs, LabId *args)$/;"	f
MergePhoneOp	HTKTools/HDMan.c	/^void MergePhoneOp(WordBuf *wb, int nArgs, LabId *args)$/;"	f
MergeQueue	HTKLVRec/kenlm/util/stream/sort.hh	/^    MergeQueue(int fd, std::size_t buffer_size, std::size_t entry_size, const Compare &compare)$/;"	f	class:util::stream::MergeQueue
MergeQueue	HTKLVRec/kenlm/util/stream/sort.hh	/^template <class Compare> class MergeQueue {$/;"	c	namespace:util::stream
MergeRight	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    MergeRight(bool interpolate_unigrams, const util::stream::ChainPosition &from_adder, const Discount &discount)$/;"	f	class:lm::builder::__anon45::MergeRight
MergeRight	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^class MergeRight {$/;"	c	namespace:lm::builder::__anon45	file:
MergeSortedFiles	HTKLVRec/kenlm/lm/trie_sort.cc	/^template <class Combine> FILE *MergeSortedFiles(FILE *first_file, FILE *second_file, const std::string &temp_prefix, std::size_t weights_size, unsigned char order, const Combine &combine) {$/;"	f	namespace:lm::ngram::trie::__anon60
MergeTokSet	HTKLVRec/HLVRec-propagate.c	/^static void MergeTokSet (DecoderInst *dec, TokenSet *src, TokenSet *dest, $/;"	f	file:
MergingReader	HTKLVRec/kenlm/util/stream/sort.hh	/^    MergingReader(int in, Offsets *in_offsets, Offsets *out_offsets, std::size_t buffer_size, std::size_t total_memory, const Compare &compare, const Combine &combine) :$/;"	f	class:util::stream::MergingReader
MergingReader	HTKLVRec/kenlm/util/stream/sort.hh	/^template <class Compare, class Combine> class MergingReader {$/;"	c	namespace:util::stream
Middle	HTKLVRec/kenlm/lm/search_hashed.hh	/^    typedef util::ProbingHashTable<typename Value::ProbingEntry, util::IdentityHash> Middle;$/;"	t	class:lm::ngram::detail::HashedSearch
Middle	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Middle(const unsigned char order, const void * \/*data*\/) {$/;"	f	class:lm::ngram::trie::__anon58::FindBlanks
Middle	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Middle(const unsigned char order, const void *data) {$/;"	f	class:lm::ngram::trie::__anon58::WriteEntries
Middle	HTKLVRec/kenlm/lm/search_trie.hh	/^    typedef trie::BitPackedMiddle<Bhiksha> Middle;$/;"	t	class:lm::ngram::trie::TrieSearch
MiddleBits	HTKLVRec/kenlm/lm/quantize.hh	/^    static uint8_t MiddleBits(const Config &\/*config*\/) { return 63; }$/;"	f	class:lm::ngram::DontQuantize
MiddleBits	HTKLVRec/kenlm/lm/quantize.hh	/^    static uint8_t MiddleBits(const Config &config) { return config.prob_bits + config.backoff_bits; }$/;"	f	class:lm::ngram::SeparatelyQuantize
MiddleBlank	HTKLVRec/kenlm/lm/search_trie.cc	/^    void MiddleBlank(const unsigned char order, const WordIndex *indices, unsigned char \/*lower*\/, float \/*prob_base*\/) {$/;"	f	class:lm::ngram::trie::__anon58::WriteEntries
MiddleBlank	HTKLVRec/kenlm/lm/search_trie.cc	/^    void MiddleBlank(const unsigned char order, const WordIndex *indices, unsigned char lower, float prob_basis) {$/;"	f	class:lm::ngram::trie::__anon58::FindBlanks
MiddlePointer	HTKLVRec/kenlm/lm/quantize.hh	/^        MiddlePointer() : address_(NULL, 0) {}$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
MiddlePointer	HTKLVRec/kenlm/lm/quantize.hh	/^        MiddlePointer() : address_(NULL, 0) {}$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
MiddlePointer	HTKLVRec/kenlm/lm/quantize.hh	/^        MiddlePointer(const DontQuantize & \/*quant*\/, unsigned char \/*order_minus_2*\/, util::BitAddress address) : address_(address) {}$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
MiddlePointer	HTKLVRec/kenlm/lm/quantize.hh	/^        MiddlePointer(const SeparatelyQuantize &quant, unsigned char order_minus_2, const util::BitAddress &address) : bins_(quant.GetTables(order_minus_2)), address_(address) {}$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
MiddlePointer	HTKLVRec/kenlm/lm/quantize.hh	/^    class MiddlePointer {$/;"	c	class:lm::ngram::DontQuantize
MiddlePointer	HTKLVRec/kenlm/lm/quantize.hh	/^    class MiddlePointer {$/;"	c	class:lm::ngram::SeparatelyQuantize
MiddlePointer	HTKLVRec/kenlm/lm/search_hashed.hh	/^    typedef typename Value::ProbingProxy MiddlePointer;$/;"	t	class:lm::ngram::detail::HashedSearch
MiddlePointer	HTKLVRec/kenlm/lm/search_trie.hh	/^    typedef typename Quant::MiddlePointer MiddlePointer;$/;"	t	class:lm::ngram::trie::TrieSearch
Milestone	HTKLVRec/kenlm/util/ersatz_progress.cc	/^void ErsatzProgress::Milestone() {$/;"	f	class:util::ErsatzProgress
Milestone	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^void MultiProgress::Milestone(WorkerProgress &worker) {$/;"	f	class:util::stream::MultiProgress
Min	HTKLVRec/kenlm/util/double-conversion/utils.h	/^static T Min(T a, T b) {$/;"	f	namespace:double_conversion
MinGDist	HTKTools/HHEd.c	/^float MinGDist(Matrix g, int *ix, int *jx, int N)$/;"	f
MinOcc	HTKTools/HMMIRest.c	/^static float MinOcc = 10;              \/* Minimum numerator (ML) occupancy for a Gaussian to be updated *\/$/;"	v	file:
MinOccSum	HTKTools/HHEd.c	/^int MinOccSum(Vector occSum, int N)$/;"	f
MinOccTrans	HTKTools/HMMIRest.c	/^static float MinOccTrans = 10;         \/* Minimum numerator (ML) occupancy for a transition row *\/$/;"	v	file:
MinOccWeights	HTKTools/HMMIRest.c	/^static float MinOccWeights = 10;       \/* Minimum numerator (ML) occupancy for a set of weights. *\/$/;"	v	file:
Minus	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  static DiyFp Minus(const DiyFp& a, const DiyFp& b) {$/;"	f	class:double_conversion::DiyFp
MissingSentenceMarker	HTKLVRec/kenlm/lm/vocab.cc	/^void MissingSentenceMarker(const Config &config, const char *str) throw(SpecialWordMissingException) {$/;"	f	namespace:lm::ngram
MissingUnknown	HTKLVRec/kenlm/lm/vocab.cc	/^void MissingUnknown(const Config &config) throw(SpecialWordMissingException) {$/;"	f	namespace:lm::ngram
MixDownCommand	HTKTools/HHEd.c	/^void MixDownCommand(void)$/;"	f
MixFloor	HTKLib/HModel.h	59;"	d
MixLogWeight	HTKLib/HModel.c	/^LogFloat MixLogWeight(HMMSet *hset, float weight)$/;"	f
MixMergeCost	HTKTools/HHEd.c	/^float MixMergeCost(MixtureElem *me1,MixtureElem *me2)$/;"	f
MixOcc	HTKLib/HFBLat.c	/^} MixOcc;$/;"	t	typeref:struct:__anon101	file:
MixPDF	HTKLib/HModel.h	/^} MixPDF;$/;"	t	typeref:struct:__anon120
MixUpCommand	HTKTools/HHEd.c	/^void MixUpCommand(void)$/;"	f
MixWeight	HTKLib/HModel.c	/^float MixWeight(HMMSet *hset, float weight)$/;"	f
MixtureElem	HTKLib/HModel.h	/^} MixtureElem;$/;"	t	typeref:struct:__anon121
MixtureVector	HTKLib/HModel.h	/^} MixtureVector; $/;"	t	typeref:union:__anon122
Model	HTKLVRec/kenlm/lm/model.hh	/^typedef ProbingModel Model;$/;"	t	namespace:lm::ngram
Model	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    explicit Model(size_t state_size) : state_size_(state_size) {}$/;"	f	class:lm::base::Model
Model	HTKLVRec/kenlm/lm/virtual_interface.hh	/^class Model {$/;"	c	namespace:lm::base
Model	HTKLVRec/kenlm/lm/wrappers/nplm.cc	/^Model::Model(const std::string &file, std::size_t cache) $/;"	f	class:lm::np::Model
Model	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^class Model : public lm::base::ModelFacade<Model, State, Vocabulary> {$/;"	c	namespace:lm::np
ModelFacade	HTKLVRec/kenlm/lm/facade.hh	/^    ModelFacade() : Model(sizeof(State)) {}$/;"	f	class:lm::base::ModelFacade
ModelFacade	HTKLVRec/kenlm/lm/facade.hh	/^template <class Child, class StateT, class VocabularyT> class ModelFacade : public Model {$/;"	c	namespace:lm::base
ModelType	HTKLVRec/kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	t	namespace:lm::ngram	typeref:enum:lm::ngram::__anon54
ModendHyp	HTKLVRec/HLVRec.h	/^typedef struct _ModendHyp ModendHyp;    \/* records model level tracback *\/$/;"	t	typeref:struct:_ModendHyp
More	HTKLVRec/kenlm/util/pool.cc	/^void *Pool::More(std::size_t size) {$/;"	f	class:util::Pool
MouseMark	HTKTools/HSLab.c	/^void MouseMark(int x, int *markA, int *markB)$/;"	f
MousePos	HTKLib/HGraf_WIN32.c	/^static POINT MousePos;   \/* updated when a WM_MOUSEMOVE occurs *\/$/;"	v	file:
MoveAlignYesRef	HTKLib/HRec.c	/^static void MoveAlignYesRef(Align *align)$/;"	f	file:
MovePathYesRef	HTKLib/HRec.c	/^static void MovePathYesRef(Path *path)$/;"	f	file:
MoveRead	HTKLVRec/kenlm/lm/filter/thread.hh	/^    void MoveRead() {$/;"	f	class:lm::Controller
MoveToRecent	HTKLib/HRec.c	/^static void MoveToRecent(NetInst *inst)$/;"	f	file:
MuAcc	HTKLib/HTrain.h	/^} MuAcc;$/;"	t	typeref:struct:__anon165
MultCovMeanLinXForms	HTKLib/HAdapt.c	/^static void MultCovMeanLinXForms(LinXForm *xf1, LinXForm *xf2, LinXForm *xf)$/;"	f	file:
MultiCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    MultiCharacter() {}$/;"	f	class:util::MultiCharacter
MultiCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    explicit MultiCharacter(const StringPiece &delimiter) : delimiter_(delimiter) {}$/;"	f	class:util::MultiCharacter
MultiCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^class MultiCharacter {$/;"	c	namespace:util
MultiProgress	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^MultiProgress::MultiProgress() : active_(false), complete_(std::numeric_limits<uint64_t>::max()), character_handout_(0) {}$/;"	f	class:util::stream::MultiProgress
MultiProgress	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^class MultiProgress {$/;"	c	namespace:util::stream
Multiple	HTKLVRec/kenlm/lm/filter/format.hh	/^  typedef MultipleARPAOutput Multiple;$/;"	t	struct:lm::ARPAFormat
Multiple	HTKLVRec/kenlm/lm/filter/format.hh	/^  typedef MultipleOutput<Output> Multiple;$/;"	t	struct:lm::CountFormat
Multiple	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    explicit Multiple(const Substrings &substrings) : detail::ConditionCommon(substrings) {}$/;"	f	class:lm::phrase::Multiple
Multiple	HTKLVRec/kenlm/lm/filter/phrase.hh	/^class Multiple : public detail::ConditionCommon {$/;"	c	namespace:lm::phrase
Multiple	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    Multiple(const Words &vocabs) : vocabs_(vocabs) {}$/;"	f	class:lm::vocab::Multiple
Multiple	HTKLVRec/kenlm/lm/filter/vocab.hh	/^class Multiple {$/;"	c	namespace:lm::vocab
MultipleARPAOutput	HTKLVRec/kenlm/lm/filter/format.hh	/^    MultipleARPAOutput(const char *prefix, size_t number) : MultipleOutput<ARPAOutput>(prefix, number) {}$/;"	f	class:lm::MultipleARPAOutput
MultipleARPAOutput	HTKLVRec/kenlm/lm/filter/format.hh	/^class MultipleARPAOutput : public MultipleOutput<ARPAOutput> {$/;"	c	namespace:lm
MultipleOutput	HTKLVRec/kenlm/lm/filter/format.hh	/^    MultipleOutput(const char *prefix, size_t number) {$/;"	f	class:lm::MultipleOutput
MultipleOutput	HTKLVRec/kenlm/lm/filter/format.hh	/^template <class Single> class MultipleOutput {$/;"	c	namespace:lm
MultipleOutputBuffer	HTKLVRec/kenlm/lm/filter/format.hh	/^    MultipleOutputBuffer() : last_(NULL) {}$/;"	f	class:lm::MultipleOutputBuffer
MultipleOutputBuffer	HTKLVRec/kenlm/lm/filter/format.hh	/^class MultipleOutputBuffer {$/;"	c	namespace:lm
Multiply	HTKLVRec/kenlm/util/double-conversion/diy-fp.cc	/^void DiyFp::Multiply(const DiyFp& other) {$/;"	f	class:double_conversion::DiyFp
Multiply	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^  void Multiply(uint32_t multiplicand) {$/;"	f	class:double_conversion::UInt128
MultiplyByPowerOfTen	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::MultiplyByPowerOfTen(int exponent) {$/;"	f	class:double_conversion::Bignum
MultiplyByUInt32	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::MultiplyByUInt32(uint32_t factor) {$/;"	f	class:double_conversion::Bignum
MultiplyByUInt64	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::MultiplyByUInt64(uint64_t factor) {$/;"	f	class:double_conversion::Bignum
MurmurHash64A	HTKLVRec/kenlm/util/murmur_hash.cc	/^uint64_t MurmurHash64A ( const void * key, std::size_t len, uint64_t seed )$/;"	f	namespace:util
MurmurHash64B	HTKLVRec/kenlm/util/murmur_hash.cc	/^uint64_t MurmurHash64B ( const void * key, std::size_t len, uint64_t seed )$/;"	f	namespace:util
MurmurHashNative	HTKLVRec/kenlm/util/murmur_hash.cc	/^uint64_t MurmurHashNative(const void * key, std::size_t len, uint64_t seed) {$/;"	f	namespace:util
MurmurHashNativeBackend	HTKLVRec/kenlm/util/murmur_hash.cc	/^template <> inline uint64_t MurmurHashNativeBackend<4>(const void * key, std::size_t len, uint64_t seed) {$/;"	f	namespace:util::__anon77
MurmurHashNativeBackend	HTKLVRec/kenlm/util/murmur_hash.cc	/^template <unsigned L> inline uint64_t MurmurHashNativeBackend(const void * key, std::size_t len, uint64_t seed) {$/;"	f	namespace:util::__anon77
MustFind	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class Key> ConstIterator MustFind(const Key key) const {$/;"	f	class:util::AutoProbing
MustFind	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class Key> ConstIterator MustFind(const Key key) const {$/;"	f	class:util::ProbingHashTable
MustSwap	HTKLib/HWave.c	/^static Boolean MustSwap(SrcOrder so)$/;"	f	file:
MutableChains	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    util::stream::Chains &MutableChains() { return chains_; }$/;"	f	class:lm::builder::__anon47::Master
MutableIterator	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef Entry *MutableIterator;$/;"	t	class:util::AutoProbing
MutableIterator	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    typedef Entry *MutableIterator;$/;"	t	class:util::ProbingHashTable
N	HLMLib/LGBase.h	/^   int N;                  \/* N-gram *\/$/;"	m	struct:__anon6
N	HLMLib/LGBase.h	/^   int N;                  \/* N-gram size *\/$/;"	m	struct:__anon4
N	HLMLib/LGBase.h	/^   int N;                  \/* N-gram size N (2..MAXNG)*\/$/;"	m	struct:__anon2
N	HLMTools/Cluster.c	/^static int         N = 1000;                \/* Default number of classes *\/$/;"	v	file:
N	HTKLib/HUtil.h	/^   int N;            \/* num states in curret hmm *\/$/;"	m	struct:__anon169
NAMESYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
NARC	HTKLib/HNet.h	100;"	d
NATIVE	HTKLib/esignal.h	105;"	d
NBIN	HTKLib/HLat.c	726;"	d	file:
NBINS	HTKLVRec/HLVRec-propagate.c	236;"	d	file:
NBestEntry	HTKLib/HRec.c	/^typedef struct nbestentry NBestEntry;$/;"	t	typeref:struct:nbestentry	file:
NC	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon199	file:
NDEBUG	HTKLVRec/config.h	30;"	d
NDUR	HTKLib/HModel.c	/^   NDUR, PDUR, GDUR, RELDUR, GENDUR,$/;"	e	enum:__anon117	file:
NEntry	HTKLVRec/HLVLM.h	/^} NEntry;$/;"	t	typeref:struct:nentry
NEntry	HTKLib/HLM.h	/^} NEntry;$/;"	t	typeref:struct:nentry
NGBuffer	HLMLib/LGBase.h	/^} NGBuffer;$/;"	t	typeref:struct:__anon5
NGHSIZE1	HTKLVRec/HLVLM.c	1497;"	d	file:
NGHSIZE1	HTKLib/HLM.c	319;"	d	file:
NGHSIZE2	HTKLVRec/HLVLM.c	1498;"	d	file:
NGHSIZE2	HTKLib/HLM.c	320;"	d	file:
NGHSIZE3	HTKLVRec/HLVLM.c	1499;"	d	file:
NGHSIZE3	HTKLib/HLM.c	321;"	d	file:
NGInfo	HLMLib/LGBase.h	/^}NGInfo;$/;"	t	typeref:struct:__anon2
NGInputSet	HLMLib/LGBase.h	/^}NGInputSet;$/;"	t	typeref:struct:__anon4
NGLM_PROB_ADD	HTKLVRec/HLVLM.h	128;"	d
NGLM_PROB_GREATER	HTKLVRec/HLVLM.h	127;"	d
NGLM_PROB_GREATER	HTKLVRec/HLVLM.h	135;"	d
NGLM_PROB_LZERO	HTKLVRec/HLVLM.h	125;"	d
NGLM_PROB_LZERO	HTKLVRec/HLVLM.h	133;"	d
NGLM_PROB_TO_FLOAT	HTKLVRec/HLVLM.h	123;"	d
NGLM_PROB_TO_FLOAT	HTKLVRec/HLVLM.h	131;"	d
NGLM_PROB_ZERO	HTKLVRec/HLVLM.h	126;"	d
NGLM_PROB_ZERO	HTKLVRec/HLVLM.h	134;"	d
NGLM_Prob	HTKLVRec/HLVLM.h	/^   typedef float NGLM_Prob;$/;"	t
NGLM_Prob	HTKLVRec/HLVLM.h	/^   typedef unsigned short NGLM_Prob;$/;"	t
NGSource	HLMLib/LGBase.h	/^}NGSource;$/;"	t	typeref:struct:__anon3
NGram	HLMLib/LGBase.h	/^typedef UInt *NGram;          \/* N-gram: {w1,w2,...,wN count} *\/$/;"	t
NGram	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    NGram(void *begin, std::size_t order)$/;"	f	class:lm::builder::NGram
NGram	HTKLVRec/kenlm/lm/builder/ngram.hh	/^class NGram {$/;"	c	namespace:lm::builder
NGramExpand	HLMLib/LGBase.c	/^void NGramExpand(int N, Byte *comp, NGram ng)$/;"	f
NGramInfo	HLMLib/LModel.h	/^} NGramInfo;$/;"	t	typeref:struct:__anon13
NGramIter	HTKLVRec/kenlm/lm/trie_sort.cc	/^typedef util::SizedIterator NGramIter;$/;"	t	namespace:lm::ngram::trie::__anon60	file:
NGramLM	HTKLib/HLM.h	/^} NGramLM;$/;"	t	typeref:struct:ngramlm
NGramSquash	HLMLib/LGBase.c	/^void NGramSquash(int N, NGram ng, Byte *comp)$/;"	f
NGramStream	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    NGramStream() : gram_(NULL, 0) {}$/;"	f	class:lm::builder::NGramStream
NGramStream	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    NGramStream(const util::stream::ChainPosition &position) : gram_(NULL, 0) {$/;"	f	class:lm::builder::NGramStream
NGramStream	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^class NGramStream {$/;"	c	namespace:lm::builder
NGramStreams	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^typedef util::stream::GenericStreams<NGramStream> NGramStreams;$/;"	t	namespace:lm::builder
NIL	HTKTools/HResults.c	/^enum _Direction{DIAG,VERT,HOR,NIL};$/;"	e	enum:_Direction	file:
NIST	HTKLib/HWave.h	/^        NIST,              \/* NIST databases eg RM1,TIMIT *\/$/;"	e	enum:__anon181
NISTSkipLine	HTKLib/HWave.c	/^static void NISTSkipLine(FILE *f)$/;"	f	file:
NISTmutab	HTKLib/HWave.c	/^static short int NISTmutab[256] = {$/;"	v	file:
NLAYERS	HTKLVRec/HLVNet.h	131;"	d
NNODE	HTKLib/HNet.h	101;"	d
NOARG	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	e	enum:__anon158
NOCMD	HTKTools/HDMan.c	/^              NOCMD} EdOp;$/;"	e	enum:__anon191	file:
NOCMD	HTKTools/HLEd.c	/^   NOCMD=0, $/;"	e	enum:__anon200	file:
NODE	HTKLib/HModel.c	/^   RCLASS=110, REGTREE, NODE, TNODE,$/;"	e	enum:__anon117	file:
NODEBLOCK	HTKTools/HParse.c	279;"	d	file:
NOHEAD	HTKLib/HWave.h	/^        NOHEAD,            \/* Headerless File *\/$/;"	e	enum:__anon181
NONE	HTKLVRec/kenlm/lm/config.hh	/^  enum ARPALoadComplain {ALL, EXPENSIVE, NONE};$/;"	e	enum:lm::ngram::Config::ARPALoadComplain
NONE_ALLOCATED	HTKLVRec/kenlm/util/mmap.hh	/^    typedef enum {MMAP_ALLOCATED, ARRAY_ALLOCATED, MALLOC_ALLOCATED, NONE_ALLOCATED} Alloc;$/;"	e	enum:util::scoped_memory::__anon75
NOPRUNE	HTKLib/HFB.h	31;"	d
NORMALKEY	HTKLib/HGraf.h	/^enum _KeyType {NORMALKEY, SHIFTKEY, COMMANDKEY, CONTROLKEY, $/;"	e	enum:_KeyType
NO_AUDIO	HTKLib/HAudio.c	58;"	d	file:
NO_FLAGS	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    NO_FLAGS = 0,$/;"	e	enum:double_conversion::DoubleToStringConverter::Flags
NO_FLAGS	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    NO_FLAGS = 0,$/;"	e	enum:double_conversion::StringToDoubleConverter::Flags
NO_HDR	HLMLib/LUtil.h	/^   NO_HDR, WMAP_HDR, CMAP_HDR, GRAM_HDR, LFOF_HDR$/;"	e	enum:__anon19
NO_OF_FONTS	HTKLib/HGraf.c	134;"	d	file:
NO_TYPE	HTKLib/esignal.h	64;"	d
NO_WIN	HTKTools/HSLab.c	/^   WAVE_WIN, LAB_WIN, IO_WIN, NO_WIN $/;"	e	enum:__anon207	file:
NPLM_MAX_ORDER	HTKLVRec/kenlm/lm/wrappers/nplm.hh	46;"	d
NSIZE	HTKLVRec/HLVLM.h	96;"	d
NSIZE	HTKLib/HLM.h	50;"	d
NULL	HTKLVRec/kenlm/util/getopt.c	15;"	d	file:
NULLC	HTKLib/HMath.h	/^   NULLC,         \/* none - implies Euclidean in distance metrics *\/$/;"	e	enum:__anon113
NULLD	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	e	enum:_DurKind
NULLSIG	HTKLib/HAudio.h	31;"	d
NULLSYM	HTKLib/HModel.c	/^   MACRO, EOFSYM, NULLSYM   \/* Special Syms - not literals *\/$/;"	e	enum:__anon117	file:
NUMBER_OF_HOOKS	HTKLVRec/kenlm/lm/builder/output.hh	/^  NUMBER_OF_HOOKS \/\/ Keep this last so we know how many values there are.$/;"	e	enum:lm::builder::HookType
NUMCEPS	HTKLib/HParm.c	/^   NUMCEPS,       \/* Num cepstral coefficients *\/$/;"	e	enum:__anon142	file:
NUMCHANS	HTKLib/HParm.c	/^   NUMCHANS,      \/* Num filterbank channels *\/$/;"	e	enum:__anon142	file:
NUMCKIND	HTKLib/HMath.h	/^   NUMCKIND       \/* DON'T TOUCH -- always leave as final element *\/$/;"	e	enum:__anon113
NUMCLASSES	HTKLib/HModel.c	/^   NUMCLASSES, ADAPTKIND, PREQUAL, INPUTXFORM,$/;"	e	enum:__anon117	file:
NUMMIXES	HTKLib/HModel.c	/^   BEGINHMM, USEMAC, ENDHMM, NUMMIXES, $/;"	e	enum:__anon117	file:
NUMSTATES	HTKLib/HModel.c	/^   NUMSTATES, STREAMINFO, VECSIZE, $/;"	e	enum:__anon117	file:
NUMSYM	HTKLib/HModel.c	455;"	d	file:
NUMXFORMS	HTKLib/HModel.c	/^   XFORMKIND=90, PARENTXFORM, NUMXFORMS, XFORMSET,$/;"	e	enum:__anon117	file:
NUM_OF_SCALES	HTKTools/HSLab.c	101;"	d	file:
NUM_SAMP_FREQS	HTKLib/HAudio.c	318;"	d	file:
NaN	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static double NaN() {$/;"	f	class:double_conversion::Double
NaN	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static float NaN() {$/;"	f	class:double_conversion::Single
NameCell	HTKLib/HLabel.h	/^}NameCell;$/;"	t	typeref:struct:_NameCell
NameFromFD	HTKLVRec/kenlm/util/file.cc	/^std::string NameFromFD(int fd) {$/;"	f	namespace:util
NameGuess	HTKLVRec/kenlm/util/file.hh	/^    const std::string &NameGuess() const { return name_guess_; }$/;"	f	class:util::FDException
NameHolder	HLMLib/LUtil.h	/^}NameHolder;$/;"	t	typeref:struct:_NameHolder
NameId	HLMLib/LUtil.h	/^typedef NameHolder *NameId;    \/* Internal representation of names *\/$/;"	t
NameOf	HTKLib/HShell.c	/^char * NameOf(char *fn, char *s)$/;"	f
NamePossiblyFind	HTKLVRec/kenlm/util/file_piece.cc	/^std::string NamePossiblyFind(int fd, const char *name) {$/;"	f	namespace:util::__anon72
NativeRead	HTKLib/esig_nat.c	/^NativeRead(void *data,$/;"	f	file:
NativeRecordSize	HTKLib/esig_nat.c	/^NativeRecordSize(FieldList list)$/;"	f
NativeTypeSize	HTKLib/esig_nat.c	/^NativeTypeSize(int type   \/* numeric data-type code *\/ )$/;"	f
NativeWrite	HTKLib/esig_nat.c	/^NativeWrite(void    *data,$/;"	f	file:
NetFilter	HTKLib/HShell.h	/^   NetFilter,       \/* Network file input via HNet *\/$/;"	e	enum:__anon153
NetInst	HTKLib/HNet.h	/^typedef struct _NetInst NetInst;$/;"	t	typeref:struct:_NetInst
NetLink	HTKLib/HNet.h	/^typedef struct _NetLink NetLink;$/;"	t	typeref:struct:_NetLink
NetNode	HTKLib/HNet.h	/^typedef struct _NetNode NetNode;$/;"	t	typeref:struct:_NetNode
NetNodeType	HTKLib/HNet.h	/^typedef int NetNodeType; $/;"	t
NetOFilter	HTKLib/HShell.h	/^   NetOFilter,      \/* Network file output via HNet *\/$/;"	e	enum:__anon153
Network	HTKLib/HNet.h	/^} Network;$/;"	t	typeref:struct:__anon139
NeverCombine	HTKLVRec/kenlm/util/stream/sort.hh	/^struct NeverCombine {$/;"	s	namespace:util::stream
New	HTKLib/HMem.c	/^void *New(MemHeap *x,size_t size)$/;"	f
NewBetaVec	HTKLib/HFB.c	/^static DVector NewBetaVec(MemHeap *x, int N)$/;"	f	file:
NewCell	HTKLib/HLabel.c	/^static NameCell *NewCell(char *name)$/;"	f	file:
NewFieldSpec	HTKLib/esignal.c	/^NewFieldSpec(int    type,       \/* numeric code for data type *\/$/;"	f
NewHMMScan	HTKLib/HUtil.c	/^void NewHMMScan(HMMSet *hset, HMMScanState *hss)$/;"	f
NewHMMSetCxtInfo	HTKLib/HNet.c	/^static HMMSetCxtInfo *NewHMMSetCxtInfo(HMMSet *hset, Boolean frcCxtInd)$/;"	f	file:
NewHolder	HLMLib/LUtil.c	/^static NameHolder *NewHolder(char *name)$/;"	f	file:
NewILattice	HTKLib/HNet.c	/^Lattice *NewILattice(MemHeap *heap,int nn,int na,Lattice *info)$/;"	f
NewInput	HTKLVRec/kenlm/lm/filter/thread.hh	/^    void NewInput() {$/;"	f	class:lm::Controller
NewItemBlock	HTKLib/HTrain.c	/^static IBLink NewItemBlock(MemHeap *x, int blkSize)$/;"	f	file:
NewLattice	HTKLib/HNet.c	/^Lattice *NewLattice(MemHeap *heap,int nn,int na)$/;"	f
NewMacro	HTKLib/HModel.c	/^MLink NewMacro(HMMSet *hset, short fidx, char type, LabId id, Ptr structure)$/;"	f
NewNRefAlign	HTKLib/HRec.c	/^static Align *NewNRefAlign(NetNode *node,int state,double like,$/;"	f	file:
NewNRefPath	HTKLib/HRec.c	/^static Path *NewNRefPath(void)$/;"	f	file:
NewNode	HTKLib/HNet.c	/^static NetNode *NewNode(MemHeap *heap,HLink hmm,int nlinks)$/;"	f	file:
NewOtprobVec	HTKLib/HFB.c	/^static float * NewOtprobVec(MemHeap *x, int M)$/;"	f	file:
NewOtprobVec	HTKLib/HFBLat.c	/^static float * NewOtprobVec(MemHeap *x, int M)$/;"	f	file:
NewPron	HTKLib/HDict.c	/^void NewPron(Vocab *voc, Word wid, int nphones, LabId *phones, $/;"	f
NewPronHolder	HTKLib/HNet.c	/^static PronHolder *NewPronHolder(MemHeap *heap,HMMSetCxtInfo *hci,$/;"	f	file:
NewSTLLink	HTKLVRec/HLVNet.c	/^STLexLink *NewSTLLink (MemHeap *heap)$/;"	f
NewSTLNode	HTKLVRec/HLVNet.c	/^STLexNode *NewSTLNode (MemHeap *heap)$/;"	f
NewString	HTKLib/HMem.c	/^char *NewString(MemHeap *x, int size)$/;"	f
NewTLexNodeCon	HTKLVRec/HLVNet.c	/^TLexNode *NewTLexNodeCon (MemHeap *heap, TLexNet *net, int layerId, LabId lc, LabId rc)$/;"	f
NewTLexNodeMod	HTKLVRec/HLVNet.c	/^TLexNode *NewTLexNodeMod (MemHeap *heap, TLexNet *net, int layerId, HLink hmm)$/;"	f
NewTLexNodeWe	HTKLVRec/HLVNet.c	/^TLexNode *NewTLexNodeWe (MemHeap *heap, TLexNet *net, int layerId, Pron pron)$/;"	f
NewTokSetArray	HTKLVRec/HLVRec.c	/^static TokenSet *NewTokSetArray(DecoderInst *dec, int N)$/;"	f	file:
NewTokSetArrayVar	HTKLVRec/HLVRec.c	/^static TokenSet *NewTokSetArrayVar(DecoderInst *dec, int N, Boolean isSil)$/;"	f	file:
NewWord	HTKLib/HDict.c	/^static Word NewWord(Vocab *voc, LabId wordName)$/;"	f	file:
Next	HTKLVRec/kenlm/lm/trie.hh	/^  uint64_t Next() const { return next; }$/;"	f	struct:lm::ngram::trie::UnigramValue
Next	HTKLVRec/kenlm/lm/value.hh	/^    uint64_t Next() const { return next; }$/;"	f	struct:lm::ngram::BackoffValue::TrieUnigramValue
Next	HTKLVRec/kenlm/lm/value.hh	/^    uint64_t Next() const { return next; }$/;"	f	struct:lm::ngram::RestValue::TrieUnigramValue
Next	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^uint64_t Next(unsigned char stone, uint64_t complete) {$/;"	f	namespace:util::stream::__anon81
NextArg	HTKLib/HShell.c	/^ArgKind NextArg(void)$/;"	f
NextDouble	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  double NextDouble() const {$/;"	f	class:double_conversion::Double
NextInMemory	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    void NextInMemory() {$/;"	f	class:lm::builder::NGram
NextLArc	HTKLib/HNet.h	249;"	d
NextSize	HTKLVRec/kenlm/util/stream/sort.hh	/^    uint64_t NextSize() {$/;"	f	class:util::stream::Offsets
NextWord	HLMTools/LGPrep.c	/^char * NextWord(char *s, char *word)$/;"	f
NoFilter	HTKLib/HShell.h	/^   NoFilter,        \/* Direct input - no pipe *\/$/;"	e	enum:__anon153
NoMLFHeader	HTKLib/HLabel.c	/^static Boolean NoMLFHeader(char *s)$/;"	f	file:
NoOFilter	HTKLib/HShell.h	/^   NoOFilter        \/* Direct output - no pipe *\/$/;"	e	enum:__anon153
NoOpUniqueWords	HTKLVRec/kenlm/lm/vocab.hh	/^    NoOpUniqueWords() {}$/;"	f	class:lm::ngram::NoOpUniqueWords
NoOpUniqueWords	HTKLVRec/kenlm/lm/vocab.hh	/^class NoOpUniqueWords {$/;"	c	namespace:lm::ngram
NoRestBuild	HTKLVRec/kenlm/lm/value_build.hh	/^    NoRestBuild() {}$/;"	f	class:lm::ngram::NoRestBuild
NoRestBuild	HTKLVRec/kenlm/lm/value_build.hh	/^class NoRestBuild {$/;"	c	namespace:lm::ngram
NoSilence	HTKLib/HFBLat.c	/^static Boolean NoSilence = FALSE;                      \/* If TRUE, then (in non-exact MPE) the silences are omitted from the reference transcription$/;"	v	file:
Node	HTKLVRec/kenlm/lm/search_hashed.hh	/^    typedef uint64_t Node;$/;"	t	class:lm::ngram::detail::HashedSearch
Node	HTKLVRec/kenlm/lm/search_trie.hh	/^    typedef NodeRange Node;$/;"	t	class:lm::ngram::trie::TrieSearch
Node	HTKTools/HHEd.c	/^}Node;$/;"	t	typeref:struct:_Node	file:
Node	HTKTools/HParse.c	/^} Node;$/;"	t	typeref:struct:_Node	file:
NodeId	HTKLib/HNet.h	/^typedef struct lnode *NodeId;$/;"	t	typeref:struct:lnode
NodeInfo	HTKTools/HParse.c	/^}NodeInfo;$/;"	t	typeref:struct:_NodeInfo	file:
NodeRange	HTKLVRec/kenlm/lm/trie.hh	/^struct NodeRange {$/;"	s	namespace:lm::ngram::trie
NodeType	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	t	typeref:enum:__anon205	file:
NonSil_and_Quinphone_IsStartPhone	HTKLib/HExactMPE.c	/^Boolean NonSil_and_Quinphone_IsStartPhone(LArc *larc, int i){$/;"	f
NonSkipRegion	HTKLib/HFB.c	/^static Boolean NonSkipRegion(int skipstart, int skipend, int t)$/;"	f	file:
NonTerminal	HTKLVRec/kenlm/lm/left.hh	/^    void NonTerminal(const ChartState &in, float prob = 0.0) {$/;"	f	class:lm::ngram::RuleScore
NormaliseFE	HLMLib/LPMerge.c	/^static void NormaliseFE(FLEntry *tgtFE)$/;"	f	file:
NormaliseLM	HLMLib/LPMerge.c	/^void NormaliseLM(BackOffLM *lm) $/;"	f
NormaliseLogEnergy	HTKLib/HSigP.c	/^void NormaliseLogEnergy(float *data,int n,int step,float silFloor,float escale)$/;"	f
NormaliseName	HTKTools/HResults.c	/^void NormaliseName(LabList *ll,int lev)$/;"	f
Normalize	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  static DiyFp Normalize(const DiyFp& a) {$/;"	f	class:double_conversion::DiyFp
Normalize	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  void Normalize() {$/;"	f	class:double_conversion::DiyFp
NormalizeTempPrefix	HTKLVRec/kenlm/util/file.cc	/^void NormalizeTempPrefix(std::string &base) {$/;"	f	namespace:util
NormalizedBoundaries	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  void NormalizedBoundaries(DiyFp* out_m_minus, DiyFp* out_m_plus) const {$/;"	f	class:double_conversion::Double
NormalizedBoundaries	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  void NormalizedBoundaries(DiyFp* out_m_minus, DiyFp* out_m_plus) const {$/;"	f	class:double_conversion::Single
NormalizedExponent	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^static int NormalizedExponent(uint64_t significand, int exponent) {$/;"	f	namespace:double_conversion
NotFound	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    WordIndex NotFound() const { return not_found_; }$/;"	f	class:lm::base::Vocabulary
NotLinked	HTKTools/HParse.c	/^static Boolean NotLinked(LinkSet *ls, Link x)$/;"	f	file:
Nq	HTKLib/HArc.h	/^  int Nq;$/;"	m	struct:_Acoustic
NullContextMemory	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    const void *NullContextMemory() const { return null_context_memory_; }$/;"	f	class:lm::base::Model
NullContextState	HTKLVRec/kenlm/lm/facade.hh	/^    const State &NullContextState() const { return null_context_; }$/;"	f	class:lm::base::ModelFacade
NullContextWrite	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    void NullContextWrite(void *to) const { memcpy(to, null_context_memory_, StateSize()); }$/;"	f	class:lm::base::Model
NullWord	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^    lm::WordIndex NullWord() const { return null_word_; }$/;"	f	class:lm::np::Vocabulary
NumAccs	HTKTools/HMMIRest.c	/^static int NumAccs;                \/*  Set in Initialise() to  1 or 2 or 3. *\/$/;"	v	file:
NumArgs	HTKLib/HShell.c	/^int  NumArgs(void)$/;"	f
NumAuxCases	HTKLib/HLabel.c	/^int NumAuxCases(LabList *ll, LabId id, int i)$/;"	f
NumCases	HTKLib/HLabel.c	/^int NumCases(LabList *ll, LabId id)$/;"	f
NumCols	HTKLib/HMem.c	/^int NumCols(Matrix m)$/;"	f
NumDCols	HTKLib/HMem.c	/^int NumDCols(DMatrix m)$/;"	f
NumDRows	HTKLib/HMem.c	/^int NumDRows(DMatrix m)$/;"	f
NumEnergy	HTKLib/HParm.c	/^static int NumEnergy(ParmKind pk)$/;"	f	file:
NumEquiv	HLMTools/LPlex.c	/^static int NumEquiv(void)$/;"	f	file:
NumFrame	HTKTools/HCompV.c	/^   int NumFrame;                         \/* number of frames for speaker *\/$/;"	m	struct:__anon190	file:
NumHead	HTKLib/HShell.c	/^static Boolean NumHead(char *s)$/;"	f	file:
NumItems	HTKLib/HUtil.c	/^int NumItems(ILink list)$/;"	f
NumJPreds	HTKTools/HParse.c	/^static int NumJPreds(int a)$/;"	f	file:
NumJSuccs	HTKTools/HParse.c	/^static int NumJSuccs(int a)$/;"	f	file:
NumLMHdrFields	HLMLib/LUtil.c	/^int NumLMHdrFields(LMFileHdr hdr)$/;"	f
NumLines	HLMLib/LUtil.c	/^static int NumLines(Source *src, IOFilter filter)$/;"	f	file:
NumMLFEntries	HTKLib/HLabel.c	/^int NumMLFEntries(void)$/;"	f
NumMLFFiles	HTKLib/HLabel.c	/^int NumMLFFiles(void)$/;"	f
NumNodeFoll	HTKLib/HNet.c	/^int NumNodeFoll(NodeId n)$/;"	f
NumNodePred	HTKLib/HNet.c	/^int NumNodePred(NodeId n)$/;"	f
NumParts	HTKTools/HLEd.c	/^int NumParts(LabId id)$/;"	f
NumRows	HTKLib/HMem.c	/^int NumRows(Matrix m)$/;"	f
NumSegs	HTKLib/HTrain.c	/^int NumSegs(SegStore ss)$/;"	f
NumStatic	HTKLib/HParm.c	/^static int NumStatic(int nTotal, ParmKind pk)$/;"	f	file:
NumTreeNodes	HTKLib/HTrain.c	/^static int NumTreeNodes(int nc)$/;"	f	file:
NumbLArc	HTKLib/HNet.h	242;"	d
NumberBytes	HTKLib/HWave.c	/^static long NumberBytes(FILE *f, int hSize, Boolean isPipe)$/;"	f	file:
NumberEntries	HTKTools/HBuild.c	/^void NumberEntries(WPGrammar *wpg, Word sentEnd)$/;"	f
NxtPath	HTKLib/HRec.h	/^typedef struct nxtpath NxtPath;    \/* NBest traceback route (HRec.c) *\/$/;"	t	typeref:struct:nxtpath
OBEXPFORM	HTKLib/HParm.c	2929;"	d	file:
OBFLTFORM	HTKLib/HParm.c	2928;"	d	file:
OBMARGIN	HTKLib/HParm.c	2927;"	d	file:
OFFSET	HTKLib/HModel.c	/^   LINXFORM, OFFSET, BIAS, LOGDET, BLOCKINFO, BLOCK, BASECLASS, $/;"	e	enum:__anon117	file:
OGI	HTKLib/HWave.h	/^        OGI,               \/* Oregon Institute format (similar to TIMIT) *\/$/;"	e	enum:__anon181
OGIhdr	HTKLib/HWave.c	/^} OGIhdr;$/;"	t	typeref:struct:__anon174	file:
OOVEntry	HLMTools/LPlex.c	/^} OOVEntry;$/;"	t	typeref:struct:__anon33	file:
OPTIONAL	HTKLib/esignal.h	91;"	d
ORANGE	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
OSS_AUDIO	HTKLib/HAudio.c	54;"	d	file:
OUTSILWARN	HTKLib/HParm.c	/^   OUTSILWARN,    \/* Output Warning before Measure Sil *\/$/;"	e	enum:__anon142	file:
OWarn	HTKLib/HModel.c	/^static void OWarn(HMMSet *hset,Boolean equal,char *opt)$/;"	f	file:
ObsCache	HTKLib/HAdapt.c	/^} ObsCache;                        \/* observation cache to save rotated observations *\/$/;"	t	typeref:struct:_ObsCache	file:
ObsInBuffer	HTKLib/HParm.c	/^int ObsInBuffer(ParmBuf pbuf)$/;"	f
Observation	HTKLib/HParm.h	/^} Observation;$/;"	t	typeref:struct:__anon147
ObtainBackoffs	HTKLVRec/kenlm/lm/search_trie.cc	/^    void ObtainBackoffs(unsigned char total_order, FILE *unigram_file, RecordReader *reader) {$/;"	f	class:lm::ngram::trie::__anon58::SRISucks
Offset	HTKLVRec/kenlm/util/file_piece.hh	/^    uint64_t Offset() const {$/;"	f	class:util::FilePiece
Offsets	HTKLVRec/kenlm/util/stream/sort.hh	/^    explicit Offsets(int fd) : log_(fd) {$/;"	f	class:util::stream::Offsets
Offsets	HTKLVRec/kenlm/util/stream/sort.hh	/^class Offsets {$/;"	c	namespace:util::stream
OldSanity	HTKLVRec/kenlm/lm/binary_format.cc	/^struct OldSanity {$/;"	s	namespace:lm::ngram::__anon41	file:
OnlyGamma	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    OnlyGamma(bool pruning) : pruning_(pruning) {}$/;"	f	class:lm::builder::__anon45::OnlyGamma
OnlyGamma	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^class OnlyGamma {$/;"	c	namespace:lm::builder::__anon45	file:
OpType	HTKTools/HSLab.c	/^} OpType;$/;"	t	typeref:enum:__anon210	file:
OpenAsChannel	HTKLib/HParm.c	/^static ReturnStatus OpenAsChannel(ParmBuf pbuf, int maxObs, $/;"	f	file:
OpenAudioInput	HTKLib/HAudio.c	/^AudioIn OpenAudioInput(MemHeap *x, HTime *sampPeriod, HTime winDur, HTime frPeriod)$/;"	f
OpenAudioOutput	HTKLib/HAudio.c	/^AudioOut OpenAudioOutput(MemHeap *x, HTime *sampPeriod)$/;"	f
OpenBuffer	HTKLib/HParm.c	/^ParmBuf OpenBuffer(MemHeap *x, char *fn, int maxObs, FileFormat ff, $/;"	f
OpenExtBuffer	HTKLib/HParm.c	/^ParmBuf OpenExtBuffer(MemHeap *x, char *fn, int maxObs, $/;"	f
OpenIn	HTKLib/esignal.c	/^OpenIn(char     *filename,      \/* name of input file *\/$/;"	f
OpenInputSet	HLMLib/LGBase.c	/^void OpenInputSet(NGInputSet *inset)$/;"	f
OpenLLF	HTKLib/HLat.c	/^LLFInfo *OpenLLF (char *fn)$/;"	f
OpenLabFile	HTKLib/HLabel.c	/^static FILE * OpenLabFile(char *fname, Boolean *isMLF)$/;"	f	file:
OpenNGramFile	HLMLib/LGBase.c	/^void OpenNGramFile(NGSource *ngs, char *fn, WordMap *wm)$/;"	f
OpenOut	HTKLib/esignal.c	/^OpenOut(char        *filename,$/;"	f
OpenParmChannel	HTKLib/HParm.c	/^static ReturnStatus OpenParmChannel(ParmBuf pbuf,char *fname, int *ret_val)$/;"	f	file:
OpenParmFile	HTKTools/HCopy.c	/^HTime OpenParmFile(char *src)$/;"	f
OpenReadOrThrow	HTKLVRec/kenlm/util/file.cc	/^int OpenReadOrThrow(const char *name) {$/;"	f	namespace:util
OpenSpeechFile	HTKTools/HCopy.c	/^void OpenSpeechFile(char *s)$/;"	f
OpenWaveFile	HTKTools/HCopy.c	/^HTime OpenWaveFile(char *src)$/;"	f
OpenWaveInput	HTKLib/HWave.c	/^Wave OpenWaveInput(MemHeap *x, char *fname, FileFormat fmt, HTime winDur, $/;"	f
OpenWaveOutput	HTKLib/HWave.c	/^Wave OpenWaveOutput(MemHeap *x, HTime *sampPeriod, long bufSize)$/;"	f
Option 1 Recognition	HTKBook/exampsys.tex	/^\\subsection{Option  1 - Recognition}$/;"	b
Option 2 Speaker Adaptation	HTKBook/exampsys.tex	/^\\subsection{Option  2 - Speaker Adaptation}$/;"	b
Option 3 Lattice Generation	HTKBook/exampsys.tex	/^\\subsection{Option 3 - Lattice Generation}$/;"	b
Option 4 Lattice Rescoring	HTKBook/exampsys.tex	/^\\subsection{Option 4 - Lattice Rescoring}$/;"	b
Order	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    std::size_t Order() const { return end_ - begin_; }$/;"	f	class:lm::builder::NGram
Order	HTKLVRec/kenlm/lm/builder/sort.hh	/^    std::size_t Order() const { return order_; }$/;"	f	class:lm::builder::Comparator
Order	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^    std::size_t Order() const { return counts_.size(); }$/;"	f	class:lm::interpolate::ARPAToStream
Order	HTKLVRec/kenlm/lm/search_hashed.hh	/^    unsigned char Order() const {$/;"	f	class:lm::ngram::detail::HashedSearch
Order	HTKLVRec/kenlm/lm/search_trie.hh	/^    unsigned char Order() const {$/;"	f	class:lm::ngram::trie::TrieSearch
Order	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    unsigned char Order() const { return order_; }$/;"	f	class:lm::base::Model
OrderFromSize	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    static std::size_t OrderFromSize(std::size_t size) {$/;"	f	class:lm::builder::NGram
OrderStat	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    struct OrderStat {$/;"	s	class:lm::builder::__anon42::StatCollector	file:
OutConMat	HTKTools/HResults.c	/^void OutConMat(void)$/;"	f
OutMLFEntry	HTKLib/HLabel.c	/^} OutMLFEntry;$/;"	t	typeref:struct:__anon107	file:
OutMacro	HTKTools/HHEd.c	/^void OutMacro(char type,Ptr structure)$/;"	f
OutOfTokens	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    OutOfTokens() throw() {}$/;"	f	class:util::OutOfTokens
OutOfTokens	HTKLVRec/kenlm/util/tokenize_piece.hh	/^class OutOfTokens : public Exception {$/;"	c	namespace:util
OutP	HTKLib/HModel.c	/^LogFloat OutP(Observation *x, HLink hmm, int state)$/;"	f
OutPBlock	HTKLVRec/HLVModel.c	/^void OutPBlock (StateInfo_lv *si, Observation **obsBlock, $/;"	f
OutPBlock_HMod	HTKLVRec/HLVRec-outP.c	/^void OutPBlock_HMod (StateInfo_lv *si, Observation **obsBlock, $/;"	f
OutPCache	HTKLVRec/HLVRec.h	/^typedef struct _OutPCache OutPCache;$/;"	t	typeref:struct:_OutPCache
OutP_lv	HTKLVRec/HLVModel.c	/^LogFloat OutP_lv (StateInfo_lv *si,  unsigned short s, float *x)$/;"	f
OutSamples	HTKLib/HAudio.c	/^static int OutSamples(AudioOut a)$/;"	f	file:
OutString	HLMLib/LCMap.c	/^static void OutString(FILE *f, Boolean htkEsc, LabId id)$/;"	f	file:
OutTrans	HTKTools/HResults.c	/^void OutTrans(void)$/;"	f
Output	HTKLVRec/kenlm/lm/builder/output.hh	/^    Output() {}$/;"	f	class:lm::builder::Output
Output	HTKLVRec/kenlm/lm/builder/output.hh	/^class Output : boost::noncopyable {$/;"	c	namespace:lm::builder
Output	HTKLVRec/kenlm/lm/filter/format.hh	/^  typedef ARPAOutput Output;$/;"	t	struct:lm::ARPAFormat
Output	HTKLVRec/kenlm/lm/filter/format.hh	/^  typedef CountOutput Output;$/;"	t	struct:lm::CountFormat
Output	HTKLVRec/kenlm/util/stream/sort.hh	/^    void Output(Chain &out) {$/;"	f	class:util::stream::Sort
Output	HTKLVRec/kenlm/util/stream/sort.hh	/^    void Output(Chain &out, std::size_t lazy_memory) {$/;"	f	class:util::stream::Sort
OutputAlign	HTKLib/HNet.c	/^static void OutputAlign(LArc *la,int format,FILE *file)$/;"	f	file:
OutputBoBigram	HTKTools/HLStats.c	/^void OutputBoBigram(void)$/;"	f
OutputCounts	HTKTools/HLStats.c	/^void OutputCounts(void)$/;"	f
OutputDurs	HTKTools/HLStats.c	/^void OutputDurs(void)$/;"	f
OutputFloatField	HTKLib/HNet.c	/^static void OutputFloatField(char field,float val,Boolean bin,$/;"	f	file:
OutputHook	HTKLVRec/kenlm/lm/builder/output.hh	/^    explicit OutputHook(HookType hook_type) : type_(hook_type), master_(NULL) {}$/;"	f	class:lm::builder::OutputHook
OutputHook	HTKLVRec/kenlm/lm/builder/output.hh	/^class OutputHook {$/;"	c	namespace:lm::builder
OutputIntField	HTKLib/HNet.c	/^static void OutputIntField(char field,int val,Boolean bin,$/;"	f	file:
OutputList	HTKTools/HLStats.c	/^void OutputList(void)$/;"	f
OutputMatBigram	HTKTools/HLStats.c	/^void OutputMatBigram(void)$/;"	f
OutputProbBackoff	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    explicit OutputProbBackoff(std::size_t \/*order*\/) {}$/;"	f	class:lm::builder::__anon46::OutputProbBackoff
OutputProbBackoff	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^class OutputProbBackoff {$/;"	c	namespace:lm::builder::__anon46	file:
OutputQ	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    explicit OutputQ(std::size_t order) : q_delta_(order) {}$/;"	f	class:lm::builder::__anon46::OutputQ
OutputQ	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^class OutputQ {$/;"	c	namespace:lm::builder::__anon46	file:
OutputSpotStats	HTKTools/HResults.c	/^void OutputSpotStats(void)$/;"	f
OutputStats	HTKTools/HLStats.c	/^void OutputStats(void)$/;"	f
OutputStats	HTKTools/HResults.c	/^void OutputStats(void)$/;"	f
OutputWorker	HTKLVRec/kenlm/lm/filter/thread.hh	/^    OutputWorker(Output &output, util::PCQueue<Request> &done) : output_(output), done_(done), base_sequence_(0) {}$/;"	f	class:lm::OutputWorker
OutputWorker	HTKLVRec/kenlm/lm/filter/thread.hh	/^template <class Batch, class Output> class OutputWorker {$/;"	c	namespace:lm
OverflowException	HTKLVRec/kenlm/util/exception.cc	/^OverflowException::OverflowException() throw() {}$/;"	f	class:util::OverflowException
OverflowException	HTKLVRec/kenlm/util/exception.hh	/^class OverflowException : public Exception {$/;"	c	namespace:util
Overwrite	HTKLVRec/kenlm/lm/trie_sort.cc	/^void RecordReader::Overwrite(const void *start, std::size_t amount) {$/;"	f	class:lm::ngram::trie::RecordReader
OwningMergingReader	HTKLVRec/kenlm/util/stream/sort.hh	/^    OwningMergingReader(int data, const Offsets &offsets, std::size_t buffer, std::size_t lazy, const Compare &compare, const Combine &combine) $/;"	f	class:util::stream::OwningMergingReader
OwningMergingReader	HTKLVRec/kenlm/util/stream/sort.hh	/^template <class Compare, class Combine> class OwningMergingReader : public MergingReader<Compare, Combine> {$/;"	c	namespace:util::stream
P	HTKLVRec/kenlm/lm/builder/sort.hh	/^    typedef util::FixedArray<S> P;$/;"	t	class:lm::builder::Sorts
P	HTKLVRec/kenlm/lm/model.hh	/^    typedef base::ModelFacade<GenericModel<Search, VocabularyT>, State, VocabularyT> P;$/;"	t	class:lm::ngram::detail::GenericModel
P	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^    typedef lm::base::ModelFacade<Model, State, Vocabulary> P;$/;"	t	class:lm::np::Model
P	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    typedef util::FixedArray<T> P;$/;"	t	class:util::stream::GenericStreams
P	HTKLVRec/kenlm/util/stream/sort.hh	/^    typedef MergingReader<Compare, Combine> P;$/;"	t	class:util::stream::OwningMergingReader
P	HTKTools/HMMIRest.c	/^static int P;                        \/* number of physical HMM's *\/$/;"	v	file:
PACKAGE	Makefile	/^PACKAGE = @PACKAGE@$/;"	m
PARALLEL_READ	HTKLVRec/kenlm/util/mmap.hh	/^  PARALLEL_READ,$/;"	e	enum:util::__anon76
PARAMETERS	HTKLib/HModel.c	/^   CLASS, XFORMWGTSET, CLASSXFORM, MMFIDMASK, PARAMETERS,$/;"	e	enum:__anon117	file:
PARENTXFORM	HTKLib/HModel.c	/^   XFORMKIND=90, PARENTXFORM, NUMXFORMS, XFORMSET,$/;"	e	enum:__anon117	file:
PARMKIND	HTKLib/HModel.c	/^   PARMKIND=120, $/;"	e	enum:__anon117	file:
PATHCHAR	HTKLib/HShell.h	482;"	d
PATHCHAR	HTKLib/HShell.h	485;"	d
PATHCHAR	HTKLib/HShell.h	488;"	d
PATHCHAR	HTKLib/HShell.h	492;"	d
PAT_ANYPATH	HTKLib/HLabel.h	/^   PAT_ANYPATH,   \/* pat is "* \/ name" and name is hashed *\/$/;"	e	enum:_MLFPatType
PAT_FIXED	HTKLib/HLabel.h	/^   PAT_FIXED,     \/* whole "pattern" is hashed *\/$/;"	e	enum:_MLFPatType
PAT_GENERAL	HTKLib/HLabel.h	/^   PAT_GENERAL    \/* general pattern - no hashing *\/$/;"	e	enum:_MLFPatType
PAT_LEN	HTKLib/HUtil.c	619;"	d	file:
PBStatus	HTKLib/HParm.h	/^} PBStatus;$/;"	t	typeref:enum:__anon148
PB_CLEARED	HTKLib/HParm.h	/^   PB_CLEARED   \/* Buffer has been emptied *\/$/;"	e	enum:__anon148
PB_FILLING	HTKLib/HParm.h	/^   PB_FILLING,  \/* Buffer is filling *\/$/;"	e	enum:__anon148
PB_INIT	HTKLib/HParm.h	/^   PB_INIT,     \/* Buffer is initialised and empty *\/$/;"	e	enum:__anon148
PB_STOPPED	HTKLib/HParm.h	/^   PB_STOPPED,  \/* Buffer has stopped but not yet empty *\/$/;"	e	enum:__anon148
PB_STOPPING	HTKLib/HParm.h	/^   PB_STOPPING, \/* Buffer is waiting for silence *\/$/;"	e	enum:__anon148
PB_WAITING	HTKLib/HParm.h	/^   PB_WAITING,  \/* Buffer is waiting for speech *\/$/;"	e	enum:__anon148
PBlock	HTKLib/HParm.c	/^PBlock;$/;"	t	typeref:struct:pblock	file:
PCQueue	HTKLVRec/kenlm/util/pcqueue.hh	/^  explicit PCQueue(size_t size)$/;"	f	class:util::PCQueue
PCQueue	HTKLVRec/kenlm/util/pcqueue.hh	/^template <class T> class PCQueue : boost::noncopyable {$/;"	c	namespace:util
PClip	HTKTools/HResults.c	/^void PClip(char * instr, char *outstr, int max)$/;"	f
PDEMOutP	HTKLib/HModel.c	/^Boolean PDEMOutP(Vector otvs, MixPDF *mp, LogFloat *mixp, LogFloat xwtdet)$/;"	f
PDUR	HTKLib/HModel.c	/^   NDUR, PDUR, GDUR, RELDUR, GENDUR,$/;"	e	enum:__anon117	file:
PERCENTSYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
PExpr	HTKTools/HParse.c	/^static void PExpr(Link *hd, Link *tl)$/;"	f	file:
PFN_MS_EX	HTKLVRec/kenlm/util/usage.cc	/^typedef WINBOOL (WINAPI *PFN_MS_EX) (lMEMORYSTATUSEX*);$/;"	t	file:
PFactor	HTKTools/HParse.c	/^static void PFactor(Link *hd, Link *tl)$/;"	f	file:
PGetCh	HTKTools/HParse.c	/^static void PGetCh(void)$/;"	f	file:
PGetIdent	HTKTools/HParse.c	/^static void PGetIdent(void)$/;"	f	file:
PGetSym	HTKTools/HParse.c	/^static void PGetSym(void)$/;"	f	file:
PGroup	HTKTools/HParse.c	/^static void PGroup(Link *hd, Link *tl)$/;"	f	file:
PHIdent	HTKLib/HUtil.c	/^static void PHIdent(ILink *models, HMMSet *hset)$/;"	f	file:
PHName	HTKLib/HUtil.c	/^static void PHName(ILink *models,HMMSet *hset)$/;"	f	file:
PHONE_BEAM	HTKLib/HExactMPE.c	/^static int PHONE_BEAM=4; \/* phones before & after...*\/$/;"	v	file:
PI	HTKLib/HMath.h	38;"	d
PI	HTKLib/HMath.h	40;"	d
PI_GEN	HTKLVRec/HLVRec-propagate.c	/^static int PI_GEN = 0;$/;"	v	file:
PI_LR	HTKLVRec/HLVRec-propagate.c	/^static int PI_LR = 0;$/;"	v	file:
PIndex	HTKLib/HUtil.c	/^static void PIndex(IntSet s)$/;"	f	file:
PInstInfo	HTKLib/HNet.c	/^PInstInfo;$/;"	t	typeref:struct:pinstinfo	file:
PIntRange	HTKLib/HUtil.c	/^static void PIntRange(IntSet s)$/;"	f	file:
PItemList	HTKLib/HUtil.c	/^char *PItemList(ILink *ilist, char *type, HMMSet *hset,$/;"	f
PItemSet	HTKLib/HUtil.c	/^static void PItemSet(ILink *ilist, char *type, HMMSet *hset)$/;"	f	file:
PLAINHS	HTKLib/HModel.h	/^enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};$/;"	e	enum:_HSetKind
PLP	HTKLib/HParm.h	/^      PLP,                             \/* Standard PLP coefficients *\/$/;"	e	enum:_BaseParmKind
PMix	HTKLib/HUtil.c	/^static void PMix(ILink models, ILink *ilist, char *type,$/;"	f	file:
PModel	HTKTools/HParse.c	/^static void PModel(Link *hd, Link *tl)$/;"	f	file:
PNetwork	HTKTools/HParse.c	/^static void PNetwork(Link *hd, Link *tl, Boolean netOnly, Boolean skipExpr)$/;"	f	file:
POISSOND	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	e	enum:_DurKind
POPULATE_OR_LAZY	HTKLVRec/kenlm/util/mmap.hh	/^  POPULATE_OR_LAZY,$/;"	e	enum:util::__anon76
POPULATE_OR_READ	HTKLVRec/kenlm/util/mmap.hh	/^  POPULATE_OR_READ,$/;"	e	enum:util::__anon76
POption	HTKTools/HParse.c	/^static void POption(Link *hd, Link *tl)$/;"	f	file:
POutP	HTKLib/HModel.c	/^LogFloat POutP(HMMSet *hset,Observation *x, StateInfo *si)$/;"	f
POutP_HModel	HTKLVRec/HLVRec-outP.c	/^LogFloat POutP_HModel (HMMSet *hset,Observation *x, StateInfo *si, int id)$/;"	f
PR	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon199	file:
PREAM_MAX	HTKLib/esignal.h	53;"	d
PRECISION	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    PRECISION$/;"	e	enum:double_conversion::DoubleToStringConverter::DtoaMode
PREEMCOEF	HTKLib/HParm.c	/^   PREEMCOEF,     \/* Preemphasis Coefficient *\/$/;"	e	enum:__anon142	file:
PREQUAL	HTKLib/HModel.c	/^   NUMCLASSES, ADAPTKIND, PREQUAL, INPUTXFORM,$/;"	e	enum:__anon117	file:
PROBING	HTKLVRec/kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon54
PROB_LOG_TO_SHORT	HLMLib/LModel.c	360;"	d	file:
PROB_LOG_TO_SHORT	HLMLib/LModel.c	375;"	d	file:
PROB_PARALLEL_HOOK	HTKLVRec/kenlm/lm/builder/output.hh	/^  PROB_PARALLEL_HOOK, \/\/ Probability and backoff (or just q).  Output must process the orders in parallel or there will be a deadlock.$/;"	e	enum:lm::builder::HookType
PROB_SEQUENTIAL_HOOK	HTKLVRec/kenlm/lm/builder/output.hh	/^  PROB_SEQUENTIAL_HOOK, \/\/ Probability and backoff (or just q).  Output can process orders any way it likes.  This requires writing the data to disk then reading.  Useful for ARPA files, which put unigrams first etc.$/;"	e	enum:lm::builder::HookType
PROB_SHORT_TO_LOG	HLMLib/LModel.c	363;"	d	file:
PROB_SHORT_TO_LOG	HLMLib/LModel.c	376;"	d	file:
PROGRESS	HTKLVRec/HLVLM.c	298;"	d	file:
PROGRESS	HTKLib/HLM.c	310;"	d	file:
PROGS	HLMTools/Makefile	/^PROGS   =	Cluster HLMCopy LAdapt LBuild LFoF \\$/;"	m
PROGS	HTKTools/Makefile	/^PROGS   = 	HSLab HBuild HCompV HCopy HDMan \\$/;"	m
PROJSIZE	HTKLib/HModel.c	/^   PROJSIZE,$/;"	e	enum:__anon117	file:
PRUNE	HTKLVRec/HLVRec.c	58;"	d	file:
PRead	HTKLVRec/kenlm/util/stream/io.hh	/^    explicit PRead(int fd, bool take_own = false) : file_(fd), own_(take_own) {}$/;"	f	class:util::stream::PRead
PRead	HTKLVRec/kenlm/util/stream/io.hh	/^class PRead {$/;"	c	namespace:util::stream
PRecInfo	HTKLib/HRec.h	/^typedef struct precinfo PRecInfo; \/* Private reconition information (HRec.c) *\/$/;"	t	typeref:struct:precinfo
PRepetition0	HTKTools/HParse.c	/^static void PRepetition0(Link *hd, Link *tl)$/;"	f	file:
PRepetition1	HTKTools/HParse.c	/^static void PRepetition1(Link *hd, Link *tl)$/;"	f	file:
PS	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon199	file:
PSequence	HTKTools/HParse.c	/^static void PSequence(Link *hd, Link *tl)$/;"	f	file:
PSetInfo	HTKLib/HRec.h	/^typedef struct psetinfo PSetInfo; \/* Private HMMSet information (HRec.c) *\/$/;"	t	typeref:struct:psetinfo
PState	HTKLib/HUtil.c	/^static void PState(ILink models, ILink *ilist, char *type, HMMSet *hset)$/;"	f	file:
PStatecomp	HTKLib/HUtil.c	/^static void PStatecomp(ILink models, ILink *ilist, char *type, $/;"	f	file:
PStats	HLMTools/LPlex.c	/^} PStats;$/;"	t	typeref:struct:__anon34	file:
PSubNet	HTKTools/HParse.c	/^static void PSubNet(void)$/;"	f	file:
PTRHASHSIZE	HTKLib/HModel.h	51;"	d
PTriloop	HTKTools/HParse.c	/^static void PTriloop(Link *hd, Link *tl)$/;"	f	file:
PURPLE	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
PVariable	HTKTools/HParse.c	/^static void PVariable(Link *hd, Link *tl)$/;"	f	file:
PWriteAndRecycle	HTKLVRec/kenlm/util/stream/io.hh	/^    explicit PWriteAndRecycle(int fd) : file_(fd) {}$/;"	f	class:util::stream::PWriteAndRecycle
PWriteAndRecycle	HTKLVRec/kenlm/util/stream/io.hh	/^class PWriteAndRecycle {$/;"	c	namespace:util::stream
Pad	HTKLib/HDict.c	/^static void Pad(FILE *f, int nSp, int minSp)$/;"	f	file:
PairedIterator	HTKLVRec/kenlm/util/joint_sort.hh	/^    PairedIterator(const KeyIter &key, const ValueIter &value) :$/;"	f	class:util::PairedIterator
PairedIterator	HTKLVRec/kenlm/util/joint_sort.hh	/^template <class KeyIter, class ValueIter> class PairedIterator : public ProxyIterator<detail::JointProxy<KeyIter, ValueIter> > {$/;"	c	namespace:util
ParallelRead	HTKLVRec/kenlm/util/parallel_read.cc	/^void ParallelRead(int fd, void *to, std::size_t amount, uint64_t offset) {$/;"	f	namespace:util
Parameters	HTKLVRec/kenlm/lm/binary_format.hh	/^struct Parameters {$/;"	s	namespace:lm::ngram
ParmBuf	HTKLib/HParm.h	/^typedef struct _ParmBuf  *ParmBuf;$/;"	t	typeref:struct:_ParmBuf
ParmBufRec	HTKLib/HParm.c	/^}ParmBufRec;$/;"	t	typeref:struct:_ParmBuf	file:
ParmFilter	HTKLib/HShell.h	/^   ParmFilter,      \/* parameter files input via HParm *\/$/;"	e	enum:__anon153
ParmKind	HTKLib/HParm.h	/^typedef short ParmKind;          \/* BaseParmKind + Qualifiers *\/$/;"	t
ParmKind2Str	HTKLib/HParm.c	/^char *ParmKind2Str(ParmKind kind, char *buf)$/;"	f
ParmOFilter	HTKLib/HShell.h	/^   ParmOFilter,     \/* parameter files output via HParm *\/$/;"	e	enum:__anon153
ParseAlpha	HTKTools/HHEd.c	/^char *ParseAlpha(char *src, char *s)$/;"	f
ParseComment	HTKLib/HShell.c	/^static char *ParseComment(Source *src,char *name)$/;"	f	file:
ParseConfIntVec	HTKLib/HAdapt.c	/^static IntVec ParseConfIntVec(MemHeap *x, char *inbuf)$/;"	f	file:
ParseError	HTKTools/HParse.c	/^static void ParseError(int errn)$/;"	f	file:
ParseNode	HTKLib/HAdapt.c	/^static Boolean ParseNode(RegNode *node, AdaptXForm *xform, $/;"	f	file:
ParseNum	HTKLVRec/kenlm/util/usage.cc	/^template <class Num> uint64_t ParseNum(const std::string &arg) {$/;"	f	namespace:util::__anon84
ParseNumber	HTKLVRec/kenlm/util/file_piece.cc	/^void ParseNumber(const char *begin, const char *&end, double &out) {$/;"	f	namespace:util::__anon73
ParseNumber	HTKLVRec/kenlm/util/file_piece.cc	/^void ParseNumber(const char *begin, const char *&end, float &out) {$/;"	f	namespace:util::__anon73
ParseNumber	HTKLVRec/kenlm/util/file_piece.cc	/^void ParseNumber(const char *begin, const char *&end, long int &out) {$/;"	f	namespace:util::__anon73
ParseNumber	HTKLVRec/kenlm/util/file_piece.cc	/^void ParseNumber(const char *begin, const char *&end, unsigned long int &out) {$/;"	f	namespace:util::__anon73
ParseNumber	HTKLib/HNet.c	/^static LatFieldType ParseNumber(double *rval,char *buf)$/;"	f	file:
ParseNumberException	HTKLVRec/kenlm/util/file_piece.cc	/^ParseNumberException::ParseNumberException(StringPiece value) throw() {$/;"	f	class:util::ParseNumberException
ParseNumberException	HTKLVRec/kenlm/util/file_piece.hh	/^class ParseNumberException : public Exception {$/;"	c	namespace:util
ParseSize	HTKLVRec/kenlm/util/usage.cc	/^uint64_t ParseSize(const std::string &arg) {$/;"	f	namespace:util
ParseString	HTKLib/HShell.c	/^char *ParseString(char *src, char *s)$/;"	f
ParseTree	HTKLib/HAdapt.c	/^static Boolean ParseTree(RegTree *rtree, AdaptXForm *xform)$/;"	f	file:
PartialIter	HTKLVRec/kenlm/lm/trie_sort.cc	/^typedef util::ProxyIterator<PartialViewProxy> PartialIter;$/;"	t	namespace:lm::ngram::trie::__anon60	file:
PartialRead	HTKLVRec/kenlm/util/file.cc	/^std::size_t PartialRead(int fd, void *to, std::size_t amount) {$/;"	f	namespace:util
PartialViewProxy	HTKLVRec/kenlm/lm/trie_sort.cc	/^    PartialViewProxy() : attention_size_(0), inner_() {}$/;"	f	class:lm::ngram::trie::__anon60::PartialViewProxy
PartialViewProxy	HTKLVRec/kenlm/lm/trie_sort.cc	/^    PartialViewProxy(void *ptr, std::size_t block_size, std::size_t attention_size) : attention_size_(attention_size), inner_(ptr, block_size) {}$/;"	f	class:lm::ngram::trie::__anon60::PartialViewProxy
PartialViewProxy	HTKLVRec/kenlm/lm/trie_sort.cc	/^class PartialViewProxy {$/;"	c	namespace:lm::ngram::trie::__anon60	file:
PassNGram	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    template <class Iterator> bool PassNGram(const Iterator &begin, const Iterator &end) {$/;"	f	class:lm::phrase::Union
PassNGram	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    template <class Iterator> bool PassNGram(const Iterator &begin, const Iterator &end) {$/;"	f	class:lm::vocab::Single
PassNGram	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    template <class Iterator> bool PassNGram(const Iterator &begin, const Iterator &end) {$/;"	f	class:lm::vocab::Union
Path	HTKLib/HRec.h	/^typedef struct path Path;          \/* Traceback route *\/$/;"	t	typeref:struct:path
PathOf	HTKLib/HShell.c	/^char * PathOf(char *fn, char *s)$/;"	f
Paths2Lat	HTKLVRec/HLVRec-traceback.c	/^static void Paths2Lat (DecoderInst *dec, Lattice *lat, WordendHyp *path,$/;"	f	file:
Payload	HTKLVRec/kenlm/lm/builder/ngram.hh	/^union Payload {$/;"	u	namespace:lm::builder
PeekSize	HTKLVRec/kenlm/util/stream/sort.hh	/^    uint64_t PeekSize() const {$/;"	f	class:util::stream::Offsets
Perturb	HTKLib/HTrain.c	/^static void Perturb(int n, int n1, int n2)$/;"	f	file:
PerturbMean	HTKTools/HHEd.c	/^void PerturbMean(Vector mean, Vector covar, float pertDepth) $/;"	f
PhoneMEE	HTKLib/HExactMPE.c	/^static Boolean PhoneMEE = TRUE;  \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
PhoneMEE	HTKLib/HFBLat.c	/^static Boolean PhoneMEE = TRUE;      \/*IMPORTANT*\/           \/* If true and the MPE routines are called, do MPE, else MWE (word level) *\/$/;"	v	file:
PhoneMEEUseContext	HTKLib/HFBLat.c	/^static Boolean PhoneMEEUseContext = FALSE;                  \/*Compare phones-in-context.  I doubt you would want this true, anyway it makes little difference.*\/$/;"	v	file:
Pipeline	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^void Pipeline(PipelineConfig &config, int text_file, Output &output) {$/;"	f	namespace:lm::builder
PipelineConfig	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^struct PipelineConfig {$/;"	s	namespace:lm::builder
Pivot32	HTKLVRec/kenlm/util/sorted_uniform.hh	/^struct Pivot32 {$/;"	s	namespace:util
Pivot64	HTKLVRec/kenlm/util/sorted_uniform.hh	/^struct Pivot64 {$/;"	s	namespace:util
PivotSelect	HTKLVRec/kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<2> { typedef Pivot32 T; };$/;"	s	namespace:util
PivotSelect	HTKLVRec/kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<4> { typedef Pivot32 T; };$/;"	s	namespace:util
PivotSelect	HTKLVRec/kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<8> { typedef Pivot64 T; };$/;"	s	namespace:util
PlayAudio	HTKLib/HAudio.c	/^static void PlayAudio(AudioOut a, short *buf, int nSamples)$/;"	f	file:
PlayLabel	HTKTools/HSLab.c	/^void PlayLabel(int x)$/;"	f
PlayReplayBuffer	HTKLib/HAudio.c	/^void PlayReplayBuffer(AudioOut ao, AudioIn ai)$/;"	f
Playback	HTKTools/HSLab.c	/^void Playback(Wave w, long sampA, long sampB, int vol, int scale, Boolean *newData)$/;"	f
PlotFileWin	HTKTools/HSLab.c	/^void PlotFileWin(void)$/;"	f
PlotGStripes	HTKTools/HSLab.c	/^void PlotGStripes(int x, int y, int width, int height)$/;"	f
PlotLabWin	HTKTools/HSLab.c	/^void PlotLabWin(void)$/;"	f
PlotLabels	HTKTools/HSLab.c	/^void PlotLabels(RectWin *win, LabList *ll, long sStart, long sEnd)$/;"	f
PlotWaveForm	HTKTools/HSLab.c	/^void PlotWaveForm(RectWin *win, int st_pt, int en_pt)$/;"	f
PlotWaveWin	HTKTools/HSLab.c	/^void PlotWaveWin(void)$/;"	f
PlotWaveWinPtr	HTKTools/HSLab.c	/^void PlotWaveWinPtr(int pos)$/;"	f
PlusCompare	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^int Bignum::PlusCompare(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:double_conversion::Bignum
PlusEqual	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static bool PlusEqual(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:double_conversion::Bignum
PlusLess	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static bool PlusLess(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:double_conversion::Bignum
PlusLessEqual	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static bool PlusLessEqual(const Bignum& a, const Bignum& b, const Bignum& c) {$/;"	f	class:double_conversion::Bignum
Point2Sample	HTKTools/HSLab.c	/^long Point2Sample(RectWin *win, int pt)$/;"	f
Poison	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    void Poison() { stream_.Poison(); }$/;"	f	class:lm::builder::NGramStream
Poison	HTKLVRec/kenlm/util/stream/chain.cc	/^void Link::Poison() {$/;"	f	class:util::stream::Link
Poison	HTKLVRec/kenlm/util/stream/stream.hh	/^    void Poison() {$/;"	f	class:util::stream::Stream
Pool	HTKLVRec/kenlm/util/pool.cc	/^Pool::Pool() {$/;"	f	class:util::Pool
Pool	HTKLVRec/kenlm/util/pool.hh	/^class Pool {$/;"	c	namespace:util
Pop	HTKLVRec/kenlm/util/stream/sort.hh	/^    void Pop() {$/;"	f	class:util::stream::MergeQueue
PopFront	HTKLVRec/kenlm/lm/trie_sort.cc	/^    void PopFront() {$/;"	f	class:lm::ngram::trie::__anon61::Closer
Populate	HTKLVRec/kenlm/lm/quantize.hh	/^        float *Populate() { return begin_; }$/;"	f	class:lm::ngram::SeparatelyQuantize::Bins
PopulateUnigramWeights	HTKLVRec/kenlm/lm/search_trie.cc	/^void PopulateUnigramWeights(FILE *file, WordIndex unigram_count, RecordReader &contexts, UnigramValue *unigrams) {$/;"	f	namespace:lm::ngram::trie::__anon58
PositiveProbWarn	HTKLVRec/kenlm/lm/read_arpa.hh	/^    PositiveProbWarn() : action_(THROW_UP) {}$/;"	f	class:lm::PositiveProbWarn
PositiveProbWarn	HTKLVRec/kenlm/lm/read_arpa.hh	/^    explicit PositiveProbWarn(WarningAction action) : action_(action) {}$/;"	f	class:lm::PositiveProbWarn
PositiveProbWarn	HTKLVRec/kenlm/lm/read_arpa.hh	/^class PositiveProbWarn {$/;"	c	namespace:lm
PowerSizeCommand	HTKTools/HHEd.c	/^void PowerSizeCommand(void)$/;"	f
PowersOfTenCache	HTKLVRec/kenlm/util/double-conversion/cached-powers.h	/^class PowersOfTenCache {$/;"	c	namespace:double_conversion
PrBar	HTKTools/HList.c	/^void PrBar(char *title)$/;"	f
PrLog	HTKLib/HFB.c	/^void PrLog(LogDouble x)$/;"	f
PrModelName	HTKTools/HParse.c	/^static void PrModelName(Link p)$/;"	f	file:
PrVInfo	HTKLib/HShell.c	/^static void PrVInfo(char *s,char *sccs)$/;"	f	file:
PreComp	HTKLib/HRec.c	/^PreComp;$/;"	t	typeref:struct:precomp	file:
PreComp	HTKLib/HTrain.h	/^} PreComp;$/;"	t	typeref:struct:__anon167
PreEmphasise	HTKLib/HSigP.c	/^void PreEmphasise (Vector s, float k)$/;"	f
PrecomputeTMix	HTKLib/HModel.c	/^void PrecomputeTMix(HMMSet *hset, Observation *x, float tmThresh, int topM)$/;"	f
PrefixOrder	HTKLVRec/kenlm/lm/builder/sort.hh	/^    explicit PrefixOrder(std::size_t order) : Comparator<PrefixOrder>(order) {}$/;"	f	class:lm::builder::PrefixOrder
PrefixOrder	HTKLVRec/kenlm/lm/builder/sort.hh	/^class PrefixOrder : public Comparator<PrefixOrder> {$/;"	c	namespace:lm::builder
PreparePlot	HTKTools/HSLab.c	/^void PreparePlot(RectWin *win, short *data, int st, int en)$/;"	f
PreviousDouble	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  double PreviousDouble() const {$/;"	f	class:double_conversion::Double
Print	HTKLVRec/kenlm/lm/builder/print.hh	/^    explicit Print(const VocabReconstitute &vocab, int fd) : vocab_(vocab), to_(fd) {}$/;"	f	class:lm::builder::Print
Print	HTKLVRec/kenlm/lm/builder/print.hh	/^template <class V> class Print {$/;"	c	namespace:lm::builder
PrintARPA	HTKLVRec/kenlm/lm/builder/print.hh	/^    explicit PrintARPA(int fd, bool verbose_header)$/;"	f	class:lm::builder::PrintARPA
PrintARPA	HTKLVRec/kenlm/lm/builder/print.hh	/^class PrintARPA : public OutputHook {$/;"	c	namespace:lm::builder
PrintAlignBestInfo	HTKLVRec/HDecode.c	/^void PrintAlignBestInfo (DecoderInst *dec, BestInfo *b)$/;"	f
PrintAlignBestInfo	HTKLVRec/HDecode.mod.c	/^void PrintAlignBestInfo (DecoderInst *dec, BestInfo *b)$/;"	f
PrintAllHeapStats	HTKLib/HMem.c	/^void PrintAllHeapStats(void)$/;"	f
PrintArc	HTKLib/HArc.c	/^void PrintArc(FILE *f, HArc *a){$/;"	f
PrintArcInfo	HTKLib/HArc.c	/^void PrintArcInfo(FILE *f, ArcInfo *ai){$/;"	f
PrintArcs	HTKLib/HArc.c	/^void PrintArcs(FILE *f, HArc *a){$/;"	f
PrintBar	HTKTools/HResults.c	/^void PrintBar(int offset, int width, char c, char *title)$/;"	f
PrintBaseClass	HTKTools/HHEd.c	/^void PrintBaseClass(FILE *f, RegTree *t, int nNodes, char *bname) $/;"	f
PrintChain	HTKLib/HNet.c	/^static void PrintChain(Network *wnet,HMMSet *hset)$/;"	f	file:
PrintChain	HTKTools/HParse.c	/^void PrintChain(Link chain)$/;"	f
PrintConfig	HTKLib/HShell.c	/^void PrintConfig(void)$/;"	f
PrintContexts	HTKTools/HLEd.c	/^void PrintContexts(void)$/;"	f
PrintCriteria	HTKTools/HMMIRest.c	/^void PrintCriteria(){$/;"	f
PrintDataBar	HTKTools/HList.c	/^void PrintDataBar(long st, long en)$/;"	f
PrintFields	HLMTools/LGPrep.c	/^void PrintFields(FieldVec *fl)$/;"	f
PrintFileStats	HTKTools/HResults.c	/^void PrintFileStats(char *fn, int h, int d, int s, int i)$/;"	f
PrintGlobalStats	HTKTools/HResults.c	/^void PrintGlobalStats(void)$/;"	f
PrintHMMProfile	HTKLib/HModel.c	/^void PrintHMMProfile(FILE *f, HLink hmm)$/;"	f
PrintHParseNetwork	HTKTools/HParse.c	/^static void PrintHParseNetwork(HPNetwork *network)$/;"	f	file:
PrintHSetProfile	HTKLib/HModel.c	/^void PrintHSetProfile(FILE *f, HMMSet *hset)$/;"	f
PrintHashTabStats	HLMLib/LUtil.c	/^void PrintHashTabStats(HashTab *htab)$/;"	f
PrintHashUsage	HTKLib/HModel.c	/^static void PrintHashUsage(FILE *f, HMMSet *hset)$/;"	f	file:
PrintHeader	HTKTools/HResults.c	/^void PrintHeader(void)$/;"	f
PrintHeading	HTKTools/HList.c	/^void PrintHeading(HeadInfo h)$/;"	f
PrintHeapStats	HTKLib/HMem.c	/^void PrintHeapStats(MemHeap *x)$/;"	f
PrintIdList	HTKTools/HDMan.c	/^void PrintIdList(LabId *i)$/;"	f
PrintIdList	HTKTools/HLEd.c	/^void PrintIdList(LabId *i)$/;"	f
PrintInfo	HLMTools/LPlex.c	/^static void PrintInfo(PStats *ps, Boolean showOOV)$/;"	f	file:
PrintInitialInfo	HTKTools/HInit.c	/^void PrintInitialInfo(void)$/;"	f
PrintInitialInfo	HTKTools/HRest.c	/^void PrintInitialInfo(void)$/;"	f
PrintKeySpots	HTKTools/HResults.c	/^void PrintKeySpots(void)$/;"	f
PrintLMHashStats	HTKLVRec/HLVLM.c	/^void PrintLMHashStats(FSLM *lm)$/;"	f
PrintLabel	HTKLib/HLabel.c	/^static void PrintLabel(LLink p, int maxAux)$/;"	f	file:
PrintLinkSet	HTKTools/HParse.c	/^static void PrintLinkSet(int n, LinkSet *p)$/;"	f	file:
PrintLinks	HTKLib/HNet.c	/^static void PrintLinks(NetLink *links,int nlinks)$/;"	f	file:
PrintList	HTKLib/HLabel.c	/^static void PrintList(LabList *ll)$/;"	f	file:
PrintLog	HTKTools/HDMan.c	/^void PrintLog(void)$/;"	f
PrintLog	HTKTools/HSmooth.c	/^void PrintLog(LogDouble x)$/;"	f
PrintModPath	HTKLVRec/HLVRec-traceback.c	/^void PrintModPath (DecoderInst *dec, ModendHyp *m)$/;"	f
PrintMsg	HTKTools/HSLab.c	/^void PrintMsg(RectWin *win, char *msg)$/;"	f
PrintNBar	HTKTools/HResults.c	/^void PrintNBar(int width, char c, char left, char right)$/;"	f
PrintNGBuffer	HLMLib/LGBase.c	/^void PrintNGBuffer(NGBuffer *ngb)$/;"	f
PrintNGram	HLMLib/LGBase.c	/^void PrintNGram(int N, NGram ng, WordMap *wm)$/;"	f
PrintNMargin	HTKTools/HResults.c	/^void PrintNMargin(void)$/;"	f
PrintNameTabStats	HTKLib/HLabel.c	/^void PrintNameTabStats(void)$/;"	f
PrintNode	HTKLib/HNet.c	/^static void PrintNode(NetNode *node,HMMSet *hset)$/;"	f	file:
PrintNode	HTKTools/HParse.c	/^static void PrintNode(Link p)$/;"	f	file:
PrintNodeInfo	HTKTools/HHEd.c	/^void PrintNodeInfo(RNode *n, int vSize) $/;"	f
PrintObsFmt	HTKTools/HList.c	/^void PrintObsFmt(Observation *o)$/;"	f
PrintObservation	HTKLib/HParm.c	/^void PrintObservation(int i, Observation *o, int itemsPerLine)$/;"	f
PrintPDEstats	HTKLib/HModel.c	/^void PrintPDEstats()$/;"	f
PrintPath	HTKLVRec/HLVRec-traceback.c	/^static void PrintPath (DecoderInst *dec, WordendHyp *we)$/;"	f	file:
PrintPayload	HTKLVRec/kenlm/lm/builder/print.hh	/^template <> inline void PrintPayload<ProbBackoff>(util::FakeOFStream &to, const Payload &payload) {$/;"	f	namespace:lm::builder
PrintPayload	HTKLVRec/kenlm/lm/builder/print.hh	/^template <> inline void PrintPayload<Uninterpolated>(util::FakeOFStream &to, const Payload &payload) {$/;"	f	namespace:lm::builder
PrintPayload	HTKLVRec/kenlm/lm/builder/print.hh	/^template <> inline void PrintPayload<uint64_t>(util::FakeOFStream &to, const Payload &payload) {$/;"	f	namespace:lm::builder
PrintROCInfo	HTKTools/HResults.c	/^void PrintROCInfo(int kn)$/;"	f
PrintRawVec	HTKTools/HList.c	/^void PrintRawVec(Vector v)$/;"	f
PrintRegTree	HTKTools/HHEd.c	/^void PrintRegTree(FILE *f, RegTree *t, int nNodes, char* rname, char* bname) $/;"	f
PrintRelTok	HTKLVRec/HLVRec-traceback.c	/^static void PrintRelTok(DecoderInst *dec, RelToken *tok)$/;"	f	file:
PrintRuleSet	HLMTools/LGPrep.c	/^void PrintRuleSet(RuleSet *rset)$/;"	f
PrintScript	HTKTools/HDMan.c	/^void PrintScript(char *name, DBuffer *db)$/;"	f
PrintScript	HTKTools/HLEd.c	/^void PrintScript(char *scriptFN)$/;"	f
PrintSettings	HTKTools/HLStats.c	/^void PrintSettings(void)$/;"	f
PrintSpkrStats	HTKTools/HResults.c	/^void PrintSpkrStats(void)$/;"	f
PrintSpotList	HTKTools/HResults.c	/^void PrintSpotList(SpotRec *p)$/;"	f
PrintState_lv	HTKLVRec/HLVModel.c	/^void PrintState_lv (StateInfo_lv *si,  unsigned short s)$/;"	f
PrintStatistics	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^void PrintStatistics(const std::vector<uint64_t> &counts, const std::vector<uint64_t> &counts_pruned, const std::vector<Discount> &discounts) {$/;"	f	namespace:lm::builder::__anon47
PrintStats	HTKTools/HERest.c	/^void PrintStats(HMMSet *hset,FILE *f, int n, HLink hmm, int numEgs)$/;"	f
PrintStats	HTKTools/HMMIRest.c	/^void PrintStats(FILE *f, int n, HLink hmm, int numEgs)$/;"	f
PrintStats	HTKTools/HParse.c	/^void PrintStats(void)$/;"	f
PrintStats	HTKTools/HSmooth.c	/^void PrintStats(FILE *f, int n, HLink hmm, int numEgs)$/;"	f
PrintStdOpts	HTKLib/HShell.c	/^void PrintStdOpts(char *opt)$/;"	f
PrintTok	HTKLVRec/HLVRec-traceback.c	/^static void PrintTok(DecoderInst *dec, Token *tok)$/;"	f	file:
PrintTokSet	HTKLVRec/HLVRec-traceback.c	/^static void PrintTokSet (DecoderInst *dec, TokenSet *ts)$/;"	f	file:
PrintTotalAccessStats	HLMLib/LModel.c	/^void PrintTotalAccessStats(FILE *f,BackOffLM *lm)$/;"	f
PrintTrace	HTKTools/HCopy.c	/^void PrintTrace(void)$/;"	f
PrintTranscription	HTKLib/HLabel.c	/^void PrintTranscription(Transcription *t, char *title)$/;"	f
PrintTree	HTKLib/HVQ.c	/^static void PrintTree(VQNode n, CovKind ck)$/;"	f	file:
PrintUsage	HTKLVRec/kenlm/util/usage.cc	/^void PrintUsage(std::ostream &out) {$/;"	f	namespace:util
PrintUsage	HTKTools/HDMan.c	/^void PrintUsage(DBuffer *db)$/;"	f
PrintVBounds	HTKTools/HLEd.c	/^void PrintVBounds(void)$/;"	f
PrintVQTab	HTKLib/HVQ.c	/^void PrintVQTab(VQTable vqTab)$/;"	f
PrintWBounds	HTKTools/HLEd.c	/^void PrintWBounds(void)$/;"	f
PrintWaveLine	HTKTools/HList.c	/^void PrintWaveLine(short *data, int nItems, long idx)$/;"	f
PrintWord	HTKTools/HSGen.c	/^void PrintWord(NodeId n)$/;"	f
PriorK	HTKTools/HMMIRest.c	/^static float PriorK = 0.0;           \/* e.g. use 1 if disc. trained prior model is better than ML trained new model.  *\/$/;"	v	file:
PriorTau	HTKTools/HMMIRest.c	/^static float PriorTau = 0.0;         \/* tau value [e.g. 10,25] for use in discriminative MAP with -Hprior option. *\/$/;"	v	file:
PriorTauTrans	HTKTools/HMMIRest.c	/^static float PriorTauTrans = 0.0;$/;"	v	file:
PriorTauWeights	HTKTools/HMMIRest.c	/^static float PriorTauWeights = 0.0;$/;"	v	file:
Prob	HTKLVRec/kenlm/lm/quantize.hh	/^        float Prob() const {$/;"	f	class:lm::ngram::DontQuantize::LongestPointer
Prob	HTKLVRec/kenlm/lm/quantize.hh	/^        float Prob() const {$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
Prob	HTKLVRec/kenlm/lm/quantize.hh	/^        float Prob() const {$/;"	f	class:lm::ngram::SeparatelyQuantize::LongestPointer
Prob	HTKLVRec/kenlm/lm/quantize.hh	/^        float Prob() const {$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
Prob	HTKLVRec/kenlm/lm/search_hashed.hh	/^    float Prob() const {$/;"	f	class:lm::ngram::detail::LongestPointer
Prob	HTKLVRec/kenlm/lm/trie.hh	/^    float Prob() const { return to_->prob; }$/;"	f	class:lm::ngram::trie::UnigramPointer
Prob	HTKLVRec/kenlm/lm/value.hh	/^    float Prob() const { return to_->prob; }$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
Prob	HTKLVRec/kenlm/lm/value.hh	/^    float Prob() const {$/;"	f	class:lm::ngram::GenericProbingProxy
Prob	HTKLVRec/kenlm/lm/weights.hh	/^struct Prob {$/;"	s	namespace:lm
Prob2Shrt	HLMLib/LModel.c	/^static UShort Prob2Shrt(float f)$/;"	f	file:
ProbBackoff	HTKLVRec/kenlm/lm/weights.hh	/^struct ProbBackoff {$/;"	s	namespace:lm
ProbBins	HTKLVRec/kenlm/lm/quantize.hh	/^        const Bins &ProbBins() const { return bins_[0]; }$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
ProbEntry	HTKLVRec/kenlm/lm/search_hashed.hh	/^struct ProbEntry {$/;"	s	namespace:lm::ngram::detail
ProbPointer	HTKLVRec/kenlm/lm/search_trie.cc	/^struct ProbPointer {$/;"	s	namespace:lm::ngram::trie::__anon58	file:
ProbingEntry	HTKLVRec/kenlm/lm/value.hh	/^  struct ProbingEntry {$/;"	s	struct:lm::ngram::BackoffValue
ProbingEntry	HTKLVRec/kenlm/lm/value.hh	/^  struct ProbingEntry {$/;"	s	struct:lm::ngram::RestValue
ProbingHashTable	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    ProbingHashTable() : entries_(0)$/;"	f	class:util::ProbingHashTable
ProbingHashTable	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    ProbingHashTable(void *start, std::size_t allocated, const Key &invalid = Key(), const Hash &hash_func = Hash(), const Equal &equal_func = Equal())$/;"	f	class:util::ProbingHashTable
ProbingHashTable	HTKLVRec/kenlm/util/probing_hash_table.hh	/^template <class EntryT, class HashT, class EqualT = std::equal_to<typename EntryT::Key> > class ProbingHashTable {$/;"	c	namespace:util
ProbingProxy	HTKLVRec/kenlm/lm/value.hh	/^      ProbingProxy() {}$/;"	f	class:lm::ngram::BackoffValue::ProbingProxy
ProbingProxy	HTKLVRec/kenlm/lm/value.hh	/^      ProbingProxy() {}$/;"	f	class:lm::ngram::RestValue::ProbingProxy
ProbingProxy	HTKLVRec/kenlm/lm/value.hh	/^      explicit ProbingProxy(const Weights &to) : GenericProbingProxy<RestWeights>(to) {}$/;"	f	class:lm::ngram::RestValue::ProbingProxy
ProbingProxy	HTKLVRec/kenlm/lm/value.hh	/^      explicit ProbingProxy(const Weights &to) : GenericProbingProxy<Weights>(to) {}$/;"	f	class:lm::ngram::BackoffValue::ProbingProxy
ProbingProxy	HTKLVRec/kenlm/lm/value.hh	/^  class ProbingProxy : public GenericProbingProxy<RestWeights> {$/;"	c	struct:lm::ngram::RestValue
ProbingProxy	HTKLVRec/kenlm/lm/value.hh	/^  class ProbingProxy : public GenericProbingProxy<Weights> {$/;"	c	struct:lm::ngram::BackoffValue
ProbingSizeException	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    ProbingSizeException() throw() {}$/;"	f	class:util::ProbingSizeException
ProbingSizeException	HTKLVRec/kenlm/util/probing_hash_table.hh	/^class ProbingSizeException : public Exception {$/;"	c	namespace:util
ProbingVocabulary	HTKLVRec/kenlm/lm/vocab.cc	/^ProbingVocabulary::ProbingVocabulary() : enumerate_(NULL) {}$/;"	f	class:lm::ngram::ProbingVocabulary
ProbingVocabulary	HTKLVRec/kenlm/lm/vocab.hh	/^class ProbingVocabulary : public base::Vocabulary {$/;"	c	namespace:lm::ngram
ProbingVocabularyEntry	HTKLVRec/kenlm/lm/vocab.hh	/^struct ProbingVocabularyEntry {$/;"	s	namespace:lm::ngram
ProbingVocabularyHeader	HTKLVRec/kenlm/lm/vocab.cc	/^struct ProbingVocabularyHeader {$/;"	s	namespace:lm::ngram::detail	file:
Process	HTKLVRec/kenlm/util/read_compressed.cc	/^    bool Process() {$/;"	f	class:util::__anon79::BZip
Process	HTKLVRec/kenlm/util/read_compressed.cc	/^    bool Process() {$/;"	f	class:util::__anon79::GZip
Process	HTKLVRec/kenlm/util/read_compressed.cc	/^    bool Process() {$/;"	f	class:util::__anon79::XZip
ProcessBiGram	HTKTools/HBuild.c	/^Lattice *ProcessBiGram(MemHeap *latHeap, Vocab *voc, LModel *biLM)$/;"	f
ProcessBoBiGram	HTKTools/HBuild.c	/^Lattice *ProcessBoBiGram(MemHeap *latHeap, Vocab *voc, NGramLM *nLM)$/;"	f
ProcessCrossWordLinks	HTKLib/HNet.c	/^void ProcessCrossWordLinks(MemHeap *heap,Lattice *lat,int xc)$/;"	f
ProcessFile	HTKTools/HVite.c	/^Boolean ProcessFile(char *fn, Network *net, int utterNum, LogDouble currGenBeam, Boolean restartable)$/;"	f
ProcessFiles	HLMTools/LPlex.c	/^static void ProcessFiles()$/;"	f	file:
ProcessFrame	HTKLVRec/HLVRec-propagate.c	/^void ProcessFrame (DecoderInst *dec, Observation **obsBlock, int nObs, $/;"	f
ProcessLabelFile	HLMTools/LPlex.c	/^static void ProcessLabelFile(char *fn, int nSize)$/;"	f	file:
ProcessLabels	HTKTools/HLRescore.c	/^void ProcessLabels (char *labfn)$/;"	f
ProcessLattice	HTKTools/HLRescore.c	/^void ProcessLattice (char *latfn)$/;"	f
ProcessMatBiGram	HTKTools/HBuild.c	/^Lattice *ProcessMatBiGram(MemHeap *latHeap, Vocab *voc, MatBiLM *bg)$/;"	f
ProcessObservation	HTKLib/HRec.c	/^void ProcessObservation(VRecInfo *vri,Observation *obs,int id, AdaptXForm *xform)$/;"	f
ProcessRet	HTKLVRec/kenlm/lm/left.hh	/^    void ProcessRet(const FullScoreReturn &ret) {$/;"	f	class:lm::ngram::RuleScore
ProcessText	HLMTools/LAdapt.c	/^void ProcessText(char *fn, Boolean lastFile)$/;"	f
ProcessText	HLMTools/LGPrep.c	/^void ProcessText(char *fn, Boolean lastFile)$/;"	f
ProcessTextStream	HLMTools/LPlex.c	/^static void ProcessTextStream(char *fn, int nSize)$/;"	f	file:
ProcessWordLoop	HTKTools/HBuild.c	/^Lattice *ProcessWordLoop(MemHeap *latHeap, Vocab *voc)$/;"	f
ProcessWordPair	HTKTools/HBuild.c	/^Lattice *ProcessWordPair(MemHeap *latHeap, Vocab *voc, char *gramFn)$/;"	f
Produce	HTKLVRec/kenlm/util/pcqueue.hh	/^  void Produce(const T &val) {$/;"	f	class:util::PCQueue
Produce	HTKLVRec/kenlm/util/thread_pool.hh	/^    void Produce(const Request &request) {$/;"	f	class:util::ThreadPool
ProgressMessages	HTKLVRec/kenlm/lm/config.hh	/^  std::ostream *ProgressMessages() const {$/;"	f	struct:lm::ngram::Config
ProjectCommand	HTKTools/HHEd.c	/^void ProjectCommand(void)$/;"	f
Pron	HTKLib/HDict.h	/^typedef struct _WordPron  *Pron;$/;"	t	typeref:struct:_WordPron
PronHolder	HTKLib/HNet.c	/^PronHolder;$/;"	t	typeref:struct:pronholder	file:
PronId	HTKLVRec/config.h	/^typedef unsigned int PronId;$/;"	t
Pronunciation	HTKTools/HDMan.c	/^}Pronunciation;$/;"	t	typeref:struct:__anon193	file:
PropIntoNode	HTKLVRec/HLVRec-propagate.c	/^static void PropIntoNode (DecoderInst *dec, TokenSet *ts, LexNode *ln, Boolean updateLMLA)$/;"	f	file:
PropagateExternal	HTKLVRec/HLVRec-propagate.c	/^static void PropagateExternal (DecoderInst *dec, LexNodeInst *inst, $/;"	f	file:
PropagateInternal	HTKLVRec/HLVRec-propagate.c	/^static void PropagateInternal (DecoderInst *dec, LexNodeInst *inst)$/;"	f	file:
ProtectedFillBufferFromAudio	HTKLib/HAudio.c	/^static void ProtectedFillBufferFromAudio(AudioIn a,int min)$/;"	f	file:
ProxyIterator	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    ProxyIterator() {}$/;"	f	class:util::ProxyIterator
ProxyIterator	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    explicit ProxyIterator(const Proxy &p) : p_(p) {}$/;"	f	class:util::ProxyIterator
ProxyIterator	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    template <class AlternateProxy> ProxyIterator(const ProxyIterator<AlternateProxy> &in) : p_(*in) {}$/;"	f	class:util::ProxyIterator
ProxyIterator	HTKLVRec/kenlm/util/proxy_iterator.hh	/^template <class Proxy> class ProxyIterator {$/;"	c	namespace:util
PruneInfo	HTKLib/HFB.h	/^} PruneInfo;$/;"	t	typeref:struct:__anon97
PruneNGramStream	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    PruneNGramStream(const util::stream::ChainPosition &position) :$/;"	f	class:lm::builder::__anon45::PruneNGramStream
PruneNGramStream	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^class PruneNGramStream {$/;"	c	namespace:lm::builder::__anon45	file:
PruneTokSet	HTKLVRec/HLVRec.c	/^static void PruneTokSet (DecoderInst *dec, TokenSet *ts)$/;"	f	file:
Ptr	HTKLib/HMem.h	/^typedef void * Ptr;$/;"	t
PtrMap	HTKLib/HModel.h	/^} PtrMap;$/;"	t	typeref:struct:_PtrMap
PurgeMacros	HTKTools/HHEd.c	/^void PurgeMacros(HMMSet *hset)$/;"	f
Push	HTKLVRec/kenlm/util/stream/sort.hh	/^    void Push(void *base, uint64_t offset, uint64_t amount) {$/;"	f	class:util::stream::MergeQueue
PutAdaptXForm	HTKLib/HModel.c	/^static void PutAdaptXForm(HMMSet *hset, FILE *f, MLink q, AdaptXForm *xform, $/;"	f	file:
PutBaseClass	HTKLib/HModel.c	/^static void PutBaseClass(HMMSet *hset, FILE *f, MLink q, BaseClass *bclass, $/;"	f	file:
PutBias	HTKLib/HModel.c	/^static void PutBias(HMMSet *hset, FILE *f, MLink q, SVector m, $/;"	f	file:
PutCovar	HTKLib/HModel.c	/^static void PutCovar(HMMSet *hset, FILE *f, MLink q, STriMat m,$/;"	f	file:
PutDiscrete	HTKLib/HModel.c	/^void PutDiscrete(FILE *f, StreamElem *se, Boolean binary)$/;"	f
PutDiscreteWeights	HTKLib/HModel.c	/^void PutDiscreteWeights(FILE *f, StreamElem *se, Boolean binary)$/;"	f
PutDuration	HTKLib/HModel.c	/^static void PutDuration(HMMSet *hset, FILE *f, MLink q, SVector v,$/;"	f	file:
PutESIGHeaderInfo	HTKLib/HWave.c	/^void PutESIGHeaderInfo(FILE *f, Wave w)$/;"	f
PutHMMDef	HTKLib/HModel.c	/^static void PutHMMDef(HMMSet *hset, FILE *f, MLink m, Boolean withHdr,$/;"	f	file:
PutHTKHeaderInfo	HTKLib/HWave.c	/^static void PutHTKHeaderInfo(FILE *f, Wave w)$/;"	f	file:
PutInputXForm	HTKLib/HModel.c	/^static void PutInputXForm(HMMSet *hset, FILE *f, MLink q, InputXForm *xf, $/;"	f	file:
PutLab	HTKTools/HLEd.c	/^void PutLab(LabId id)$/;"	f
PutLinXForm	HTKLib/HModel.c	/^static void PutLinXForm(HMMSet *hset, FILE *f, MLink q, LinXForm *xf, $/;"	f	file:
PutMacroHdr	HTKLib/HModel.c	/^static void PutMacroHdr(HMMSet *hset, FILE *f, MLink m, char mType, $/;"	f	file:
PutMean	HTKLib/HModel.c	/^static void PutMean(HMMSet *hset, FILE *f, MLink q, SVector m, $/;"	f	file:
PutMixPDF	HTKLib/HModel.c	/^static void PutMixPDF(HMMSet *hset, FILE *f, MLink q, MixPDF *mp, $/;"	f	file:
PutMixWeight	HTKLib/HModel.c	/^void PutMixWeight(FILE *f, short repeatLast, short w, Boolean binary)$/;"	f
PutOptions	HTKLib/HModel.c	/^static void PutOptions(HMMSet *hset, FILE *f, Boolean binary)$/;"	f	file:
PutPhone	HTKTools/HDMan.c	/^void PutPhone(LabId id)$/;"	f
PutRegNode	HTKLib/HModel.c	/^static void PutRegNode(HMMSet *hset, FILE *f, RegNode *rnode, Boolean binary) $/;"	f	file:
PutRegTree	HTKLib/HModel.c	/^static void PutRegTree(HMMSet *hset, FILE *f, MLink q, RegTree *t, $/;"	f	file:
PutSWeights	HTKLib/HModel.c	/^static void PutSWeights(HMMSet *hset, FILE *f, MLink q, SVector v,$/;"	f	file:
PutShiftRegister	HLMTools/LAdapt.c	/^void PutShiftRegister(LabId id, ShiftReg *sr)$/;"	f
PutShiftRegister	HLMTools/LGPrep.c	/^void PutShiftRegister(LabId id, ShiftReg *sr)$/;"	f
PutStateInfo	HTKLib/HModel.c	/^static void PutStateInfo(HMMSet *hset, FILE *f, MLink q, StateInfo *si, $/;"	f	file:
PutSymbol	HTKLib/HModel.c	/^static void PutSymbol(FILE *f, Symbol sym, Boolean binary)$/;"	f	file:
PutTargetFile	HTKTools/HCopy.c	/^void PutTargetFile(char *s)$/;"	f
PutTiedMixtures	HTKLib/HModel.c	/^void PutTiedMixtures(HMMSet *hset,FILE *f,int s,StreamElem *se,Boolean binary)$/;"	f
PutTiedWeight	HTKLib/HModel.c	/^void PutTiedWeight(FILE *f, short repeatLast, float w, Boolean binary)$/;"	f
PutTiedWeights	HTKLib/HModel.c	/^void PutTiedWeights(FILE *f, StreamElem *se, Boolean binary)$/;"	f
PutTransMat	HTKLib/HModel.c	/^static void PutTransMat(HMMSet *hset, FILE *f, MLink q, SMatrix m,$/;"	f	file:
PutTransform	HTKLib/HModel.c	/^static void PutTransform(HMMSet *hset, FILE *f, MLink q, SMatrix m,$/;"	f	file:
PutVFloor	HTKTools/HCompV.c	/^void PutVFloor(void)$/;"	f
PutVariance	HTKLib/HModel.c	/^static void PutVariance(HMMSet *hset, FILE *f, MLink q, SVector v,$/;"	f	file:
PutWaveSample	HTKLib/HWave.c	/^void PutWaveSample(Wave w, long nSamples, short *buf)$/;"	f
PutXFormSet	HTKLib/HModel.c	/^static void PutXFormSet(HMMSet *hset, FILE *f, MLink q, XFormSet *xformSet, $/;"	f	file:
Q	HTKLib/HArc.h	/^  int Q;       \/*number of unique arcs.. *\/$/;"	m	struct:ArcInfoStruct
Q	HTKLib/HFB.h	/^  int Q;              \/* number of models in transcription *\/$/;"	m	struct:__anon96
Q	HTKLib/HFBLat.h	/^  int Q;$/;"	m	struct:__anon102
Q	HTKLib/esig_asc.c	39;"	d	file:
QEnt	HTKTools/HHEd.c	/^}QEnt;$/;"	t	typeref:struct:_QEnt	file:
QLink	HTKTools/HHEd.c	/^typedef struct _QEnt *QLink;   \/* Linked list of Questions *\/$/;"	t	typeref:struct:_QEnt	file:
QMatch	HTKTools/HHEd.c	/^Boolean QMatch(char *name, QLink q)$/;"	f
QS	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon199	file:
QSCmpArcs	HTKLib/HNet.c	/^static int QSCmpArcs(const void *v1,const void *v2)$/;"	f	file:
QSCmpNodes	HTKLib/HNet.c	/^static int QSCmpNodes(const void *v1,const void *v2)$/;"	f	file:
QUANT_ARRAY_TRIE	HTKLVRec/kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon54
QUANT_ARRAY_TRIE_SORTED	HTKLVRec/kenlm/lm/model_type.hh	/^const ModelType QUANT_ARRAY_TRIE_SORTED = QUANT_ARRAY_TRIE;$/;"	m	namespace:lm::ngram
QUANT_TRIE	HTKLVRec/kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon54
QUANT_TRIE_SORTED	HTKLVRec/kenlm/lm/model_type.hh	/^const ModelType QUANT_TRIE_SORTED = QUANT_TRIE;$/;"	m	namespace:lm::ngram
QUOTE	HTKLib/esig_asc.c	40;"	d	file:
Query	HTKLVRec/kenlm/lm/ngram_query.hh	/^template <class Model, class Printer> void Query(const Model &model, bool sentence_context) {$/;"	f	namespace:lm::ngram
Query	HTKLVRec/kenlm/lm/ngram_query.hh	/^template <class Model> void Query(const char *file, const Config &config, bool sentence_context, bool show_words) {$/;"	f	namespace:lm::ngram
QuestionCommand	HTKTools/HHEd.c	/^void QuestionCommand(void)$/;"	f
Queue	HTKLVRec/kenlm/util/stream/sort.hh	/^    typedef std::priority_queue<Entry, std::vector<Entry>, Greater> Queue;$/;"	t	class:util::stream::MergeQueue
Quinphone	HTKLib/HExactMPE.c	/^static Boolean Quinphone = FALSE; \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
Quinphone	HTKLib/HFBLat.c	/^static Boolean Quinphone = FALSE;            \/* Set this TRUE if this is a quinphone model set.  The code for quinphones depends on the naming conventions $/;"	v	file:
RANDF	HTKLib/HMath.c	1623;"	d	file:
RANDF	HTKLib/HMath.c	1627;"	d	file:
RANGSYM	HTKTools/HParse.c	/^             RBRACESYM, LANGSYM, RANGSYM, LBRAKSYM, RBRAKSYM, $/;"	e	enum:_Symbol	file:
RANLIB	HLMLib/Makefile	/^RANLIB = ranlib$/;"	m
RANLIB	HTKLib/Makefile	/^RANLIB = ranlib$/;"	m
RAWENERGY	HTKLib/HParm.c	/^   RAWENERGY,     \/* Use raw energy *\/$/;"	e	enum:__anon142	file:
RAWMODE	HTKTools/HDMan.c	/^              TCTXT, APPSIL, REMSTRESS, REPLACEW, RAWMODE, $/;"	e	enum:__anon191	file:
RBRACESYM	HTKTools/HParse.c	/^             RBRACESYM, LANGSYM, RANGSYM, LBRAKSYM, RBRAKSYM, $/;"	e	enum:_Symbol	file:
RBRAKSYM	HTKTools/HParse.c	/^             RBRACESYM, LANGSYM, RANGSYM, LBRAKSYM, RBRAKSYM, $/;"	e	enum:_Symbol	file:
RC	HTKTools/HHEd.c	/^                         RC ,$/;"	e	enum:__anon199	file:
RCLASS	HTKLib/HModel.c	/^   RCLASS=110, REGTREE, NODE, TNODE,$/;"	e	enum:__anon117	file:
RCTXT	HTKTools/HDMan.c	/^              LCTXT, RCTXT,$/;"	e	enum:__anon191	file:
RCTXT	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon200	file:
RCtxtOp	HTKTools/HDMan.c	/^void RCtxtOp(WordBuf *wb, int nArgs,LabId *args)$/;"	f
READ	HTKLVRec/kenlm/util/mmap.hh	/^  READ,$/;"	e	enum:util::__anon76
READ_FLOAT	HLMLib/LModel.c	652;"	d	file:
REC_BUF_SIZE	HTKTools/HSLab.c	368;"	d	file:
RED	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
REGTREE	HTKLib/HModel.c	/^   RCLASS=110, REGTREE, NODE, TNODE,$/;"	e	enum:__anon117	file:
RELD	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	e	enum:_DurKind
RELDUR	HTKLib/HModel.c	/^   NDUR, PDUR, GDUR, RELDUR, GENDUR,$/;"	e	enum:__anon117	file:
REMSTRESS	HTKTools/HDMan.c	/^              TCTXT, APPSIL, REMSTRESS, REPLACEW, RAWMODE, $/;"	e	enum:__anon191	file:
REPLACE	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon200	file:
REPLACEP	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon191	file:
REPLACEW	HTKTools/HDMan.c	/^              TCTXT, APPSIL, REMSTRESS, REPLACEW, RAWMODE, $/;"	e	enum:__anon191	file:
REQUIRED	HTKLib/esignal.h	90;"	d
REST_LOWER	HTKLVRec/kenlm/lm/config.hh	/^    REST_LOWER, \/\/ Use lower-order files given below.$/;"	e	enum:lm::ngram::Config::RestFunction
REST_MAX	HTKLVRec/kenlm/lm/config.hh	/^    REST_MAX,   \/\/ Maximum of any score to the left$/;"	e	enum:lm::ngram::Config::RestFunction
REST_PROBING	HTKLVRec/kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon54
RM	HTKTools/HHEd.c	/^                         RO , RM , RN , RP ,$/;"	e	enum:__anon199	file:
RMatch	HTKLib/HShell.c	/^Boolean RMatch(char *s,char *p,int slen,int minplen,int numstars)$/;"	f
RN	HTKTools/HHEd.c	/^                         RO , RM , RN , RP ,$/;"	e	enum:__anon199	file:
RNode	HTKTools/HHEd.c	/^} RNode;$/;"	t	typeref:struct:__anon198	file:
RO	HTKTools/HHEd.c	/^                         RO , RM , RN , RP ,$/;"	e	enum:__anon199	file:
RP	HTKTools/HHEd.c	/^                         RO , RM , RN , RP ,$/;"	e	enum:__anon199	file:
RPARSYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
RT	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon199	file:
RTRISYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
RadixStringToIeee	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^static double RadixStringToIeee(const char* current,$/;"	f	namespace:double_conversion
RandInit	HTKLib/HMath.c	/^void RandInit(int seed)$/;"	f
RandSucc	HTKTools/HSGen.c	/^NodeId RandSucc(NodeId n)$/;"	f
RandomValue	HTKLib/HMath.c	/^float RandomValue(void)$/;"	f
RangeLessBySize	HTKLVRec/kenlm/util/multi_intersection.hh	/^template <class Range> struct RangeLessBySize : public std::binary_function<const Range &, const Range &, bool> {$/;"	s	namespace:util::detail
Raw	HTKLVRec/kenlm/lm/search_hashed.hh	/^        typename Value::Weights *Raw() { return unigram_; }$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Raw	HTKLVRec/kenlm/lm/trie.hh	/^    UnigramValue *Raw() {$/;"	f	class:lm::ngram::trie::Unigram
RawAmount	HTKLVRec/kenlm/util/read_compressed.hh	/^    uint64_t RawAmount() const { return raw_amount_; }$/;"	f	class:util::ReadCompressed
RawReadFloat	HTKLib/HShell.c	/^Boolean RawReadFloat(Source *src, float *x, int n, Boolean bin, Boolean swap)$/;"	f
RawReadInt	HTKLib/HShell.c	/^Boolean RawReadInt(Source *src, int *i, int n, Boolean bin, Boolean swap)$/;"	f
RawReadShort	HTKLib/HShell.c	/^Boolean RawReadShort(Source *src, short *s, int n, Boolean bin, Boolean swap)$/;"	f
ReBase	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    void ReBase(void *to) {$/;"	f	class:lm::builder::NGram
ReEstimateModel	HTKTools/HRest.c	/^void ReEstimateModel(void)$/;"	f
ReFormatTranscription	HTKLVRec/HLVRec.c	/^void ReFormatTranscription(Transcription *trans,HTime frameDur,$/;"	f
ReOrderComponents	HTKLib/HModel.c	/^static void ReOrderComponents(HMMSet *hset)$/;"	f	file:
ReOrderFeaturesCommand	HTKTools/HHEd.c	/^void ReOrderFeaturesCommand()$/;"	f
ReOrderList	HTKLib/HRec.c	/^static void ReOrderList(NetNode *node)$/;"	f	file:
ReSizeNodes	HTKTools/HParse.c	/^static void ReSizeNodes(HPNetwork *net)$/;"	f	file:
ReSortGFList	HLMLib/LGBase.c	/^static void ReSortGFList(NGInputSet *inset)$/;"	f	file:
ReWriteString	HTKLib/HShell.c	/^char *ReWriteString(char *s,char *dst, char q)$/;"	f
Read	HTKLVRec/kenlm/lm/filter/count_io.hh	/^    void Read(std::istream &in) {$/;"	f	class:lm::CountBatch
Read	HTKLVRec/kenlm/util/read_compressed.cc	/^    std::size_t Read(void *, std::size_t, ReadCompressed &) {$/;"	f	class:util::__anon79::Complete
Read	HTKLVRec/kenlm/util/read_compressed.cc	/^    std::size_t Read(void *to, std::size_t amount, ReadCompressed &thunk) {$/;"	f	class:util::__anon79::IStreamReader
Read	HTKLVRec/kenlm/util/read_compressed.cc	/^    std::size_t Read(void *to, std::size_t amount, ReadCompressed &thunk) {$/;"	f	class:util::__anon79::StreamCompressed
Read	HTKLVRec/kenlm/util/read_compressed.cc	/^    std::size_t Read(void *to, std::size_t amount, ReadCompressed &thunk) {$/;"	f	class:util::__anon79::Uncompressed
Read	HTKLVRec/kenlm/util/read_compressed.cc	/^    std::size_t Read(void *to, std::size_t amount, ReadCompressed &thunk) {$/;"	f	class:util::__anon79::UncompressedWithHeader
Read	HTKLVRec/kenlm/util/read_compressed.cc	/^std::size_t ReadCompressed::Read(void *to, std::size_t amount) {$/;"	f	class:util::ReadCompressed
Read	HTKLVRec/kenlm/util/stream/io.hh	/^    explicit Read(int fd) : file_(fd) {}$/;"	f	class:util::stream::Read
Read	HTKLVRec/kenlm/util/stream/io.hh	/^class Read {$/;"	c	namespace:util::stream
Read	HTKLVRec/kenlm/util/stream/sort.hh	/^        bool Read(int fd, std::size_t buf_size) {$/;"	f	class:util::stream::MergeQueue::Entry
Read1Gram	HTKLVRec/kenlm/lm/read_arpa.hh	/^template <class Voc, class Weights> void Read1Gram(util::FilePiece &f, Voc &vocab, Weights *unigrams, PositiveProbWarn &warn) {$/;"	f	namespace:lm
Read1Grams	HTKLVRec/kenlm/lm/read_arpa.hh	/^template <class Voc, class Weights> void Read1Grams(util::FilePiece &f, std::size_t count, Voc &vocab, Weights *unigrams, PositiveProbWarn &warn) {$/;"	f	namespace:lm
ReadARPA	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^template <class Output> void ReadARPA(util::FilePiece &in_lm, Output &out) {$/;"	f	namespace:lm
ReadARPACounts	HTKLVRec/kenlm/lm/read_arpa.cc	/^void ReadARPACounts(util::FilePiece &in, std::vector<uint64_t> &number) {$/;"	f	namespace:lm
ReadARPALM	HTKLVRec/HLVLM.c	/^FSLM *ReadARPALM(MemHeap *heap, char *lmfn, Vocab *vocab)$/;"	f
ReadARPAngram	HTKLVRec/HLVLM.c	/^static void ReadARPAngram (FSLM_ngram *nglm, Source *lmSrc, int n, int count, Boolean bin,$/;"	f	file:
ReadAlign	HTKLib/HNet.c	/^static int ReadAlign(Lattice *lat,LArc *la,char *buf)$/;"	f	file:
ReadAsBuffer	HTKLib/HParm.c	/^Boolean ReadAsBuffer(ParmBuf pbuf, Observation *o)$/;"	f
ReadAsTable	HTKLib/HParm.c	/^void ReadAsTable(ParmBuf pbuf, int index, Observation *o)$/;"	f
ReadAsciiArray	HTKLib/esig_asc.c	/^ReadAsciiArray(Array    *array,$/;"	f	file:
ReadAsciiAxisNames	HTKLib/esig_asc.c	/^ReadAsciiAxisNames(char ***axis_names, int rank, FILE *file)$/;"	f	file:
ReadAsciiData	HTKLib/esig_asc.c	/^ReadAsciiData(FieldSpec *field, FILE *file)$/;"	f	file:
ReadAsciiDims	HTKLib/esig_asc.c	/^ReadAsciiDims(short *rank, long **dim, FILE *file)$/;"	f	file:
ReadAsciiDouble	HTKLib/esig_asc.c	/^ReadAsciiDouble(double *x, FILE *file)$/;"	f	file:
ReadAsciiEscape	HTKLib/esig_asc.c	/^ReadAsciiEscape(unsigned long   *val,$/;"	f	file:
ReadAsciiFieldList	HTKLib/esig_asc.c	/^ReadAsciiFieldList(FieldList    *listp,$/;"	f
ReadAsciiFieldSpec	HTKLib/esig_asc.c	/^ReadAsciiFieldSpec(FieldSpec    **field,$/;"	f	file:
ReadAsciiFieldStruct	HTKLib/esig_asc.c	/^ReadAsciiFieldStruct(FieldSpec  **field,$/;"	f	file:
ReadAsciiMisc	HTKLib/esig_asc.c	/^ReadAsciiMisc(int rank, char **units, double *scale,$/;"	f	file:
ReadAsciiName	HTKLib/esig_asc.c	/^ReadAsciiName(int depth, char **names, FILE *file)$/;"	f	file:
ReadAsciiNewline	HTKLib/esig_asc.c	/^ReadAsciiNewline(FILE *file)$/;"	f	file:
ReadAsciiOccurrence	HTKLib/esig_asc.c	/^ReadAsciiOccurrence(short *occurrence, FILE *file)$/;"	f	file:
ReadAsciiRecord	HTKLib/esig_asc.c	/^ReadAsciiRecord(FieldSpec **fields,$/;"	f
ReadAsciiSamples	HTKLib/esig_asc.c	/^ReadAsciiSamples(void       *data,$/;"	f
ReadAsciiString	HTKLib/esig_asc.c	/^ReadAsciiString(char **string, FILE *file)$/;"	f	file:
ReadAsciiType	HTKLib/esig_asc.c	/^ReadAsciiType(short *type, FILE *file)$/;"	f	file:
ReadAudio	HTKLib/HAudio.c	/^static void ReadAudio(AudioIn a, short *buf, int nSamples)$/;"	f	file:
ReadBackoff	HTKLVRec/kenlm/lm/read_arpa.cc	/^void ReadBackoff(util::FilePiece &in, Prob &\/*weights*\/) {$/;"	f	namespace:lm
ReadBackoff	HTKLVRec/kenlm/lm/read_arpa.cc	/^void ReadBackoff(util::FilePiece &in, float &backoff) {$/;"	f	namespace:lm
ReadBackoff	HTKLVRec/kenlm/lm/read_arpa.hh	/^inline void ReadBackoff(util::FilePiece &in, ProbBackoff &weights) {$/;"	f	namespace:lm
ReadBackoff	HTKLVRec/kenlm/lm/read_arpa.hh	/^inline void ReadBackoff(util::FilePiece &in, RestWeights &weights) {$/;"	f	namespace:lm
ReadBase	HTKLVRec/kenlm/util/read_compressed.cc	/^class ReadBase {$/;"	c	namespace:util	file:
ReadBoNGram	HTKLib/HLM.c	/^static void ReadBoNGram(LModel *lm,char *fn)$/;"	f	file:
ReadCh	HTKLib/HUtil.c	/^static void ReadCh(void)$/;"	f	file:
ReadChanFiles	HTKLib/HParm.c	/^static ReturnStatus ReadChanFiles(ChannelInfo *chan)$/;"	f	file:
ReadClassCounts	HLMLib/LModel.c	/^static void ReadClassCounts(Source *src, int nWords, BackOffLM *lm)$/;"	f	file:
ReadClassProbs	HLMLib/LModel.c	/^static void ReadClassProbs(Source *src, int nWords, BackOffLM *lm)$/;"	f	file:
ReadClassProbsHeader	HLMLib/LModel.c	/^static void ReadClassProbsHeader(char *fname, int *nWords, Source *src, BackOffLM *lm)$/;"	f	file:
ReadCmd	HTKTools/HDMan.c	/^EdOp ReadCmd(Source *src)$/;"	f
ReadCmd	HTKTools/HLEd.c	/^EdOp ReadCmd(Source *src)$/;"	f
ReadCompressed	HTKLVRec/kenlm/util/read_compressed.cc	/^ReadCompressed::ReadCompressed() {}$/;"	f	class:util::ReadCompressed
ReadCompressed	HTKLVRec/kenlm/util/read_compressed.cc	/^ReadCompressed::ReadCompressed(int fd) {$/;"	f	class:util::ReadCompressed
ReadCompressed	HTKLVRec/kenlm/util/read_compressed.cc	/^ReadCompressed::ReadCompressed(std::istream &in) {$/;"	f	class:util::ReadCompressed
ReadCompressed	HTKLVRec/kenlm/util/read_compressed.hh	/^class ReadCompressed {$/;"	c	namespace:util
ReadConfName	HTKLib/HShell.c	/^static Boolean ReadConfName(Source *src, char *s)$/;"	f	file:
ReadConfigFile	HTKLib/HShell.c	/^static ReturnStatus ReadConfigFile(char *fname)$/;"	f	file:
ReadCount	HTKLVRec/kenlm/lm/filter/count_io.hh	/^template <class Output> void ReadCount(util::FilePiece &in_file, Output &out) {$/;"	f	namespace:lm
ReadCount	HTKLVRec/kenlm/lm/read_arpa.cc	/^uint64_t ReadCount(const std::string &from) {$/;"	f	namespace:lm::__anon56
ReadCount	HTKLVRec/kenlm/util/read_compressed.cc	/^    static uint64_t &ReadCount(ReadCompressed &thunk) {$/;"	f	class:util::ReadBase
ReadDelimited	HTKLVRec/kenlm/util/file_piece.hh	/^    StringPiece ReadDelimited(const bool *delim = kSpaces) {$/;"	f	class:util::FilePiece
ReadDict	HTKLib/HDict.c	/^ReturnStatus ReadDict(char *dictFn, Vocab *voc)$/;"	f
ReadDictProns	HTKTools/HDMan.c	/^Boolean ReadDictProns(DBuffer *db)$/;"	f
ReadDictWord	HTKLib/HDict.c	/^ReturnStatus ReadDictWord(Source *src,LabId *labels,float *prob, int *num)$/;"	f
ReadDiyFp	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static void ReadDiyFp(Vector<const char> buffer,$/;"	f	namespace:double_conversion
ReadDouble	HTKLVRec/kenlm/util/file_piece.cc	/^double FilePiece::ReadDouble() {$/;"	f	class:util::FilePiece
ReadESIGPHeader	HTKLib/HParm.c	/^Boolean ReadESIGPHeader(FILE *f, long *nSamp, long *sampP, short *sampS,$/;"	f
ReadEdrArray	HTKLib/esig_edr.c	/^ReadEdrArray(Array  *array,$/;"	f	file:
ReadEdrData	HTKLib/esig_edr.c	/^ReadEdrData(FieldSpec *field,$/;"	f	file:
ReadEdrFieldList	HTKLib/esig_edr.c	/^ReadEdrFieldList(FieldList  *listp,  \/* output variable *\/$/;"	f
ReadEdrFieldSpec	HTKLib/esig_edr.c	/^ReadEdrFieldSpec(FILE   *file,$/;"	f	file:
ReadEdrRecord	HTKLib/esig_edr.c	/^ReadEdrRecord(FieldSpec **fields,$/;"	f
ReadEdrSamples	HTKLib/esig_edr.c	/^ReadEdrSamples(void         *data,$/;"	f
ReadEdrString	HTKLib/esig_edr.c	/^ReadEdrString(char  **string,$/;"	f	file:
ReadEnd	HTKLVRec/kenlm/lm/read_arpa.cc	/^void ReadEnd(util::FilePiece &in) {$/;"	f	namespace:lm
ReadEntry	HTKLVRec/kenlm/lm/trie.hh	/^    util::BitAddress ReadEntry(uint64_t pointer, NodeRange &range) {$/;"	f	class:lm::ngram::trie::BitPackedMiddle
ReadEsignalHeader	HTKLib/HWave.c	/^Boolean ReadEsignalHeader(FILE *f, long *nSamp, long *sampP, short *sampS,$/;"	f
ReadFactory	HTKLVRec/kenlm/util/read_compressed.cc	/^ReadBase *ReadFactory(int fd, uint64_t &raw_amount, const void *already_data, const std::size_t already_size, bool require_compressed) {$/;"	f	namespace:util::__anon79
ReadFieldList	HTKLib/esignal.c	/^ReadFieldList(FieldList *list,$/;"	f
ReadFloat	HTKLVRec/kenlm/util/file_piece.cc	/^float FilePiece::ReadFloat() {$/;"	f	class:util::FilePiece
ReadFloat	HTKLib/HShell.c	/^Boolean ReadFloat(Source *src, float *x, int n, Boolean binary)$/;"	f
ReadFloat32	HTKLVRec/kenlm/util/bit_packing.hh	/^inline float ReadFloat32(const void *base, uint64_t bit_off) {$/;"	f	namespace:util
ReadFoFTab	HLMLib/LGBase.c	/^FoFTab *ReadFoFTab(MemHeap *mem, char *fn)$/;"	f
ReadForConfig	HTKLVRec/kenlm/lm/binary_format.cc	/^void BinaryFormat::ReadForConfig(void *to, std::size_t amount, uint64_t offset_excluding_header) const {$/;"	f	class:lm::ngram::BinaryFormat
ReadHGram	HLMLib/LGBase.c	/^static void ReadHGram(char *name, LMFileHdr hdr, int N, LabId *ng, char *fn)$/;"	f	file:
ReadHMMList	HTKTools/HResults.c	/^void ReadHMMList(char *fn)$/;"	f
ReadHTKHeader	HTKLib/HWave.c	/^Boolean ReadHTKHeader(FILE *f, long *nSamp, long *sampP, short *sampS, $/;"	f
ReadHeader	HTKLVRec/kenlm/lm/binary_format.cc	/^void ReadHeader(int fd, Parameters &out) {$/;"	f	namespace:lm::ngram
ReadHeader	HTKLib/esignal.c	/^ReadHeader(char     **version,  \/* version (output) *\/$/;"	f
ReadHeaderInfo	HLMLib/LModel.c	/^void ReadHeaderInfo(Source *src, BackOffLM *lm, char *line1)$/;"	f
ReadIOConfig	HTKLib/HParm.c	/^static IOConfig ReadIOConfig(IOConfig p)$/;"	f	file:
ReadIdList	HTKTools/HDMan.c	/^int ReadIdList(Source *src, LabId *argList)$/;"	f
ReadIdList	HTKTools/HLEd.c	/^int ReadIdList(Source *src,LabId *argList)$/;"	f
ReadInput	HTKLVRec/kenlm/util/read_compressed.cc	/^    void ReadInput(ReadCompressed &thunk) {$/;"	f	class:util::__anon79::StreamCompressed	file:
ReadInt	HTKLib/HShell.c	/^Boolean ReadInt(Source *src, int *i, int n, Boolean binary)$/;"	f
ReadInt25	HTKLVRec/kenlm/util/bit_packing.hh	/^inline uint32_t ReadInt25(const void *base, uint64_t bit_off, uint8_t length, uint32_t mask) {$/;"	f	namespace:util
ReadInt57	HTKLVRec/kenlm/util/bit_packing.hh	/^inline uint64_t ReadInt57(const void *base, uint64_t bit_off, uint8_t length, uint64_t mask) {$/;"	f	namespace:util
ReadIntVec	HTKLib/HMath.c	/^Boolean ReadIntVec(Source *src, IntVec v, Boolean binary)$/;"	f
ReadLMHeader	HLMLib/LUtil.c	/^LMHdrKind ReadLMHeader(MemHeap *mem, Source *src, IOFilter filter,$/;"	f
ReadLMWord	HTKLib/HLM.c	/^static char *ReadLMWord(char *buf)$/;"	f	file:
ReadLModel	HTKLib/HLM.c	/^LModel *ReadLModel(MemHeap *heap,char *fn)$/;"	f
ReadLabId	HTKTools/HLEd.c	/^LabId ReadLabId(Source *src)$/;"	f
ReadLabel	HTKLib/HLabel.c	/^Boolean ReadLabel(FILE *f, char *buf)$/;"	f
ReadLattice	HTKLib/HNet.c	/^Lattice *ReadLattice(FILE *file, MemHeap *heap, Vocab *voc, $/;"	f
ReadLine	HTKLVRec/kenlm/util/file_piece.cc	/^StringPiece FilePiece::ReadLine(char delim) {$/;"	f	class:util::FilePiece
ReadLine	HTKLib/HShell.c	/^Boolean ReadLine(Source *src,char *s)$/;"	f
ReadLineOrEOF	HTKLVRec/kenlm/util/file_piece.cc	/^bool FilePiece::ReadLineOrEOF(StringPiece &to, char delim) {$/;"	f	class:util::FilePiece
ReadLong	HTKLVRec/kenlm/util/file_piece.cc	/^long int FilePiece::ReadLong() {$/;"	f	class:util::FilePiece
ReadMapHeader	HLMLib/LCMap.c	/^static void ReadMapHeader(Source *src, ClassMap *cm, int *entries)$/;"	f	file:
ReadMapHeader	HLMLib/LWMap.c	/^static void ReadMapHeader(Source *src, WordMap *wm)$/;"	f	file:
ReadMatBigram	HTKLib/HLM.c	/^static void ReadMatBigram(LModel *lm,char *fn)$/;"	f	file:
ReadMatrix	HTKLib/HMath.c	/^Boolean ReadMatrix(Source *src, Matrix m, Boolean binary)$/;"	f
ReadMultiple	HTKLVRec/kenlm/lm/filter/phrase.cc	/^unsigned int ReadMultiple(std::istream &in, Substrings &out) {$/;"	f	namespace:lm::phrase
ReadMultiple	HTKLVRec/kenlm/lm/filter/vocab.cc	/^unsigned int ReadMultiple(std::istream &in, boost::unordered_map<std::string, std::vector<unsigned int> > &out) {$/;"	f	namespace:lm::vocab
ReadNGram	HLMLib/LGBase.c	/^void ReadNGram(NGSource *ngs, NGram ng)$/;"	f
ReadNGram	HTKLVRec/kenlm/lm/read_arpa.hh	/^template <class Voc, class Weights, class Iterator> void ReadNGram(util::FilePiece &f, const unsigned char n, const Voc &vocab, Iterator indices_out, Weights &weights, PositiveProbWarn &warn) {$/;"	f	namespace:lm
ReadNGramHeader	HTKLVRec/kenlm/lm/read_arpa.cc	/^void ReadNGramHeader(util::FilePiece &in, unsigned int length) {$/;"	f	namespace:lm
ReadNGrams	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^template <class Output> void ReadNGrams(util::FilePiece &in, unsigned int length, uint64_t number, Output &out) {$/;"	f	namespace:lm
ReadNGrams	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <class Build, class Activate, class Store> void ReadNGrams($/;"	f	namespace:lm::ngram::__anon57
ReadNGrams	HTKLib/HLM.c	/^static int ReadNGrams(NGramLM *nglm,int n,int count, Boolean bin)$/;"	f	file:
ReadNativeArray	HTKLib/esig_nat.c	/^ReadNativeArray(Array *array,$/;"	f	file:
ReadNativeData	HTKLib/esig_nat.c	/^ReadNativeData(FieldSpec *field,$/;"	f	file:
ReadNativeFieldList	HTKLib/esig_nat.c	/^ReadNativeFieldList(FieldList *listp, \/* output variable *\/$/;"	f
ReadNativeFieldSpec	HTKLib/esig_nat.c	/^ReadNativeFieldSpec(FILE *file)$/;"	f	file:
ReadNativeRecord	HTKLib/esig_nat.c	/^ReadNativeRecord(FieldSpec  **fields,$/;"	f
ReadNativeSamples	HTKLib/esig_nat.c	/^ReadNativeSamples(void      *data,$/;"	f
ReadNativeString	HTKLib/esig_nat.c	/^ReadNativeString(char **string, FILE *file)$/;"	f	file:
ReadNext	HTKLVRec/kenlm/lm/bhiksha.hh	/^    void ReadNext(const void *base, uint64_t bit_offset, uint64_t \/*index*\/, uint8_t total_bits, NodeRange &out) const {$/;"	f	class:lm::ngram::trie::DontBhiksha
ReadNext	HTKLVRec/kenlm/lm/bhiksha.hh	/^    void ReadNext(const void *base, uint64_t bit_offset, uint64_t index, uint8_t total_bits, NodeRange &out) const {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
ReadNextWord	HTKTools/HDMan.c	/^Boolean ReadNextWord(DBuffer *db)$/;"	f
ReadNonPositiveFloat31	HTKLVRec/kenlm/util/bit_packing.hh	/^inline float ReadNonPositiveFloat31(const void *base, uint64_t bit_off) {$/;"	f	namespace:util
ReadNumber	HTKLVRec/kenlm/util/file_piece.cc	/^template <class T> T FilePiece::ReadNumber() {$/;"	f	class:util::FilePiece
ReadObs	HTKLib/HParm.c	/^static void ReadObs(ParmBuf pbuf, int outRow,Observation *o)$/;"	f	file:
ReadOff	HTKLVRec/kenlm/util/bit_packing.hh	/^inline uint64_t ReadOff(const void *base, uint64_t bit_off) {$/;"	f	namespace:util
ReadOneLattice	HTKLib/HNet.c	/^Lattice *ReadOneLattice(Source *src, MemHeap *heap, Vocab *voc, $/;"	f
ReadOptSpace	HTKLib/esig_asc.c	/^ReadOptSpace(FILE *file)$/;"	f	file:
ReadOrEOF	HTKLVRec/kenlm/util/file.cc	/^std::size_t ReadOrEOF(int fd, void *to_void, std::size_t amount) {$/;"	f	namespace:util
ReadOrEOF	HTKLVRec/kenlm/util/read_compressed.cc	/^std::size_t ReadCompressed::ReadOrEOF(void *const to_in, std::size_t amount) {$/;"	f	class:util::ReadCompressed
ReadOrThrow	HTKLVRec/kenlm/lm/search_trie.cc	/^void ReadOrThrow(FILE *from, void *data, size_t size) {$/;"	f	namespace:lm::ngram::trie::__anon58
ReadOrThrow	HTKLVRec/kenlm/util/file.cc	/^void ReadOrThrow(int fd, void *to_void, std::size_t amount) {$/;"	f	namespace:util
ReadPreamble	HTKLib/esignal.c	/^ReadPreamble(char **version,    \/* version (output) *\/$/;"	f
ReadRawString	HTKLib/HShell.c	/^Boolean ReadRawString(Source *src, char *s)$/;"	f
ReadRecord	HTKLib/esignal.c	/^ReadRecord(FieldSpec    **fields,$/;"	f
ReadRow	HTKLib/HLM.c	/^int ReadRow(Vector v)$/;"	f
ReadRuleDef	HLMTools/LGPrep.c	/^void ReadRuleDef(char *s, RuleSet *rset)$/;"	f
ReadRuleSet	HLMTools/LGPrep.c	/^void ReadRuleSet(char *fn, RuleSet *rset)$/;"	f
ReadSamples	HTKLib/esignal.c	/^ReadSamples(void        *data,$/;"	f
ReadScript	HTKTools/HDMan.c	/^void ReadScript(char *scriptFn, DBuffer *db, Boolean isInput)$/;"	f
ReadScript	HTKTools/HLEd.c	/^void ReadScript(char *scriptFn)$/;"	f
ReadSetDef	HLMTools/LGPrep.c	/^void ReadSetDef(char *s, RuleSet *rset)$/;"	f
ReadShift	HTKLVRec/kenlm/util/file_piece.cc	/^void FilePiece::ReadShift() {$/;"	f	class:util::FilePiece
ReadShort	HTKLib/HShell.c	/^Boolean ReadShort(Source *src, short *s, int n, Boolean binary)$/;"	f
ReadShortVec	HTKLib/HMath.c	/^Boolean ReadShortVec(Source *src, ShortVec v, Boolean binary)$/;"	f
ReadSingle	HTKLVRec/kenlm/lm/filter/vocab.cc	/^void ReadSingle(std::istream &in, boost::unordered_set<std::string> &out) {$/;"	f	namespace:lm::vocab
ReadSingle	HTKLVRec/kenlm/util/stream/sort.hh	/^    void ReadSingle(uint64_t offset, const uint64_t size, const ChainPosition &position) {$/;"	f	class:util::stream::MergingReader
ReadSizeException	HTKLVRec/kenlm/util/stream/io.cc	/^ReadSizeException::ReadSizeException() throw() {}$/;"	f	class:util::stream::ReadSizeException
ReadSizeException	HTKLVRec/kenlm/util/stream/io.hh	/^class ReadSizeException : public util::Exception {$/;"	c	namespace:util::stream
ReadSpace	HTKLib/esig_asc.c	/^ReadSpace(FILE *file)$/;"	f	file:
ReadString	HTKLib/HShell.c	/^Boolean ReadString(Source *src, char *s){  $/;"	f
ReadStringWithLen	HTKLib/HShell.c	/^Boolean ReadStringWithLen(Source *src, char *s, int buflen)$/;"	f
ReadTriMat	HTKLib/HMath.c	/^Boolean ReadTriMat(Source *src, TriMat m, Boolean binary)$/;"	f
ReadUInt64	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^static uint64_t ReadUInt64(Vector<const char> buffer,$/;"	f	namespace:double_conversion
ReadULong	HTKLVRec/kenlm/util/file_piece.cc	/^unsigned long int FilePiece::ReadULong() {$/;"	f	class:util::FilePiece
ReadUint64	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static uint64_t ReadUint64(Vector<const char> buffer,$/;"	f	namespace:double_conversion
ReadUntilLine	HTKLib/HShell.c	/^void ReadUntilLine (Source *src, char *s)$/;"	f
ReadVector	HTKLib/HMath.c	/^Boolean ReadVector(Source *src, Vector v, Boolean binary)$/;"	f
ReadWPGrammar	HTKTools/HBuild.c	/^void ReadWPGrammar(WPGrammar *wpg, Vocab * voc, char *gramFn)$/;"	f
ReadWordFromLine	HTKTools/HResults.c	/^Boolean ReadWordFromLine(Source *src, char *s)$/;"	f
ReadWordSameLine	HTKLVRec/kenlm/util/file_piece.hh	/^    bool ReadWordSameLine(StringPiece &to, const bool *delim = kSpaces) {$/;"	f	class:util::FilePiece
ReadWords	HTKLVRec/kenlm/lm/vocab.cc	/^void ReadWords(int fd, EnumerateVocab *enumerate, WordIndex expected_count, uint64_t offset) {$/;"	f	namespace:lm::ngram::__anon62
Reader	HTKLVRec/kenlm/util/parallel_read.cc	/^    explicit Reader(int fd) : fd_(fd) {}$/;"	f	class:util::__anon78::Reader
Reader	HTKLVRec/kenlm/util/parallel_read.cc	/^class Reader {$/;"	c	namespace:util::__anon78	file:
Realft	HTKLib/HSigP.c	/^void Realft (Vector s)$/;"	f
RebuildAETab	HTKTools/HLStats.c	/^void RebuildAETab(AEntry **aelists)$/;"	f
RebuildLM	HLMLib/LPCalc.c	/^void RebuildLM(BackOffLM *lm, int *cutOff, float *wdThresh, LMProbType tgtPType) $/;"	f
RebuildNGrams	HLMLib/LPCalc.c	/^static int RebuildNGrams(BackOffLM *lm,int cxSize,int nSize,FLEntry **context)$/;"	f	file:
Recognition Tools	HTKBook/htkoview.tex	/^\\subsection{Recognition Tools}$/;"	b
Recognize	HTKLVRec/kenlm/lm/wrappers/nplm.cc	/^bool Model::Recognize(const std::string &name) {$/;"	f	class:lm::np::Model
RecognizeBinary	HTKLVRec/kenlm/lm/binary_format.cc	/^bool RecognizeBinary(const char *file, ModelType &recognized) {$/;"	f	namespace:lm::ngram
Record	HTKTools/HSLab.c	/^Wave Record(long *nSamples, HTime *sampPeriod)$/;"	f
RecordFileStats	HTKTools/HResults.c	/^Boolean RecordFileStats(CellPtr p)$/;"	f
RecordHeap	HTKLib/HMem.c	/^static void RecordHeap(MemHeap *x)$/;"	f	file:
RecordOp	HTKTools/HSLab.c	/^void RecordOp(OpType op, LLink p)$/;"	f
RecordReader	HTKLVRec/kenlm/lm/trie_sort.hh	/^    RecordReader() : remains_(true) {}$/;"	f	class:lm::ngram::trie::RecordReader
RecordReader	HTKLVRec/kenlm/lm/trie_sort.hh	/^class RecordReader {$/;"	c	namespace:lm::ngram::trie
RecordSize	HTKLib/esignal.c	/^RecordSize(FieldList list,$/;"	f
RecordStart	HTKLVRec/kenlm/util/usage.cc	/^    RecordStart() {$/;"	f	class:util::__anon83::RecordStart
RecordStart	HTKLVRec/kenlm/util/usage.cc	/^class RecordStart {$/;"	c	namespace:util::__anon83	file:
RecordTriphone	HTKTools/HHEd.c	/^void RecordTriphone(HLink left, HLink right, MLink ml)$/;"	f
RecoverArcsForNode	HTKLib/HLat.c	/^void RecoverArcsForNode(Lattice *lat, LNode *ln)$/;"	f
RectWin	HTKTools/HSLab.c	/^} RectWin;$/;"	t	typeref:struct:__anon212	file:
RecursiveInsert	HTKLVRec/kenlm/lm/search_trie.cc	/^template <class Doing> void RecursiveInsert(const unsigned char total_order, const WordIndex unigram_count, RecordReader *input, std::ostream *progress_out, const char *message, Doing &doing) {$/;"	f	namespace:lm::ngram::trie::__anon58
Recycler	HTKLVRec/kenlm/util/stream/chain.hh	/^class Recycler {$/;"	c	namespace:util::stream
RedrawHButton	HTKLib/HGraf.c	/^void RedrawHButton(HButton *btn)$/;"	f
RedrawHButton	HTKLib/HGraf.null.c	/^void RedrawHButton(HButton *btn)$/;"	f
RedrawHButton	HTKLib/HGraf_WIN32.c	/^void RedrawHButton(HButton *btn)$/;"	f
RedrawHButtonList	HTKLib/HGraf.c	/^void RedrawHButtonList(HButton *btnlst)$/;"	f
RedrawHButtonList	HTKLib/HGraf.null.c	/^void RedrawHButtonList(HButton *btnlst)$/;"	f
RedrawHButtonList	HTKLib/HGraf_WIN32.c	/^void RedrawHButtonList(HButton *btnlst)$/;"	f
RefAlign	HTKLib/HRec.c	/^static void RefAlign(Align *align)$/;"	f	file:
RefC2LPC	HTKLib/HSigP.c	/^void RefC2LPC (Vector k, Vector a)$/;"	f
RefPath	HTKLib/HRec.c	/^static void RefPath(Path *path)$/;"	f	file:
Reference Section	HTKBook/htkbook-pdf.tex	/^\\part{Reference Section}$/;"	p
Reference Section	HTKBook/htkbook.tex	/^\\part{Reference Section}$/;"	p
RegAcc	HTKLib/HAdapt.c	/^} RegAcc;$/;"	t	typeref:struct:__anon87	file:
RegClassesCommand	HTKTools/HHEd.c	/^void RegClassesCommand(void) $/;"	f
RegNode	HTKLib/HModel.h	/^} RegNode ;$/;"	t	typeref:struct:_RegNode
RegTree	HTKLib/HModel.h	/^typedef struct RegTree {$/;"	s
RegTree	HTKLib/HModel.h	/^} RegTree;             $/;"	t	typeref:struct:RegTree
Register	HTKLib/HShell.c	/^void Register(char *ver, char *sccs)$/;"	f
RegisterExtFileName	HTKLib/HShell.c	/^char * RegisterExtFileName(char *s)$/;"	f
Regress	HTKLib/HSigP.c	/^static void Regress(float *data, int vSize, int n, int step, int offset,$/;"	f	file:
RelTokScore	HTKLVRec/config.h	/^typedef LogFloat RelTokScore;$/;"	t
RelToken	HTKLVRec/HLVRec.h	/^typedef struct _RelToken RelToken;      \/* Info about partial hypothesis relative to main token *\/$/;"	t	typeref:struct:_RelToken
RelToken	HTKLib/HRec.c	/^RelToken;$/;"	t	typeref:struct:reltoken	file:
Relocate	HTKLVRec/kenlm/lm/vocab.cc	/^void ProbingVocabulary::Relocate(void *new_start) {$/;"	f	class:lm::ngram::ProbingVocabulary
Relocate	HTKLVRec/kenlm/lm/vocab.cc	/^void SortedVocabulary::Relocate(void *new_start) {$/;"	f	class:lm::ngram::SortedVocabulary
Relocate	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    void Relocate(void *new_base) {$/;"	f	class:util::ProbingHashTable
RemDuplicates	HTKTools/HDMan.c	/^void RemDuplicates(DBuffer *db)$/;"	f
RemMean	HTKTools/HHEd.c	/^void RemMean(Vector src, Vector tgt)$/;"	f
RemMeansCommand	HTKTools/HHEd.c	/^void RemMeansCommand(void)$/;"	f
RemOutliers	HTKTools/HHEd.c	/^void RemOutliers(CLink *cvec, Matrix idist, Matrix gdist, int *numClust, $/;"	f
RemOutliersCommand	HTKTools/HHEd.c	/^void RemOutliersCommand(void)$/;"	f
RemStress	HTKTools/HDMan.c	/^void RemStress(WordBuf *wb, LabId *args)$/;"	f
RemTop	HTKTools/HHEd.c	/^MixtureElem RemTop(void)$/;"	f
RemWordFromClass	HLMLib/LCMap.c	/^void RemWordFromClass(ClassMap *c, int clndx, int wdndx)$/;"	f
RemainingBlocks	HTKLVRec/kenlm/util/stream/sort.hh	/^    uint64_t RemainingBlocks() const { return block_count_; }$/;"	f	class:util::stream::Offsets
RemoveDiscon	HTKTools/HParse.c	/^static void RemoveDiscon(HPNetwork *net)$/;"	f	file:
RemoveGlue	HTKTools/HParse.c	/^static void  RemoveGlue(HPNetwork *network)$/;"	f	file:
RenameHMMSetIdCommand	HTKTools/HHEd.c	/^void RenameHMMSetIdCommand(void)$/;"	f
ReplaceOp	HTKTools/HLEd.c	/^int ReplaceOp(LabList *ll,LabId *args)$/;"	f
ReplacePhoneOp	HTKTools/HDMan.c	/^void ReplacePhoneOp(WordBuf *wb, LabId *args)$/;"	f
ReplaceThis	HTKLVRec/kenlm/util/read_compressed.cc	/^    static void ReplaceThis(ReadBase *with, ReadCompressed &thunk) {$/;"	f	class:util::ReadBase
ReplaceUnigrams	HLMTools/HLMCopy.c	/^void ReplaceUnigrams(char *fn, BackOffLM *lm)$/;"	f
ReplaceWordOp	HTKTools/HDMan.c	/^void ReplaceWordOp(WordBuf *wb, LabId *args)$/;"	f
ReplayAudio	HTKTools/HVite.c	/^void ReplayAudio(BufferInfo info)$/;"	f
ReplayBuf	HTKLib/HAudio.c	/^}ReplayBuf;$/;"	t	typeref:struct:__anon92	file:
ReportOutput	HTKTools/HCompV.c	/^void ReportOutput()$/;"	f
ReportUsage	HLMTools/Cluster.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/HLMCopy.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LAdapt.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LBuild.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LFoF.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LGCopy.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LGList.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LGPrep.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LLink.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LMerge.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LNewMap.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LNorm.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LPlex.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HLMTools/LSubset.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKLVRec/HDecode.c	/^ReportUsage (void)$/;"	f
ReportUsage	HTKLVRec/HDecode.mod.c	/^ReportUsage (void)$/;"	f
ReportUsage	HTKTools/HBuild.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HCompV.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HCopy.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HDMan.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HERest.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HHEd.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HInit.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HLEd.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HLRescore.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HLStats.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HList.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HMMIRest.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HParse.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HQuant.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HRest.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HResults.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HSGen.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HSLab.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HSmooth.c	/^void ReportUsage(void)$/;"	f
ReportUsage	HTKTools/HVite.c	/^void ReportUsage(void)$/;"	f
Request	HTKLVRec/kenlm/lm/filter/thread.hh	/^    typedef Batch *Request;$/;"	t	class:lm::FilterWorker
Request	HTKLVRec/kenlm/lm/filter/thread.hh	/^    typedef Batch *Request;$/;"	t	class:lm::OutputWorker
Request	HTKLVRec/kenlm/util/parallel_read.cc	/^    struct Request {$/;"	s	class:util::__anon78::Reader	file:
Request	HTKLVRec/kenlm/util/thread_pool.hh	/^    typedef typename Handler::Request Request;$/;"	t	class:util::ThreadPool
Request	HTKLVRec/kenlm/util/thread_pool.hh	/^    typedef typename Handler::Request Request;$/;"	t	class:util::Worker
RequiredBits	HTKLVRec/kenlm/util/bit_packing.cc	/^uint8_t RequiredBits(uint64_t max_value) {$/;"	f	namespace:util
Reserve	HTKLVRec/kenlm/lm/filter/format.hh	/^    void Reserve(size_t size) { lines_.reserve(size); }$/;"	f	class:lm::InputBuffer
Reserve	HTKLVRec/kenlm/lm/filter/format.hh	/^    void Reserve(size_t size) {$/;"	f	class:lm::BinaryOutputBuffer
Reserve	HTKLVRec/kenlm/lm/filter/format.hh	/^    void Reserve(size_t size) {$/;"	f	class:lm::MultipleOutputBuffer
Reserve	HTKLVRec/kenlm/lm/filter/thread.hh	/^    void Reserve(size_t size) {$/;"	f	class:lm::ThreadBatch
ReserveForCounts	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^void ARPAOutput::ReserveForCounts(std::streampos reserve) {$/;"	f	class:lm::ARPAOutput
ReserveForCounts	HTKLVRec/kenlm/lm/filter/format.hh	/^    void ReserveForCounts(std::streampos reserve) { B::output_.ReserveForCounts(reserve); }$/;"	f	class:lm::DispatchARPAInput
ReserveForCounts	HTKLVRec/kenlm/lm/filter/format.hh	/^    void ReserveForCounts(std::streampos reserve) {$/;"	f	class:lm::MultipleARPAOutput
Reset	HTKLVRec/kenlm/lm/left.hh	/^    void Reset() {$/;"	f	class:lm::ngram::RuleScore
Reset	HTKLVRec/kenlm/lm/left.hh	/^    void Reset(ChartState &replacement) {$/;"	f	class:lm::ngram::RuleScore
Reset	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  void Reset() { position_ = 0; }$/;"	f	class:double_conversion::StringBuilder
Reset	HTKLVRec/kenlm/util/read_compressed.cc	/^void ReadCompressed::Reset(int fd) {$/;"	f	class:util::ReadCompressed
Reset	HTKLVRec/kenlm/util/read_compressed.cc	/^void ReadCompressed::Reset(std::istream &in) {$/;"	f	class:util::ReadCompressed
Reset	HTKLVRec/kenlm/util/stream/sort.hh	/^    void Reset() {$/;"	f	class:util::stream::Offsets
ResetAccCache	HTKLib/HAdapt.c	/^void ResetAccCache(void)$/;"	f
ResetAccessInfo	HLMLib/LModel.c	/^void ResetAccessInfo(BackOffLM *lm)$/;"	f
ResetChannelSession	HTKLib/HParm.c	/^void ResetChannelSession(char *confName)$/;"	f
ResetComp	HTKLib/HAdapt.c	/^static void ResetComp(MixPDF *mp)$/;"	f	file:
ResetFVTrans	HTKLVRec/HDecode.c	/^void ResetFVTrans (HMMSet *hset, BlockMatrix transMat)$/;"	f
ResetFVTrans	HTKLVRec/HDecode.mod.c	/^void ResetFVTrans (HMMSet *hset, BlockMatrix transMat)$/;"	f
ResetHMMPreComps	HTKLib/HTrain.c	/^void ResetHMMPreComps(HLink hmm, int nStreams)$/;"	f
ResetHMMSet	HTKLib/HModel.c	/^void ResetHMMSet(HMMSet *hset)$/;"	f
ResetHMMWtAccs	HTKLib/HTrain.c	/^void ResetHMMWtAccs(HLink hmm, int nStreams)$/;"	f
ResetHeap	HTKLib/HMem.c	/^void ResetHeap(MemHeap *x)$/;"	f
ResetHeaps	HTKTools/HSmooth.c	/^void ResetHeaps(void)$/;"	f
ResetHooks	HTKLib/HUtil.c	/^void ResetHooks(HMMSet *hset,char *what)$/;"	f
ResetLMCache	HTKLVRec/HLVRec-LM.c	/^static void ResetLMCache (LMCache *cache)$/;"	f	file:
ResetObsCache	HTKLib/HAdapt.c	/^void ResetObsCache(void)$/;"	f
ResetOutPCache	HTKLVRec/HLVRec-outP.c	/^static void ResetOutPCache (OutPCache *cache)$/;"	f	file:
ResetPreComps	HTKLib/HTrain.c	/^void ResetPreComps(HMMSet *hset)$/;"	f
ResetReplayBuf	HTKLib/HAudio.c	/^static void ResetReplayBuf(AudioIn a)$/;"	f	file:
ResetStacks	HTKLib/HFB.c	/^static void ResetStacks(AlphaBeta *ab)$/;"	f	file:
ResetUtilItemList	HTKLib/HUtil.c	/^void ResetUtilItemList()$/;"	f
ResetXFormHMMSet	HTKLib/HAdapt.c	/^void ResetXFormHMMSet(HMMSet *hset)$/;"	f
Resize	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Resize(std::size_t to) {$/;"	f	class:lm::ngram::trie::__anon58::BackoffMessages	file:
ResizeLinkSet	HTKTools/HParse.c	/^static void ResizeLinkSet(LinkSet *ls, int newSize)$/;"	f	file:
ResizeOrThrow	HTKLVRec/kenlm/util/file.cc	/^void ResizeOrThrow(int fd, uint64_t to) {$/;"	f	namespace:util
ResizeSTriMat	HTKTools/HHEd.c	/^STriMat ResizeSTriMat(HMMSet *hset,STriMat m, int n, char type, float pad)$/;"	f
ResizeSVector	HTKTools/HHEd.c	/^SVector ResizeSVector(HMMSet *hset,SVector v, int n, char type, float pad)$/;"	f
ResolveFilterList	HLMTools/LGList.c	/^void ResolveFilterList(void)$/;"	f
Rest	HTKLVRec/kenlm/lm/quantize.hh	/^        float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
Rest	HTKLVRec/kenlm/lm/quantize.hh	/^        float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
Rest	HTKLVRec/kenlm/lm/trie.hh	/^    float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::trie::UnigramPointer
Rest	HTKLVRec/kenlm/lm/value.hh	/^      float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::BackoffValue::ProbingProxy
Rest	HTKLVRec/kenlm/lm/value.hh	/^      float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::BackoffValue::TrieUnigramProxy
Rest	HTKLVRec/kenlm/lm/value.hh	/^      float Rest() const { return to_->rest; }$/;"	f	class:lm::ngram::RestValue::ProbingProxy
Rest	HTKLVRec/kenlm/lm/value.hh	/^      float Rest() const { return to_->rest; }$/;"	f	class:lm::ngram::RestValue::TrieUnigramProxy
Rest	HTKLVRec/kenlm/lm/value.hh	/^    float Rest() const { return Prob(); }$/;"	f	class:lm::ngram::GenericTrieUnigramProxy
RestCoVar	HTKTools/HRest.c	/^Boolean RestCoVar(MixPDF *mp, int vSize, Vector minV,$/;"	f
RestFunction	HTKLVRec/kenlm/lm/config.hh	/^  enum RestFunction {$/;"	g	struct:lm::ngram::Config
RestMean	HTKTools/HRest.c	/^void RestMean(Vector mean, int vSize)$/;"	f
RestMixWeights	HTKTools/HRest.c	/^void RestMixWeights(int state, int s, StreamElem *se)$/;"	f
RestStream	HTKTools/HRest.c	/^void RestStream(int state, int s, StreamElem *se, int vSize)$/;"	f
RestTransP	HTKTools/HRest.c	/^void RestTransP(void)$/;"	f
RestValue	HTKLVRec/kenlm/lm/value.hh	/^struct RestValue {$/;"	s	namespace:lm::ngram
RestWeights	HTKLVRec/kenlm/lm/weights.hh	/^struct RestWeights {$/;"	s	namespace:lm
RestoreAccs	HTKLib/HTrain.c	/^void RestoreAccs(HMMSet *hset){ RestoreAccsParallel(hset,0); }$/;"	f
RestoreAccsParallel	HTKLib/HTrain.c	/^void RestoreAccsParallel(HMMSet *hset, int index)$/;"	f
RestorePDF	HTKLib/HTrain.c	/^void RestorePDF(MixPDF *mp, int index){$/;"	f
ResumeScore	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> void GenericModel<Search, VocabularyT>::ResumeScore(const WordIndex *hist_iter, const WordIndex *const context_rend, unsigned char order_minus_2, typename Search::Node &node, float *backoff_out, unsigned char &next_use, FullScoreReturn &ret) const {$/;"	f	class:lm::ngram::detail::GenericModel
RetrieveCommandLine	HTKLib/HShell.c	/^char *RetrieveCommandLine(void)$/;"	f
RetrieveESIGFieldList	HTKLib/HWave.c	/^void RetrieveESIGFieldList(HFieldList *fList)$/;"	f
ReturnLMName	HLMTools/HLMCopy.c	/^char *ReturnLMName(int fmt)$/;"	f
ReturnLMName	HLMTools/LAdapt.c	/^char *ReturnLMName(int fmt)$/;"	f
ReturnLMName	HLMTools/LBuild.c	/^char *ReturnLMName(int fmt)$/;"	f
ReturnLMName	HLMTools/LMerge.c	/^char *ReturnLMName(int fmt)$/;"	f
ReturnLMName	HLMTools/LNorm.c	/^char *ReturnLMName(int fmt)$/;"	f
ReturnStatus	HTKLib/HShell.h	/^typedef enum {FAIL=-1, SUCCESS=0} ReturnStatus;$/;"	t	typeref:enum:__anon151
RevealAfter	HTKLVRec/kenlm/lm/partial.hh	/^template <class Model> float RevealAfter(const Model &model, Left &left, Right &right, const Left &reveal, unsigned char seen) {$/;"	f	namespace:lm::ngram
RevealBefore	HTKLVRec/kenlm/lm/partial.hh	/^template <class Model> float RevealBefore(const Model &model, const Right &reveal, const unsigned char seen, bool reveal_full, Left &left, Right &right) {$/;"	f	namespace:lm::ngram
Rewind	HTKLVRec/kenlm/lm/trie_sort.cc	/^void RecordReader::Rewind() {$/;"	f	class:lm::ngram::trie::RecordReader
Right	HTKLVRec/kenlm/lm/state.hh	/^typedef State Right;$/;"	t	namespace:lm::ngram
RightTriCxt	HTKTools/HLEd.c	/^LabId RightTriCxt(LLink l)$/;"	f
Roll	HTKLVRec/kenlm/util/mmap.cc	/^void Rolling::Roll(uint64_t index) {$/;"	f	class:util::Rolling
Rolling	HTKLVRec/kenlm/util/mmap.cc	/^Rolling::Rolling(const Rolling &copy_from, uint64_t increase) {$/;"	f	class:util::Rolling
Rolling	HTKLVRec/kenlm/util/mmap.cc	/^Rolling::Rolling(int fd, bool for_write, std::size_t block, std::size_t read_bound, uint64_t offset, uint64_t amount) {$/;"	f	class:util::Rolling
Rolling	HTKLVRec/kenlm/util/mmap.hh	/^    Rolling() {}$/;"	f	class:util::Rolling
Rolling	HTKLVRec/kenlm/util/mmap.hh	/^    explicit Rolling(void *data) { Init(data); }$/;"	f	class:util::Rolling
Rolling	HTKLVRec/kenlm/util/mmap.hh	/^class Rolling {$/;"	c	namespace:util
RotRows	HTKLib/HMath.c	/^static void RotRows(DMatrix M, int i, int k, $/;"	f	file:
RoundAlign	HTKLVRec/HLVModel.c	/^size_t RoundAlign(size_t addr, size_t align)$/;"	f
RoundUp	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^static void RoundUp(Vector<char> buffer, int* length, int* decimal_point) {$/;"	f	namespace:double_conversion
RoundWeed	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^static bool RoundWeed(Vector<char> buffer,$/;"	f	namespace:double_conversion
RoundWeedCounted	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^static bool RoundWeedCounted(Vector<char> buffer,$/;"	f	namespace:double_conversion
RuleDef	HLMTools/LGPrep.c	/^} RuleDef;$/;"	t	typeref:struct:ruledef	file:
RuleScore	HTKLVRec/kenlm/lm/left.hh	/^    explicit RuleScore(const M &model, ChartState &out) : model_(model), out_(&out), left_done_(false), prob_(0.0) {$/;"	f	class:lm::ngram::RuleScore
RuleScore	HTKLVRec/kenlm/lm/left.hh	/^template <class M> class RuleScore {$/;"	c	namespace:lm::ngram
RuleSet	HLMTools/LGPrep.c	/^} RuleSet;$/;"	t	typeref:struct:__anon31	file:
RuleSummary	HLMTools/LGPrep.c	/^void RuleSummary(void)$/;"	f
Run	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^void AdjustCounts::Run(const util::stream::ChainPositions &positions) {$/;"	f	class:lm::builder::AdjustCounts
Run	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^void CorpusCount::Run(const util::stream::ChainPosition &position) {$/;"	f	class:lm::builder::CorpusCount
Run	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    void Run(const util::stream::ChainPosition &output) {$/;"	f	class:lm::builder::__anon45::AddRight
Run	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    void Run(const util::stream::ChainPosition &position) {$/;"	f	class:lm::builder::__anon45::OnlyGamma
Run	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    void Run(const util::stream::ChainPosition &primary) {$/;"	f	class:lm::builder::__anon45::MergeRight
Run	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^void Interpolate::Run(const util::stream::ChainPositions &positions) {$/;"	f	class:lm::builder::Interpolate
Run	HTKLVRec/kenlm/lm/builder/print.cc	/^void PrintARPA::Run(const util::stream::ChainPositions &positions) {$/;"	f	class:lm::builder::PrintARPA
Run	HTKLVRec/kenlm/lm/builder/print.hh	/^    void Run(const util::stream::ChainPosition &position) {$/;"	f	class:lm::builder::Print
Run	HTKLVRec/kenlm/lm/builder/print.hh	/^    void Run(const util::stream::ChainPositions &chains) {$/;"	f	class:lm::builder::Print
Run	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.cc	/^void ARPAToStream::Run(const util::stream::ChainPositions &positions) {$/;"	f	class:lm::interpolate::ARPAToStream
Run	HTKLVRec/kenlm/util/stream/chain.cc	/^void Recycler::Run(const ChainPosition &position) {$/;"	f	class:util::stream::Recycler
Run	HTKLVRec/kenlm/util/stream/io.cc	/^void PRead::Run(const ChainPosition &position) {$/;"	f	class:util::stream::PRead
Run	HTKLVRec/kenlm/util/stream/io.cc	/^void PWriteAndRecycle::Run(const ChainPosition &position) {$/;"	f	class:util::stream::PWriteAndRecycle
Run	HTKLVRec/kenlm/util/stream/io.cc	/^void Read::Run(const ChainPosition &position) {$/;"	f	class:util::stream::Read
Run	HTKLVRec/kenlm/util/stream/io.cc	/^void Write::Run(const ChainPosition &position) {$/;"	f	class:util::stream::Write
Run	HTKLVRec/kenlm/util/stream/io.cc	/^void WriteAndRecycle::Run(const ChainPosition &position) {$/;"	f	class:util::stream::WriteAndRecycle
Run	HTKLVRec/kenlm/util/stream/line_input.cc	/^void LineInput::Run(const ChainPosition &position) {$/;"	f	class:util::stream::LineInput
Run	HTKLVRec/kenlm/util/stream/sort.hh	/^    void Run(const ChainPosition &position) {$/;"	f	class:util::stream::BlockSorter
Run	HTKLVRec/kenlm/util/stream/sort.hh	/^    void Run(const ChainPosition &position) {$/;"	f	class:util::stream::MergingReader
Run	HTKLVRec/kenlm/util/stream/sort.hh	/^    void Run(const ChainPosition &position) {$/;"	f	class:util::stream::OwningMergingReader
Run	HTKLVRec/kenlm/util/stream/sort.hh	/^    void Run(const ChainPosition &position, bool assert_one) {$/;"	f	class:util::stream::MergingReader
RunFilter	HTKLVRec/kenlm/lm/filter/format.hh	/^  template <class Filter, class Out> static void RunFilter(util::FilePiece &in, Filter &filter, Out &output) {$/;"	f	struct:lm::ARPAFormat
RunFilter	HTKLVRec/kenlm/lm/filter/format.hh	/^  template <class Filter, class Out> static void RunFilter(util::FilePiece &in, Filter &filter, Out &output) {$/;"	f	struct:lm::CountFormat
RunSilDet	HTKLib/HParm.c	/^void RunSilDet(ParmBuf pbuf,Boolean cleared)$/;"	f
Running	HTKLVRec/kenlm/util/stream/chain.hh	/^    bool Running() const { return !queues_.empty(); }$/;"	f	class:util::stream::Chain
S	HTKLVRec/kenlm/lm/builder/sort.hh	/^    typedef util::stream::Sort<Compare> S;$/;"	t	class:lm::builder::Sorts
S	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    typedef ProxyIterator<Proxy> S;$/;"	t	class:util::ProxyIterator
S	HTKLib/HFB.h	/^  int S;              \/* number of data streams *\/$/;"	m	struct:__anon96
S	HTKLib/HFBLat.h	/^  int S;$/;"	m	struct:__anon102
S	HTKLib/HMap.c	/^static int S;$/;"	v	file:
S	HTKLib/HUtil.h	/^   int S;            \/* num Streams = hset->swidth[0] *\/$/;"	m	struct:__anon169
S	HTKTools/HMMIRest.c	/^static int S;                    \/* number of data streams *\/   \/*! Equals 1 or error![?] *\/$/;"	v	file:
SANITY	HTKLib/HRec.c	45;"	d	file:
SAVECOMPRESSED	HTKLib/HParm.c	/^   SAVECOMPRESSED,\/* Save output files in compressed form *\/$/;"	e	enum:__anon142	file:
SAVEWITHCRC	HTKLib/HParm.c	/^   SAVEWITHCRC,   \/* Add crc check to output files *\/$/;"	e	enum:__anon142	file:
SBDEF	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon200	file:
SCANBUFMAX	HTKTools/HParse.c	1298;"	d	file:
SCHAR	HTKLib/esignal.h	72;"	d
SCHAR_COMPLEX	HTKLib/esignal.h	79;"	d
SCHCX_FMT	HTKLib/esig_asc.c	91;"	d	file:
SCHCX_W	HTKLib/esig_asc.c	90;"	d	file:
SCHCX_WFMT	HTKLib/esig_asc.c	92;"	d	file:
SCH_FMT	HTKLib/esig_asc.c	67;"	d	file:
SCH_W	HTKLib/esig_asc.c	66;"	d	file:
SCH_WFMT	HTKLib/esig_asc.c	68;"	d	file:
SCRIBE	HTKLib/HWave.h	/^        SCRIBE,            \/* UK Scribe databases *\/$/;"	e	enum:__anon181
SCRIBE Label Files	HTKBook/labels.tex	/^\\subsection{SCRIBE Label Files}$/;"	b
SCROLL_PT	HTKTools/HSLab.c	100;"	d	file:
SDES1	HTKLib/HWave.h	/^        SDES1,             \/* Sound Designer I format *\/$/;"	e	enum:__anon181
SDes1Header	HTKLib/HWave.c	/^} SDes1Header;$/;"	t	typeref:struct:__anon175	file:
SELFCALSILDET	HTKLib/HParm.c	/^   SELFCALSILDET, \/* Self calibrating silence detection on each utterance *\/$/;"	e	enum:__anon142	file:
SEMISYM	HTKTools/HParse.c	/^             LTRISYM,RTRISYM,EQSYM, SEMISYM, BARSYM, PERCENTSYM, $/;"	e	enum:_Symbol	file:
SEMIT	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	e	enum:_XFormKind
SETLEV	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon200	file:
SET_totalProbScale	HTKLib/HFBLat.c	144;"	d	file:
SEntry	HTKLVRec/HLVLM.h	/^} SEntry;$/;"	t	typeref:struct:sentry
SEntry	HTKLib/HLM.h	/^} SEntry;$/;"	t	typeref:struct:sentry
SH	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon199	file:
SHAREDHS	HTKLib/HModel.h	/^enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};$/;"	e	enum:_HSetKind
SHELL	HLMLib/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	HLMTools/Makefile	/^SHELL   =	\/bin\/sh$/;"	m
SHELL	HTKLVRec/Makefile	/^SHELL   = 	\/bin\/sh$/;"	m
SHELL	HTKLib/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	HTKTools/Makefile	/^SHELL =	\/bin\/sh$/;"	m
SHELL	Makefile	/^SHELL = \/bin\/sh$/;"	m
SHIFTKEY	HTKLib/HGraf.h	/^enum _KeyType {NORMALKEY, SHIFTKEY, COMMANDKEY, CONTROLKEY, $/;"	e	enum:_KeyType
SHORT	HTKLib/esignal.h	70;"	d
SHORTEN	HTKLib/HWave.c	/^   SHORTEN,     \/* CUED Shorten *\/$/;"	e	enum:_CompressType	file:
SHORTEST	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    SHORTEST,$/;"	e	enum:double_conversion::DoubleToStringConverter::DtoaMode
SHORTEST_SINGLE	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    SHORTEST_SINGLE,$/;"	e	enum:double_conversion::DoubleToStringConverter::DtoaMode
SHORTPACK	HTKLib/HWave.c	/^   SHORTPACK,   \/* MIT shortpack-v0 *\/$/;"	e	enum:_CompressType	file:
SHORT_COMPLEX	HTKLib/esignal.h	78;"	d
SHRCX_FMT	HTKLib/esig_asc.c	87;"	d	file:
SHRCX_W	HTKLib/esig_asc.c	86;"	d	file:
SHRCX_WFMT	HTKLib/esig_asc.c	88;"	d	file:
SHR_FMT	HTKLib/esig_asc.c	59;"	d	file:
SHR_W	HTKLib/esig_asc.c	58;"	d	file:
SHR_WFMT	HTKLib/esig_asc.c	60;"	d	file:
SIDEXFORMEXT	HTKLib/HParm.c	/^   SIDEXFORMEXT, \/* extension for use with side-based xforms *\/$/;"	e	enum:__anon142	file:
SIDEXFORMMASK	HTKLib/HParm.c	/^   SIDEXFORMMASK,\/* mask for use with side-based xforms *\/$/;"	e	enum:__anon142	file:
SILDISCARD	HTKLib/HParm.c	/^   SILDISCARD,    \/* Energy below which frames discarded when calibrating *\/$/;"	e	enum:__anon142	file:
SILENERGY	HTKLib/HParm.c	/^   SILENERGY,     \/* Silence detector threshold *\/$/;"	e	enum:__anon142	file:
SILENT	HTKLVRec/kenlm/lm/lm_exception.hh	/^typedef enum {THROW_UP, COMPLAIN, SILENT} WarningAction;$/;"	e	enum:lm::__anon51
SILFLOOR	HTKLib/HParm.c	/^   SILFLOOR,      \/* Silence floor in dBs *\/$/;"	e	enum:__anon142	file:
SILGLCHCOUNT	HTKLib/HParm.c	/^   SILGLCHCOUNT,  \/* Silence glitch count *\/$/;"	e	enum:__anon142	file:
SILMARGIN	HTKLib/HParm.c	/^   SILMARGIN,     \/* Margin of silence around speech *\/$/;"	e	enum:__anon142	file:
SILSEQCOUNT	HTKLib/HParm.c	/^   SILSEQCOUNT,   \/* Silence sequence count *\/$/;"	e	enum:__anon142	file:
SIMPLEDIFFS	HTKLib/HParm.c	/^   SIMPLEDIFFS,   \/* Use simple differences *\/$/;"	e	enum:__anon142	file:
SING_QUOTE	HTKLib/HShell.h	80;"	d
SK	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon199	file:
SLEN	HTKTools/HSLab.c	73;"	d	file:
SMAX	HTKLib/HShell.h	77;"	d
SMEntry	HLMLib/LModel.h	/^} SMEntry;$/;"	t	typeref:struct:_SMEntry
SMatrix	HTKLib/HMem.h	/^typedef Matrix SMatrix;    \/* shared matrix[1..nrows][1..ncols] *\/$/;"	t
SMatrixElemSize	HTKLib/HMem.c	/^size_t SMatrixElemSize(int nrows,int ncols)$/;"	f
SORT	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon200	file:
SORT_FREQ	HLMTools/Cluster.c	79;"	d	file:
SORT_WMAP	HLMTools/Cluster.c	78;"	d	file:
SOURCEFORMAT	HTKLib/HParm.c	/^   SOURCEFORMAT,  \/* FileFormat *\/$/;"	e	enum:__anon142	file:
SOURCEKIND	HTKLib/HParm.c	/^   SOURCEKIND,    \/* ParmKind *\/ $/;"	e	enum:__anon142	file:
SOURCERATE	HTKLib/HParm.c	/^   SOURCERATE,    \/* Source sample rate in 100ns *\/$/;"	e	enum:__anon142	file:
SOutP	HTKLib/HModel.c	/^LogFloat SOutP(HMMSet *hset, int s, Observation *x, StreamElem *se)$/;"	f
SOutP_HMod	HTKLVRec/HLVRec-outP.c	/^static LogFloat SOutP_HMod (HMMSet *hset, int s, Observation *x, StreamElem *se,$/;"	f	file:
SOutP_ID_mix_Block	HTKLVRec/HLVRec-outP.c	/^LogFloat SOutP_ID_mix_Block(HMMSet *hset, int s, Observation *x, StreamElem *se)$/;"	f
SP	HTKLib/HArc.h	/^  Boolean SP; \/*short pause.  If (SP) rest of variables are NULL.*\/$/;"	m	struct:_Acoustic
SP	HTKLib/HRec.c	58;"	d	file:
SPCGLCHCOUNT	HTKLib/HParm.c	/^   SPCGLCHCOUNT,  \/* Speech glitch count *\/$/;"	e	enum:__anon142	file:
SPCSEQCOUNT	HTKLib/HParm.c	/^   SPCSEQCOUNT,   \/* Speech sequence count *\/$/;"	e	enum:__anon142	file:
SPEECHTHRESH	HTKLib/HParm.c	/^   SPEECHTHRESH,  \/* Speech detector threshold *\/$/;"	e	enum:__anon142	file:
SPLITP	HTKTools/HDMan.c	/^              REPLACEP, CONREPLACE, MERGEP, SPLITP, DELETEP, DELSOURCE, $/;"	e	enum:__anon191	file:
SPLLEV	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon200	file:
SQUASH	HLMLib/LGBase.h	41;"	d
SRAND	HTKLib/HMath.c	1624;"	d	file:
SRAND	HTKLib/HMath.c	1628;"	d	file:
SRISucks	HTKLVRec/kenlm/lm/search_trie.cc	/^    SRISucks() {$/;"	f	class:lm::ngram::trie::__anon58::SRISucks
SRISucks	HTKLVRec/kenlm/lm/search_trie.cc	/^class SRISucks {$/;"	c	namespace:lm::ngram::trie::__anon58	file:
SS	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon199	file:
ST	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon199	file:
STACKSIZE	HTKTools/HCopy.c	98;"	d	file:
STACKSIZE	HTKTools/HSLab.c	144;"	d	file:
STATE	HTKLib/HModel.c	/^   STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,$/;"	e	enum:__anon117	file:
STATE_KEY	HTKLib/HUtil.c	/^   TRANSP_KEY, STATE_KEY, DUR_KEY, WEIGHTS_KEY,$/;"	e	enum:__anon168	file:
STATICPRIOR	HTKTools/HMMIRest.c	/^static Boolean STATICPRIOR = FALSE;$/;"	v	file:
STATS_MAXT	HTKLVRec/HLVRec.h	158;"	d
STDIN_FILENO	HTKLVRec/kenlm/util/unistd.hh	10;"	d
STDOUT_FILENO	HTKLVRec/kenlm/util/unistd.hh	11;"	d
STLN_CON	HTKLVRec/HLVNet.c	/^  STLN_WORDEND, STLN_CON, STLN_MODEL$/;"	e	enum:_STLexNodeType	file:
STLN_MODEL	HTKLVRec/HLVNet.c	/^  STLN_WORDEND, STLN_CON, STLN_MODEL$/;"	e	enum:_STLexNodeType	file:
STLN_WORDEND	HTKLVRec/HLVNet.c	/^  STLN_WORDEND, STLN_CON, STLN_MODEL$/;"	e	enum:_STLexNodeType	file:
STLexLink	HTKLVRec/HLVNet.c	/^typedef struct _STLexLink STLexLink;$/;"	t	typeref:struct:_STLexLink	file:
STLexNode	HTKLVRec/HLVNet.c	/^typedef struct _STLexNode STLexNode;$/;"	t	typeref:struct:_STLexNode	file:
STLexNodeType	HTKLVRec/HLVNet.c	/^} STLexNodeType;$/;"	t	typeref:enum:_STLexNodeType	file:
STREAM	HTKLib/HModel.c	/^   STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,$/;"	e	enum:__anon117	file:
STREAMINFO	HTKLib/HModel.c	/^   NUMSTATES, STREAMINFO, VECSIZE, $/;"	e	enum:__anon117	file:
STREAM_KEY	HTKLib/HUtil.c	/^   MIX_KEY, MEAN_KEY, STREAM_KEY, COV_KEY$/;"	e	enum:__anon168	file:
STRINGARG	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	e	enum:__anon158
STR_ALLOC_SIZE	HTKLib/esig_asc.c	37;"	d	file:
STR_BG	HTKTools/HSLab.c	1148;"	d	file:
STR_FG	HTKTools/HSLab.c	1147;"	d	file:
STR_FIELD	HTKLib/HNet.c	/^typedef enum {UNK_FIELD, STR_FIELD, INT_FIELD, FLT_FIELD} LatFieldType;$/;"	e	enum:__anon136	file:
STriMat	HTKLib/HMem.h	/^typedef Matrix STriMat;    \/* shared matrix[1..nrows][1..i] (lower tri) *\/$/;"	t
STriMatElemSize	HTKLib/HMem.c	/^size_t STriMatElemSize(int size)$/;"	f
SU	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon199	file:
SUBDIRS	Makefile	/^SUBDIRS = $(HTKLIB) $(HLMLIB) $(HTKTOOLS) $(HLMTOOLS) $(LVREC) $(BOOK) $/;"	m
SUBLATHASHSIZE	HTKLib/HNet.c	308;"	d	file:
SUCCESS	HTKLib/HShell.h	/^typedef enum {FAIL=-1, SUCCESS=0} ReturnStatus;$/;"	e	enum:__anon151
SUN16_AUDIO	HTKLib/HAudio.c	107;"	d	file:
SUNAU8	HTKLib/HWave.h	/^        SUNAU8,            \/* Sun 8 bit MuLaw .au format *\/$/;"	e	enum:__anon181
SUNSO	HTKLib/HWave.c	/^   SUNSO,      \/* big-endian ie hi byte first *\/$/;"	e	enum:_SrcOrder	file:
SUPPORT_EXACT_CORRECTNESS	HTKLib/HExactMPE.h	38;"	d
SUPPORT_QUINPHONE	HTKLib/HFBLat.h	119;"	d
SVD	HTKLib/HMath.c	/^void SVD(DMatrix A, DMatrix U, DMatrix V, DVector d)$/;"	f
SVector	HTKLib/HMem.h	/^typedef Vector SVector;    \/* shared vector[1..size]   *\/$/;"	t
SVectorElemSize	HTKLib/HMem.c	/^size_t SVectorElemSize(int size){ return (size+1)*sizeof(float)+2*sizeof(Ptr); }$/;"	f
SW	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon199	file:
SWEIGHTS	HTKLib/HModel.c	/^   STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,$/;"	e	enum:__anon117	file:
SWITCHARG	HTKLib/HShell.h	/^typedef enum {SWITCHARG, STRINGARG, INTARG, FLOATARG, NOARG} ArgKind;$/;"	e	enum:__anon158
S_EOF	HTKLib/HLabel.c	/^   S_LBB, S_LBA, S_UTS, S_EOF$/;"	e	enum:_ScribeLab	file:
S_LBA	HTKLib/HLabel.c	/^   S_LBB, S_LBA, S_UTS, S_EOF$/;"	e	enum:_ScribeLab	file:
S_LBB	HTKLib/HLabel.c	/^   S_LBB, S_LBA, S_UTS, S_EOF$/;"	e	enum:_ScribeLab	file:
S_UTS	HTKLib/HLabel.c	/^   S_LBB, S_LBA, S_UTS, S_EOF$/;"	e	enum:_ScribeLab	file:
SafeCopyString	HTKLib/HNet.c	142;"	d	file:
SameArcs	HTKLib/HArc.c	/^Boolean SameArcs(LArc *a1, LArc *a2){ \/*word arcs have same times & phones *\/$/;"	f
SameGrams	HLMLib/LGBase.c	/^Boolean SameGrams(int N, NGram ng1, NGram ng2)$/;"	f
SameHGrams	HLMLib/LGBase.c	/^static Boolean SameHGrams(int N, NGram ng, LabId *tg)$/;"	f	file:
SameLinks	HTKTools/HParse.c	/^static Boolean SameLinks(int a1, int a2)$/;"	f	file:
SameTriphone	HTKTools/HHEd.c	/^MLink SameTriphone(HLink left, HLink right)$/;"	f
SampleType	HTKTools/HSLab.c	/^typedef signed short SampleType;$/;"	t	file:
SamplesInAudio	HTKLib/HAudio.c	/^int SamplesInAudio(AudioIn a)$/;"	f
SamplesToPlay	HTKLib/HAudio.c	/^int SamplesToPlay(AudioOut a)$/;"	f
SampsInAudioFrame	HTKLib/HAudio.c	/^int SampsInAudioFrame(AudioIn a)$/;"	f
SampsInWaveFrame	HTKLib/HWave.c	/^int SampsInWaveFrame(Wave w)$/;"	f
Sanity	HTKLVRec/kenlm/lm/binary_format.cc	/^struct Sanity {$/;"	s	namespace:lm::ngram::__anon41	file:
SanityCheckCounts	HTKLVRec/kenlm/lm/search_trie.cc	/^void SanityCheckCounts(const std::vector<uint64_t> &initial, const std::vector<uint64_t> &fixed) {$/;"	f	namespace:lm::ngram::trie::__anon58
SaveAllXForms	HTKLib/HModel.c	/^void SaveAllXForms(HMMSet *hset, char *fname, Boolean binary)$/;"	f
SaveBuffer	HTKLib/HParm.c	/^ReturnStatus SaveBuffer(ParmBuf pbuf, char *fname, FileFormat ff)$/;"	f
SaveClassMap	HLMLib/LCMap.c	/^void SaveClassMap(char *fn, ClassMap *c)$/;"	f
SaveCommandLine	HTKLib/HShell.c	/^static void SaveCommandLine(int argc, char **argv)$/;"	f	file:
SaveESPSLabels	HTKLib/HLabel.c	/^static void SaveESPSLabels( FILE *f, Transcription *t)$/;"	f	file:
SaveHMMList	HTKLib/HModel.c	/^ReturnStatus SaveHMMList(HMMSet *hset, char *fname)$/;"	f
SaveHMMSet	HTKLib/HModel.c	/^ReturnStatus SaveHMMSet(HMMSet *hset, char *hmmDir, char *hmmExt, char *macroExt, Boolean binary)$/;"	f
SaveHTKLabels	HTKLib/HLabel.c	/^static void SaveHTKLabels( FILE *f, Transcription *t) $/;"	f	file:
SaveInOneFile	HTKLib/HModel.c	/^void SaveInOneFile(HMMSet *hset, char *fname)$/;"	f
SaveInReplay	HTKLib/HAudio.c	/^static void SaveInReplay(AudioIn a, short x)$/;"	f	file:
SaveInputXForm	HTKLib/HModel.c	/^void SaveInputXForm(HMMSet *hset, InputXForm *xf, char *fname, Boolean binary)$/;"	f
SaveLabs	HTKTools/HCopy.c	/^void SaveLabs(char *tgt, Transcription *t)$/;"	f
SaveLangModel	HLMLib/LModel.c	/^void SaveLangModel(char *lmFn, BackOffLM *lm)$/;"	f
SaveLattice	HTKTools/HBuild.c	/^void SaveLattice(Lattice *lat, char *latFn, LatFormat format)$/;"	f
SaveLattice	HTKTools/HParse.c	/^static void SaveLattice(Lattice *lat, char *latFn, LatFormat format)$/;"	f	file:
SaveMacros	HTKLib/HModel.c	/^static void SaveMacros(FILE *f, HMMSet *hset, short fidx, Boolean binary)$/;"	f	file:
SaveModel	HTKTools/HCompV.c	/^void SaveModel(char *outfn)$/;"	f
SaveModel	HTKTools/HInit.c	/^void SaveModel(char *outfn)$/;"	f
SaveNGram	HLMLib/LModel.c	/^static int SaveNGram(FILE *f, int G, BackOffLM *lm)$/;"	f	file:
SaveOneXForm	HTKLib/HModel.c	/^void SaveOneXForm(HMMSet *hset, AdaptXForm *xform, char *fname, Boolean binary)$/;"	f
SaveOutBuffer	HLMTools/LGCopy.c	/^static void SaveOutBuffer(void)$/;"	f	file:
SaveToMasterfile	HTKLib/HLabel.c	/^ReturnStatus SaveToMasterfile(char *fname)$/;"	f
SaveUltraNGrams	HLMLib/LModel.c	/^static void SaveUltraNGrams(FILE *f, BackOffLM *lm)$/;"	f	file:
SaveWordMap	HLMLib/LWMap.c	/^void SaveWordMap(char *fn, WordMap *w, Boolean noHeader)$/;"	f
SavedMixes	HTKLib/HFBLat.c	/^static MixOcc *SavedMixes[SMAX]; \/* [1..S][1..nPDFs[s]] *\/$/;"	v	file:
SavedMixesSize	HTKLib/HFBLat.c	/^static int SavedMixesSize[SMAX]; $/;"	v	file:
SawUnk	HTKLVRec/kenlm/lm/vocab.hh	/^    bool SawUnk() const { return saw_unk_; }$/;"	f	class:lm::ngram::ProbingVocabulary
SawUnk	HTKLVRec/kenlm/lm/vocab.hh	/^    bool SawUnk() const { return saw_unk_; }$/;"	f	class:lm::ngram::SortedVocabulary
ScaleAccs	HTKLib/HTrain.c	/^double ScaleAccs(HMMSet *hset, float wt)$/;"	f
ScaleAccsParallel	HTKLib/HTrain.c	/^double ScaleAccsParallel(HMMSet *hset, float wt, int index)$/;"	f
ScalePDF	HTKLib/HTrain.c	/^double ScalePDF(MixPDF *mpdf, int vSize, int index, float wt)$/;"	f
ScanDict	HTKTools/HDMan.c	/^Boolean ScanDict(DBuffer *db, LabId reqd)$/;"	f
ScanLLF	HTKLib/HLat.c	/^Boolean ScanLLF (LLFInfo *llf, char *fn, char *ext)$/;"	f
Schar	HTKLib/esignal.h	/^typedef signed char			Schar;$/;"	t
ScharComplex	HTKLib/esignal.h	/^typedef struct {Schar	real, imag;}	ScharComplex;$/;"	t	typeref:struct:__anon186
Score	HTKLVRec/kenlm/lm/facade.hh	/^    float Score(const State &in_state, const WordIndex new_word, State &out_state) const {$/;"	f	class:lm::base::ModelFacade
ScoreExceptBackoff	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> FullScoreReturn GenericModel<Search, VocabularyT>::ScoreExceptBackoff($/;"	f	class:lm::ngram::detail::GenericModel
ScribeLab	HTKLib/HLabel.c	/^typedef enum _ScribeLab ScribeLab;$/;"	t	typeref:enum:_ScribeLab	file:
ScriptItem	HTKTools/HDMan.c	/^}ScriptItem;$/;"	t	typeref:struct:_ScriptItem	file:
ScriptItem	HTKTools/HLEd.c	/^}ScriptItem;$/;"	t	typeref:struct:_ScriptItem	file:
ScriptWord	HTKLib/HShell.c	/^static char * ScriptWord(void)$/;"	f	file:
ScriptWord	HTKTools/HERest.c	/^char *ScriptWord(FILE *script, char *scriptBuf)$/;"	f
SeekEnd	HTKLVRec/kenlm/util/file.cc	/^void SeekEnd(int fd) {$/;"	f	namespace:util
SeekOrThrow	HTKLVRec/kenlm/util/file.cc	/^void SeekOrThrow(int fd, uint64_t off) {$/;"	f	namespace:util
SegLength	HTKLib/HTrain.c	/^int SegLength(SegStore ss, int i)$/;"	f
SegStore	HTKLib/HTrain.h	/^typedef struct _SegStoreRec * SegStore;$/;"	t	typeref:struct:_SegStoreRec
SegStoreRec	HTKLib/HTrain.h	/^}SegStoreRec;$/;"	t	typeref:struct:_SegStoreRec
Select	HTKTools/HSGen.c	/^int Select(NodeId n, int nfoll, LogFloat *prob)$/;"	f
Semaphore	HTKLVRec/kenlm/util/pcqueue.hh	/^    explicit Semaphore(int value) : task_(mach_task_self()) {$/;"	f	class:util::Semaphore
Semaphore	HTKLVRec/kenlm/util/pcqueue.hh	/^class Semaphore {$/;"	c	namespace:util
Semi Tied Transform Estimation htool HERest	HTKBook/train.tex	/^\\subsection{Semi-Tied Transform Estimation (\\htool{HERest})}$/;"	b
Send	HTKLVRec/kenlm/lm/filter/count_io.hh	/^    template <class Output> void Send(Output &out) {$/;"	f	class:lm::CountBatch
Send	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Send(unsigned char begin, unsigned char order, const WordIndex *to, float prob_basis) {$/;"	f	class:lm::ngram::trie::__anon58::SRISucks
SendToEditBuffer	HLMTools/LGPrep.c	/^void SendToEditBuffer(LabId id)$/;"	f
Sentence	HTKLVRec/kenlm/lm/filter/phrase.cc	/^typedef unsigned int Sentence;$/;"	t	namespace:lm::phrase::__anon48	file:
SentenceRelation	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    struct SentenceRelation {$/;"	s	class:lm::phrase::Substrings
Sentences	HTKLVRec/kenlm/lm/filter/phrase.cc	/^typedef std::vector<Sentence> Sentences;$/;"	t	namespace:lm::phrase::__anon48	file:
SeparatelyQuantize	HTKLVRec/kenlm/lm/quantize.hh	/^    SeparatelyQuantize() {}$/;"	f	class:lm::ngram::SeparatelyQuantize
SeparatelyQuantize	HTKLVRec/kenlm/lm/quantize.hh	/^class SeparatelyQuantize {$/;"	c	namespace:lm::ngram
SeqMatch	HTKTools/HDMan.c	/^Boolean SeqMatch(int nMerge, LabId *list1, LabId *list2)$/;"	f
SeqMatch	HTKTools/HLEd.c	/^LLink SeqMatch(LLink l,int numIds, LabId *idList)$/;"	f
Sequence	HTKLVRec/kenlm/lm/filter/thread.hh	/^    uint64_t Sequence() const { return sequence_; }$/;"	f	class:lm::ThreadBatch
Sequence	HTKLib/HTrain.h	/^typedef SequenceInfo *Sequence;$/;"	t
SequenceCov	HTKLib/HTrain.c	/^void SequenceCov(Sequence ss, CovKind ck, Covariance cov, Vector mean)$/;"	f
SequenceInfo	HTKLib/HTrain.h	/^}SequenceInfo;$/;"	t	typeref:struct:__anon160
SequenceMean	HTKLib/HTrain.c	/^void SequenceMean(Sequence ss, Vector mean)$/;"	f
Set	HTKLVRec/kenlm/lm/filter/phrase.cc	/^void Arc::Set(Vertex &to, const Sentences &sentences) {$/;"	f	class:lm::phrase::detail::Arc
Set	HTKLVRec/kenlm/util/ersatz_progress.hh	/^    void Set(uint64_t to) {$/;"	f	class:util::ErsatzProgress
SetAInfo	HTKLib/HAdapt.c	/^static void SetAInfo(HMMSet *hset, AdaptXForm *xform, Boolean parent)$/;"	f	file:
SetAccCache	HTKLib/HAdapt.c	/^static void SetAccCache(AdaptXForm *xform)$/;"	f	file:
SetActive	HTKLib/HGraf.c	/^void SetActive(HButton *btnlst, Boolean active)$/;"	f
SetActive	HTKLib/HGraf.null.c	/^void SetActive(HButton *btnlst, Boolean active)$/;"	f
SetActive	HTKLib/HGraf_WIN32.c	/^void SetActive(HButton *btnlst, Boolean active)$/;"	f
SetActiveCount	HTKTools/HDMan.c	/^void SetActiveCount(void)$/;"	f
SetAlpha	HTKTools/HRest.c	/^LogDouble SetAlpha(int seg)$/;"	f
SetAudioSpDetParms	HTKLib/HParm.c	/^static void SetAudioSpDetParms(ParmBuf pbuf, float dur, Boolean warn)$/;"	f	file:
SetBarWidth	HTKTools/HList.c	/^void SetBarWidth(int itemWidth)$/;"	f
SetBaseAccsTime	HTKLib/HAdapt.c	/^void SetBaseAccsTime(int t)$/;"	f
SetBeamTaper	HTKLib/HFB.c	/^static void SetBeamTaper(PruneInfo *p, short *qDms, int Q, int T)$/;"	f	file:
SetBeta	HTKLib/HFB.c	/^static LogDouble SetBeta(AlphaBeta *ab, FBInfo *fbInfo, UttInfo *utt)$/;"	f	file:
SetBeta	HTKTools/HRest.c	/^LogDouble SetBeta(int seg)$/;"	f
SetBetaPlus	HTKLib/HFBLat.c	/^static void SetBetaPlus()$/;"	f	file:
SetButtonLit	HTKLib/HGraf.c	/^void SetButtonLit(HButton *btn, Boolean lit)$/;"	f
SetButtonLit	HTKLib/HGraf.null.c	/^void SetButtonLit(HButton *btn, Boolean lit)$/;"	f
SetButtonLit	HTKLib/HGraf_WIN32.c	/^void SetButtonLit(HButton *btn, Boolean lit)$/;"	f
SetCase	HTKTools/HDMan.c	/^static void SetCase(EdOp cmd, char *s)$/;"	f	file:
SetChannel	HTKLib/HParm.c	/^ReturnStatus SetChannel(char *confName)$/;"	f
SetClassWords	HLMLib/LCMap.c	/^static void SetClassWords(ClassEntry *ce, WordMap *wmap, int nItem, LabId *cword)$/;"	f	file:
SetCodeStyle	HTKLib/HParm.c	/^static void SetCodeStyle(IOConfig cf)$/;"	f	file:
SetConfParms	HLMTools/Cluster.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/HLMCopy.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LAdapt.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LBuild.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LFoF.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LGCopy.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LGList.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LGPrep.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LLink.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LMerge.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LNewMap.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LNorm.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LPlex.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HLMTools/LSubset.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKLVRec/HDecode.c	/^SetConfParms (void)$/;"	f
SetConfParms	HTKLVRec/HDecode.mod.c	/^SetConfParms (void)$/;"	f
SetConfParms	HTKTools/HBuild.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HCompV.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HCopy.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HDMan.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HERest.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HHEd.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HInit.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HLEd.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HLRescore.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HLStats.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HList.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HMMIRest.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HParse.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HQuant.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HRest.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HResults.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HSGen.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HSLab.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HSmooth.c	/^void SetConfParms(void)$/;"	f
SetConfParms	HTKTools/HVite.c	/^void SetConfParms(void)$/;"	f
SetCorrectness	HTKLib/HFBLat.c	/^static void SetCorrectness(FBLatInfo *fbInfo, Lattice *numLat){  $/;"	f	file:
SetCorrectnessAsError	HTKLib/HFBLat.c	/^static void SetCorrectnessAsError(FBLatInfo *fbInfo, Lattice *numLat){    \/* re the "CALCASERROR" option, other version of approx MPE. *\/$/;"	f	file:
SetCovKindUsage	HTKLib/HModel.c	/^void SetCovKindUsage (HMMSet *hset)$/;"	f
SetCovs	HTKTools/HCompV.c	/^void SetCovs(void)$/;"	f
SetDef	HLMTools/LGPrep.c	/^} SetDef;$/;"	t	typeref:struct:__anon29	file:
SetDoingFourthAcc	HTKLib/HFBLat.c	/^void SetDoingFourthAcc(Boolean DO, int indx){$/;"	f
SetEntryState	HTKLib/HRec.c	/^static void SetEntryState(NetNode *node,TokenSet *src)$/;"	f	file:
SetExtSpDetParms	HTKLib/HParm.c	/^static void SetExtSpDetParms(ParmBuf pbuf, float dur, Boolean warn)$/;"	f	file:
SetExtension	HTKLVRec/kenlm/lm/blank.hh	/^inline void SetExtension(float &backoff) {$/;"	f	namespace:lm::ngram
SetFD	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    void SetFD(int to) {$/;"	f	class:util::FakeOFStream
SetFieldOrdering	HTKLib/esignal.c	/^SetFieldOrdering(FieldList  *list,$/;"	f
SetGCStats	HTKTools/HHEd.c	/^void SetGCStats(void)$/;"	f
SetGDist	HTKTools/HHEd.c	/^void SetGDist(CLink *cvec, Matrix id, Matrix gd, int N)$/;"	f
SetHSetKindCommand	HTKTools/HHEd.c	/^void SetHSetKindCommand(void)$/;"	f
SetHeader	HTKLVRec/kenlm/lm/builder/output.hh	/^    void SetHeader(const HeaderInfo &header) { header_ = header; }$/;"	f	class:lm::builder::Output
SetHook	HTKLib/HMem.c	/^void SetHook(Ptr m, Ptr ptr)$/;"	f
SetIDist	HTKTools/HHEd.c	/^void SetIDist(CLink *cvec, Matrix id, int N, char type)$/;"	f
SetIndexes	HTKLib/HModel.c	/^void SetIndexes(HMMSet *hset)$/;"	f
SetInput	HTKLVRec/kenlm/util/read_compressed.cc	/^    void SetInput(const void *base, std::size_t amount) {$/;"	f	class:util::__anon79::BZip
SetInput	HTKLVRec/kenlm/util/read_compressed.cc	/^    void SetInput(const void *base, std::size_t amount) {$/;"	f	class:util::__anon79::GZip
SetInput	HTKLVRec/kenlm/util/read_compressed.cc	/^    void SetInput(const void *base, std::size_t amount) {$/;"	f	class:util::__anon79::XZip
SetInputXFormConfig	HTKLib/HParm.c	/^static void SetInputXFormConfig(IOConfig cf, InputXForm *xf)$/;"	f	file:
SetKey	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  void SetKey(WordIndex *to) { key = to; }$/;"	f	struct:lm::builder::__anon43::DedupeEntry
SetKey	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  void SetKey(uint64_t to) { key = to; }$/;"	f	struct:lm::builder::__anon43::VocabEntry
SetKey	HTKLVRec/kenlm/lm/vocab.hh	/^  void SetKey(uint64_t to) { key = to; }$/;"	f	struct:lm::ngram::ProbingVocabularyEntry
SetLabSeg	HTKTools/HCopy.c	/^void SetLabSeg(Transcription *tr)$/;"	f
SetLocation	HTKLVRec/kenlm/util/exception.cc	/^void Exception::SetLocation(const char *file, unsigned int line, const char *func, const char *child_name, const char *condition) {$/;"	f	class:util::Exception
SetMInfo	HTKLib/HAdapt.c	/^static void SetMInfo(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
SetMSize	HTKTools/HHEd.c	/^void SetMSize(STriMat m,int n)$/;"	f
SetMacroHook	HTKLib/HUtil.c	/^void SetMacroHook(MLink ml,Ptr hook)$/;"	f
SetMacroUse	HTKLib/HUtil.c	/^void SetMacroUse(MLink ml,int use)$/;"	f
SetMinDurs	HTKLib/HFB.c	/^void SetMinDurs(HMMSet *hset)$/;"	f
SetModelBetaPlus	HTKLib/HFBLat.c	/^void SetModelBetaPlus(int t, int q){$/;"	f
SetNEntryBO	HTKLVRec/HLVLM.c	/^void SetNEntryBO (FSLM *lm)$/;"	f
SetNGInfo	HLMLib/LGBase.c	/^static NGInfo SetNGInfo(int N)$/;"	f	file:
SetNewConfig	HTKLib/HParm.c	/^void SetNewConfig(char *confName)$/;"	f
SetNext	HLMLib/LGBase.c	/^static void SetNext(NGSource *ngs, Byte ngRawBuf[GSIZE])$/;"	f	file:
SetNodeOcc	HTKLib/HAdapt.c	/^static float SetNodeOcc(RegNode *node, BaseClass *bclass)$/;"	f	file:
SetNullContexts	HTKLib/HNet.c	/^void SetNullContexts(Lattice *lat,int xc)$/;"	f
SetNullLRecurse	HTKLib/HNet.c	/^void SetNullLRecurse(PronHolder *pInst,Lattice *lat,int xc)$/;"	f
SetNullRRecurse	HTKLib/HNet.c	/^void SetNullRRecurse(PronHolder *pInst,Lattice *lat,int xc)$/;"	f
SetObsCache	HTKLib/HAdapt.c	/^static void SetObsCache(AdaptXForm *xform, Boolean parent)$/;"	f	file:
SetOccSums	HTKTools/HHEd.c	/^Vector SetOccSums(CLink *cvec, int N)$/;"	f
SetOccr	HTKTools/HRest.c	/^void SetOccr(LogDouble pr, int seg)$/;"	f
SetOcct	HTKLib/HFB.c	/^static void SetOcct(HLink hmm, int q, Vector occt, Vector *occa,$/;"	f	file:
SetOutP	HTKTools/HRest.c	/^void SetOutP(int seg)$/;"	f
SetOutput	HTKLVRec/kenlm/util/read_compressed.cc	/^    void SetOutput(void *base, std::size_t amount) {$/;"	f	class:util::__anon79::BZip
SetOutput	HTKLVRec/kenlm/util/read_compressed.cc	/^    void SetOutput(void *base, std::size_t amount) {$/;"	f	class:util::__anon79::XZip
SetOutput	HTKLVRec/kenlm/util/read_compressed.cc	/^    void SetOutput(void *to, std::size_t amount) {$/;"	f	class:util::__anon79::GZip
SetParentXForm	HTKLib/HAdapt.c	/^void SetParentXForm(HMMSet *hset, AdaptXForm *xform)$/;"	f
SetParmHMMSet	HTKLib/HParm.c	/^void SetParmHMMSet(Ptr aset)$/;"	f
SetParsePhysicalHMM	HTKLib/HUtil.c	/^void SetParsePhysicalHMM(Boolean parse)$/;"	f
SetPhrase	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    void SetPhrase(detail::Vertex &from, detail::Vertex &to, const Sentences &intersect) {$/;"	f	class:lm::phrase::detail::Arc
SetProgressTarget	HTKLVRec/kenlm/util/stream/chain.hh	/^    void SetProgressTarget(uint64_t target) {$/;"	f	class:util::stream::Chain
SetPruningLevels	HTKLib/HRec.c	/^void SetPruningLevels(VRecInfo *vri,int maxBeam,LogFloat genBeam,$/;"	f
SetRest	HTKLVRec/kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *, unsigned int, RestWeights &weights) const {$/;"	f	class:lm::ngram::MaxRestBuild
SetRest	HTKLVRec/kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *, unsigned int, const Prob &\/*prob*\/) const {}$/;"	f	class:lm::ngram::LowerRestBuild
SetRest	HTKLVRec/kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *, unsigned int, const Prob &\/*prob*\/) const {}$/;"	f	class:lm::ngram::MaxRestBuild
SetRest	HTKLVRec/kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *, unsigned int, const Prob &\/*prob*\/) const {}$/;"	f	class:lm::ngram::NoRestBuild
SetRest	HTKLVRec/kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *, unsigned int, const ProbBackoff &) const {}$/;"	f	class:lm::ngram::NoRestBuild
SetRest	HTKLVRec/kenlm/lm/value_build.hh	/^    void SetRest(const WordIndex *vocab_ids, unsigned int n, RestWeights &weights) const {$/;"	f	class:lm::ngram::LowerRestBuild
SetRight	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    void SetRight(detail::Vertex &to, const Sentences &complete) {$/;"	f	class:lm::phrase::detail::Arc
SetSampKindCommand	HTKTools/HHEd.c	/^void SetSampKindCommand(void)$/;"	f
SetScriptFile	HTKLib/HShell.c	/^ReturnStatus SetScriptFile(char *fn)$/;"	f
SetSelfCalSpDetParms	HTKLib/HParm.c	/^static void SetSelfCalSpDetParms(ParmBuf pbuf)$/;"	f	file:
SetSemiTiedAvCov	HTKLib/HAdapt.c	/^static void SetSemiTiedAvCov(HMMSet *hset)$/;"	f	file:
SetSemiTiedVFloor	HTKLib/HModel.c	/^void SetSemiTiedVFloor(HMMSet *hset)$/;"	f
SetSet	HTKLib/HUtil.c	/^void SetSet(IntSet s)$/;"	f
SetSign	HTKLVRec/kenlm/util/bit_packing.hh	/^inline void SetSign(float &to) {$/;"	f	namespace:util
SetSilDetParms	HTKLib/HParm.c	/^static void SetSilDetParms(ParmBuf pbuf, TriState silMeasure)$/;"	f	file:
SetSize	HTKTools/HHEd.c	/^int SetSize(char *hname, StreamElem *ste \/*nMix must be +ve*\/, int tgt){ \/*returns nDefunct*\/$/;"	f
SetSpecial	HTKLVRec/kenlm/lm/virtual_interface.cc	/^void Vocabulary::SetSpecial(WordIndex begin_sentence, WordIndex end_sentence, WordIndex not_found) {$/;"	f	class:lm::base::Vocabulary
SetStartEnd	HTKLVRec/HLVLM.c	/^void SetStartEnd (FSLM *lm, char *startWord, char *endWord, Vocab *vocab)$/;"	f
SetStreamWidthCommand	HTKTools/HHEd.c	/^void SetStreamWidthCommand(void)$/;"	f
SetStreamWidths	HTKLib/HParm.c	/^void  SetStreamWidths(ParmKind pk, int size, short *swidth, Boolean *eSep)$/;"	f
SetTarget	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^void MultiProgress::SetTarget(uint64_t complete) {$/;"	f	class:util::stream::MultiProgress
SetToPoison	HTKLVRec/kenlm/util/stream/block.hh	/^    void SetToPoison() {$/;"	f	class:util::stream::Block
SetToReference	HTKLVRec/kenlm/lm/binary_format.cc	/^  void SetToReference() {$/;"	f	struct:lm::ngram::__anon41::OldSanity
SetToReference	HTKLVRec/kenlm/lm/binary_format.cc	/^  void SetToReference() {$/;"	f	struct:lm::ngram::__anon41::Sanity
SetTraceCommand	HTKTools/HHEd.c	/^void SetTraceCommand(void)$/;"	f
SetTraceFB	HTKLib/HFB.c	/^void SetTraceFB(void)$/;"	f
SetTreeName	HTKTools/HHEd.c	/^static void SetTreeName(char *name) {$/;"	f	file:
SetUpForCoding	HTKLib/HParm.c	/^static void SetUpForCoding(MemHeap *x, IOConfig cf, int frSize)$/;"	f	file:
SetUse	HTKLib/HMem.c	/^void SetUse(Ptr m,int n)$/;"	f
SetVFloor	HTKLib/HModel.c	/^void SetVFloor(HMMSet *hset, Vector *vFloor, float minVar)$/;"	f
SetVSize	HTKTools/HHEd.c	/^void SetVSize(SVector v,int n)$/;"	f
SetValidSize	HTKLVRec/kenlm/util/stream/block.hh	/^    void SetValidSize(std::size_t to) { valid_size_ = to; }$/;"	f	class:util::stream::Block
SetVocabFD	HTKLVRec/kenlm/lm/builder/output.hh	/^    void SetVocabFD(int to) { vocab_fd_ = to; }$/;"	f	class:lm::builder::Output
SetVol	HTKLib/HAudio.c	/^static void SetVol(AudioOut a, float volume)$/;"	f	file:
SetVolume	HTKLib/HAudio.c	/^void SetVolume(AudioOut a, int volume)$/;"	f
SetWaveSpDetParms	HTKLib/HParm.c	/^static void SetWaveSpDetParms(ParmBuf pbuf)$/;"	f	file:
SetXForm	HTKLib/HAdapt.c	/^void SetXForm(HMMSet *hset, AdaptXForm *xform)$/;"	f
Setotprob	HTKLib/HFB.c	/^static void Setotprob(AlphaBeta *ab, FBInfo *fbInfo, ParmBuf pbuf, $/;"	f	file:
Setotprob	HTKLib/HFBLat.c	/^static void Setotprob(int t)$/;"	f	file:
SetuFlags	HTKTools/HERest.c	/^void SetuFlags(void)$/;"	f
SetuFlags	HTKTools/HInit.c	/^void SetuFlags(void)$/;"	f
SetuFlags	HTKTools/HMMIRest.c	/^void SetuFlags(UPDSet *uFlags)$/;"	f
SetuFlags	HTKTools/HRest.c	/^void SetuFlags(void)$/;"	f
SetuFlags	HTKTools/HSmooth.c	/^void SetuFlags(void)$/;"	f
SetupJustVocab	HTKLVRec/kenlm/lm/binary_format.cc	/^void *BinaryFormat::SetupJustVocab(std::size_t memory_size, uint8_t order) {$/;"	f	class:lm::ngram::BinaryFormat
SetupMemory	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> void GenericModel<Search, VocabularyT>::SetupMemory(void *base, const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::detail::GenericModel
SetupMemory	HTKLVRec/kenlm/lm/quantize.cc	/^void SeparatelyQuantize::SetupMemory(void *base, unsigned char order, const Config &config) {$/;"	f	class:lm::ngram::SeparatelyQuantize
SetupMemory	HTKLVRec/kenlm/lm/quantize.hh	/^    void SetupMemory(void * \/*start*\/, unsigned char \/*order*\/, const Config & \/*config*\/) {}$/;"	f	class:lm::ngram::DontQuantize
SetupMemory	HTKLVRec/kenlm/lm/search_hashed.cc	/^template <class Value> uint8_t *HashedSearch<Value>::SetupMemory(uint8_t *start, const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::detail::HashedSearch
SetupMemory	HTKLVRec/kenlm/lm/search_trie.cc	/^template <class Quant, class Bhiksha> uint8_t *TrieSearch<Quant, Bhiksha>::SetupMemory(uint8_t *start, const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::trie::TrieSearch
SetupMemory	HTKLVRec/kenlm/lm/vocab.cc	/^void ProbingVocabulary::SetupMemory(void *start, std::size_t allocated) {$/;"	f	class:lm::ngram::ProbingVocabulary
SetupMemory	HTKLVRec/kenlm/lm/vocab.cc	/^void SortedVocabulary::SetupMemory(void *start, std::size_t allocated, std::size_t entries, const Config &config) {$/;"	f	class:lm::ngram::SortedVocabulary
SetupMemory	HTKLVRec/kenlm/lm/vocab.hh	/^    void SetupMemory(void *start, std::size_t allocated, std::size_t \/*entries*\/, const Config &\/*config*\/) {$/;"	f	class:lm::ngram::ProbingVocabulary
SetupSorts	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    template <class Compare> void SetupSorts(Sorts<Compare> &sorts) {$/;"	f	class:lm::builder::__anon47::Master
ShStrP	HTKLib/HFB.c	/^static float * ShStrP(HMMSet *hset, StreamElem *ste, Vector v, int t,$/;"	f	file:
ShStrP	HTKLib/HFBLat.c	/^static float * ShStrP(Vector v, int t, StreamElem *ste, AdaptXForm *xform, MemHeap *amem)$/;"	f	file:
Shift	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^  void Shift(int shift_amount) {$/;"	f	class:double_conversion::UInt128
Shift	HTKLVRec/kenlm/util/file_piece.cc	/^void FilePiece::Shift() {$/;"	f	class:util::FilePiece
ShiftLeft	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::ShiftLeft(int shift_amount) {$/;"	f	class:double_conversion::Bignum
ShiftReg	HLMTools/LAdapt.c	/^} ShiftReg;$/;"	t	typeref:struct:__anon26	file:
ShiftReg	HLMTools/LGPrep.c	/^} ShiftReg;$/;"	t	typeref:struct:__anon32	file:
Short2DProb	HTKLib/HModel.c	/^LogFloat Short2DProb(short s)$/;"	f
ShortComplex	HTKLib/esignal.h	/^typedef struct {short	real, imag;}	ShortComplex;$/;"	t	typeref:struct:__anon185
ShortVec	HTKLib/HMem.h	/^typedef short *ShortVec;   \/* short vector[1..size] *\/$/;"	t
ShortVecElemSize	HTKLib/HMem.c	/^size_t ShortVecElemSize(int size) { return (size+1)*sizeof(short); }$/;"	f
ShortVecSize	HTKLib/HMem.c	/^int ShortVecSize(ShortVec v)$/;"	f
ShowAbbrRawGram	HLMLib/LGBase.c	/^static void ShowAbbrRawGram(int N, NGram ng, WordMap *wm)$/;"	f	file:
ShowAbbrTxtGram	HLMLib/LGBase.c	/^static void ShowAbbrTxtGram(int N, LabId *ng)$/;"	f	file:
ShowAccs	HTKLib/HTrain.c	/^void ShowAccs(HMMSet *hset, UPDSet uFlags){ ShowAccsParallel(hset, uFlags, 0); }$/;"	f
ShowAccsParallel	HTKLib/HTrain.c	/^void ShowAccsParallel(HMMSet *hset, UPDSet uFlags, int index)$/;"	f
ShowAlignment	HTKTools/HInit.c	/^void ShowAlignment(int segNum, int segLen, IntVec states, IntVec *mixes)$/;"	f
ShowClassMap	HLMLib/LCMap.c	/^void ShowClassMap(ClassMap *c)$/;"	f
ShowClusterSet	HTKLib/HTrain.c	/^void ShowClusterSet(ClusterSet *cs)$/;"	f
ShowDB	HTKTools/HDMan.c	/^void ShowDB(DBuffer *db, char * title)$/;"	f
ShowDMatrix	HTKLib/HMath.c	/^void ShowDMatrix(char * title,DMatrix m,int maxCols,int maxRows)$/;"	f
ShowDVector	HTKLib/HMath.c	/^void ShowDVector(char * title, DVector v,int maxTerms)$/;"	f
ShowDict	HTKLib/HDict.c	/^void ShowDict(Vocab *voc)$/;"	f
ShowGFSons	HLMLib/LGBase.c	/^static void ShowGFSons(int N, GFLink gf, char * parent, WordMap *wm)$/;"	f	file:
ShowHMMSet	HTKTools/HHEd.c	/^void ShowHMMSet(void)$/;"	f
ShowInputSetTree	HLMLib/LGBase.c	/^static void ShowInputSetTree(NGInputSet *inset)$/;"	f	file:
ShowInputState	HLMLib/LGBase.c	/^static void ShowInputState(char *mess, NGInputSet *inset)$/;"	f	file:
ShowIntVec	HTKLib/HMath.c	/^void ShowIntVec(char * title, IntVec v,int maxTerms)$/;"	f
ShowLattice	HTKLib/HLat.c	/^void ShowLattice(Lattice *lat)$/;"	f
ShowMacros	HTKTools/HHEd.c	/^void ShowMacros(HMMDef *hmm)$/;"	f
ShowMatrix	HTKLib/HMath.c	/^void ShowMatrix(char * title,Matrix m,int maxCols,int maxRows)$/;"	f
ShowNgram	HLMTools/LGList.c	/^Boolean ShowNgram(int N, NGram ng)$/;"	f
ShowP	HTKTools/HInit.c	/^void ShowP(int col, Vector colVec)$/;"	f
ShowSegNum	HTKTools/HRest.c	/^void ShowSegNum(int seg)$/;"	f
ShowSeqMat	HTKTools/HInit.c	/^void ShowSeqMat(Sequence **seqMat)$/;"	f
ShowShortVec	HTKLib/HMath.c	/^void ShowShortVec(char * title, ShortVec v,int maxTerms)$/;"	f
ShowSizes	HTKLVRec/kenlm/lm/sizes.cc	/^void ShowSizes(const char *file, const lm::ngram::Config &config) {$/;"	f	namespace:lm::ngram
ShowSizes	HTKLVRec/kenlm/lm/sizes.cc	/^void ShowSizes(const std::vector<uint64_t> &counts) {$/;"	f	namespace:lm::ngram
ShowSizes	HTKLVRec/kenlm/lm/sizes.cc	/^void ShowSizes(const std::vector<uint64_t> &counts, const lm::ngram::Config &config) {$/;"	f	namespace:lm::ngram
ShowStats	HLMLib/LModel.c	/^static void ShowStats(FILE *f, AccessInfo *acs, char *lmstr)$/;"	f	file:
ShowTraceBack	HTKTools/HInit.c	/^void ShowTraceBack(int len, short **tB)$/;"	f
ShowTreesCommand	HTKTools/HHEd.c	/^void ShowTreesCommand(void)$/;"	f
ShowTriMat	HTKLib/HMath.c	/^void ShowTriMat(char * title,TriMat m,int maxCols,int maxRows)$/;"	f
ShowVector	HTKLib/HMath.c	/^void ShowVector(char * title,Vector v,int maxTerms)$/;"	f
ShowWaveInfo	HTKLib/HWave.c	/^static void ShowWaveInfo(Wave w)$/;"	f	file:
ShowWhere	HTKTools/HHEd.c	/^void ShowWhere(int state, int stream, int mix)$/;"	f
ShowWordMap	HLMLib/LWMap.c	/^void ShowWordMap(WordMap *w)$/;"	f
ShowWords	HTKLib/HNet.c	/^void ShowWords(Lattice *lat,Vocab *voc,HMMSetCxtInfo *hci)$/;"	f
ShrinkNode	HTKTools/HParse.c	/^static void ShrinkNode(Link p)$/;"	f	file:
Shrt2Prob	HLMLib/LModel.c	/^static float Shrt2Prob(UShort s)$/;"	f	file:
Sign	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  int Sign() const {$/;"	f	class:double_conversion::Double
Sign	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  int Sign() const {$/;"	f	class:double_conversion::Single
SignalFillBufferAndStopAudio	HTKLib/HAudio.c	/^static void SignalFillBufferAndStopAudio(AudioIn a)$/;"	f	file:
SignedZero	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^static double SignedZero(bool sign) {$/;"	f	namespace:double_conversion
Significand	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  uint32_t Significand() const {$/;"	f	class:double_conversion::Single
Significand	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  uint64_t Significand() const {$/;"	f	class:double_conversion::Double
SignificandSizeForOrderOfMagnitude	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static int SignificandSizeForOrderOfMagnitude(int order) {$/;"	f	class:double_conversion::Double
Single	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    explicit Single(const Words &vocab) : vocab_(vocab) {}$/;"	f	class:lm::vocab::Single
Single	HTKLVRec/kenlm/lm/filter/vocab.hh	/^class Single {$/;"	c	namespace:lm::vocab
Single	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  Single() : d32_(0) {}$/;"	f	class:double_conversion::Single
Single	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  explicit Single(float f) : d32_(float_to_uint32(f)) {}$/;"	f	class:double_conversion::Single
Single	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  explicit Single(uint32_t d32) : d32_(d32) {}$/;"	f	class:double_conversion::Single
Single	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^class Single {$/;"	c	namespace:double_conversion
SingleAddNGram	HTKLVRec/kenlm/lm/filter/format.hh	/^    template <class Iterator> void SingleAddNGram(size_t offset, const Iterator &begin, const Iterator &end, const StringPiece &line) {$/;"	f	class:lm::MultipleOutput
SingleAddNGram	HTKLVRec/kenlm/lm/filter/format.hh	/^    void SingleAddNGram(size_t offset, const StringPiece &line) {$/;"	f	class:lm::MultipleOutput
SingleAddNGram	HTKLVRec/kenlm/lm/filter/format.hh	/^    void SingleAddNGram(size_t offset, const StringPiece &line) {$/;"	f	class:lm::MultipleOutputBuffer
SingleCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    SingleCharacter() {}$/;"	f	class:util::SingleCharacter
SingleCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    explicit SingleCharacter(char delim) : delim_(delim) {}$/;"	f	class:util::SingleCharacter
SingleCharacter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^class SingleCharacter {$/;"	c	namespace:util
Singles	HTKLVRec/kenlm/lm/filter/format.hh	/^    typedef boost::ptr_vector<Single> Singles;$/;"	t	class:lm::MultipleOutput
SinglesIterator	HTKLVRec/kenlm/lm/filter/format.hh	/^    typedef typename Singles::iterator SinglesIterator;$/;"	t	class:lm::MultipleOutput
Sink	HTKLVRec/kenlm/util/stream/io.hh	/^    PWriteAndRecycle Sink() const {$/;"	f	class:util::stream::FileBuffer
Size	HTKLVRec/kenlm/lm/bhiksha.cc	/^uint64_t ArrayBhiksha::Size(uint64_t max_offset, uint64_t max_next, const Config &config) {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
Size	HTKLVRec/kenlm/lm/bhiksha.hh	/^    static uint64_t Size(uint64_t \/*max_offset*\/, uint64_t \/*max_next*\/, const Config &\/*config*\/) { return 0; }$/;"	f	class:lm::ngram::trie::DontBhiksha
Size	HTKLVRec/kenlm/lm/builder/print.hh	/^    std::size_t Size() const {$/;"	f	class:lm::builder::VocabReconstitute
Size	HTKLVRec/kenlm/lm/filter/format.hh	/^    size_t Size() { return actual_; }$/;"	f	class:lm::InputBuffer
Size	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> uint64_t GenericModel<Search, VocabularyT>::Size(const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::detail::GenericModel
Size	HTKLVRec/kenlm/lm/quantize.hh	/^    static uint64_t Size(uint8_t \/*order*\/, const Config &\/*config*\/) { return 0; }$/;"	f	class:lm::ngram::DontQuantize
Size	HTKLVRec/kenlm/lm/quantize.hh	/^    static uint64_t Size(uint8_t order, const Config &config) {$/;"	f	class:lm::ngram::SeparatelyQuantize
Size	HTKLVRec/kenlm/lm/search_hashed.hh	/^        static uint64_t Size(uint64_t count) {$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Size	HTKLVRec/kenlm/lm/search_hashed.hh	/^    static uint64_t Size(const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::detail::HashedSearch
Size	HTKLVRec/kenlm/lm/search_trie.hh	/^    static uint64_t Size(const std::vector<uint64_t> &counts, const Config &config) {$/;"	f	class:lm::ngram::trie::TrieSearch
Size	HTKLVRec/kenlm/lm/trie.cc	/^template <class Bhiksha> uint64_t BitPackedMiddle<Bhiksha>::Size(uint8_t quant_bits, uint64_t entries, uint64_t max_vocab, uint64_t max_ptr, const Config &config) {$/;"	f	class:lm::ngram::trie::BitPackedMiddle
Size	HTKLVRec/kenlm/lm/trie.hh	/^    static uint64_t Size(uint64_t count) {$/;"	f	class:lm::ngram::trie::Unigram
Size	HTKLVRec/kenlm/lm/trie.hh	/^    static uint64_t Size(uint8_t quant_bits, uint64_t entries, uint64_t max_vocab) {$/;"	f	class:lm::ngram::trie::BitPackedLongest
Size	HTKLVRec/kenlm/lm/vocab.cc	/^uint64_t ProbingVocabulary::Size(uint64_t entries, const Config &config) {$/;"	f	class:lm::ngram::ProbingVocabulary
Size	HTKLVRec/kenlm/lm/vocab.cc	/^uint64_t ProbingVocabulary::Size(uint64_t entries, float probing_multiplier) {$/;"	f	class:lm::ngram::ProbingVocabulary
Size	HTKLVRec/kenlm/lm/vocab.cc	/^uint64_t SortedVocabulary::Size(uint64_t entries, const Config &\/*config*\/) {$/;"	f	class:lm::ngram::SortedVocabulary
Size	HTKLVRec/kenlm/lm/vocab.hh	/^    WordIndex Size() const { return lookup_.Size(); }$/;"	f	class:lm::ngram::GrowableVocab
Size	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    static uint64_t Size(uint64_t entries, float multiplier) {$/;"	f	class:util::ProbingHashTable
Size	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    std::size_t Size() const {$/;"	f	class:util::AutoProbing
Size	HTKLVRec/kenlm/util/stream/io.hh	/^    uint64_t Size() const {$/;"	f	class:util::stream::FileBuffer
Size	HTKLVRec/kenlm/util/stream/sort.hh	/^    std::size_t Size() const {$/;"	f	class:util::stream::MergeQueue
Size	HTKLVRec/kenlm/util/stream/sort.hh	/^    uint64_t Size() const {$/;"	f	class:util::stream::Sort
SizeFile	HTKLVRec/kenlm/util/file.cc	/^uint64_t SizeFile(int fd) {$/;"	f	namespace:util
SizeInHexChars	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^static int SizeInHexChars(S number) {$/;"	f	namespace:double_conversion
SizeNeededForCounts	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^size_t SizeNeededForCounts(const std::vector<uint64_t> &number) {$/;"	f	namespace:lm
SizeNoSerialization	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    std::size_t SizeNoSerialization() const {$/;"	f	class:util::ProbingHashTable
SizeOrThrow	HTKLVRec/kenlm/util/file.cc	/^uint64_t SizeOrThrow(int fd) {$/;"	f	namespace:util
SizePage	HTKLVRec/kenlm/util/mmap.cc	/^long SizePage() {$/;"	f	namespace:util
SizeParseError	HTKLVRec/kenlm/util/usage.cc	/^    explicit SizeParseError(const std::string &str) throw() {$/;"	f	class:util::__anon84::SizeParseError
SizeParseError	HTKLVRec/kenlm/util/usage.cc	/^class SizeParseError : public Exception {$/;"	c	namespace:util::__anon84	file:
SizedCompare	HTKLVRec/kenlm/util/sized_iterator.hh	/^    explicit SizedCompare(const Delegate &delegate = Delegate()) : delegate_(delegate) {}$/;"	f	class:util::SizedCompare
SizedCompare	HTKLVRec/kenlm/util/sized_iterator.hh	/^template <class Delegate, class Proxy = SizedProxy> class SizedCompare : public std::binary_function<const Proxy &, const Proxy &, bool> {$/;"	c	namespace:util
SizedInnerIterator	HTKLVRec/kenlm/util/sized_iterator.hh	/^    SizedInnerIterator() {}$/;"	f	class:util::SizedInnerIterator
SizedInnerIterator	HTKLVRec/kenlm/util/sized_iterator.hh	/^    SizedInnerIterator(void *ptr, std::size_t size) : ptr_(static_cast<uint8_t*>(ptr)), size_(size) {}$/;"	f	class:util::SizedInnerIterator
SizedInnerIterator	HTKLVRec/kenlm/util/sized_iterator.hh	/^class SizedInnerIterator {$/;"	c	namespace:util
SizedIt	HTKLVRec/kenlm/util/sized_iterator.hh	/^inline SizedIterator SizedIt(void *ptr, std::size_t size) { return SizedIterator(SizedProxy(ptr, size)); }$/;"	f	namespace:util
SizedIterator	HTKLVRec/kenlm/util/sized_iterator.hh	/^typedef ProxyIterator<SizedProxy> SizedIterator;$/;"	t	namespace:util
SizedProxy	HTKLVRec/kenlm/util/sized_iterator.hh	/^    SizedProxy() {}$/;"	f	class:util::SizedProxy
SizedProxy	HTKLVRec/kenlm/util/sized_iterator.hh	/^    SizedProxy(void *ptr, std::size_t size) : inner_(ptr, size) {}$/;"	f	class:util::SizedProxy
SizedProxy	HTKLVRec/kenlm/util/sized_iterator.hh	/^class SizedProxy {$/;"	c	namespace:util
SkipComment	HTKLib/HShell.c	/^void SkipComment(Source *src)$/;"	f
SkipComment	HTKLib/esig_asc.c	/^SkipComment(FILE *file)$/;"	f	file:
SkipHeader	HTKTools/HBuild.c	/^Boolean SkipHeader(FILE *f)$/;"	f
SkipHeader	HTKTools/HDMan.c	/^void SkipHeader(Source *src, int skipHeaderLines)$/;"	f
SkipLine	HTKLib/HShell.c	/^Boolean SkipLine(Source *src)$/;"	f
SkipSpace	HTKLib/esig_asc.c	/^SkipSpace(int ch, FILE *file)$/;"	f	file:
SkipSpaces	HTKLVRec/kenlm/util/file_piece.hh	/^    void SkipSpaces(const bool *delim = kSpaces) {$/;"	f	class:util::FilePiece
SkipSpaces	HTKLVRec/kenlm/util/usage.cc	/^const char *SkipSpaces(const char *at) {$/;"	f	namespace:util::__anon83
SkipSpaces	HTKLib/HUtil.c	/^static void SkipSpaces(void)$/;"	f	file:
SkipSpacesEoln	HTKTools/HBuild.c	/^Boolean SkipSpacesEoln(FILE *f)$/;"	f
SkipToWord	HLMTools/LGPrep.c	/^char *SkipToWord(char *s)$/;"	f
SkipWhiteSpace	HTKLib/HShell.c	/^void SkipWhiteSpace(Source *src)$/;"	f
SliceTriMat	HTKTools/HHEd.c	/^Matrix SliceTriMat(Matrix mat, int i, int j)$/;"	f
SliceVector	HTKTools/HHEd.c	/^Vector SliceVector(Vector vec, int i, int j)$/;"	f
SmoothTransFromPriorHMM	HTKTools/HMMIRest.c	/^static void SmoothTransFromPriorHMM(int index, float Tau){$/;"	f	file:
SmoothWeightsFromPriorHMM	HTKTools/HMMIRest.c	/^static void SmoothWeightsFromPriorHMM(int index, float Tau){$/;"	f	file:
SmoothWtAcc	HTKTools/HSmooth.c	/^void SmoothWtAcc(StreamElem *ste, float l, int M)$/;"	f
SolveQuadratic	HTKTools/HMMIRest.c	/^Boolean SolveQuadratic(double a, double b, double c, double *ans1, double *ans2){$/;"	f
Sort	HTKLVRec/kenlm/util/stream/sort.hh	/^    Sort(Chain &in, const SortConfig &config, const Compare &compare = Compare(), const Combine &combine = Combine())$/;"	f	class:util::stream::Sort
Sort	HTKLVRec/kenlm/util/stream/sort.hh	/^template <class Compare, class Combine = NeverCombine> class Sort {$/;"	c	namespace:util::stream
SortAndReadTwice	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    void SortAndReadTwice(const std::vector<uint64_t> &counts, Sorts<ContextOrder> &sorts, util::stream::Chains &second, util::stream::ChainConfig second_config) {$/;"	f	class:lm::builder::__anon47::Master
SortArcs	HTKLib/HArc.c	/^void SortArcs( ArcInfo *aInfo )$/;"	f
SortConfig	HTKLVRec/kenlm/util/stream/config.hh	/^struct SortConfig {$/;"	s	namespace:util::stream
SortEntries	HTKLib/HVQ.c	/^static VQNode SortEntries(VQNode *list, short rootId)$/;"	f	file:
SortGFList	HLMLib/LGBase.c	/^static void SortGFList(NGInputSet *inset)$/;"	f	file:
SortNGBuffer	HLMLib/LGBase.c	/^void SortNGBuffer(NGBuffer *ngb)$/;"	f
SortOOV	HLMTools/LPlex.c	/^static int SortOOV(PStats *ps)$/;"	f	file:
SortOp	HTKTools/HLEd.c	/^void SortOp(LabList *rl)$/;"	f
SortWordMap	HLMLib/LWMap.c	/^void SortWordMap(WordMap *wm)$/;"	f
SortedFiles	HTKLVRec/kenlm/lm/trie_sort.cc	/^SortedFiles::SortedFiles(const Config &config, util::FilePiece &f, std::vector<uint64_t> &counts, size_t buffer, const std::string &file_prefix, SortedVocabulary &vocab) {$/;"	f	class:lm::ngram::trie::SortedFiles
SortedFiles	HTKLVRec/kenlm/lm/trie_sort.hh	/^class SortedFiles {$/;"	c	namespace:lm::ngram::trie
SortedUniformFind	HTKLVRec/kenlm/util/sorted_uniform.hh	/^template <class Iterator, class Accessor, class Pivot> bool SortedUniformFind(const Accessor &accessor, Iterator begin, Iterator end, const typename Accessor::Key key, Iterator &out) {$/;"	f	namespace:util
SortedVocabulary	HTKLVRec/kenlm/lm/vocab.cc	/^SortedVocabulary::SortedVocabulary() : begin_(NULL), end_(NULL), enumerate_(NULL) {}$/;"	f	class:lm::ngram::SortedVocabulary
SortedVocabulary	HTKLVRec/kenlm/lm/vocab.hh	/^class SortedVocabulary : public base::Vocabulary {$/;"	c	namespace:lm::ngram
Sorts	HTKLVRec/kenlm/lm/builder/sort.hh	/^    Sorts() {}$/;"	f	class:lm::builder::Sorts
Sorts	HTKLVRec/kenlm/lm/builder/sort.hh	/^    explicit Sorts(std::size_t number) : util::FixedArray<util::stream::Sort<Compare> >(number) {}$/;"	f	class:lm::builder::Sorts
Sorts	HTKLVRec/kenlm/lm/builder/sort.hh	/^template <class Compare> class Sorts : public util::FixedArray<util::stream::Sort<Compare> > {$/;"	c	namespace:lm::builder
Source	HTKLVRec/kenlm/util/stream/io.hh	/^    PRead Source() const {$/;"	f	class:util::stream::FileBuffer
Source	HTKLib/HShell.h	/^} Source;$/;"	t	typeref:struct:__anon154
SpMatch	HTKTools/HResults.c	/^Boolean SpMatch(char *spkrpat, char *spkr, char *str)$/;"	f
SpRMatch	HTKLib/HShell.c	/^static Boolean SpRMatch(char *s,char *p,char *spkr,$/;"	f	file:
SpRMatch	HTKTools/HResults.c	/^static Boolean SpRMatch(char *s,char *p,char *spkr,$/;"	f	file:
SpecLogModulus	HTKLib/HSigP.c	/^void SpecLogModulus(Vector s, Vector m, Boolean invert)$/;"	f
SpecModulus	HTKLib/HSigP.c	/^void SpecModulus(Vector s, Vector m)$/;"	f
SpecPhase	HTKLib/HSigP.c	/^void SpecPhase(Vector s, Vector m)$/;"	f
SpecialWordMissingException	HTKLVRec/kenlm/lm/lm_exception.cc	/^SpecialWordMissingException::SpecialWordMissingException() throw() {}$/;"	f	class:lm::SpecialWordMissingException
SpecialWordMissingException	HTKLVRec/kenlm/lm/lm_exception.hh	/^class SpecialWordMissingException : public VocabLoadException {$/;"	c	namespace:lm
Spkr	HTKTools/HResults.c	/^} Spkr;$/;"	t	typeref:struct:_Spkr	file:
SpkrAcc	HTKTools/HCompV.c	/^}SpkrAcc;                  $/;"	t	typeref:struct:__anon190	file:
SpkrAccListItem	HTKTools/HCompV.c	/^typedef struct SpkrAccListItem{$/;"	s	file:
SpkrAccListItem	HTKTools/HCompV.c	/^}SpkrAccListItem;$/;"	t	typeref:struct:SpkrAccListItem	file:
SpkrName	HTKTools/HCompV.c	/^   char SpkrName[MAXSTRLEN];             \/* speaker name *\/$/;"	m	struct:__anon190	file:
SplitLevels	HTKTools/HLEd.c	/^Transcription *SplitLevels(LabList *rl)$/;"	f
SplitMix	HTKTools/HHEd.c	/^void SplitMix(MixtureElem *mi,MixtureElem *m01,MixtureElem *m02,int vSize)$/;"	f
SplitName	HTKTools/HParse.c	/^}SplitName;$/;"	t	typeref:struct:__anon206	file:
SplitPath	HTKLib/HLabel.c	/^static void SplitPath(char *path, char *name, char *subdir, char *tryspec)$/;"	f	file:
SplitPhon	HTKTools/HDMan.c	/^void SplitPhon(Pronunciation *p, int nArgs, LabId *args)$/;"	f
SplitPhoneOp	HTKTools/HDMan.c	/^void SplitPhoneOp(WordBuf *wb, int nArgs, LabId *args)$/;"	f
SplitStreamCommand	HTKTools/HHEd.c	/^void SplitStreamCommand(Boolean userWidths)$/;"	f
SplitStreams	HTKTools/HHEd.c	/^void SplitStreams(HMMSet *hset,StateInfo *si,Boolean simple,Boolean first)$/;"	f
SplitTreeNode	HTKTools/HHEd.c	/^void SplitTreeNode(Tree *tree, Node *node)$/;"	f
SplitTriName	HTKTools/HParse.c	/^static void SplitTriName(LabId n, SplitName *x)$/;"	f	file:
SplitVectors	HTKLib/HTrain.c	/^static void SplitVectors(int n, int n1, int n2)$/;"	f	file:
SpotRec	HTKTools/HResults.c	/^} SpotRec;$/;"	t	typeref:struct:_SpotRec	file:
Square	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::Square() {$/;"	f	class:double_conversion::Bignum
SrcOrder	HTKLib/HWave.c	/^}SrcOrder;$/;"	t	typeref:enum:_SrcOrder	file:
SrcPosition	HTKLib/HShell.c	/^char *SrcPosition(Source src, char *s)$/;"	f
StackInitialised	HTKLib/HArc.c	/^Boolean StackInitialised=FALSE;$/;"	v
Start	HTKLVRec/kenlm/util/stream/chain.cc	/^void Chain::Start() {$/;"	f	class:util::stream::Chain
StartAudi	HTKLib/HAudio.c	/^static void StartAudi(AudioIn a)$/;"	f	file:
StartAudioInput	HTKLib/HAudio.c	/^void StartAudioInput(AudioIn a, int sig)$/;"	f
StartAudioOutput	HTKLib/HAudio.c	/^void StartAudioOutput(AudioOut a, long nSamples, short *buf)$/;"	f
StartAudioSignal	HTKLib/HAudio.c	/^static void StartAudioSignal(void)$/;"	f	file:
StartBlock	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    void StartBlock() {$/;"	f	class:lm::builder::__anon42::CollapseStream	file:
StartBlock	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    void StartBlock() {$/;"	f	class:lm::builder::__anon45::PruneNGramStream	file:
StartBlock	HTKLVRec/kenlm/util/stream/stream.hh	/^    void StartBlock() {$/;"	f	class:util::stream::Stream
StartBuffer	HTKLib/HParm.c	/^void StartBuffer(ParmBuf pbuf)$/;"	f
StartOfWord	HTKLib/HArc.h	215;"	d
StartOfWord	HTKLib/HExactMPE.c	93;"	d	file:
StartOfWord	HTKLib/HFBLat.c	133;"	d	file:
StartRecognition	HTKLib/HRec.c	/^void StartRecognition(VRecInfo *vri,Network *net,$/;"	f
StartSentence	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    void StartSentence() {$/;"	f	class:lm::builder::__anon43::Writer
StartTime	HTKLib/HFBLat.c	/^static int StartTime=0;     \/* This is a value that we use to help calculating the PreComp's of$/;"	v	file:
Started	HTKLVRec/kenlm/util/usage.cc	/^    const Wall &Started() const {$/;"	f	class:util::__anon83::RecordStart
StatCollector	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    StatCollector(std::size_t order, std::vector<uint64_t> &counts, std::vector<uint64_t> &counts_pruned, std::vector<Discount> &discounts)$/;"	f	class:lm::builder::__anon42::StatCollector
StatCollector	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^class StatCollector {$/;"	c	namespace:lm::builder::__anon42	file:
StatReport	HTKTools/HERest.c	/^void StatReport(HMMSet *hset)$/;"	f
StatReport	HTKTools/HMMIRest.c	/^void StatReport(void) \/*This is used by other programs so I have had to change it back to how it was.*\/$/;"	f
StatReport	HTKTools/HSmooth.c	/^void StatReport(void)$/;"	f
State	HTKLVRec/kenlm/lm/facade.hh	/^    typedef StateT State;$/;"	t	class:lm::base::ModelFacade
State	HTKLVRec/kenlm/lm/state.hh	/^class State {$/;"	c	namespace:lm::ngram
State	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^struct State {$/;"	s	namespace:lm::np
StateDistance	HTKTools/HHEd.c	/^float StateDistance(ILink i1, ILink i2)$/;"	f
StateElem	HTKLib/HModel.h	/^} StateElem;$/;"	t	typeref:struct:__anon127
StateInfo	HTKLib/HModel.h	/^} StateInfo;$/;"	t	typeref:struct:__anon126
StateInfo_lv	HTKLVRec/HLVModel.h	/^typedef struct _StateInfo_lv StateInfo_lv;$/;"	t	typeref:struct:_StateInfo_lv
StateSize	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    size_t StateSize() const { return state_size_; }$/;"	f	class:lm::base::Model
StaticAssertionPassed	HTKLVRec/kenlm/util/bit_packing.cc	/^template <> struct StaticCheck<true> { typedef bool StaticAssertionPassed; };$/;"	t	struct:util::__anon64::StaticCheck	file:
StaticCheck	HTKLVRec/kenlm/util/bit_packing.cc	/^template <> struct StaticCheck<true> { typedef bool StaticAssertionPassed; };$/;"	s	namespace:util::__anon64	file:
StaticCheck	HTKLVRec/kenlm/util/bit_packing.cc	/^template <bool> struct StaticCheck {};$/;"	s	namespace:util::__anon64	file:
Stats	HTKLVRec/HLVRec.h	/^typedef struct _Stats Stats;    \/* statistics about pruning etc. *\/$/;"	t	typeref:struct:_Stats
StatsInfo	HTKLib/HLat.c	/^} StatsInfo;$/;"	t	typeref:struct:_StatsInfo	file:
StealCompleted	HTKLVRec/kenlm/util/stream/sort.hh	/^    int StealCompleted() {$/;"	f	class:util::stream::Sort
StealUnigram	HTKLVRec/kenlm/lm/trie_sort.hh	/^    int StealUnigram() {$/;"	f	class:lm::ngram::trie::SortedFiles
Step 1 Generation of Initial Maximum Likelihood Models	HTKBook/exampsys.tex	/^\\subsection{Step 1 - Generation of Initial Maximum Likelihood Models} $/;"	b
Step 1 the Task Grammar	HTKBook/exampsys.tex	/^\\subsection{Step 1 - the Task Grammar}$/;"	b
Step 14 Evaluation of the Adapted System	HTKBook/exampsys.tex	/^\\subsection{Step 14 - Evaluation of the Adapted System}$/;"	b
Step 2 Training Data LM Creation	HTKBook/exampsys.tex	/^\\subsection{Step 2 - Training Data LM Creation}$/;"	b
Step 2 the Dictionary	HTKBook/exampsys.tex	/^\\subsection{Step 2 - the Dictionary}$/;"	b
Step 3 Recording the Data	HTKBook/exampsys.tex	/^\\subsection{Step 3 - Recording the Data}$/;"	b
Step 3 Word Lattice Creation	HTKBook/exampsys.tex	/^\\subsection{Step 3 - Word Lattice Creation} $/;"	b
Step 4 Creating the Transcription Files	HTKBook/exampsys.tex	/^\\subsection{Step 4 - Creating the Transcription Files}$/;"	b
Step 4 Phone Marking of Numerator and Denominator Lattices	HTKBook/exampsys.tex	/^\\subsection{Step 4 - Phone Marking of Numerator and Denominator$/;"	b
Step 5 Coding the Data	HTKBook/exampsys.tex	/^\\subsection{Step 5 - Coding the Data}$/;"	b
Step 5 Generating Discriminatively Trained Models	HTKBook/exampsys.tex	/^\\subsection{Step 5 - Generating Discriminatively Trained Models} $/;"	b
Step 6 Creating Flat Start Monophones	HTKBook/exampsys.tex	/^\\subsection{Step 6 - Creating Flat Start Monophones}$/;"	b
Step 7 Fixing the Silence Models	HTKBook/exampsys.tex	/^\\subsection{Step 7 - Fixing the Silence Models}$/;"	b
Step 8 Realigning the Training Data	HTKBook/exampsys.tex	/^\\subsection{Step 8 - Realigning the Training Data}$/;"	b
Step 9 Making Triphones from Monophones	HTKBook/exampsys.tex	/^\\subsection{Step 9 - Making Triphones from Monophones}$/;"	b
StepAlpha	HTKLib/HFB.c	/^static void StepAlpha(AlphaBeta *ab, int t, int *start, int *end, $/;"	f	file:
StepAlpha	HTKLib/HFBLat.c	/^static void StepAlpha(int t)$/;"	f	file:
StepBack	HTKLib/HFB.c	/^static Boolean StepBack(FBInfo *fbInfo, UttInfo *utt, char * datafn)$/;"	f	file:
StepBar	HTKTools/HSLab.c	/^static void StepBar(BarType *bar, int pos)$/;"	f	file:
StepForward	HTKLib/HFB.c	/^static void StepForward(FBInfo *fbInfo, UttInfo *utt)$/;"	f	file:
StepForward	HTKLib/HFBLat.c	/^static void StepForward()$/;"	f	file:
StepHMM1	HTKLib/HRec.c	/^static void StepHMM1(NetNode *node) \/* Model internal propagation NBEST *\/$/;"	f	file:
StepHMM2	HTKLib/HRec.c	/^static void StepHMM2(NetNode *node) $/;"	f	file:
StepInst1	HTKLib/HRec.c	/^static void StepInst1(NetNode *node) \/* First pass of token propagation (Internal) *\/$/;"	f	file:
StepInst2	HTKLib/HRec.c	/^static void StepInst2(NetNode *node) \/* Second pass of token propagation (External) *\/$/;"	f	file:
StepWord1	HTKLib/HRec.c	/^static void StepWord1(NetNode *node) \/* Just invalidate the tokens *\/$/;"	f	file:
StepWord2	HTKLib/HRec.c	/^static void StepWord2(NetNode *node) \/* Update the path - may be repeated *\/$/;"	f	file:
StopAndFlushAudio	HTKLib/HAudio.c	/^static void StopAndFlushAudio(AudioIn a, Boolean deferred)$/;"	f	file:
StopAudi	HTKLib/HAudio.c	/^static void StopAudi(AudioIn a)$/;"	f	file:
StopAudioInput	HTKLib/HAudio.c	/^void StopAudioInput(AudioIn a)$/;"	f
StopAudioSignal	HTKLib/HAudio.c	/^static void StopAudioSignal(void)$/;"	f	file:
StopBuffer	HTKLib/HParm.c	/^void StopBuffer(ParmBuf pbuf)$/;"	f
Storage	HTKLVRec/kenlm/lm/neural/wordvecs.hh	/^    typedef Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor> Storage;$/;"	t	class:lm::neural::WordVecs
StoreAdaptCov	HTKLib/HAdapt.c	/^static Boolean StoreAdaptCov(AdaptXForm *xform)$/;"	f	file:
StoreAdaptMean	HTKLib/HAdapt.c	/^static Boolean StoreAdaptMean(AdaptXForm *xform)$/;"	f	file:
StoreESIGFieldList	HTKLib/HWave.c	/^void StoreESIGFieldList(HFieldList fList)$/;"	f
StoreFEA	HLMLib/LModel.c	/^void StoreFEA(FLEntry *fe, MemHeap *heap)$/;"	f
StoreItem	HTKLib/HTrain.c	/^void StoreItem(Sequence seq, Ptr item)$/;"	f
StoreMLFEntry	HTKLib/HLabel.c	/^static void StoreMLFEntry(MLFEntry *e)$/;"	f	file:
StoreNGram	HLMLib/LGBase.c	/^Boolean StoreNGram(NGBuffer *ngb, NGram ng)$/;"	f
StoreOOV	HLMTools/LPlex.c	/^static void StoreOOV(PStats *ps, LabId wdid, int count)$/;"	f	file:
StoreObsCache	HTKLib/HAdapt.c	/^static Boolean StoreObsCache(AdaptXForm *xform)$/;"	f	file:
StoreSEA	HLMLib/LModel.c	/^void StoreSEA(FLEntry *fe, MemHeap *heap)$/;"	f
StoreTree	HTKLib/HVQ.c	/^static void StoreTree(FILE *f, VQNode n, CovKind ck, short s)$/;"	f	file:
StoreVQTab	HTKLib/HVQ.c	/^void StoreVQTab(VQTable vqTab, char *tabFN)$/;"	f
Str2AdaptKind	HTKLib/HModel.c	/^AdaptKind Str2AdaptKind(char *str)$/;"	f
Str2BaseClassKind	HTKLib/HModel.c	/^BaseClassKind Str2BaseClassKind(char *str)$/;"	f
Str2Format	HTKLib/HWave.c	/^FileFormat Str2Format(char *fmt)$/;"	f
Str2ParmKind	HTKLib/HParm.c	/^ParmKind Str2ParmKind(char *str)$/;"	f
Str2XFormKind	HTKLib/HModel.c	/^XFormKind Str2XFormKind(char *str)$/;"	f
StrArrFromRect	HTKLib/strarr.c	/^StrArrFromRect(long *dim, void *data)$/;"	f
StrArrLen	HTKLib/strarr.c	/^StrArrLen(char **str_arr)$/;"	f
StrArrMaxLen	HTKLib/strarr.c	/^StrArrMaxLen(char **str_arr)$/;"	f
StrArrToRect	HTKLib/strarr.c	/^StrArrToRect(char **strarr, long **dimenp, void **datap)$/;"	f
StrCKind	HTKLib/HShell.h	/^   StrCKind,            \/* string, optionally in dble quotes *\/$/;"	e	enum:__anon155
StrDup	HTKLib/esignal.c	/^StrDup(char *str)$/;"	f
StrLength	HTKLVRec/kenlm/util/double-conversion/utils.h	/^inline int StrLength(const char* string) {$/;"	f	namespace:double_conversion
Stream	HTKLVRec/kenlm/util/read_compressed.cc	/^    const bz_stream &Stream() const { return stream_; }$/;"	f	class:util::__anon79::BZip
Stream	HTKLVRec/kenlm/util/read_compressed.cc	/^    const lzma_stream &Stream() const { return stream_; }$/;"	f	class:util::__anon79::XZip
Stream	HTKLVRec/kenlm/util/read_compressed.cc	/^    const z_stream &Stream() const { return stream_; }$/;"	f	class:util::__anon79::GZip
Stream	HTKLVRec/kenlm/util/stream/stream.hh	/^    Stream() : current_(NULL), end_(NULL) {}$/;"	f	class:util::stream::Stream
Stream	HTKLVRec/kenlm/util/stream/stream.hh	/^    explicit Stream(const ChainPosition &position) {$/;"	f	class:util::stream::Stream
Stream	HTKLVRec/kenlm/util/stream/stream.hh	/^class Stream : boost::noncopyable {$/;"	c	namespace:util::stream
StreamCompressed	HTKLVRec/kenlm/util/read_compressed.cc	/^    StreamCompressed(int fd, const void *already_data, std::size_t already_size)$/;"	f	class:util::__anon79::StreamCompressed
StreamCompressed	HTKLVRec/kenlm/util/read_compressed.cc	/^template <class Compression> class StreamCompressed : public ReadBase {$/;"	c	namespace:util::__anon79	file:
StreamElem	HTKLib/HModel.h	/^}StreamElem;$/;"	t	typeref:struct:__anon125
Streams	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^typedef GenericStreams<Stream> Streams;$/;"	t	namespace:util::stream
StringBuilder	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  StringBuilder(char* buffer, int size)$/;"	f	class:double_conversion::StringBuilder
StringBuilder	HTKLVRec/kenlm/util/double-conversion/utils.h	/^class StringBuilder {$/;"	c	namespace:double_conversion
StringPiece	HTKLVRec/kenlm/util/string_piece.hh	/^  StringPiece() : ptr_(NULL), length_(0) { }$/;"	f	class:StringPiece
StringPiece	HTKLVRec/kenlm/util/string_piece.hh	/^  StringPiece(const char* offset, size_type len)$/;"	f	class:StringPiece
StringPiece	HTKLVRec/kenlm/util/string_piece.hh	/^  StringPiece(const char* str)$/;"	f	class:StringPiece
StringPiece	HTKLVRec/kenlm/util/string_piece.hh	/^  StringPiece(const std::string& str)$/;"	f	class:StringPiece
StringPiece	HTKLVRec/kenlm/util/string_piece.hh	/^class StringPiece {$/;"	c
StringPieceCompatibleEquals	HTKLVRec/kenlm/util/string_piece_hash.hh	/^struct StringPieceCompatibleEquals : public std::binary_function<const StringPiece &, const std::string &, bool> {$/;"	s
StringPieceCompatibleHash	HTKLVRec/kenlm/util/string_piece_hash.hh	/^struct StringPieceCompatibleHash : public std::unary_function<const StringPiece &, size_t> {$/;"	s
StringToDouble	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  double StringToDouble(const char* buffer,$/;"	f	class:double_conversion::StringToDoubleConverter
StringToDoubleConverter	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  StringToDoubleConverter(int flags,$/;"	f	class:double_conversion::StringToDoubleConverter
StringToDoubleConverter	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^class StringToDoubleConverter {$/;"	c	namespace:double_conversion
StringToFloat	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  float StringToFloat(const char* buffer,$/;"	f	class:double_conversion::StringToDoubleConverter
StringToIeee	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^double StringToDoubleConverter::StringToIeee($/;"	f	class:double_conversion::StringToDoubleConverter
Strtod	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^double Strtod(Vector<const char> buffer, int exponent) {$/;"	f	namespace:double_conversion
Strtof	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^float Strtof(Vector<const char> buffer, int exponent) {$/;"	f	namespace:double_conversion
SubCorrectness	HTKLib/HExactMPE.c	/^static float SubCorrectness = -1;   \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
SubFieldOrder	HTKLib/esignal.c	/^SubFieldOrder(FieldList list, char *prefix)$/;"	f	file:
SubLArc	HTKLib/HLat.c	/^typedef struct _SubLArc SubLArc;$/;"	t	typeref:struct:_SubLArc	file:
SubLNode	HTKLib/HLat.c	/^typedef struct _SubLNode SubLNode;$/;"	t	typeref:struct:_SubLNode	file:
SubLatDef	HTKLib/HNet.h	/^} SubLatDef;$/;"	t	typeref:struct:sublatdef
SubLatList	HTKLib/HNet.c	/^Lattice *SubLatList(Lattice *lat, Lattice *tail, int depth)$/;"	f
SubLattice	HTKLib/HNet.c	/^void SubLattice(Lattice *newlat,NodeId thisNode, NodeId latStart,NodeId latEnd)$/;"	f
SubNetDef	HTKTools/HParse.c	/^} SubNetDef;$/;"	t	typeref:struct:_SubNetDef	file:
SubVector	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  Vector<T> SubVector(int from, int to) {$/;"	f	class:double_conversion::Vector
SubstFName	HTKLib/HShell.c	/^void SubstFName(char *fname, char *s)$/;"	f
SubstituteSubNet	HTKTools/HParse.c	/^static void SubstituteSubNet(HPNetwork *subNet, Link p)$/;"	f	file:
Substrings	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    Substrings() {}$/;"	f	class:lm::phrase::Substrings
Substrings	HTKLVRec/kenlm/lm/filter/phrase.hh	/^class Substrings {$/;"	c	namespace:lm::phrase
Subsume	HTKLVRec/kenlm/lm/partial.hh	/^template <class Model> float Subsume(const Model &model, Left &first_left, const Right &first_right, const Left &second_left, Right &second_right, const unsigned int between_length) {$/;"	f	namespace:lm::ngram
Subtract	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  void Subtract(const DiyFp& other) {$/;"	f	class:double_conversion::DiyFp
Subtract	HTKLVRec/kenlm/util/usage.cc	/^double Subtract(const struct timespec &first, const struct timespec &second) {$/;"	f	namespace:util::__anon83
Subtract	HTKLVRec/kenlm/util/usage.cc	/^double Subtract(const struct timeval &first, const struct timeval &second) {$/;"	f	namespace:util::__anon83
Subtract	HTKLVRec/kenlm/util/usage.cc	/^double Subtract(time_t first, time_t second) {$/;"	f	namespace:util::__anon83
SubtractBignum	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::SubtractBignum(const Bignum& other) {$/;"	f	class:double_conversion::Bignum
SubtractTimes	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::SubtractTimes(const Bignum& other, int factor) {$/;"	f	class:double_conversion::Bignum
SuffixOrder	HTKLVRec/kenlm/lm/builder/sort.hh	/^    explicit SuffixOrder(std::size_t order) : Comparator<SuffixOrder>(order) {}$/;"	f	class:lm::builder::SuffixOrder
SuffixOrder	HTKLVRec/kenlm/lm/builder/sort.hh	/^class SuffixOrder : public Comparator<SuffixOrder> {$/;"	c	namespace:lm::builder
SumWtChain	HTKTools/HSmooth.c	/^float SumWtChain(WALink wa, Vector v, int dBlk, int M)$/;"	f
SummarisePruning	HTKLib/HFB.c	/^static void SummarisePruning(PruneInfo *p, int Q, int T)$/;"	f	file:
Summary	HTKLVRec/kenlm/lm/ngram_query.hh	/^  void Summary(double ppl_including_oov, double ppl_excluding_oov, uint64_t corpus_oov, uint64_t corpus_tokens) {$/;"	f	struct:lm::ngram::FullPrint
Summary	HTKLVRec/kenlm/lm/ngram_query.hh	/^  void Summary(double, double, uint64_t, uint64_t) {}$/;"	f	struct:lm::ngram::BasicPrint
Summary	HTKTools/HDMan.c	/^void Summary(void)$/;"	f
Summary	HTKTools/HHEd.c	/^void Summary(void)$/;"	f
Summary	HTKTools/HLEd.c	/^void Summary(void)$/;"	f
SunAU8Header	HTKLib/HWave.c	/^} SunAU8Header;$/;"	t	typeref:struct:__anon176	file:
SwapAdaptXForms	HTKLib/HAdapt.c	/^static void SwapAdaptXForms(AdaptXForm *xform, AdaptXForm *paxform)$/;"	f	file:
SwapInt32	HTKLib/HShell.c	/^void SwapInt32(int32 *p)$/;"	f
SwapLists	HTKTools/HHEd.c	/^void SwapLists(HMMSet *set,HMMSet *list)$/;"	f
SwapMLLRCovMLLRMean	HTKLib/HAdapt.c	/^static void SwapMLLRCovMLLRMean(AdaptXForm *xform, AdaptXForm *paxform)$/;"	f	file:
SwapMacro	HTKTools/HHEd.c	/^void SwapMacro(HMMSet *hset,char type,Ptr o, Ptr n)$/;"	f
SwapNodeNames	HTKTools/HParse.c	/^void SwapNodeNames(Link l1, Link l2)$/;"	f
SwapSN	HTKTools/HParse.c	/^void SwapSN(SplitName *sn1, SplitName *sn2)$/;"	f
SwapShort	HTKLib/HShell.c	/^void SwapShort(short *p)$/;"	f
SwapXForm	HTKLib/HAdapt.c	/^static void SwapXForm(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
SweepAltPaths	HTKLVRec/HLVRec-GC.c	/^static void SweepAltPaths (MemHeap *heap)$/;"	f	file:
SweepModPaths	HTKLVRec/HLVRec-GC.c	/^static void SweepModPaths (MemHeap *heap)$/;"	f	file:
SweepPaths	HTKLVRec/HLVRec-GC.c	/^static void SweepPaths (MemHeap *heap)$/;"	f	file:
Symbol	HTKLib/HModel.c	/^} Symbol;$/;"	t	typeref:enum:__anon117	file:
SyncBuffers	HTKLib/HParm.c	/^Boolean SyncBuffers(ParmBuf pbuf,ParmBuf pbuf2)$/;"	f
SyncOrThrow	HTKLVRec/kenlm/util/mmap.cc	/^void SyncOrThrow(void *start, size_t length) {$/;"	f	namespace:util
SyncStr	HLMLib/LModel.c	/^void SyncStr(Source *src, char *str)$/;"	f
SyncStr	HTKLib/HLM.c	/^static void SyncStr(char *buf,char *str)$/;"	f	file:
Syntax and Semantics	HTKBook/labels.tex	/^\\subsection{Syntax and Semantics}$/;"	b
SynthModel	HTKTools/HHEd.c	/^HMMDef *SynthModel(LabId id)$/;"	f
T	HTKLVRec/kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<2> { typedef Pivot32 T; };$/;"	t	struct:util::PivotSelect
T	HTKLVRec/kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<4> { typedef Pivot32 T; };$/;"	t	struct:util::PivotSelect
T	HTKLVRec/kenlm/util/sorted_uniform.hh	/^template <> struct PivotSelect<8> { typedef Pivot64 T; };$/;"	t	struct:util::PivotSelect
T	HTKLib/HArc.h	/^  int T;       \/* time is 1..T. *\/$/;"	m	struct:ArcInfoStruct
T	HTKLib/HFB.h	/^  int T;              \/* number of frames in utterance *\/$/;"	m	struct:__anon96
T	HTKLib/HFBLat.h	/^  int T;$/;"	m	struct:__anon102
T	HTKTools/HRest.c	/^static int maxT,minT,T;    \/* max,min and current segment lengths *\/$/;"	v	file:
T	HTKTools/HSLab.c	/^static long  T;              \/* number of samples *\/$/;"	v	file:
TAR	Makefile	/^TAR = gtar$/;"	m
TARGETFORMAT	HTKLib/HParm.c	/^   TARGETFORMAT,  \/* FileFormat *\/$/;"	e	enum:__anon142	file:
TARGETKIND	HTKLib/HParm.c	/^   TARGETKIND,    \/* ParmKind *\/$/;"	e	enum:__anon142	file:
TARGETRATE	HTKLib/HParm.c	/^   TARGETRATE,    \/* Target sample rate in 100ns *\/$/;"	e	enum:__anon142	file:
TB	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon199	file:
TC	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon199	file:
TCTXT	HTKTools/HDMan.c	/^              TCTXT, APPSIL, REMSTRESS, REPLACEW, RAWMODE, $/;"	e	enum:__anon191	file:
TCTXT	HTKTools/HLEd.c	/^   RCTXT,   TCTXT,  SETLEV, DELLEV, SPLLEV, ISIL,$/;"	e	enum:__anon200	file:
TCtxtOp	HTKTools/HDMan.c	/^void TCtxtOp(WordBuf *wb, int nArgs,LabId *args)$/;"	f
TDistance	HTKTools/HHEd.c	/^float TDistance(StreamElem *s1, StreamElem *s2)$/;"	f
TFuncX11	HTKLib/HGraf.c	/^static int   TFuncX11[4] = {$/;"	v	file:
THIRDWINDOW	HTKLib/HParm.c	/^   THIRDWINDOW,$/;"	e	enum:__anon142	file:
THREEACCS	HTKTools/HMMIRest.c	/^static Boolean THREEACCS = FALSE;  \/*  Set TRUE if 3 sets of accs need to be stored (for MPE, or possibly for MMI-MAP) *\/$/;"	v	file:
THROW_UP	HTKLVRec/kenlm/lm/lm_exception.hh	/^typedef enum {THROW_UP, COMPLAIN, SILENT} WarningAction;$/;"	e	enum:lm::__anon51
TI	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon199	file:
TIEDHS	HTKLib/HModel.h	/^enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};$/;"	e	enum:_HSetKind
TIMES_LABELLED	HTKTools/HSLab.c	103;"	d	file:
TIMIT	HTKLib/HWave.h	/^        TIMIT,             \/* Prototype TIMIT database *\/$/;"	e	enum:__anon181
TIMIT Label Files	HTKBook/labels.tex	/^\\subsection{TIMIT Label Files}$/;"	b
TIMIThdr	HTKLib/HWave.c	/^} TIMIThdr;$/;"	t	typeref:struct:__anon173	file:
TLexConNode	HTKLVRec/HLVNet.h	/^typedef struct _TLexNode TLexConNode;$/;"	t	typeref:struct:_TLexNode
TLexLink	HTKLVRec/HLVNet.h	/^typedef struct _TLexLink TLexLink;$/;"	t	typeref:struct:_TLexLink
TLexNet	HTKLVRec/HLVNet.h	/^} TLexNet;$/;"	t	typeref:struct:_TLexNet
TLexNode	HTKLVRec/HLVNet.h	/^typedef struct _TLexNode TLexNode;$/;"	t	typeref:struct:_TLexNode
TMAttachAccs	HTKLib/HTrain.c	/^void TMAttachAccs(HMMSet *hset, MemHeap *x, int nPara)$/;"	f
TMIX	HTKLib/HModel.c	/^   STATE, TMIX, MIXTURE, STREAM, SWEIGHTS,$/;"	e	enum:__anon117	file:
TMProb	HTKLib/HModel.h	/^}TMProb;$/;"	t	typeref:struct:__anon123
TMShowAccs	HTKLib/HTrain.c	/^void TMShowAccs(HMMSet *hset, int index)$/;"	f
TMZeroAccs	HTKLib/HTrain.c	/^void TMZeroAccs(HMMSet *hset, int start, int end)$/;"	f
TMixRec	HTKLib/HModel.h	/^} TMixRec;$/;"	t	typeref:struct:__anon124
TNODE	HTKLib/HModel.c	/^   RCLASS=110, REGTREE, NODE, TNODE,$/;"	e	enum:__anon117	file:
TOK_LMSTATE_EQ	HTKLVRec/HLVRec.h	128;"	d
TOK_LMSTATE_LT	HTKLVRec/HLVRec.h	125;"	d
TPI	HTKLib/HMath.h	41;"	d
TR	HTKTools/HHEd.c	/^                         LS , QS , TB , TR , AU , GQ , MD , ST , LT ,$/;"	e	enum:__anon199	file:
TRANSP	HTKLib/HModel.c	/^   DURATION, INVDIAGCOV, TRANSP, DPROB, LLTCOV, LLTCOVAR,$/;"	e	enum:__anon117	file:
TRANSP_KEY	HTKLib/HUtil.c	/^   TRANSP_KEY, STATE_KEY, DUR_KEY, WEIGHTS_KEY,$/;"	e	enum:__anon168	file:
TRCOMMA	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TREE	HTKLib/HModel.h	/^enum _AdaptKind {TREE, BASE};$/;"	e	enum:_AdaptKind
TREOF	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TREOL	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TRIE	HTKLVRec/kenlm/lm/model_type.hh	/^typedef enum {PROBING=0, REST_PROBING=1, TRIE=2, QUANT_TRIE=3, ARRAY_TRIE=4, QUANT_ARRAY_TRIE=5} ModelType;$/;"	e	enum:lm::ngram::__anon54
TRIE_SORTED	HTKLVRec/kenlm/lm/model_type.hh	/^const ModelType TRIE_SORTED = TRIE;$/;"	m	namespace:lm::ngram
TRINDEX	HLMLib/LModel.c	791;"	d	file:
TRIST	HTKTools/HLEd.c	/^   REPLACE, CHANGE, FIND,   MERGE,  EDOP_DELETE, DEFCON, TRIST,  $/;"	e	enum:__anon200	file:
TRI_UNDEF	HTKLib/HParm.h	/^   TRI_UNDEF=-1     \/* -1 *\/$/;"	e	enum:__anon146
TRLEV	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TRNULL	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TRNUM	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TRSTR	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	e	enum:_TrSymbol	file:
TRUE	HTKLib/HShell.h	/^typedef enum {FALSE=0, TRUE=1} Boolean;$/;"	e	enum:__anon152
TRUE	HTKLib/HShell.h	90;"	d
TRUE	HTKLib/esignal.h	48;"	d
TRUE_dup	HTKLib/HParm.h	/^   TRUE_dup=TRUE,   \/*  1 *\/$/;"	e	enum:__anon146
TSIDOPT	HTKLVRec/config.h	56;"	d
TSIDOPT	HTKLVRec/config.h	59;"	d
TSIDOPT	HTKLVRec/config.h	74;"	d
TYPE_ORDER	HTKLib/esignal.h	97;"	d
T_ACC	HTKLib/HAdapt.c	58;"	d	file:
T_ACCESS	HTKLVRec/HLVLM.c	54;"	d	file:
T_ACTIV	HTKLVRec/HLVRec.c	67;"	d	file:
T_ADP	HTKLVRec/HDecode.c	66;"	d	file:
T_ADP	HTKLVRec/HDecode.mod.c	67;"	d	file:
T_ADT	HTKLib/HAdapt.c	57;"	d	file:
T_ALD	HTKLib/HTrain.c	61;"	d	file:
T_ALF	HTKLib/HFB.c	59;"	d	file:
T_ALF	HTKTools/HRest.c	51;"	d	file:
T_ALL	HTKLib/HNet.c	55;"	d	file:
T_ALN	HTKTools/HInit.c	52;"	d	file:
T_ARC	HTKLib/HArc.c	56;"	d	file:
T_ARC2	HTKLib/HArc.c	57;"	d	file:
T_AUD	HTKLib/HAudio.c	37;"	d	file:
T_BAS	HTKTools/HHEd.c	64;"	d	file:
T_BAS	HTKTools/HLStats.c	48;"	d	file:
T_BAS	HTKTools/HResults.c	42;"	d	file:
T_BEST	HTKLVRec/HLVRec.c	63;"	d	file:
T_BET	HTKTools/HRest.c	52;"	d	file:
T_BID	HTKTools/HHEd.c	87;"	d	file:
T_BIG	HTKTools/HLStats.c	50;"	d	file:
T_BOND	HLMTools/Cluster.c	59;"	d	file:
T_BTR	HTKLib/HModel.c	61;"	d	file:
T_BUF	HTKLib/HParm.c	57;"	d	file:
T_CAL	HTKLib/HTrain.c	58;"	d	file:
T_CDI	HTKLib/HTrain.c	59;"	d	file:
T_CGE	HTKLib/HTrain.c	55;"	d	file:
T_CHK	HTKLib/HModel.c	55;"	d	file:
T_CHOP	HTKTools/HLEd.c	47;"	d	file:
T_CHP	HTKLib/HMem.c	36;"	d	file:
T_CLC	HTKLib/HTrain.c	56;"	d	file:
T_CLUST	HTKTools/HQuant.c	48;"	d	file:
T_CLUSTERS	HTKTools/HHEd.c	75;"	d	file:
T_CMDX	HTKTools/HLEd.c	46;"	d	file:
T_CML	HLMLib/LCMap.c	48;"	d	file:
T_CMV	HTKTools/HCompV.c	71;"	d	file:
T_CNT	HTKTools/HInit.c	54;"	d	file:
T_COVS	HTKTools/HCompV.c	68;"	d	file:
T_CPX	HTKLib/HParm.c	58;"	d	file:
T_CST	HTKLib/HNet.c	53;"	d	file:
T_CXT	HTKLib/HNet.c	52;"	d	file:
T_DCM	HTKLib/HTrain.c	57;"	d	file:
T_DET	HTKLib/HAudio.c	36;"	d	file:
T_DET	HTKLib/HParm.c	62;"	d	file:
T_DET	HTKTools/HHEd.c	66;"	d	file:
T_DET	HTKTools/HSGen.c	43;"	d	file:
T_DIC	HTKLib/HDict.c	37;"	d	file:
T_DIC	HTKTools/HLEd.c	52;"	d	file:
T_DLEV	HTKTools/HLEd.c	49;"	d	file:
T_DSOP	HTKTools/HDMan.c	54;"	d	file:
T_DWOP	HTKTools/HDMan.c	55;"	d	file:
T_EDIN	HTKTools/HLEd.c	50;"	d	file:
T_EDW0	HTKTools/HDMan.c	50;"	d	file:
T_EDW1	HTKTools/HDMan.c	51;"	d	file:
T_EVN	HTKTools/HResults.c	43;"	d	file:
T_EXF	HTKLib/HShell.c	54;"	d	file:
T_EXP	HTKLib/HLat.c	60;"	d	file:
T_EXTRA	HLMTools/Cluster.c	58;"	d	file:
T_FB	HTKLib/HLat.c	59;"	d	file:
T_FIL	HTKTools/HLStats.c	51;"	d	file:
T_FILE	HLMTools/Cluster.c	57;"	d	file:
T_FOF	HLMLib/LGBase.c	53;"	d	file:
T_FOF	HLMLib/LPCalc.c	47;"	d	file:
T_FRS	HTKLib/HAdapt.c	64;"	d	file:
T_FRS	HTKTools/HVite.c	61;"	d	file:
T_GC	HTKLVRec/HLVRec.c	70;"	d	file:
T_GMX	HTKLib/HModel.c	62;"	d	file:
T_HASH	HLMLib/LUtil.c	47;"	d	file:
T_HASH	HTKLib/HLabel.c	39;"	d	file:
T_HDR	HLMLib/LUtil.c	46;"	d	file:
T_HPMEMSTAT	HTKTools/HParse.c	93;"	d	file:
T_HPNET	HTKTools/HParse.c	92;"	d	file:
T_HPREMGLUE	HTKTools/HParse.c	94;"	d	file:
T_HTKL	HTKLib/HLabel.c	38;"	d	file:
T_IND	HTKTools/HHEd.c	86;"	d	file:
T_INP	HLMTools/LAdapt.c	62;"	d	file:
T_INP	HLMTools/LGPrep.c	59;"	d	file:
T_INT	HTKTools/HHEd.c	65;"	d	file:
T_INT	HTKTools/HSmooth.c	43;"	d	file:
T_IOP	HTKLib/HShell.c	53;"	d	file:
T_IST	HLMLib/LGBase.c	52;"	d	file:
T_ITM	HTKLib/HUtil.c	53;"	d	file:
T_ITM	HTKTools/HHEd.c	67;"	d	file:
T_ITR	HLMLib/LGBase.c	50;"	d	file:
T_KINDS	HTKTools/HCopy.c	39;"	d	file:
T_LAT	HTKLVRec/HLVRec.c	69;"	d	file:
T_LAT	HTKTools/HLRescore.c	58;"	d	file:
T_LD0	HTKTools/HInit.c	48;"	d	file:
T_LD0	HTKTools/HRest.c	48;"	d	file:
T_LD1	HTKTools/HInit.c	49;"	d	file:
T_LD1	HTKTools/HRest.c	49;"	d	file:
T_LGP	HTKTools/HRest.c	62;"	d	file:
T_LLF	HTKLib/HLat.c	63;"	d	file:
T_LOAD	HLMLib/LModel.c	51;"	d	file:
T_LOAD	HTKTools/HCompV.c	69;"	d	file:
T_LOAD	HTKTools/HQuant.c	46;"	d	file:
T_MAC	HTKLib/HModel.c	59;"	d	file:
T_MAC	HTKTools/HHEd.c	71;"	d	file:
T_MAC	HTKTools/HRest.c	55;"	d	file:
T_MAP	HTKTools/HERest.c	76;"	d	file:
T_MAPS	HLMLib/LModel.c	53;"	d	file:
T_MAT	HTKLib/HLabel.c	36;"	d	file:
T_MAT	HTKLib/HParm.c	63;"	d	file:
T_MD	HTKTools/HHEd.c	88;"	d	file:
T_MEAN	HTKTools/HQuant.c	45;"	d	file:
T_MEL	HTKLib/HSigP.c	51;"	d	file:
T_MEM	HLMTools/Cluster.c	60;"	d	file:
T_MEM	HLMTools/LGPrep.c	63;"	d	file:
T_MEM	HTKLVRec/HDecode.c	67;"	d	file:
T_MEM	HTKLVRec/HDecode.mod.c	68;"	d	file:
T_MEM	HTKLVRec/HLVRec.c	71;"	d	file:
T_MEM	HTKLib/HLat.c	61;"	d	file:
T_MEM	HTKTools/HCopy.c	41;"	d	file:
T_MEM	HTKTools/HHEd.c	68;"	d	file:
T_MEM	HTKTools/HLEd.c	51;"	d	file:
T_MEM	HTKTools/HLRescore.c	59;"	d	file:
T_MEM	HTKTools/HLStats.c	49;"	d	file:
T_MEM	HTKTools/HResults.c	47;"	d	file:
T_MEM	HTKTools/HVite.c	62;"	d	file:
T_MHASH	HTKLib/HLabel.c	35;"	d	file:
T_MHP	HTKLib/HMem.c	35;"	d	file:
T_MIX	HTKLib/HFB.c	62;"	d	file:
T_MIX	HTKTools/HInit.c	53;"	d	file:
T_MLF	HTKLib/HLabel.c	34;"	d	file:
T_MMU	HTKTools/HVite.c	63;"	d	file:
T_MOD	HTKLib/HNet.c	54;"	d	file:
T_MOP	HLMLib/LGBase.c	51;"	d	file:
T_MRE	HTKTools/HRest.c	60;"	d	file:
T_MRG	HTKLib/HLat.c	64;"	d	file:
T_NAC	HTKLib/HTrain.c	60;"	d	file:
T_NET	HTKLVRec/HLVNet.c	60;"	d	file:
T_NETCON	HTKLVRec/HLVNet.c	61;"	d	file:
T_NGEN	HTKLib/HRec.c	41;"	d	file:
T_NKY	HTKTools/HResults.c	45;"	d	file:
T_NPHN	HTKTools/HDMan.c	53;"	d	file:
T_OBC	HTKLib/HAdapt.c	62;"	d	file:
T_OBP	HTKTools/HInit.c	55;"	d	file:
T_OBS	HTKLVRec/HDecode.c	65;"	d	file:
T_OBS	HTKLVRec/HDecode.mod.c	66;"	d	file:
T_OBS	HTKLib/HParm.c	61;"	d	file:
T_OBS	HTKTools/HVite.c	60;"	d	file:
T_OCC	HTKLib/HFB.c	60;"	d	file:
T_OCC	HTKLib/HUtil.c	54;"	d	file:
T_OCC	HTKTools/HRest.c	53;"	d	file:
T_OOV	HLMTools/LPlex.c	59;"	d	file:
T_OPEN	HTKLib/HWave.c	103;"	d	file:
T_OPT	HTKLib/HFB.c	57;"	d	file:
T_OPT	HTKTools/HSmooth.c	44;"	d	file:
T_ORP	HTKLib/HModel.c	60;"	d	file:
T_OTP	HTKTools/HRest.c	50;"	d	file:
T_OUT	HTKLib/HFB.c	63;"	d	file:
T_PAR	HTKLib/HModel.c	57;"	d	file:
T_PBS	HTKLib/HParm.c	59;"	d	file:
T_PMP	HTKLib/HModel.c	58;"	d	file:
T_PROB	HLMLib/LModel.c	54;"	d	file:
T_PROB	HLMLib/LPMerge.c	48;"	d	file:
T_PROB	HLMTools/LPlex.c	60;"	d	file:
T_PROP	HTKLVRec/HLVRec.c	68;"	d	file:
T_PRU	HTKLib/HFB.c	58;"	d	file:
T_PRUN	HTKLib/HLat.c	58;"	d	file:
T_PRUNE	HTKLVRec/HLVRec.c	66;"	d	file:
T_QST	HTKTools/HHEd.c	76;"	d	file:
T_QUA	HTKLib/HParm.c	60;"	d	file:
T_RDSC	HTKTools/HLEd.c	45;"	d	file:
T_RIN	HLMTools/LGPrep.c	61;"	d	file:
T_RUL	HLMTools/LGPrep.c	62;"	d	file:
T_RUN	HTKLib/HAudio.c	38;"	d	file:
T_SAV	HLMTools/LAdapt.c	61;"	d	file:
T_SAV	HLMTools/LGCopy.c	58;"	d	file:
T_SAV	HLMTools/LGPrep.c	58;"	d	file:
T_SAV	HTKLib/HLabel.c	40;"	d	file:
T_SAVE	HLMLib/LModel.c	52;"	d	file:
T_SCPT	HTKTools/HDMan.c	52;"	d	file:
T_SEGMENT	HTKTools/HCopy.c	40;"	d	file:
T_SEGS	HTKTools/HCompV.c	70;"	d	file:
T_SEGS	HTKTools/HQuant.c	47;"	d	file:
T_SEL	HLMTools/LPlex.c	61;"	d	file:
T_SENT	HLMTools/LPlex.c	58;"	d	file:
T_SEQ	HTKLib/HTrain.c	54;"	d	file:
T_SHR	HLMTools/LAdapt.c	63;"	d	file:
T_SHR	HLMTools/LGPrep.c	60;"	d	file:
T_SIZ	HTKTools/HHEd.c	72;"	d	file:
T_SLEV	HTKTools/HLEd.c	48;"	d	file:
T_SPK	HTKTools/HResults.c	44;"	d	file:
T_SPT	HTKTools/HResults.c	46;"	d	file:
T_SQU	HLMLib/LGBase.c	48;"	d	file:
T_SRT	HLMLib/LGBase.c	49;"	d	file:
T_SRT	HLMLib/LWMap.c	48;"	d	file:
T_STC	HTKLib/HAudio.c	35;"	d	file:
T_STK	HTKLib/HMem.c	37;"	d	file:
T_SUBD	HTKLib/HLabel.c	37;"	d	file:
T_SWP	HTKLib/HAdapt.c	63;"	d	file:
T_SXF	HTKLib/HAdapt.c	61;"	d	file:
T_TAB	HTKTools/HQuant.c	49;"	d	file:
T_TAC	HTKTools/HRest.c	54;"	d	file:
T_TIM	HTKLib/HFB.c	66;"	d	file:
T_TIM	HTKLib/HFBLat.c	77;"	d	file:
T_TIM	HTKTools/HMMIRest.c	69;"	d	file:
T_TIO	HTKLib/HLM.c	47;"	d	file:
T_TMX	HTKLib/HFB.c	65;"	d	file:
T_TOK	HTKLib/HModel.c	56;"	d	file:
T_TOKSTATS	HTKLVRec/HLVRec.c	65;"	d	file:
T_TOP	HLMLib/LCMap.c	47;"	d	file:
T_TOP	HLMLib/LGBase.c	47;"	d	file:
T_TOP	HLMLib/LModel.c	50;"	d	file:
T_TOP	HLMLib/LPCalc.c	46;"	d	file:
T_TOP	HLMLib/LPMerge.c	47;"	d	file:
T_TOP	HLMLib/LPMerge.c	53;"	d	file:
T_TOP	HLMLib/LUtil.c	45;"	d	file:
T_TOP	HLMLib/LWMap.c	46;"	d	file:
T_TOP	HLMTools/Cluster.c	56;"	d	file:
T_TOP	HLMTools/HLMCopy.c	55;"	d	file:
T_TOP	HLMTools/LAdapt.c	60;"	d	file:
T_TOP	HLMTools/LBuild.c	49;"	d	file:
T_TOP	HLMTools/LFoF.c	57;"	d	file:
T_TOP	HLMTools/LGCopy.c	57;"	d	file:
T_TOP	HLMTools/LGList.c	47;"	d	file:
T_TOP	HLMTools/LGPrep.c	57;"	d	file:
T_TOP	HLMTools/LLink.c	42;"	d	file:
T_TOP	HLMTools/LMerge.c	56;"	d	file:
T_TOP	HLMTools/LNewMap.c	42;"	d	file:
T_TOP	HLMTools/LNorm.c	54;"	d	file:
T_TOP	HLMTools/LPlex.c	57;"	d	file:
T_TOP	HLMTools/LSubset.c	47;"	d	file:
T_TOP	HTKLVRec/HDecode.c	64;"	d	file:
T_TOP	HTKLVRec/HDecode.mod.c	65;"	d	file:
T_TOP	HTKLVRec/HLVLM.c	53;"	d	file:
T_TOP	HTKLVRec/HLVModel.c	55;"	d	file:
T_TOP	HTKLVRec/HLVNet.c	59;"	d	file:
T_TOP	HTKLVRec/HLVRec.c	62;"	d	file:
T_TOP	HTKLib/HAdapt.c	56;"	d	file:
T_TOP	HTKLib/HAudio.c	34;"	d	file:
T_TOP	HTKLib/HDict.c	36;"	d	file:
T_TOP	HTKLib/HFB.c	56;"	d	file:
T_TOP	HTKLib/HFBLat.c	76;"	d	file:
T_TOP	HTKLib/HLat.c	57;"	d	file:
T_TOP	HTKLib/HMap.c	66;"	d	file:
T_TOP	HTKLib/HMem.c	34;"	d	file:
T_TOP	HTKLib/HModel.c	54;"	d	file:
T_TOP	HTKLib/HParm.c	56;"	d	file:
T_TOP	HTKLib/HTrain.c	53;"	d	file:
T_TOP	HTKLib/HUtil.c	52;"	d	file:
T_TOP	HTKTools/HBuild.c	37;"	d	file:
T_TOP	HTKTools/HCompV.c	67;"	d	file:
T_TOP	HTKTools/HCopy.c	38;"	d	file:
T_TOP	HTKTools/HDMan.c	47;"	d	file:
T_TOP	HTKTools/HERest.c	75;"	d	file:
T_TOP	HTKTools/HInit.c	47;"	d	file:
T_TOP	HTKTools/HLEd.c	44;"	d	file:
T_TOP	HTKTools/HLRescore.c	56;"	d	file:
T_TOP	HTKTools/HList.c	53;"	d	file:
T_TOP	HTKTools/HMMIRest.c	68;"	d	file:
T_TOP	HTKTools/HParse.c	91;"	d	file:
T_TOP	HTKTools/HQuant.c	44;"	d	file:
T_TOP	HTKTools/HRest.c	47;"	d	file:
T_TOP	HTKTools/HSGen.c	42;"	d	file:
T_TOP	HTKTools/HSmooth.c	42;"	d	file:
T_TOP	HTKTools/HVite.c	59;"	d	file:
T_TRA	HTKLib/HFB.c	61;"	d	file:
T_TRAN	HTKLib/HLat.c	62;"	d	file:
T_TRAN	HTKTools/HLRescore.c	57;"	d	file:
T_TRE	HTKLib/HAdapt.c	59;"	d	file:
T_TRE	HTKTools/HRest.c	58;"	d	file:
T_TREE	HTKTools/HHEd.c	85;"	d	file:
T_TREE_ALLM	HTKTools/HHEd.c	82;"	d	file:
T_TREE_ALLQ	HTKTools/HHEd.c	81;"	d	file:
T_TREE_ANS	HTKTools/HHEd.c	77;"	d	file:
T_TREE_BESTM	HTKTools/HHEd.c	79;"	d	file:
T_TREE_BESTQ	HTKTools/HHEd.c	78;"	d	file:
T_TREE_OKQ	HTKTools/HHEd.c	80;"	d	file:
T_UNI	HTKTools/HInit.c	50;"	d	file:
T_UPD	HTKLib/HFB.c	64;"	d	file:
T_UPD	HTKLib/HMap.c	67;"	d	file:
T_UPD	HTKTools/HERest.c	77;"	d	file:
T_VAC	HTKTools/HRest.c	56;"	d	file:
T_VALI	HTKTools/HDMan.c	49;"	d	file:
T_VIT	HTKTools/HInit.c	51;"	d	file:
T_VRE	HTKTools/HRest.c	61;"	d	file:
T_WAC	HTKTools/HRest.c	57;"	d	file:
T_WBUF	HTKTools/HDMan.c	48;"	d	file:
T_WMP	HLMLib/LWMap.c	47;"	d	file:
T_WORD	HTKLVRec/HLVRec.c	64;"	d	file:
T_WRE	HTKTools/HRest.c	59;"	d	file:
T_XFD	HTKLib/HModel.c	64;"	d	file:
T_XFM	HTKLib/HAdapt.c	60;"	d	file:
T_XFM	HTKLib/HModel.c	63;"	d	file:
Table	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    typedef boost::unordered_map<Hash, SentenceRelation> Table;$/;"	t	class:lm::phrase::Substrings
TailMerge	HTKTools/HParse.c	/^void TailMerge(Link a, Link b)$/;"	f
TargetPKStr	HTKTools/HCompV.c	/^static char TargetPKStr[MAXSTRLEN];      \/* target parm kind string *\/$/;"	v	file:
TempPrefix	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  const std::string &TempPrefix() const { return sort.temp_prefix; }$/;"	f	struct:lm::builder::PipelineConfig
TermHGraf	HTKLib/HGraf.c	/^void TermHGraf()$/;"	f
TermHGraf	HTKLib/HGraf.null.c	/^void TermHGraf()$/;"	f
TermHGraf	HTKLib/HGraf_WIN32.c	/^void TermHGraf()$/;"	f
TermScanner	HTKLib/HModel.c	/^static void TermScanner(Source *src)$/;"	f	file:
Terminal	HTKLVRec/kenlm/lm/left.hh	/^    void Terminal(WordIndex word) {$/;"	f	class:lm::ngram::RuleScore
Thread	HTKLVRec/kenlm/util/stream/chain.hh	/^    template <class Position, class Worker> Thread(const Position &position, const Worker &worker)$/;"	f	class:util::stream::Thread
Thread	HTKLVRec/kenlm/util/stream/chain.hh	/^class Thread {$/;"	c	namespace:util::stream
ThreadBatch	HTKLVRec/kenlm/lm/filter/thread.hh	/^    ThreadBatch() {}$/;"	f	class:lm::ThreadBatch
ThreadBatch	HTKLVRec/kenlm/lm/filter/thread.hh	/^template <class OutputBuffer> class ThreadBatch {$/;"	c	namespace:lm
ThreadPool	HTKLVRec/kenlm/util/thread_pool.hh	/^    template <class Construct> ThreadPool(size_t queue_length, size_t workers, Construct handler_construct, Request poison) : in_(queue_length), poison_(poison) {$/;"	f	class:util::ThreadPool
ThreadPool	HTKLVRec/kenlm/util/thread_pool.hh	/^template <class HandlerT> class ThreadPool : boost::noncopyable {$/;"	c	namespace:util
ThrowCombine	HTKLVRec/kenlm/lm/trie_sort.cc	/^struct ThrowCombine {$/;"	s	namespace:lm::ngram::trie::__anon60	file:
TidyBaseAccs	HTKLib/HAdapt.c	/^void TidyBaseAccs()$/;"	f
TieCommand	HTKTools/HHEd.c	/^void TieCommand(void)$/;"	f
TieDur	HTKTools/HHEd.c	/^void TieDur(ILink ilist, LabId macId)$/;"	f
TieHMMs	HTKTools/HHEd.c	/^void TieHMMs(ILink ilist,LabId macId)$/;"	f
TieInv	HTKTools/HHEd.c	/^void TieInv(ILink ilist, LabId macId)$/;"	f
TieLeafNodes	HTKTools/HHEd.c	/^void TieLeafNodes(Tree *tree, char *macRoot)$/;"	f
TieMean	HTKTools/HHEd.c	/^void TieMean(ILink ilist, LabId macId)$/;"	f
TieMix	HTKTools/HHEd.c	/^void TieMix(ILink ilist, LabId macId)$/;"	f
TiePDF	HTKTools/HHEd.c	/^void TiePDF(ILink ilist, LabId macId)$/;"	f
TieState	HTKTools/HHEd.c	/^void TieState(ILink ilist, LabId macId)$/;"	f
TieTrans	HTKTools/HHEd.c	/^void TieTrans(ILink ilist, LabId macId)$/;"	f
TieVar	HTKTools/HHEd.c	/^void TieVar(ILink ilist, LabId macId)$/;"	f
TieWeights	HTKTools/HHEd.c	/^void TieWeights(ILink ilist, LabId macId)$/;"	f
TieXform	HTKTools/HHEd.c	/^void TieXform(ILink ilist, LabId macId)$/;"	f
TimeToNFrames	HTKLib/HArc.c	/^int TimeToNFrames(float time, ArcInfo *aInfo){$/;"	f
Timer	HTKLib/HGraf.c	/^static void Timer(int n)$/;"	f	file:
Times	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  static DiyFp Times(const DiyFp& a, const DiyFp& b) {$/;"	f	class:double_conversion::DiyFp
Times10	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  void Times10() { return MultiplyByUInt32(10); }$/;"	f	class:double_conversion::Bignum
TimesLabelled	HTKTools/HSLab.c	/^int TimesLabelled(LabList *ll, long pos)$/;"	f
ToExponential	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^bool DoubleToStringConverter::ToExponential($/;"	f	class:double_conversion::DoubleToStringConverter
ToFixed	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^bool DoubleToStringConverter::ToFixed(double value,$/;"	f	class:double_conversion::DoubleToStringConverter
ToHexString	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^bool Bignum::ToHexString(char* buffer, int buffer_size) const {$/;"	f	class:double_conversion::Bignum
ToMergeLatNodesBackw	HTKLib/HLat.c	/^Boolean ToMergeLatNodesBackw(Lattice *lat, LNode *ln)$/;"	f
ToMergeLatNodesForw	HTKLib/HLat.c	/^Boolean ToMergeLatNodesForw(Lattice *lat, LNode *ln)$/;"	f
ToPrecision	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^bool DoubleToStringConverter::ToPrecision(double value,$/;"	f	class:double_conversion::DoubleToStringConverter
ToShortest	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  bool ToShortest(double value, StringBuilder* result_builder) const {$/;"	f	class:double_conversion::DoubleToStringConverter
ToShortestIeeeNumber	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^bool DoubleToStringConverter::ToShortestIeeeNumber($/;"	f	class:double_conversion::DoubleToStringConverter
ToShortestSingle	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  bool ToShortestSingle(float value, StringBuilder* result_builder) const {$/;"	f	class:double_conversion::DoubleToStringConverter
TokScore	HTKLVRec/config.h	/^typedef LogFloat TokScore;$/;"	t
TokSetMerge	HTKLib/HRec.c	/^static void TokSetMerge(TokenSet *res,Token *cmp,TokenSet *src)$/;"	f	file:
Token	HTKLVRec/HLVRec.h	/^typedef struct _Token Token;            \/* Info about partial hypothesis *\/$/;"	t	typeref:struct:_Token
Token	HTKLib/HModel.c	/^} Token;$/;"	t	typeref:struct:__anon119	file:
Token	HTKLib/HRec.h	/^Token;$/;"	t	typeref:struct:token
TokenIter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    TokenIter() {}$/;"	f	class:util::TokenIter
TokenIter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    template <class Construct> TokenIter(const StringPiece &str, const Construct &construct) : after_(str), finder_(construct) {$/;"	f	class:util::TokenIter
TokenIter	HTKLVRec/kenlm/util/tokenize_piece.hh	/^template <class Find, bool SkipEmpty = false> class TokenIter : public boost::iterator_facade<TokenIter<Find, SkipEmpty>, const StringPiece, boost::forward_traversal_tag> {$/;"	c	namespace:util
TokenSet	HTKLVRec/HLVRec.h	/^typedef struct _TokenSet TokenSet;      \/* contains n tokens with different LM states *\/$/;"	t	typeref:struct:_TokenSet
TokenSet	HTKLib/HRec.c	/^TokenSet;$/;"	t	typeref:struct:tokenset	file:
Top	HTKLVRec/kenlm/util/stream/sort.hh	/^    const void *Top() const {$/;"	f	class:util::stream::MergeQueue
TotMixInSet	HTKLib/HMap.c	/^static int TotMixInSet(HMMSet *hset)$/;"	f	file:
TotalComps	HTKLib/HParm.c	/^static int TotalComps(int nStatic, ParmKind pk)$/;"	f	file:
TotalCorr	HTKTools/HMMIRest.c	/^static double TotalCorr=0;$/;"	v	file:
TotalHeaderSize	HTKLVRec/kenlm/lm/binary_format.cc	/^std::size_t TotalHeaderSize(unsigned char order) {$/;"	f	namespace:lm::ngram::__anon41
TotalMemory	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  std::size_t TotalMemory() const { return sort.total_memory; }$/;"	f	struct:lm::builder::PipelineConfig
TotalNWords	HTKTools/HMMIRest.c	/^static int TotalNWords=0;$/;"	v	file:
TotalOffset	HTKLVRec/kenlm/util/stream/sort.hh	/^    uint64_t TotalOffset() const { return output_sum_; }$/;"	f	class:util::stream::Offsets
TotalSize	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    static std::size_t TotalSize(std::size_t order) {$/;"	f	class:lm::builder::NGram
TotalSize	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    std::size_t TotalSize() const {$/;"	f	class:lm::builder::NGram
Touch	HTKLib/HModel.c	/^void Touch(int *flag)$/;"	f
TouchV	HTKLib/HMem.c	/^void TouchV(Ptr m)$/;"	f
TrAcc	HTKLib/HTrain.h	/^} TrAcc;$/;"	t	typeref:struct:__anon163
TrL	HTKTools/HCopy.c	/^} TrL;$/;"	t	typeref:struct:_TrList	file:
TrOpEntry	HTKTools/HLEd.c	/^void TrOpEntry(char *name)$/;"	f
TrOpExit	HTKTools/HLEd.c	/^void TrOpExit(int count)$/;"	f
TrPtr	HTKTools/HCopy.c	/^typedef struct _TrList *TrPtr;  \/* simple linked list for trace info *\/$/;"	t	typeref:struct:_TrList	file:
TrSymbol	HTKLib/HLabel.c	/^typedef enum _TrSymbol TrSymbol;$/;"	t	typeref:enum:_TrSymbol	file:
Trace Output	HTKBook/HTKRef/HCopy.tex	/^\\subsection{Trace Output}$/;"	b
TraceAlphaBeta	HTKLib/HFB.c	/^static void TraceAlphaBeta(AlphaBeta *ab, int t, int startq, int endq, LogDouble pr)$/;"	f	file:
TraceBack	HTKLVRec/HLVRec-traceback.c	/^Transcription *TraceBack(MemHeap *heap, DecoderInst *dec)$/;"	f
TraceOcc	HTKLib/HFB.c	/^static void TraceOcc(AlphaBeta *ab, UttInfo *utt, int t)$/;"	f	file:
TracePath	HTKLib/HRec.c	/^void TracePath(FILE *file,Path *path)$/;"	f
TraceQuestion	HTKTools/HHEd.c	/^void TraceQuestion(char *cmd, QLink q)$/;"	f
Tracing	HTKBook/HTKRef/HHEd.tex	/^\\subsection{Tracing}$/;"	b
TrackButtons	HTKLib/HGraf.c	/^ButtonId TrackButtons(HButton *btnlist, HEventRec hev)$/;"	f
TrackButtons	HTKLib/HGraf.null.c	/^ButtonId TrackButtons(HButton *btnlist, HEventRec hev)$/;"	f
TrackButtons	HTKLib/HGraf_WIN32.c	/^ButtonId TrackButtons(HButton *btnlist, HEventRec hev)$/;"	f
TrackWPtr	HTKTools/HSLab.c	/^void TrackWPtr(void)$/;"	f
Train	HTKLVRec/kenlm/lm/quantize.cc	/^void SeparatelyQuantize::Train(uint8_t order, std::vector<float> &prob, std::vector<float> &backoff) {$/;"	f	class:lm::ngram::SeparatelyQuantize
Train	HTKLVRec/kenlm/lm/quantize.hh	/^    void Train(uint8_t \/*order*\/, std::vector<float> &\/*prob*\/, std::vector<float> &\/*backoff*\/) {}$/;"	f	class:lm::ngram::DontQuantize
TrainProb	HTKLVRec/kenlm/lm/quantize.cc	/^void SeparatelyQuantize::TrainProb(uint8_t order, std::vector<float> &prob) {$/;"	f	class:lm::ngram::SeparatelyQuantize
TrainProb	HTKLVRec/kenlm/lm/quantize.hh	/^    void TrainProb(uint8_t, std::vector<float> &\/*prob*\/) {}$/;"	f	class:lm::ngram::DontQuantize
TrainProbQuantizer	HTKLVRec/kenlm/lm/search_trie.cc	/^template <class Quant> void TrainProbQuantizer(uint8_t order, uint64_t count, RecordReader &reader, util::ErsatzProgress &progress, Quant &quant) {$/;"	f	namespace:lm::ngram::trie::__anon58
TrainQuantizer	HTKLVRec/kenlm/lm/search_trie.cc	/^template <class Quant> void TrainQuantizer(uint8_t order, uint64_t count, const std::vector<float> &additional, RecordReader &reader, util::ErsatzProgress &progress, Quant &quant) {$/;"	f	namespace:lm::ngram::trie::__anon58
Training Tools	HTKBook/htkoview.tex	/^\\subsection{Training Tools}$/;"	b
Transcription	HTKLib/HLabel.h	/^}Transcription;$/;"	t	typeref:struct:__anon108
TranscriptionFromLattice	HTKLib/HRec.c	/^Transcription *TranscriptionFromLattice(MemHeap *heap,Lattice *lat,int N)$/;"	f
TransitionToRead	HTKLVRec/kenlm/util/file_piece.cc	/^void FilePiece::TransitionToRead() {$/;"	f	class:util::FilePiece
TraverseTree	HTKLVRec/HLVNet.c	/^int TraverseTree (TLexNode *ln, int start, int *lmlaCount)$/;"	f
Tree	HTKTools/HHEd.c	/^}Tree;$/;"	t	typeref:struct:_Tree	file:
TreeBuildCommand	HTKTools/HHEd.c	/^void TreeBuildCommand(void)$/;"	f
TreeCluster	HTKLib/HTrain.c	/^ClusterSet *TreeCluster(MemHeap *x, Sequence vpool, int nc, $/;"	f
TreeFilter	HTKTools/HHEd.c	/^void TreeFilter(HMMSet *newSet)$/;"	f
TreeType	HTKLib/HVQ.h	/^} TreeType;$/;"	t	typeref:enum:__anon171
Tri2DMat	HTKLib/HAdapt.c	/^static void Tri2DMat (DMatrix m1, DMatrix m2)$/;"	f	file:
Tri2Mat	HTKLib/HMath.c	/^void Tri2Mat (TriMat m1, Matrix m2)$/;"	f
TriDiag2Vector	HTKTools/HCompV.c	/^void TriDiag2Vector(TriMat m, Vector v)$/;"	f
TriMat	HTKLib/HMem.h	/^typedef Matrix TriMat;     \/* matrix[1..nrows][1..i] (lower triangular) *\/$/;"	t
TriMatElemSize	HTKLib/HMem.c	/^size_t TriMatElemSize(int size)$/;"	f
TriMatSize	HTKLib/HMem.c	/^int TriMatSize(TriMat m)$/;"	f
TriPhon	HTKTools/HDMan.c	/^void TriPhon(Pronunciation *p, Boolean left, Boolean right, $/;"	f
TriPhonise	HTKTools/HLEd.c	/^int TriPhonise(LabList *ll,Boolean left, Boolean right, LabId stId, $/;"	f
TriRec	HTKTools/HHEd.c	/^}TriRec;$/;"	t	typeref:struct:__anon197	file:
TriState	HTKLib/HParm.h	/^TriState;$/;"	t	typeref:enum:__anon146
TriStrip	HTKLib/HLabel.c	/^void TriStrip(char *s)$/;"	f
TrieSearch	HTKLVRec/kenlm/lm/search_trie.hh	/^    TrieSearch() : middle_begin_(NULL), middle_end_(NULL) {}$/;"	f	class:lm::ngram::trie::TrieSearch
TrieSearch	HTKLVRec/kenlm/lm/search_trie.hh	/^template <class Quant, class Bhiksha> class TrieSearch {$/;"	c	namespace:lm::ngram::trie
TrieUnigramProxy	HTKLVRec/kenlm/lm/value.hh	/^      TrieUnigramProxy() {}$/;"	f	class:lm::ngram::BackoffValue::TrieUnigramProxy
TrieUnigramProxy	HTKLVRec/kenlm/lm/value.hh	/^      TrieUnigramProxy() {}$/;"	f	class:lm::ngram::RestValue::TrieUnigramProxy
TrieUnigramProxy	HTKLVRec/kenlm/lm/value.hh	/^      explicit TrieUnigramProxy(const Weights &to) : GenericTrieUnigramProxy<Weights>(to) {}$/;"	f	class:lm::ngram::BackoffValue::TrieUnigramProxy
TrieUnigramProxy	HTKLVRec/kenlm/lm/value.hh	/^      explicit TrieUnigramProxy(const Weights &to) : GenericTrieUnigramProxy<Weights>(to) {}$/;"	f	class:lm::ngram::RestValue::TrieUnigramProxy
TrieUnigramProxy	HTKLVRec/kenlm/lm/value.hh	/^  class TrieUnigramProxy : public GenericTrieUnigramProxy<Weights> {$/;"	c	struct:lm::ngram::BackoffValue
TrieUnigramProxy	HTKLVRec/kenlm/lm/value.hh	/^  class TrieUnigramProxy : public GenericTrieUnigramProxy<Weights> {$/;"	c	struct:lm::ngram::RestValue
TrieUnigramValue	HTKLVRec/kenlm/lm/value.hh	/^  struct TrieUnigramValue {$/;"	s	struct:lm::ngram::BackoffValue
TrieUnigramValue	HTKLVRec/kenlm/lm/value.hh	/^  struct TrieUnigramValue {$/;"	s	struct:lm::ngram::RestValue
TrimAndCut	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static void TrimAndCut(Vector<const char> buffer, int exponent,$/;"	f	namespace:double_conversion
TrimLeadingZeros	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static Vector<const char> TrimLeadingZeros(Vector<const char> buffer) {$/;"	f	namespace:double_conversion
TrimSampFreq	HTKLib/HAudio.c	/^static int TrimSampFreq(int f)$/;"	f	file:
TrimTrailingZeros	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static Vector<const char> TrimTrailingZeros(Vector<const char> buffer) {$/;"	f	namespace:double_conversion
TrimZeros	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^static void TrimZeros(Vector<char> buffer, int* length, int* decimal_point) {$/;"	f	namespace:double_conversion
Triphonise	HTKTools/HDMan.c	/^void Triphonise(WordBuf *wb,  Boolean left, Boolean right, $/;"	f
True	HTKLVRec/kenlm/util/file.cc	/^  struct True {};$/;"	s	struct:util::__anon70::CheckOffT	file:
TryName	HTKLVRec/kenlm/util/file.cc	/^bool TryName(int fd, std::string &out) {$/;"	f	namespace:util::__anon71
TuringGoodInfo	HLMLib/LModel.h	/^} TuringGoodInfo;$/;"	t	typeref:struct:__anon10
Tutorial Overview	HTKBook/htkbook-pdf.tex	/^\\part{Tutorial Overview}$/;"	p
Tutorial Overview	HTKBook/htkbook.tex	/^\\part{Tutorial Overview}$/;"	p
TypeCode	HTKLib/esignal.c	/^TypeCode(char *name)$/;"	f
TypeName	HTKLib/esignal.c	/^TypeName(int type    \/* numeric data-type code *\/ )$/;"	f
TypeOrder	HTKLib/esignal.c	/^TypeOrder(FieldList list)$/;"	f
Types	HTKLib/esignal.c	/^static short    Types[] =$/;"	v	file:
TypicalState	HTKTools/HHEd.c	/^ILink TypicalState(ILink ilist, LabId macId)$/;"	f
UCHAR	HTKLib/esignal.h	73;"	d
UCH_FMT	HTKLib/esig_asc.c	71;"	d	file:
UCH_W	HTKLib/esig_asc.c	70;"	d	file:
UCH_WFMT	HTKLib/esig_asc.c	72;"	d	file:
UCPHONE	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon191	file:
UCPhoneOp	HTKTools/HDMan.c	/^void UCPhoneOp(WordBuf *wb)$/;"	f
UCWORD	HTKTools/HDMan.c	/^typedef enum {UCWORD, UCPHONE, LCWORD, LCPHONE, DELETEW, DELDEF, FUNCW, DEFCON,$/;"	e	enum:__anon191	file:
UCase	HTKTools/HDMan.c	/^LabId UCase(LabId id)$/;"	f
UCollectData	HTKTools/HInit.c	/^void UCollectData(Sequence **seqMat)$/;"	f
UF	HTKTools/HHEd.c	/^typedef enum           { AT=1, RT , SS , CL , CO , JO , MU , TI , UF , NC ,$/;"	e	enum:__anon199	file:
UINT64_2PART_C	HTKLVRec/kenlm/util/double-conversion/utils.h	96;"	d
UInt	HLMLib/LGBase.h	/^typedef unsigned int   UInt;$/;"	t
UInt	HLMLib/LModel.h	/^typedef unsigned int   UInt;$/;"	t
UInt128	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^  UInt128() : high_bits_(0), low_bits_(0) { }$/;"	f	class:double_conversion::UInt128
UInt128	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^  UInt128(uint64_t high, uint64_t low) : high_bits_(high), low_bits_(low) { }$/;"	f	class:double_conversion::UInt128
UInt128	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^class UInt128 {$/;"	c	namespace:double_conversion	file:
ULN_FMT	HTKLib/esig_asc.c	55;"	d	file:
ULN_W	HTKLib/esig_asc.c	54;"	d	file:
ULN_WFMT	HTKLib/esig_asc.c	56;"	d	file:
ULONG	HTKLib/esignal.h	69;"	d
UNDEFF	HTKLib/HWave.h	/^        UNDEFF$/;"	e	enum:__anon181
UNIMPLEMENTED	HTKLVRec/kenlm/util/double-conversion/utils.h	39;"	d
UNIQUE_ZERO	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^    UNIQUE_ZERO = 8$/;"	e	enum:double_conversion::DoubleToStringConverter::Flags
UNIX	HTKLib/HShell.h	66;"	d
UNKNOWN	HTKLib/esignal.h	102;"	d
UNKNOWNSO	HTKLib/HWave.c	/^   UNKNOWNSO   \/* unknown source byte order *\/$/;"	e	enum:_SrcOrder	file:
UNK_FIELD	HTKLib/HNet.c	/^typedef enum {UNK_FIELD, STR_FIELD, INT_FIELD, FLT_FIELD} LatFieldType;$/;"	e	enum:__anon136	file:
UNLOG_NATURAL	HLMLib/LModel.h	64;"	d
UNMARK_ALTPATH	HTKLVRec/HLVRec-GC.c	49;"	d	file:
UNMARK_MODPATH	HTKLVRec/HLVRec-GC.c	57;"	d	file:
UNMARK_PATH	HTKLVRec/HLVRec-GC.c	42;"	d	file:
UNREACHABLE	HTKLVRec/kenlm/util/double-conversion/utils.h	42;"	d
UNUSED	HTKLib/HWave.h	/^        UNUSED,$/;"	e	enum:__anon181
UPDSet	HTKLib/HTrain.h	/^typedef enum _UPDSet UPDSet;$/;"	t	typeref:enum:_UPDSet
UPMAP	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPMEANS	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPMIXES	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPMODE_BOTH	HTKTools/HERest.c	83;"	d	file:
UPMODE_BOTH	HTKTools/HMMIRest.c	74;"	d	file:
UPMODE_DUMP	HTKTools/HERest.c	81;"	d	file:
UPMODE_DUMP	HTKTools/HMMIRest.c	72;"	d	file:
UPMODE_UPDATE	HTKTools/HERest.c	82;"	d	file:
UPMODE_UPDATE	HTKTools/HMMIRest.c	73;"	d	file:
UPSEMIT	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPTRANS	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPVARS	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
UPXFORM	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	e	enum:_UPDSet
USEHAMMING	HTKLib/HParm.c	/^   USEHAMMING,    \/* Apply Hamming Window *\/$/;"	e	enum:__anon142	file:
USEMAC	HTKLib/HModel.c	/^   BEGINHMM, USEMAC, ENDHMM, NUMMIXES, $/;"	e	enum:__anon117	file:
USEPOWER	HTKLib/HParm.c	/^   USEPOWER,      \/* Use power instead of magnitude *\/$/;"	e	enum:__anon142	file:
USER	HTKLib/HParm.h	/^      USER,                            \/* Arbitrary user specified data *\/$/;"	e	enum:_BaseParmKind
USESILDET	HTKLib/HParm.c	/^   USESILDET,     \/* Enable speech\/silence detection *\/$/;"	e	enum:__anon142	file:
USE_INTEL_SSE	HTKLVRec/config.h	65;"	d
USE_STAT	HTKTools/HSLab.c	59;"	d	file:
USHORT	HTKLib/esignal.h	71;"	d
USH_FMT	HTKLib/esig_asc.c	63;"	d	file:
USH_W	HTKLib/esig_asc.c	62;"	d	file:
USH_WFMT	HTKLib/esig_asc.c	64;"	d	file:
UShort	HLMLib/LGBase.h	/^typedef unsigned short UShort;$/;"	t
UShort	HLMLib/LModel.h	/^typedef unsigned short UShort;$/;"	t
UT	HTKTools/HHEd.c	/^                         TC , UT , MT , SH , SU , SW , SK ,$/;"	e	enum:__anon199	file:
UTIL_BIT_PACKING_H	HTKLVRec/kenlm/util/bit_packing.hh	2;"	d
UTIL_BZIP	HTKLVRec/kenlm/util/read_compressed.cc	/^  UTIL_UNKNOWN, UTIL_GZIP, UTIL_BZIP, UTIL_XZIP$/;"	e	enum:util::__anon79::MagicResult	file:
UTIL_ERSATZ_PROGRESS_H	HTKLVRec/kenlm/util/ersatz_progress.hh	2;"	d
UTIL_EXCEPTION_H	HTKLVRec/kenlm/util/exception.hh	2;"	d
UTIL_FAKE_OFSTREAM_H	HTKLVRec/kenlm/util/fake_ofstream.hh	6;"	d
UTIL_FILE_H	HTKLVRec/kenlm/util/file.hh	2;"	d
UTIL_FILE_PIECE_H	HTKLVRec/kenlm/util/file_piece.hh	2;"	d
UTIL_FIXED_ARRAY_H	HTKLVRec/kenlm/util/fixed_array.hh	2;"	d
UTIL_FUNC_NAME	HTKLVRec/kenlm/util/exception.hh	56;"	d
UTIL_FUNC_NAME	HTKLVRec/kenlm/util/exception.hh	59;"	d
UTIL_FUNC_NAME	HTKLVRec/kenlm/util/exception.hh	61;"	d
UTIL_GETOPT_H	HTKLVRec/kenlm/util/getopt.hh	15;"	d
UTIL_GZIP	HTKLVRec/kenlm/util/read_compressed.cc	/^  UTIL_UNKNOWN, UTIL_GZIP, UTIL_BZIP, UTIL_XZIP$/;"	e	enum:util::__anon79::MagicResult	file:
UTIL_HAVE_H	HTKLVRec/kenlm/util/have.hh	3;"	d
UTIL_JOINT_SORT_H	HTKLVRec/kenlm/util/joint_sort.hh	2;"	d
UTIL_MMAP_H	HTKLVRec/kenlm/util/mmap.hh	2;"	d
UTIL_MULTI_INTERSECTION_H	HTKLVRec/kenlm/util/multi_intersection.hh	2;"	d
UTIL_MURMUR_HASH_H	HTKLVRec/kenlm/util/murmur_hash.hh	2;"	d
UTIL_PARALLEL_READ__	HTKLVRec/kenlm/util/parallel_read.hh	2;"	d
UTIL_PCQUEUE_H	HTKLVRec/kenlm/util/pcqueue.hh	2;"	d
UTIL_POOL_H	HTKLVRec/kenlm/util/pool.hh	5;"	d
UTIL_PROBING_HASH_TABLE_H	HTKLVRec/kenlm/util/probing_hash_table.hh	2;"	d
UTIL_PROXY_ITERATOR_H	HTKLVRec/kenlm/util/proxy_iterator.hh	2;"	d
UTIL_READ_COMPRESSED_H	HTKLVRec/kenlm/util/read_compressed.hh	2;"	d
UTIL_SCOPED_H	HTKLVRec/kenlm/util/scoped.hh	2;"	d
UTIL_SIZED_ITERATOR_H	HTKLVRec/kenlm/util/sized_iterator.hh	2;"	d
UTIL_SORTED_UNIFORM_H	HTKLVRec/kenlm/util/sorted_uniform.hh	2;"	d
UTIL_STREAM_BLOCK_H	HTKLVRec/kenlm/util/stream/block.hh	2;"	d
UTIL_STREAM_CHAIN_H	HTKLVRec/kenlm/util/stream/chain.hh	2;"	d
UTIL_STREAM_CONFIG_H	HTKLVRec/kenlm/util/stream/config.hh	2;"	d
UTIL_STREAM_IO_H	HTKLVRec/kenlm/util/stream/io.hh	2;"	d
UTIL_STREAM_LINE_INPUT_H	HTKLVRec/kenlm/util/stream/line_input.hh	2;"	d
UTIL_STREAM_MULTI_PROGRESS_H	HTKLVRec/kenlm/util/stream/multi_progress.hh	3;"	d
UTIL_STREAM_MULTI_STREAM_H	HTKLVRec/kenlm/util/stream/multi_stream.hh	2;"	d
UTIL_STREAM_SORT_H	HTKLVRec/kenlm/util/stream/sort.hh	19;"	d
UTIL_STREAM_STREAM_H	HTKLVRec/kenlm/util/stream/stream.hh	2;"	d
UTIL_STREAM_TIMER_H	HTKLVRec/kenlm/util/stream/timer.hh	2;"	d
UTIL_STRING_PIECE_H	HTKLVRec/kenlm/util/string_piece.hh	49;"	d
UTIL_STRING_PIECE_HASH_H	HTKLVRec/kenlm/util/string_piece_hash.hh	2;"	d
UTIL_THREAD_POOL_H	HTKLVRec/kenlm/util/thread_pool.hh	2;"	d
UTIL_THROW	HTKLVRec/kenlm/util/exception.hh	83;"	d
UTIL_THROW2	HTKLVRec/kenlm/util/exception.hh	86;"	d
UTIL_THROW_ARG	HTKLVRec/kenlm/util/exception.hh	80;"	d
UTIL_THROW_BACKEND	HTKLVRec/kenlm/util/exception.hh	73;"	d
UTIL_THROW_IF	HTKLVRec/kenlm/util/exception.hh	101;"	d
UTIL_THROW_IF2	HTKLVRec/kenlm/util/exception.hh	104;"	d
UTIL_THROW_IF_ARG	HTKLVRec/kenlm/util/exception.hh	95;"	d
UTIL_TIMER	HTKLVRec/kenlm/util/stream/timer.hh	13;"	d
UTIL_TOKENIZE_PIECE_H	HTKLVRec/kenlm/util/tokenize_piece.hh	2;"	d
UTIL_UNISTD_H	HTKLVRec/kenlm/util/unistd.hh	2;"	d
UTIL_UNKNOWN	HTKLVRec/kenlm/util/read_compressed.cc	/^  UTIL_UNKNOWN, UTIL_GZIP, UTIL_BZIP, UTIL_XZIP$/;"	e	enum:util::__anon79::MagicResult	file:
UTIL_UNLIKELY	HTKLVRec/kenlm/util/exception.hh	90;"	d
UTIL_UNLIKELY	HTKLVRec/kenlm/util/exception.hh	92;"	d
UTIL_USAGE_H	HTKLVRec/kenlm/util/usage.hh	2;"	d
UTIL_XZIP	HTKLVRec/kenlm/util/read_compressed.cc	/^  UTIL_UNKNOWN, UTIL_GZIP, UTIL_BZIP, UTIL_XZIP$/;"	e	enum:util::__anon79::MagicResult	file:
Uchar	HTKLib/esignal.h	/^typedef unsigned char			Uchar;$/;"	t
Ulong	HTKLib/esignal.h	/^typedef unsigned long			Ulong;$/;"	t
UnGetCh	HTKLib/HShell.c	/^void UnGetCh(int c, Source *src)$/;"	f
UnMarkAllWords	HTKLVRec/HLVNet.c	/^void UnMarkAllWords (Vocab *voc)$/;"	f
UnRecordHeap	HTKLib/HMem.c	/^static void UnRecordHeap(MemHeap *x)$/;"	f	file:
UnRest	HTKLVRec/kenlm/lm/model.hh	/^    float UnRest(const uint64_t *pointers_begin, const uint64_t *pointers_end, unsigned char first_length) const {$/;"	f	class:lm::ngram::detail::GenericModel
UnWeightCepstrum	HTKLib/HSigP.c	/^void UnWeightCepstrum(Vector c, int start, int count, int cepLiftering)$/;"	f
UncheckedInsert	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class T> MutableIterator UncheckedInsert(const T &t) {$/;"	f	class:util::ProbingHashTable
Uncompressed	HTKLVRec/kenlm/util/read_compressed.cc	/^    explicit Uncompressed(int fd) : fd_(fd) {}$/;"	f	class:util::__anon79::Uncompressed
Uncompressed	HTKLVRec/kenlm/util/read_compressed.cc	/^class Uncompressed : public ReadBase {$/;"	c	namespace:util::__anon79	file:
UncompressedWithHeader	HTKLVRec/kenlm/util/read_compressed.cc	/^    UncompressedWithHeader(int fd, const void *already_data, std::size_t already_size) : fd_(fd) {$/;"	f	class:util::__anon79::UncompressedWithHeader
UncompressedWithHeader	HTKLVRec/kenlm/util/read_compressed.cc	/^class UncompressedWithHeader : public ReadBase {$/;"	c	namespace:util::__anon79	file:
UndoOp	HTKTools/HSLab.c	/^void UndoOp(void)$/;"	f
UndoRecord	HTKTools/HSLab.c	/^} UndoRecord; $/;"	t	typeref:struct:__anon211	file:
UnhandledException	HTKLVRec/kenlm/util/stream/chain.cc	/^void Thread::UnhandledException(const std::exception &e) {$/;"	f	class:util::stream::Thread
UniformSegment	HTKTools/HInit.c	/^void UniformSegment(void)$/;"	f
Unigram	HTKLVRec/kenlm/lm/search_hashed.hh	/^        Unigram() {}$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Unigram	HTKLVRec/kenlm/lm/search_hashed.hh	/^        Unigram(void *start, uint64_t count) :$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Unigram	HTKLVRec/kenlm/lm/search_hashed.hh	/^    class Unigram {$/;"	c	class:lm::ngram::detail::HashedSearch
Unigram	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Unigram(WordIndex \/*index*\/) {$/;"	f	class:lm::ngram::trie::__anon58::FindBlanks
Unigram	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Unigram(WordIndex word) {$/;"	f	class:lm::ngram::trie::__anon58::WriteEntries
Unigram	HTKLVRec/kenlm/lm/search_trie.hh	/^    typedef ::lm::ngram::trie::Unigram Unigram;$/;"	t	class:lm::ngram::trie::TrieSearch
Unigram	HTKLVRec/kenlm/lm/trie.hh	/^    Unigram() {}$/;"	f	class:lm::ngram::trie::Unigram
Unigram	HTKLVRec/kenlm/lm/trie.hh	/^class Unigram {$/;"	c	namespace:lm::ngram::trie
UnigramLMIdMapper	HTKLVRec/HLVLM.c	/^static LMId UnigramLMIdMapper(FSLM_ngram *nglm, char *w)$/;"	f	file:
UnigramPointer	HTKLVRec/kenlm/lm/search_hashed.hh	/^    typedef typename Value::ProbingProxy UnigramPointer;$/;"	t	class:lm::ngram::detail::HashedSearch
UnigramPointer	HTKLVRec/kenlm/lm/search_trie.hh	/^    typedef ::lm::ngram::trie::UnigramPointer UnigramPointer;$/;"	t	class:lm::ngram::trie::TrieSearch
UnigramPointer	HTKLVRec/kenlm/lm/trie.hh	/^    UnigramPointer() : to_(NULL) {}$/;"	f	class:lm::ngram::trie::UnigramPointer
UnigramPointer	HTKLVRec/kenlm/lm/trie.hh	/^    explicit UnigramPointer(const ProbBackoff &to) : to_(&to) {}$/;"	f	class:lm::ngram::trie::UnigramPointer
UnigramPointer	HTKLVRec/kenlm/lm/trie.hh	/^class UnigramPointer {$/;"	c	namespace:lm::ngram::trie
UnigramProb	HTKLVRec/kenlm/lm/search_trie.cc	/^    float UnigramProb(WordIndex index) const { return unigrams_[index].weights.prob; }$/;"	f	class:lm::ngram::trie::__anon58::WriteEntries
UnigramProb	HTKLVRec/kenlm/lm/search_trie.cc	/^    float UnigramProb(WordIndex index) const {$/;"	f	class:lm::ngram::trie::__anon58::FindBlanks
UnigramValue	HTKLVRec/kenlm/lm/trie.hh	/^struct UnigramValue {$/;"	s	namespace:lm::ngram::trie
Uninterpolated	HTKLVRec/kenlm/lm/builder/ngram.hh	/^struct Uninterpolated {$/;"	s	namespace:lm::builder
Union	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    explicit Union(const Substrings &substrings) : detail::ConditionCommon(substrings) {}$/;"	f	class:lm::phrase::Union
Union	HTKLVRec/kenlm/lm/filter/phrase.hh	/^class Union : public detail::ConditionCommon {$/;"	c	namespace:lm::phrase
Union	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    explicit Union(const Words &vocabs) : vocabs_(vocabs) {}$/;"	f	class:lm::vocab::Union
Union	HTKLVRec/kenlm/lm/filter/vocab.hh	/^class Union {$/;"	c	namespace:lm::vocab
UnkCountChangePadding	HTKLVRec/kenlm/lm/vocab.hh	/^    std::size_t UnkCountChangePadding() const { return 0; }$/;"	f	class:lm::ngram::ProbingVocabulary
UnkCountChangePadding	HTKLVRec/kenlm/lm/vocab.hh	/^    std::size_t UnkCountChangePadding() const { return SawUnk() ? 0 : sizeof(uint64_t); }$/;"	f	class:lm::ngram::SortedVocabulary
Unknown	HTKLVRec/kenlm/lm/search_hashed.hh	/^        typename Value::Weights &Unknown() { return unigram_[0]; }$/;"	f	class:lm::ngram::detail::HashedSearch::Unigram
Unknown	HTKLVRec/kenlm/lm/trie.hh	/^    ProbBackoff &Unknown() { return unigram_[0].weights; }$/;"	f	class:lm::ngram::trie::Unigram
UnknownUnigram	HTKLVRec/kenlm/lm/search_hashed.hh	/^    typename Value::Weights &UnknownUnigram() { return unigram_.Unknown(); }$/;"	f	class:lm::ngram::detail::HashedSearch
UnknownUnigram	HTKLVRec/kenlm/lm/search_trie.hh	/^    ProbBackoff &UnknownUnigram() { return unigram_.Unknown(); }$/;"	f	class:lm::ngram::trie::TrieSearch
UnlinkAlign	HTKLib/HRec.c	/^static void UnlinkAlign(Align *align)$/;"	f	file:
UnlinkPath	HTKLib/HRec.c	/^static void UnlinkPath(Path *path)$/;"	f	file:
UnmapOrThrow	HTKLVRec/kenlm/util/mmap.cc	/^void UnmapOrThrow(void *start, size_t length) {$/;"	f	namespace:util
Unmark	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    void Unmark() {$/;"	f	class:lm::builder::NGram
UnmarkedCount	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    uint64_t UnmarkedCount() const {$/;"	f	class:lm::builder::NGram
Unpack	HTKLVRec/kenlm/lm/search_hashed.hh	/^    MiddlePointer Unpack(uint64_t extend_pointer, unsigned char extend_length, Node &node) const {$/;"	f	class:lm::ngram::detail::HashedSearch
Unpack	HTKLVRec/kenlm/lm/search_trie.hh	/^    MiddlePointer Unpack(uint64_t extend_pointer, unsigned char extend_length, Node &node) const {$/;"	f	class:lm::ngram::trie::TrieSearch
UnsafeMutableFind	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class Key> bool UnsafeMutableFind(const Key key, MutableIterator &out) {$/;"	f	class:util::AutoProbing
UnsafeMutableFind	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class Key> bool UnsafeMutableFind(const Key key, MutableIterator &out) {$/;"	f	class:util::ProbingHashTable
UnsafeMutableMustFind	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class Key> MutableIterator UnsafeMutableMustFind(const Key key) {$/;"	f	class:util::AutoProbing
UnsafeMutableMustFind	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    template <class Key> MutableIterator UnsafeMutableMustFind(const Key key) {$/;"	f	class:util::ProbingHashTable
UnsetSign	HTKLVRec/kenlm/util/bit_packing.hh	/^inline void UnsetSign(float &to) {$/;"	f	namespace:util
UntieCommand	HTKTools/HHEd.c	/^void UntieCommand(void)$/;"	f
UntieInv	HTKTools/HHEd.c	/^void UntieInv(ILink ilist)$/;"	f
UntieMean	HTKTools/HHEd.c	/^void UntieMean(ILink ilist)$/;"	f
UntieMix	HTKTools/HHEd.c	/^void UntieMix(ILink ilist)$/;"	f
UntieState	HTKTools/HHEd.c	/^void UntieState(ILink ilist)$/;"	f
UntieTrans	HTKTools/HHEd.c	/^void UntieTrans(ILink ilist)$/;"	f
UntieVar	HTKTools/HHEd.c	/^void UntieVar(ILink ilist)$/;"	f
UntieXform	HTKTools/HHEd.c	/^void UntieXform(ILink ilist)$/;"	f
Untouch	HTKLib/HModel.c	/^void Untouch(int *flag)$/;"	f
UntouchV	HTKLib/HMem.c	/^void UntouchV(Ptr m)$/;"	f
UpDProbs	HTKTools/HInit.c	/^void UpDProbs(int i, int s, int M, WtAcc *wa, ShortVec dw)$/;"	f
UpMeans	HTKTools/HInit.c	/^void UpMeans(int i, int s, int m, int size, MuAcc *ma, Vector mean)$/;"	f
UpMix	HTKTools/HHEd.c	/^void UpMix(char *hname, StreamElem *ste, int oldM, int newM)$/;"	f
UpMixParms	HTKLib/HFB.c	/^static void UpMixParms(FBInfo *fbInfo, int q, HLink hmm, HLink al_hmm,$/;"	f	file:
UpMixParms	HTKLib/HFBLat.c	/^static double UpMixParms(int q, HLink hmm, int t, DVector aqt, $/;"	f	file:
UpPDFCounts	HTKTools/HRest.c	/^void UpPDFCounts(LogDouble pr, int seg)$/;"	f
UpSkipTranParms	HTKLib/HFBLat.c	/^void UpSkipTranParms(int q, int t){$/;"	f
UpStreamCounts	HTKTools/HRest.c	/^void UpStreamCounts(int j, int s, StreamElem *se, int vSize, LogDouble pr, int seg,$/;"	f
UpTranCounts	HTKTools/HRest.c	/^void UpTranCounts(LogDouble pr,int seg)$/;"	f
UpTranParms	HTKLib/HFB.c	/^static void UpTranParms(FBInfo *fbInfo, HLink hmm, int t, int q,$/;"	f	file:
UpTranParms	HTKLib/HFBLat.c	/^static void UpTranParms(int t, int q){ $/;"	f	file:
UpTrans	HTKTools/HInit.c	/^void UpTrans(TrAcc *ta, Matrix tr)$/;"	f
UpVars	HTKTools/HInit.c	/^void UpVars(int i, int s, int m, int size, VaAcc *va, Vector oldMean,$/;"	f
UpWeights	HTKTools/HInit.c	/^void UpWeights(int i, int s, int M, WtAcc *wa, StreamElem *ste)$/;"	f
UpdateAccCache	HTKLib/HAdapt.c	/^void UpdateAccCache(double Lr, Vector svec, MixPDF *mp)$/;"	f
UpdateBaseAccs	HTKLib/HAdapt.c	/^void UpdateBaseAccs(Vector svec)$/;"	f
UpdateBaseAccsWithPaac	HTKLib/HAdapt.c	/^void UpdateBaseAccsWithPaac(void)$/;"	f
UpdateCRCC	HTKLib/HParm.c	/^unsigned int UpdateCRCC(void *data,int n,int s,Boolean bSwap,unsigned int crcc)$/;"	f
UpdateConfigFromBinary	HTKLVRec/kenlm/lm/bhiksha.cc	/^void ArrayBhiksha::UpdateConfigFromBinary(const BinaryFormat &file, uint64_t offset, Config &config) {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
UpdateConfigFromBinary	HTKLVRec/kenlm/lm/bhiksha.hh	/^    static void UpdateConfigFromBinary(const BinaryFormat &, uint64_t, Config &\/*config*\/) {}$/;"	f	class:lm::ngram::trie::DontBhiksha
UpdateConfigFromBinary	HTKLVRec/kenlm/lm/quantize.cc	/^void SeparatelyQuantize::UpdateConfigFromBinary(const BinaryFormat &file, uint64_t offset, Config &config) {$/;"	f	class:lm::ngram::SeparatelyQuantize
UpdateConfigFromBinary	HTKLVRec/kenlm/lm/quantize.hh	/^    static void UpdateConfigFromBinary(const BinaryFormat &, uint64_t, Config &) {}$/;"	f	class:lm::ngram::DontQuantize
UpdateConfigFromBinary	HTKLVRec/kenlm/lm/search_hashed.hh	/^    static void UpdateConfigFromBinary(const BinaryFormat &, const std::vector<uint64_t> &, uint64_t, Config &) {}$/;"	f	class:lm::ngram::detail::HashedSearch
UpdateConfigFromBinary	HTKLVRec/kenlm/lm/search_trie.hh	/^    static void UpdateConfigFromBinary(const BinaryFormat &file, const std::vector<uint64_t> &counts, uint64_t offset, Config &config) {$/;"	f	class:lm::ngram::trie::TrieSearch
UpdateCopyFrom	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    void UpdateCopyFrom() {$/;"	f	class:lm::builder::__anon42::CollapseStream	file:
UpdateCounters	HTKTools/HRest.c	/^void UpdateCounters(LogDouble pr, int seg)$/;"	f
UpdateCounts	HTKTools/HInit.c	/^void UpdateCounts(int segNum, int segLen, IntVec states,IntVec *mixes)$/;"	f
UpdateGauss	HTKTools/HMMIRest.c	/^Boolean UpdateGauss(int stream, MixPDF *mp){$/;"	f
UpdateHLDAModel	HTKLib/HAdapt.c	/^void UpdateHLDAModel(HMMSet *hset)$/;"	f
UpdateLMlookahead	HTKLVRec/HLVRec-LM.c	/^static void UpdateLMlookahead(DecoderInst *dec, LexNode *ln)$/;"	f	file:
UpdateMInfo	HTKLib/HAdapt.c	/^static void UpdateMInfo(HMMSet *hset, AdaptXForm *xform)$/;"	f	file:
UpdateMeanVar	HTKTools/HCompV.c	/^void UpdateMeanVar(SpkrAccListItem *sal)$/;"	f
UpdateMeans	HTKLib/HMap.c	/^static int UpdateMeans(HMMSet *hset, int px, HLink hmm)$/;"	f	file:
UpdateMeans	HTKTools/HERest.c	/^void UpdateMeans(HMMSet *hset, int px, HLink hmm)$/;"	f
UpdateModPaths	HTKLVRec/HLVRec-propagate.c	/^void UpdateModPaths (DecoderInst *dec, TokenSet *ts, LexNode *ln)$/;"	f
UpdateModel	HLMLib/LPCalc.c	/^BackOffLM *UpdateModel(BackOffLM *lm, BuildInfo *bi)$/;"	f
UpdateModels	HTKTools/HERest.c	/^void UpdateModels(HMMSet *hset, ParmBuf pbuf2)$/;"	f
UpdateModels	HTKTools/HMMIRest.c	/^void UpdateModels(void)$/;"	f
UpdateModels	HTKTools/HSmooth.c	/^void UpdateModels(void)$/;"	f
UpdateObsCache	HTKLib/HAdapt.c	/^static void UpdateObsCache( ObsCache *oc, Vector svec, LogFloat det, int t)  $/;"	f	file:
UpdateOccSums	HTKTools/HHEd.c	/^void UpdateOccSums(int i, int j, Vector occSum, int N)$/;"	f
UpdateParameters	HTKTools/HInit.c	/^void UpdateParameters(void)$/;"	f
UpdateProjectModels	HTKLib/HAdapt.c	/^void UpdateProjectModels(HMMSet *hset, char *dir)$/;"	f
UpdateSemiTiedAccs	HTKLib/HAdapt.c	/^static void UpdateSemiTiedAccs(AdaptXForm *xform, AccStruct *accs, IntVec classes, TriMat totCov)$/;"	f	file:
UpdateSemiTiedMeans	HTKLib/HAdapt.c	/^static void UpdateSemiTiedMeans(HMMSet *hset, LinXForm *xf, BaseClass *bclass, IntVec classes, Vector totMean)$/;"	f	file:
UpdateSemiTiedModels	HTKLib/HAdapt.c	/^void UpdateSemiTiedModels(HMMSet *hset, XFInfo *xfinfo)$/;"	f
UpdateSemiTiedVFloor	HTKLib/HAdapt.c	/^static void UpdateSemiTiedVFloor(HMMSet *hset, LinXForm *xf, TriMat avCov, SVector vFloor)$/;"	f	file:
UpdateSemiTiedVars	HTKLib/HAdapt.c	/^static double UpdateSemiTiedVars(HMMSet *hset, LinXForm *xf, BaseClass *bclass, IntVec classes, Vector vFloor, TriMat totCov)$/;"	f	file:
UpdateSemiTiedXForm	HTKLib/HAdapt.c	/^static void UpdateSemiTiedXForm(AccStruct *accs, LinXForm *xf, LinXForm *ixf)$/;"	f	file:
UpdateSpkrAccList	HTKTools/HCompV.c	/^SpkrAccListItem *UpdateSpkrAccList(SpkrAccListItem *sal, SpkrAcc *sa)$/;"	f
UpdateSpkrModels	HTKLVRec/HDecode.c	/^Boolean UpdateSpkrModels (char *fn)$/;"	f
UpdateSpkrModels	HTKLVRec/HDecode.mod.c	/^Boolean UpdateSpkrModels (char *fn)$/;"	f
UpdateSpkrStats	HTKLib/HAdapt.c	/^Boolean UpdateSpkrStats(HMMSet *hset, XFInfo *xfinfo, char *datafn)$/;"	f
UpdateTMMeans	HTKTools/HERest.c	/^void UpdateTMMeans(HMMSet *hset)$/;"	f
UpdateTMMeans	HTKTools/HSmooth.c	/^void UpdateTMMeans(void)$/;"	f
UpdateTMVars	HTKTools/HERest.c	/^void UpdateTMVars(HMMSet *hset)$/;"	f
UpdateTMVars	HTKTools/HSmooth.c	/^void UpdateTMVars(void)$/;"	f
UpdateTheModel	HTKTools/HRest.c	/^void UpdateTheModel(void)$/;"	f
UpdateTrans	HTKTools/HERest.c	/^void UpdateTrans(HMMSet *hset, int px, HLink hmm)$/;"	f
UpdateTrans	HTKTools/HMMIRest.c	/^void UpdateTrans(int px, HLink hmm)$/;"	f
UpdateTrans	HTKTools/HSmooth.c	/^void UpdateTrans(HLink hmm)$/;"	f
UpdateVars	HTKLib/HMap.c	/^static void UpdateVars(HMMSet *hset, int px, HLink hmm)$/;"	f	file:
UpdateVars	HTKTools/HERest.c	/^void UpdateVars(HMMSet *hset, int px, HLink hmm)$/;"	f
UpdateWeight	HTKTools/HMMIRest.c	/^void UpdateWeight(int s, StreamElem *ste){$/;"	f
UpdateWeights	HTKLib/HMap.c	/^static void UpdateWeights(HMMSet *hset, int px, HLink hmm)$/;"	f	file:
UpdateWeights	HTKTools/HERest.c	/^void UpdateWeights(HMMSet *hset, int px, HLink hmm)$/;"	f
UpdateWeights	HTKTools/HSmooth.c	/^void UpdateWeights(HLink hmm)$/;"	f
UpdateWeightsAndTrans	HTKTools/HMMIRest.c	/^void UpdateWeightsAndTrans(void){$/;"	f
UpdateWeightsOrTrans	HTKTools/HMMIRest.c	/^void UpdateWeightsOrTrans(int M, float *acc1, float *acc2, float *mixes, float *oldMixes, float C){ $/;"	f
UpdateWordEndHyp	HTKLVRec/HLVRec-propagate.c	/^static void UpdateWordEndHyp (DecoderInst *dec, LexNodeInst *inst)$/;"	f	file:
UpperBoundary	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  DiyFp UpperBoundary() const {$/;"	f	class:double_conversion::Double
UpperBoundary	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  DiyFp UpperBoundary() const {$/;"	f	class:double_conversion::Single
UpperCase	HLMLib/LUtil.c	/^void UpperCase(char *s)$/;"	f
Use	HTKBook/HTKRef/HCopy.tex	/^\\subsection{Use}$/;"	b
Use	HTKBook/HTKRef/HHEd.tex	/^\\subsection{Use}$/;"	b
UseAlignHMMSet	HTKLib/HFB.c	/^void UseAlignHMMSet(FBInfo* fbInfo, MemHeap* x, HMMSet *al_hset)$/;"	f
UseCommand	HTKTools/HHEd.c	/^void UseCommand(void)$/;"	f
UseOldXFormCVN	HTKLib/HParm.c	/^static Boolean UseOldXFormCVN = (Boolean)FALSE;  \/* this allows us to go back to the old version with broken CVN *\/$/;"	v	file:
Ushort	HTKLib/esignal.h	/^typedef unsigned short			Ushort;$/;"	t
UttInfo	HTKLib/HFB.h	/^} UttInfo;$/;"	t	typeref:struct:__anon96
V1COMPAT	HTKLib/HParm.c	/^   V1COMPAT,      \/* Set Version 1 compatibility mode *\/$/;"	e	enum:__anon142	file:
VARATSYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
VARIANCE	HTKLib/HModel.c	/^   MEAN, VARIANCE, INVCOVAR, XFORM, GCONST,$/;"	e	enum:__anon117	file:
VARSCALEDIR	HTKLib/HParm.c	/^   VARSCALEDIR,  \/* dir to find the variance estimate files *\/$/;"	e	enum:__anon142	file:
VARSCALEFN	HTKLib/HParm.c	/^   VARSCALEFN,$/;"	e	enum:__anon142	file:
VARSCALEMASK	HTKLib/HParm.c	/^   VARSCALEMASK, \/* label mask to idenitfy the variance estimate files *\/$/;"	e	enum:__anon142	file:
VARSCALEPATHMASK	HTKLib/HParm.c	/^   VARSCALEPATHMASK, \/* label mask to idenitfy the path of the variance estimate files *\/$/;"	e	enum:__anon142	file:
VARSYM	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	e	enum:_Symbol	file:
VAXSO	HTKLib/HWave.c	/^   VAXSO,      \/* little-endian ie low byte first *\/$/;"	e	enum:_SrcOrder	file:
VAdd	HTKTools/HHEd.c	/^void VAdd(Vector a, Vector b)$/;"	f
VBDEF	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon200	file:
VECSIZE	HTKLib/HModel.c	/^   NUMSTATES, STREAMINFO, VECSIZE, $/;"	e	enum:__anon117	file:
VERSION	HLMTools/LPlex.c	55;"	d	file:
VERSION	HTKLib/esignal.h	55;"	d
VERSION	Makefile	/^VERSION = @VERSION@$/;"	m
VERT	HTKTools/HResults.c	/^enum _Direction{DIAG,VERT,HOR,NIL};$/;"	e	enum:_Direction	file:
VGetLabelList	HTKTools/HLEd.c	/^LabList* VGetLabelList(Transcription *t, int n)$/;"	f
VHASHSIZE	HTKLib/HDict.h	32;"	d
VIRTUAL	HTKLib/esignal.h	92;"	d
VMax	HTKTools/HHEd.c	/^void VMax(Vector a, Vector b)$/;"	f
VNorm	HTKTools/HHEd.c	/^void VNorm(Vector a, int n)$/;"	f
VOLUME_STEPS	HTKTools/HSLab.c	102;"	d	file:
VQNode	HTKLib/HVQ.h	/^typedef struct _VQNodeRec *VQNode;$/;"	t	typeref:struct:_VQNodeRec
VQNodeRec	HTKLib/HVQ.h	/^}VQNodeRec;$/;"	t	typeref:struct:_VQNodeRec
VQNodeScore	HTKLib/HVQ.c	/^float VQNodeScore(VQNode n, Vector v, int size, CovKind ck)$/;"	f
VQTABLE	HTKLib/HParm.c	/^   VQTABLE,       \/* Name of file holding VQ table *\/$/;"	e	enum:__anon142	file:
VQTabRec	HTKLib/HVQ.h	/^}VQTabRec;$/;"	t	typeref:struct:_VQTabRec
VQTable	HTKLib/HVQ.h	/^typedef struct _VQTabRec *VQTable;$/;"	t	typeref:struct:_VQTabRec
VQbased	HTKLib/HParm.c	/^typedef enum { FFTbased, LPCbased, VQbased} CodeStyle;$/;"	e	enum:__anon140	file:
VRecInfo	HTKLib/HRec.h	/^typedef struct vrecinfo VRecInfo; \/* Visible recognition information *\/$/;"	t	typeref:struct:vrecinfo
VSetLabelList	HTKTools/HLEd.c	/^void VSetLabelList(int n)$/;"	f
VaAcc	HTKLib/HTrain.h	/^} VaAcc;$/;"	t	typeref:struct:__anon166
ValidCodeParms	HTKLib/HParm.c	/^static void ValidCodeParms(IOConfig cf)$/;"	f	file:
ValidConversion	HTKLib/HParm.c	/^Boolean ValidConversion (ParmKind src, ParmKind tgt)$/;"	f
ValidEnd	HTKLVRec/kenlm/util/stream/block.hh	/^    const void *ValidEnd() const { $/;"	f	class:util::stream::Block
ValidProbNode	HTKTools/HHEd.c	/^void ValidProbNode(Node *node,float thresh)$/;"	f
ValidSize	HTKLVRec/kenlm/util/stream/block.hh	/^    std::size_t ValidSize() const { return valid_size_; }$/;"	f	class:util::stream::Block
ValidType	HTKLib/esignal.c	/^ValidType(int type    \/* numeric data-type code *\/ )$/;"	f
Value	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    Payload &Value() { return *reinterpret_cast<Payload *>(end_); }$/;"	f	class:lm::builder::NGram
Value	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    const Payload &Value() const { return *reinterpret_cast<const Payload *>(end_); }$/;"	f	class:lm::builder::NGram
Value	HTKLVRec/kenlm/lm/search_hashed.hh	/^  typedef Prob Value;$/;"	t	struct:lm::ngram::detail::ProbEntry
Value	HTKLVRec/kenlm/lm/value.hh	/^    typedef Weights Value;$/;"	t	struct:lm::ngram::BackoffValue::ProbingEntry
Value	HTKLVRec/kenlm/lm/value.hh	/^    typedef Weights Value;$/;"	t	struct:lm::ngram::RestValue::ProbingEntry
Value	HTKLVRec/kenlm/lm/value_build.hh	/^    typedef BackoffValue Value;$/;"	t	class:lm::ngram::NoRestBuild
Value	HTKLVRec/kenlm/lm/value_build.hh	/^    typedef RestValue Value;$/;"	t	class:lm::ngram::LowerRestBuild
Value	HTKLVRec/kenlm/lm/value_build.hh	/^    typedef RestValue Value;$/;"	t	class:lm::ngram::MaxRestBuild
Values	HTKLVRec/kenlm/lm/search_trie.cc	/^    const std::vector<float> &Values(unsigned char order) const {$/;"	f	class:lm::ngram::trie::__anon58::SRISucks
Vector	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  Vector() : start_(NULL), length_(0) {}$/;"	f	class:double_conversion::Vector
Vector	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  Vector(T* data, int length) : start_(data), length_(length) {$/;"	f	class:double_conversion::Vector
Vector	HTKLVRec/kenlm/util/double-conversion/utils.h	/^class Vector {$/;"	c	namespace:double_conversion
Vector	HTKLib/HMem.h	/^typedef float *Vector;     \/* vector[1..size]   *\/$/;"	t
VectorElemSize	HTKLib/HMem.c	/^size_t VectorElemSize(int size) { return (size+1)*sizeof(float); }$/;"	f
VectorSize	HTKLib/HMem.c	/^int VectorSize(Vector v)$/;"	f
Vectors	HTKLVRec/kenlm/lm/neural/wordvecs.hh	/^    const Storage &Vectors() const { return vecs_; }$/;"	f	class:lm::neural::WordVecs
VersionEntry	HTKLib/HShell.c	/^}VersionEntry;$/;"	t	typeref:struct:_VersionEntry	file:
Vertex	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    Vertex() : current_(0) {}$/;"	f	class:lm::phrase::detail::Vertex
Vertex	HTKLVRec/kenlm/lm/filter/phrase.cc	/^class Vertex {$/;"	c	namespace:lm::phrase::detail	file:
Visit	HTKLVRec/kenlm/lm/search_trie.cc	/^    void Visit(const WordIndex *to, unsigned char length, float prob) {$/;"	f	class:lm::ngram::trie::__anon58::BlankManager
ViterbiAlign	HTKTools/HInit.c	/^LogFloat ViterbiAlign(int segNum,int segLen, IntVec states, IntVec *mixes)$/;"	f
Vocab	HTKLib/HDict.h	/^} Vocab;$/;"	t	typeref:struct:__anon94
VocabEntry	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^struct VocabEntry {$/;"	s	namespace:lm::builder::__anon43	file:
VocabHash	HTKLib/HDict.c	/^static int VocabHash(LabId name)$/;"	f	file:
VocabLoadException	HTKLVRec/kenlm/lm/lm_exception.cc	/^VocabLoadException::VocabLoadException() throw() {}$/;"	f	class:lm::VocabLoadException
VocabLoadException	HTKLVRec/kenlm/lm/lm_exception.hh	/^class VocabLoadException : public LoadException {$/;"	c	namespace:lm
VocabReconstitute	HTKLVRec/kenlm/lm/builder/print.cc	/^VocabReconstitute::VocabReconstitute(int fd) {$/;"	f	class:lm::builder::VocabReconstitute
VocabReconstitute	HTKLVRec/kenlm/lm/builder/print.hh	/^class VocabReconstitute {$/;"	c	namespace:lm::builder
VocabStringReadingOffset	HTKLVRec/kenlm/lm/binary_format.hh	/^    uint64_t VocabStringReadingOffset() const {$/;"	f	class:lm::ngram::BinaryFormat
VocabUsage	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^std::size_t CorpusCount::VocabUsage(std::size_t vocab_estimate) {$/;"	f	class:lm::builder::CorpusCount
Vocabulary	HTKLVRec/kenlm/lm/facade.hh	/^    typedef VocabularyT Vocabulary;$/;"	t	class:lm::base::ModelFacade
Vocabulary	HTKLVRec/kenlm/lm/model.hh	/^typedef ::lm::ngram::ProbingVocabulary Vocabulary;$/;"	t	namespace:lm::ngram
Vocabulary	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    Vocabulary() {}$/;"	f	class:lm::base::Vocabulary
Vocabulary	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    Vocabulary(WordIndex begin_sentence, WordIndex end_sentence, WordIndex not_found) {$/;"	f	class:lm::base::Vocabulary
Vocabulary	HTKLVRec/kenlm/lm/virtual_interface.hh	/^class Vocabulary {$/;"	c	namespace:lm::base
Vocabulary	HTKLVRec/kenlm/lm/wrappers/nplm.cc	/^Vocabulary::Vocabulary(const nplm::vocabulary &vocab) $/;"	f	class:lm::np::Vocabulary
Vocabulary	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^class Vocabulary : public base::Vocabulary {$/;"	c	namespace:lm::np
VolType	HTKLib/HAudio.c	/^} VolType;$/;"	t	typeref:enum:__anon90	file:
W	HLMTools/Cluster.c	/^static int         W = 0;     		    \/* Number of words *\/$/;"	v	file:
WALink	HTKTools/HSmooth.c	/^typedef struct _ChWtAcc *WALink;$/;"	t	typeref:struct:_ChWtAcc	file:
WARPFREQ	HTKLib/HParm.c	/^   WARPFREQ,      \/* Vocal tract length compensation by frequency warping *\/$/;"	e	enum:__anon142	file:
WARPLCUTOFF	HTKLib/HParm.c	/^   WARPLCUTOFF,   \/* VTL warping cutoff frequencies for smoothing *\/$/;"	e	enum:__anon142	file:
WARPUCUTOFF	HTKLib/HParm.c	/^   WARPUCUTOFF,$/;"	e	enum:__anon142	file:
WAV	HTKLib/HWave.h	/^	WAV,               \/* Microsoft WAVE format *\/$/;"	e	enum:__anon181
WAVEFORM	HTKLib/HParm.h	/^      WAVEFORM,            \/* Raw speech waveform (handled by HWave) *\/$/;"	e	enum:_BaseParmKind
WAVEFORM	HTKLib/HWave.c	1398;"	d	file:
WAVEFORM	HTKLib/HWave.c	47;"	d	file:
WAVE_FORMAT_ALAW	HTKLib/HWave.c	52;"	d	file:
WAVE_FORMAT_MULAW	HTKLib/HWave.c	53;"	d	file:
WAVE_FORMAT_PCM	HTKLib/HWave.c	50;"	d	file:
WAVE_WIN	HTKTools/HSLab.c	/^   WAVE_WIN, LAB_WIN, IO_WIN, NO_WIN $/;"	e	enum:__anon207	file:
WBDEF	HTKTools/HLEd.c	/^   SBDEF,   EXPAND, IFILL,  SORT,   WBDEF,  VBDEF,  LCTXT,  $/;"	e	enum:__anon200	file:
WCHAR	HTKLib/esignal.h	81;"	d
WCH_W	HTKLib/esig_asc.c	96;"	d	file:
WDPEN	HTKLib/HArc.c	/^static float WDPEN = 0;$/;"	v	file:
WEIGHTS_KEY	HTKLib/HUtil.c	/^   TRANSP_KEY, STATE_KEY, DUR_KEY, WEIGHTS_KEY,$/;"	e	enum:__anon168	file:
WHITE	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
WIDTH	HTKTools/HSLab.c	78;"	d	file:
WIN32_LEAN_AND_MEAN	HTKLVRec/kenlm/util/usage.cc	17;"	d	file:
WINBOOL	HTKLVRec/kenlm/util/usage.cc	/^typedef int WINBOOL;$/;"	t	file:
WINDOWSIZE	HTKLib/HParm.c	/^   WINDOWSIZE,    \/* Window size in 100ns *\/ $/;"	e	enum:__anon142	file:
WINNAME	HTKTools/HSLab.c	70;"	d	file:
WMAP_HDR	HLMLib/LUtil.h	/^   NO_HDR, WMAP_HDR, CMAP_HDR, GRAM_HDR, LFOF_HDR$/;"	e	enum:__anon19
WNHASHSIZE	HTKLib/HNet.c	1739;"	d	file:
WORDFIELDWIDTH	HTKLib/HDict.c	348;"	d	file:
WPGrammar	HTKTools/HBuild.c	/^}WPGrammar;$/;"	t	typeref:struct:__anon188	file:
WPtrOff	HTKTools/HSLab.c	/^void WPtrOff(void)$/;"	f
WPtrOn	HTKTools/HSLab.c	/^void WPtrOn(void)$/;"	f
WRITE_AFTER	HTKLVRec/kenlm/lm/config.hh	/^    WRITE_AFTER \/\/ Write after we're done.$/;"	e	enum:lm::ngram::Config::WriteMethod
WRITE_MMAP	HTKLVRec/kenlm/lm/config.hh	/^    WRITE_MMAP, \/\/ Map the file directly.$/;"	e	enum:lm::ngram::Config::WriteMethod
Wait	HTKLVRec/kenlm/util/stream/chain.cc	/^void Chain::Wait(bool release_memory) {$/;"	f	class:util::stream::Chain
Wait	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    void Wait(bool release_memory = true) {$/;"	f	class:util::stream::Chains
WaitSemaphore	HTKLVRec/kenlm/util/pcqueue.hh	/^inline void WaitSemaphore(Semaphore &semaphore) {$/;"	f	namespace:util
Wall	HTKLVRec/kenlm/util/usage.cc	/^typedef struct timeval Wall;$/;"	t	namespace:util::__anon83	typeref:struct:util::__anon83::timeval	file:
WallTime	HTKLVRec/kenlm/util/usage.cc	/^double WallTime() {$/;"	f	namespace:util
Warn	HTKLVRec/kenlm/lm/read_arpa.cc	/^void PositiveProbWarn::Warn(float prob) {$/;"	f	class:lm::PositiveProbWarn
WarningAction	HTKLVRec/kenlm/lm/lm_exception.hh	/^typedef enum {THROW_UP, COMPLAIN, SILENT} WarningAction;$/;"	t	namespace:lm	typeref:enum:lm::__anon51
WarpFreq	HTKLib/HSigP.c	/^float WarpFreq (float fcl, float fcu, float freq, float minFreq, float maxFreq , float alpha)$/;"	f
Wave	HTKLib/HWave.h	/^typedef struct _Wave *Wave;  \/* Abstract type representing waveform file *\/$/;"	t	typeref:struct:_Wave
Wave2FBank	HTKLib/HSigP.c	/^void Wave2FBank(Vector s, Vector fbank, float *te, FBankInfo info)$/;"	f
Wave2LPC	HTKLib/HSigP.c	/^void Wave2LPC (Vector s, Vector a, Vector k, float *re, float *te)$/;"	f
WaveFilter	HTKLib/HShell.h	/^   WaveFilter,      \/* waveforms input via HWave *\/$/;"	e	enum:__anon153
WaveFormat	HTKLib/HWave.c	/^FileFormat WaveFormat(Wave w)$/;"	f
WaveOFilter	HTKLib/HShell.h	/^   WaveOFilter,     \/* waveforms output via HWave *\/$/;"	e	enum:__anon153
WaveRec	HTKLib/HWave.c	/^}WaveRec;$/;"	t	typeref:struct:_Wave	file:
Wchar	HTKLib/esignal.h	/^typedef unsigned short			Wchar;$/;"	t
Wd_Cmp	HTKLib/HDict.c	/^static int Wd_Cmp(const void *v1,const void *v2)$/;"	f	file:
WeightCepstrum	HTKLib/HSigP.c	/^void WeightCepstrum (Vector c, int start, int count, int cepLiftering)$/;"	f
Weights	HTKLVRec/kenlm/lm/value.hh	/^  typedef ProbBackoff Weights;$/;"	t	struct:lm::ngram::BackoffValue
Weights	HTKLVRec/kenlm/lm/value.hh	/^  typedef RestWeights Weights;$/;"	t	struct:lm::ngram::RestValue
WinKind	HTKTools/HSLab.c	/^} WinKind;$/;"	t	typeref:enum:__anon207	file:
Word	HTKLVRec/kenlm/lm/ngram_query.hh	/^  void Word(StringPiece surface, WordIndex vocab, const FullScoreReturn &ret) const {$/;"	f	struct:lm::ngram::FullPrint
Word	HTKLVRec/kenlm/lm/ngram_query.hh	/^  void Word(StringPiece, WordIndex, const FullScoreReturn &) const {}$/;"	f	struct:lm::ngram::BasicPrint
Word	HTKLib/HDict.h	/^typedef struct _DictEntry *Word;$/;"	t	typeref:struct:_DictEntry
WordBuf	HTKTools/HDMan.c	/^}WordBuf;$/;"	t	typeref:struct:__anon194	file:
WordClass	HLMLib/LCMap.c	/^int WordClass(ClassMap *c, int wdndx)$/;"	f
WordFllr	HTKTools/HBuild.c	/^}WordFllr;$/;"	t	typeref:struct:_WordFllr	file:
WordIndex	HTKLVRec/kenlm/lm/word_index.hh	/^typedef unsigned int WordIndex;$/;"	t	namespace:lm
WordInfo	HTKTools/HLStats.c	/^} WordInfo;$/;"	t	typeref:struct:wordinfo	file:
WordLMCmp	HLMLib/LWMap.c	/^int WordLMCmp(int ndx1, int ndx2, WordMap *wm)$/;"	f
WordLMCount	HLMLib/LWMap.c	/^int WordLMCount(LabId id)$/;"	f
WordLMIndex	HLMLib/LWMap.c	/^int WordLMIndex(LabId id)$/;"	f
WordLMName	HLMLib/LWMap.c	/^LabId WordLMName(int ndx, WordMap *wm)$/;"	f
WordMap	HLMLib/LWMap.h	/^} WordMap;$/;"	t	typeref:struct:__anon23
WordMatch	HTKLib/HRec.c	/^static Boolean WordMatch(NBestEntry *cmp,NBestEntry *ans)$/;"	f	file:
WordProb	HLMLib/LModel.h	/^} WordProb;$/;"	t	typeref:struct:__anon14
WordPron	HTKLib/HDict.h	/^} WordPron;$/;"	t	typeref:struct:_WordPron
WordVecs	HTKLVRec/kenlm/lm/neural/wordvecs.cc	/^WordVecs::WordVecs(util::FilePiece &f) {$/;"	f	class:lm::neural::WordVecs
WordVecs	HTKLVRec/kenlm/lm/neural/wordvecs.hh	/^class WordVecs {$/;"	c	namespace:lm::neural
WordendHyp	HTKLVRec/HLVRec.h	/^typedef struct _WordendHyp WordendHyp;      \/* records word level tracback *\/$/;"	t	typeref:struct:_WordendHyp
Words	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    typedef boost::unordered_map<std::string, std::vector<unsigned int> > Words;$/;"	t	class:lm::vocab::Multiple
Words	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    typedef boost::unordered_map<std::string, std::vector<unsigned int> > Words;$/;"	t	class:lm::vocab::Union
Words	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    typedef boost::unordered_set<std::string> Words;$/;"	t	class:lm::vocab::Single
Worker	HTKLVRec/kenlm/util/thread_pool.hh	/^    template <class Construct> Worker(PCQueue<Request> &in, Construct &construct, const Request &poison)$/;"	f	class:util::Worker
Worker	HTKLVRec/kenlm/util/thread_pool.hh	/^template <class HandlerT> class Worker : boost::noncopyable {$/;"	c	namespace:util
WorkerProgress	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    WorkerProgress() : parent_(NULL) {}$/;"	f	class:util::stream::WorkerProgress
WorkerProgress	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    WorkerProgress(uint64_t next, MultiProgress &parent, char character) $/;"	f	class:util::stream::WorkerProgress
WorkerProgress	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^class WorkerProgress {$/;"	c	namespace:util::stream
Write	HTKLVRec/kenlm/lm/quantize.hh	/^        void Write(float prob) const {$/;"	f	class:lm::ngram::SeparatelyQuantize::LongestPointer
Write	HTKLVRec/kenlm/lm/quantize.hh	/^        void Write(float prob) {$/;"	f	class:lm::ngram::DontQuantize::LongestPointer
Write	HTKLVRec/kenlm/lm/quantize.hh	/^        void Write(float prob, float backoff) const {$/;"	f	class:lm::ngram::SeparatelyQuantize::MiddlePointer
Write	HTKLVRec/kenlm/lm/quantize.hh	/^        void Write(float prob, float backoff) {$/;"	f	class:lm::ngram::DontQuantize::MiddlePointer
Write	HTKLVRec/kenlm/util/stream/io.hh	/^    explicit Write(int fd) : file_(fd) {}$/;"	f	class:util::stream::Write
Write	HTKLVRec/kenlm/util/stream/io.hh	/^class Write {$/;"	c	namespace:util::stream
WriteAndRecycle	HTKLVRec/kenlm/util/stream/io.hh	/^    explicit WriteAndRecycle(int fd) : file_(fd) {}$/;"	f	class:util::stream::WriteAndRecycle
WriteAndRecycle	HTKLVRec/kenlm/util/stream/io.hh	/^class WriteAndRecycle {$/;"	c	namespace:util::stream
WriteAsciiArray	HTKLib/esig_asc.c	/^WriteAsciiArray(Array *array, FILE *file, Annot *annotate)$/;"	f	file:
WriteAsciiData	HTKLib/esig_asc.c	/^WriteAsciiData(FieldSpec *field,$/;"	f	file:
WriteAsciiFieldList	HTKLib/esig_asc.c	/^WriteAsciiFieldList(FieldList list,$/;"	f
WriteAsciiFieldSpec	HTKLib/esig_asc.c	/^WriteAsciiFieldSpec(FieldSpec *field,$/;"	f	file:
WriteAsciiRecord	HTKLib/esig_asc.c	/^WriteAsciiRecord(FieldSpec **fields,    \/* linear array of fields *\/$/;"	f
WriteAsciiSamples	HTKLib/esig_asc.c	/^WriteAsciiSamples(void      *data,$/;"	f
WriteAsciiString	HTKLib/esig_asc.c	/^WriteAsciiString(char *data,$/;"	f	file:
WriteBoNGram	HTKLib/HLM.c	/^static void WriteBoNGram(LModel *lm,char *fn,int flags)$/;"	f	file:
WriteClassMap	HLMLib/LCMap.c	/^static void WriteClassMap(FILE *f, ClassMap *cm, Boolean debug)$/;"	f	file:
WriteContextFile	HTKLVRec/kenlm/lm/trie_sort.cc	/^FILE *WriteContextFile(uint8_t *begin, uint8_t *end, const std::string &temp_prefix, std::size_t entry_size, unsigned char order) {$/;"	f	namespace:lm::ngram::trie::__anon60
WriteCounts	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^void WriteCounts(std::ostream &out, const std::vector<uint64_t> &number) {$/;"	f	namespace:lm
WriteDict	HTKLib/HDict.c	/^ReturnStatus WriteDict(char *dictFn, Vocab *voc)$/;"	f
WriteDictWord	HTKTools/HDMan.c	/^void WriteDictWord(DBuffer *db, FILE *f, int margin, Boolean findNew)$/;"	f
WriteESIGPHeader	HTKLib/HParm.c	/^void WriteESIGPHeader(FILE *f, IOConfig cf, HTime sampPeriod, short sampSize, short pKind)$/;"	f
WriteEdrArray	HTKLib/esig_edr.c	/^WriteEdrArray(Array *array,$/;"	f	file:
WriteEdrData	HTKLib/esig_edr.c	/^WriteEdrData(FieldSpec  *field,$/;"	f	file:
WriteEdrFieldList	HTKLib/esig_edr.c	/^WriteEdrFieldList(FieldList list,   \/* field list *\/$/;"	f
WriteEdrFieldSpec	HTKLib/esig_edr.c	/^WriteEdrFieldSpec(FieldSpec *field,$/;"	f	file:
WriteEdrRecord	HTKLib/esig_edr.c	/^WriteEdrRecord(FieldSpec    **fields,$/;"	f
WriteEdrSamples	HTKLib/esig_edr.c	/^WriteEdrSamples(void        *data,$/;"	f
WriteEdrString	HTKLib/esig_edr.c	/^WriteEdrString(char     *string,$/;"	f	file:
WriteEntries	HTKLVRec/kenlm/lm/search_trie.cc	/^    WriteEntries(RecordReader *contexts, const Quant &quant, UnigramValue *unigrams, BitPackedMiddle<Bhiksha> *middle, BitPackedLongest &longest, unsigned char order, SRISucks &sri) :$/;"	f	class:lm::ngram::trie::__anon58::WriteEntries
WriteEntries	HTKLVRec/kenlm/lm/search_trie.cc	/^template <class Quant, class Bhiksha> class WriteEntries {$/;"	c	namespace:lm::ngram::trie::__anon58	file:
WriteEntry	HTKTools/HDMan.c	/^void WriteEntry(FILE *f, LabId word, LabId outsym, Pronunciation *p, int margin, Boolean findNew)$/;"	f
WriteFieldList	HTKLib/esignal.c	/^WriteFieldList(FieldList list,$/;"	f
WriteFloat	HTKLib/HShell.c	/^void WriteFloat (FILE *f, float *x, int n, Boolean binary)$/;"	f
WriteFloat32	HTKLVRec/kenlm/util/bit_packing.hh	/^inline void WriteFloat32(void *base, uint64_t bit_off, float value) {$/;"	f	namespace:util
WriteFoFHeader	HLMLib/LGBase.c	/^static void WriteFoFHeader(FILE *f, FoFTab *tab, char *source)$/;"	f	file:
WriteFoFTab	HLMLib/LGBase.c	/^void WriteFoFTab(char *fn, FoFTab *tab, char *source)$/;"	f
WriteHTKHeader	HTKLib/HWave.c	/^void WriteHTKHeader(FILE *f, long nSamp, long sampP, short sampS, $/;"	f
WriteHeader	HTKLVRec/kenlm/lm/binary_format.cc	/^void WriteHeader(void *to, const Parameters &params) {$/;"	f	namespace:lm::ngram::__anon41
WriteHeader	HTKLib/esignal.c	/^WriteHeader(FieldList  list,$/;"	f
WriteHeaderInfo	HLMLib/LModel.c	/^void WriteHeaderInfo(FILE *f, BackOffLM *lm)$/;"	f
WriteInt	HTKLib/HShell.c	/^void WriteInt(FILE *f, int *i, int n, Boolean binary)$/;"	f
WriteInt25	HTKLVRec/kenlm/util/bit_packing.hh	/^inline void WriteInt25(void *base, uint64_t bit_off, uint8_t length, uint32_t value) {$/;"	f	namespace:util
WriteInt57	HTKLVRec/kenlm/util/bit_packing.hh	/^inline void WriteInt57(void *base, uint64_t bit_off, uint8_t length, uint64_t value) {$/;"	f	namespace:util
WriteIntVec	HTKLib/HMath.c	/^void WriteIntVec(FILE *f, IntVec v, Boolean binary)$/;"	f
WriteLModel	HTKLib/HLM.c	/^void WriteLModel(LModel *lm,char *fn,int flags)$/;"	f
WriteLattice	HTKLib/HNet.c	/^ReturnStatus WriteLattice(Lattice *lat,FILE *file,LatFormat format)$/;"	f
WriteMapHeader	HLMLib/LCMap.c	/^static void WriteMapHeader(FILE *f, ClassMap *cm)$/;"	f	file:
WriteMapHeader	HLMLib/LWMap.c	/^static void WriteMapHeader(FILE *f, WordMap *w)$/;"	f	file:
WriteMatBigram	HTKLib/HLM.c	/^static void WriteMatBigram(LModel *lm,char *fn,int flags)$/;"	f	file:
WriteMatrix	HTKLib/HMath.c	/^void WriteMatrix(FILE *f, Matrix m, Boolean binary)$/;"	f
WriteMethod	HTKLVRec/kenlm/lm/config.hh	/^  enum WriteMethod {$/;"	g	struct:lm::ngram::Config
WriteNEntry	HLMLib/LModel.c	/^static int WriteNEntry(FILE *f, BackOffLM *lm, int lev, FLEntry **feBuf,$/;"	f	file:
WriteNGBuffer	HLMLib/LGBase.c	/^void WriteNGBuffer(NGBuffer *ngb, char *source)$/;"	f
WriteNGHeader	HLMLib/LGBase.c	/^static void WriteNGHeader(FILE *f, NGBuffer *ngb, char *source)$/;"	f	file:
WriteNGram	HLMLib/LGBase.c	/^int WriteNGram(FILE *f, int N, NGram ng)$/;"	f
WriteNGram	HLMLib/LModel.c	/^static int WriteNGram(FILE *f, BackOffLM *lm, FLEntry **feStack,$/;"	f	file:
WriteNGrams	HTKLib/HLM.c	/^static int WriteNGrams(FILE *file,NGramLM *nglm,int n,float scale)$/;"	f	file:
WriteNativeArray	HTKLib/esig_nat.c	/^WriteNativeArray(Array *array,$/;"	f	file:
WriteNativeData	HTKLib/esig_nat.c	/^WriteNativeData(FieldSpec *field,$/;"	f	file:
WriteNativeFieldList	HTKLib/esig_nat.c	/^WriteNativeFieldList(FieldList list,$/;"	f
WriteNativeFieldSpec	HTKLib/esig_nat.c	/^WriteNativeFieldSpec(FieldSpec  *field,$/;"	f	file:
WriteNativeRecord	HTKLib/esig_nat.c	/^WriteNativeRecord(FieldSpec **fields,$/;"	f
WriteNativeSamples	HTKLib/esig_nat.c	/^WriteNativeSamples(void     *data,$/;"	f
WriteNativeString	HTKLib/esig_nat.c	/^WriteNativeString(char *string,$/;"	f	file:
WriteNext	HTKLVRec/kenlm/lm/bhiksha.hh	/^    void WriteNext(void *base, uint64_t bit_offset, uint64_t \/*index*\/, uint64_t value) {$/;"	f	class:lm::ngram::trie::DontBhiksha
WriteNext	HTKLVRec/kenlm/lm/bhiksha.hh	/^    void WriteNext(void *base, uint64_t bit_offset, uint64_t index, uint64_t value) {$/;"	f	class:lm::ngram::trie::ArrayBhiksha
WriteNonPositiveFloat31	HTKLVRec/kenlm/util/bit_packing.hh	/^inline void WriteNonPositiveFloat31(void *base, uint64_t bit_off, float value) {$/;"	f	namespace:util
WriteOneLattice	HTKLib/HNet.c	/^ReturnStatus WriteOneLattice(Lattice *lat,FILE *file,LatFormat format)$/;"	f
WriteOrThrow	HTKLVRec/kenlm/util/file.cc	/^void WriteOrThrow(FILE *to, const void *data, std::size_t size) {$/;"	f	namespace:util
WriteOrThrow	HTKLVRec/kenlm/util/file.cc	/^void WriteOrThrow(int fd, const void *data_void, std::size_t size) {$/;"	f	namespace:util
WritePreamble	HTKLib/esignal.c	/^WritePreamble(char  *arch,$/;"	f
WriteRawHGram	HLMLib/LGBase.c	/^void WriteRawHGram(FILE *f, char *name, int N, NGram ng, WordMap *wm)$/;"	f
WriteRecord	HTKLib/esignal.c	/^WriteRecord(FieldSpec   **fields,$/;"	f
WriteSEntry	HLMLib/LModel.c	/^static int WriteSEntry(FILE *f,BackOffLM *lm,FLEntry **feTab, int fetCount)$/;"	f	file:
WriteSamples	HTKLib/esignal.c	/^WriteSamples(void       *data,$/;"	f
WriteShort	HTKLib/HShell.c	/^void WriteShort (FILE *f, short *s, int n, Boolean binary)$/;"	f
WriteShortVec	HTKLib/HMath.c	/^void WriteShortVec(FILE *f, ShortVec v, Boolean binary)$/;"	f
WriteString	HTKLib/HShell.c	/^void WriteString(FILE *f,char *s,char q)$/;"	f
WriteTLex	HTKLVRec/HLVNet.c	/^void WriteTLex (TLexNet *net, char *fn)$/;"	f
WriteTriMat	HTKLib/HMath.c	/^void WriteTriMat(FILE *f, TriMat m, Boolean binary)$/;"	f
WriteTxtHGram	HLMLib/LGBase.c	/^static void WriteTxtHGram(FILE *f, char *name, int N, LabId *ng)$/;"	f	file:
WriteUniqueWords	HTKLVRec/kenlm/lm/vocab.hh	/^    explicit WriteUniqueWords(int fd) : word_list_(fd) {}$/;"	f	class:lm::ngram::WriteUniqueWords
WriteUniqueWords	HTKLVRec/kenlm/lm/vocab.hh	/^class WriteUniqueWords {$/;"	c	namespace:lm::ngram
WriteVQTable	HTKTools/HQuant.c	/^void WriteVQTable(ClusterSet *cs[], char *fn)$/;"	f
WriteVector	HTKLib/HMath.c	/^void WriteVector(FILE *f, Vector v, Boolean binary)$/;"	f
WriteVocabWords	HTKLVRec/kenlm/lm/binary_format.cc	/^void BinaryFormat::WriteVocabWords(const std::string &buffer, void *&vocab_base, void *&search_base) {$/;"	f	class:lm::ngram::BinaryFormat
WriteWordMap	HLMLib/LWMap.c	/^static void WriteWordMap(FILE *f, WordMap *w, Boolean noHeader, Boolean debug)$/;"	f	file:
WriteWordsWrapper	HTKLVRec/kenlm/lm/vocab.cc	/^WriteWordsWrapper::WriteWordsWrapper(EnumerateVocab *inner) : inner_(inner) {}$/;"	f	class:lm::ngram::WriteWordsWrapper
WriteWordsWrapper	HTKLVRec/kenlm/lm/vocab.hh	/^class WriteWordsWrapper : public EnumerateVocab {$/;"	c	namespace:lm::ngram
Writer	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    Writer(std::size_t order, const util::stream::ChainPosition &position, void *dedupe_mem, std::size_t dedupe_mem_size) $/;"	f	class:lm::builder::__anon43::Writer
Writer	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^class Writer {$/;"	c	namespace:lm::builder::__anon43	file:
WritingToMeta	HTKLib/HGraf_WIN32.c	/^static Boolean WritingToMeta = FALSE;               \/* TRUE if spooling to a metafile *\/$/;"	v	file:
WtAcc	HTKLib/HTrain.h	/^} WtAcc;$/;"	t	typeref:struct:__anon164
XColArray	HTKLib/HGraf.c	/^static char  *XColArray[] = {$/;"	v	file:
XF	HTKTools/HHEd.c	/^                         MM , DP , HK , FC , FA , FV, XF, PS, PR }$/;"	e	enum:__anon199	file:
XFDirInfo	HTKLib/HModel.c	/^} XFDirInfo;$/;"	t	typeref:struct:_XFDirInfo	file:
XFDirLink	HTKLib/HModel.c	/^typedef struct _XFDirInfo *XFDirLink;$/;"	t	typeref:struct:_XFDirInfo	file:
XFInfo	HTKLib/HAdapt.h	/^} XFInfo;$/;"	t	typeref:struct:__anon89
XFORM	HTKLib/HModel.c	/^   MEAN, VARIANCE, INVCOVAR, XFORM, GCONST,$/;"	e	enum:__anon117	file:
XFORM	HTKLib/HModel.h	62;"	d
XFORMC	HTKLib/HMath.h	/^   XFORMC,        \/* arbitrary rectangular transform *\/$/;"	e	enum:__anon113
XFORMCOV	HTKLib/HModel.c	/^   DIAGCOV,  FULLCOV, XFORMCOV,$/;"	e	enum:__anon117	file:
XFORMKIND	HTKLib/HModel.c	/^   XFORMKIND=90, PARENTXFORM, NUMXFORMS, XFORMSET,$/;"	e	enum:__anon117	file:
XFORMSET	HTKLib/HModel.c	/^   XFORMKIND=90, PARENTXFORM, NUMXFORMS, XFORMSET,$/;"	e	enum:__anon117	file:
XFORMWGTSET	HTKLib/HModel.c	/^   CLASS, XFORMWGTSET, CLASSXFORM, MMFIDMASK, PARAMETERS,$/;"	e	enum:__anon117	file:
XFormAccInfo	HTKLib/HModel.h	/^} XFormAccInfo;$/;"	t	typeref:struct:__anon130
XFormInfo	HTKLib/HAdapt.c	/^} XFormInfo;$/;"	t	typeref:struct:__anon88	file:
XFormKind	HTKLib/HModel.h	/^typedef enum _XFormKind XFormKind;$/;"	t	typeref:enum:_XFormKind
XFormKind2Str	HTKLib/HModel.c	/^char *XFormKind2Str(XFormKind xkind, char *buf)$/;"	f
XFormModCovar	HTKLib/HAdapt.c	/^static Boolean XFormModCovar(AdaptXForm *xform)$/;"	f	file:
XFormSet	HTKLib/HModel.h	/^} XFormSet;$/;"	t	typeref:struct:__anon133
XK_MISCELLANY	HTKLib/HGraf.c	76;"	d	file:
XOutP	HTKLib/HModel.c	/^static LogFloat XOutP(Vector x, int vecSize, MixPDF *mp)$/;"	f	file:
XZException	HTKLVRec/kenlm/util/read_compressed.cc	/^XZException::XZException() throw() {}$/;"	f	class:util::XZException
XZException	HTKLVRec/kenlm/util/read_compressed.hh	/^class XZException : public CompressedException {$/;"	c	namespace:util
XZip	HTKLVRec/kenlm/util/read_compressed.cc	/^    XZip(const void *base, std::size_t amount)$/;"	f	class:util::__anon79::XZip
XZip	HTKLVRec/kenlm/util/read_compressed.cc	/^class XZip {$/;"	c	namespace:util::__anon79	file:
X_	HLMTools/Makefile	/^	if [ X_ = X_yes ] ; then $(INSTALL) -m 755 $@ $(bindir) ; fi$/;"	m
X_	HTKTools/Makefile	/^	if [ X_ = X_yes ] ; then $(INSTALL) -m 755 $@ $(bindir)  ; fi$/;"	m
XferMode	HTKLib/HGraf.h	/^typedef enum _XferMode XferMode;$/;"	t	typeref:enum:_XferMode
XformBase	HTKLib/HParm.c	/^static void XformBase(float *data, IOConfig cf)$/;"	f	file:
XformFBANK2MELSPEC	HTKLib/HParm.c	/^static void XformFBANK2MELSPEC(float *data,int d)$/;"	f	file:
XformFBANK2MFCC	HTKLib/HParm.c	/^static void XformFBANK2MFCC(float *data,int d,int dnew,int lifter)$/;"	f	file:
XformLPC2LPCEPSTRA	HTKLib/HParm.c	/^static void XformLPC2LPCEPSTRA(float *data,int d,int dnew,int lifter)$/;"	f	file:
XformLPC2LPREFC	HTKLib/HParm.c	/^static void XformLPC2LPREFC(float *data,int d)$/;"	f	file:
XformLPCEPSTRA2LPC	HTKLib/HParm.c	/^static void XformLPCEPSTRA2LPC(float *data,int d,int lifter)$/;"	f	file:
XformLPREFC2LPC	HTKLib/HParm.c	/^static void XformLPREFC2LPC(float *data,int d)$/;"	f	file:
XformMELSPEC2FBANK	HTKLib/HParm.c	/^static void XformMELSPEC2FBANK(float *data,int d)$/;"	f	file:
YELLOW	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	e	enum:_HColour
ZMEANSOURCE	HTKLib/HParm.c	/^   ZMEANSOURCE,   \/* Zero Mean (Wave only) *\/$/;"	e	enum:__anon142	file:
ZapAliases	HTKTools/HHEd.c	/^void ZapAliases(void)$/;"	f
Zero	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^void Bignum::Zero() {$/;"	f	class:double_conversion::Bignum
ZeroAccSum	HTKTools/HHEd.c	/^void ZeroAccSum(AccSum *acc)$/;"	f
ZeroAccs	HTKLib/HTrain.c	/^void ZeroAccs(HMMSet *hset, UPDSet uFlags){ ZeroAccsParallel(hset,uFlags,1); }$/;"	f
ZeroAccsParallel	HTKLib/HTrain.c	/^void ZeroAccsParallel(HMMSet *hset, UPDSet uFlags, int nPara)$/;"	f
ZeroAdaptAccs	HTKLib/HAdapt.c	/^void ZeroAdaptAccs(HMMSet *hset, AdaptXForm *xform)$/;"	f
ZeroAlpha	HTKLib/HFB.c	/^static void ZeroAlpha(AlphaBeta *ab, int qlo, int qhi)$/;"	f	file:
ZeroAlpha	HTKLib/HFBLat.c	/^static void ZeroAlpha(int sq, int eq)$/;"	f	file:
ZeroBaseTriMat	HTKLib/HAdapt.c	/^static void ZeroBaseTriMat(TriMat *bTriMat)$/;"	f	file:
ZeroBlockTriMat	HTKLib/HAdapt.c	/^static void ZeroBlockTriMat(TriMat *bTriMat)$/;"	f	file:
ZeroDMatrix	HTKLib/HMath.c	/^void ZeroDMatrix(DMatrix m)$/;"	f
ZeroDVector	HTKLib/HMath.c	/^void ZeroDVector(DVector v)$/;"	f
ZeroHooks	HTKLib/HArc.c	/^void ZeroHooks(Lattice *lat){ \/*Checks that the hooks are zero.*\/$/;"	f
ZeroIntVec	HTKLib/HMath.c	/^void ZeroIntVec(IntVec v)$/;"	f
ZeroMatrix	HTKLib/HMath.c	/^void ZeroMatrix(Matrix m)$/;"	f
ZeroMean	HTKLib/HSigP.c	/^void ZeroMean(short *data, long nSamples)$/;"	f
ZeroMeanFrame	HTKLib/HParm.c	/^void ZeroMeanFrame(Vector v)$/;"	f
ZeroMeanWave	HTKLib/HWave.c	/^void ZeroMeanWave(Wave w)$/;"	f
ZeroRemaining	HTKLVRec/kenlm/lm/state.hh	/^    void ZeroRemaining() {$/;"	f	class:lm::ngram::State
ZeroRemaining	HTKLVRec/kenlm/lm/state.hh	/^  void ZeroRemaining() {$/;"	f	struct:lm::ngram::ChartState
ZeroRemaining	HTKLVRec/kenlm/lm/state.hh	/^  void ZeroRemaining() {$/;"	f	struct:lm::ngram::Left
ZeroShortVec	HTKLib/HMath.c	/^void ZeroShortVec(ShortVec v)$/;"	f
ZeroStats	HLMTools/LPlex.c	/^static void ZeroStats(PStats *ps)$/;"	f	file:
ZeroStreamWidths	HTKLib/HParm.c	/^void ZeroStreamWidths(int numS, short *swidth)$/;"	f
ZeroTriMat	HTKLib/HMath.c	/^void ZeroTriMat(TriMat m)$/;"	f
ZeroVector	HTKLib/HMath.c	/^void ZeroVector(Vector v)$/;"	f
ZoomRecord	HTKTools/HSLab.c	/^} ZoomRecord;$/;"	t	typeref:struct:__anon209	file:
_AInfo	HTKLib/HAdapt.c	/^typedef struct _AInfo {$/;"	s	file:
_AccCache	HTKLib/HAdapt.c	/^typedef struct _AccCache{$/;"	s	file:
_AccSum	HTKTools/HHEd.c	/^typedef struct _AccSum {        \/* Accumulator Record for storing *\/$/;"	s	file:
_AccessInfo	HLMLib/LModel.c	/^typedef struct _AccessInfo{$/;"	s	file:
_Acoustic	HTKLib/HArc.h	/^typedef struct _Acoustic{$/;"	s
_AdaptKind	HTKLib/HModel.h	/^enum _AdaptKind {TREE, BASE};$/;"	g
_AdaptXForm	HTKLib/HModel.h	/^typedef struct _AdaptXForm {$/;"	s
_AltState	HTKLib/HGraf_WIN32.c	/^enum _AltState {ALT_UP,ALT_DOWN}; \/* keep track of Alt key *\/$/;"	g	file:
_AltWordendHyp	HTKLVRec/HLVRec.h	/^struct _AltWordendHyp {         \/* stores info about N-best word(end) for lattice traceback *\/$/;"	s
_Arc	HTKLib/HArc.h	/^struct _Arc{$/;"	s
_ArcList	HTKLib/HArc.c	/^typedef struct _ArcList{$/;"	s	file:
_ArcTrans	HTKLib/HArc.h	/^struct _ArcTrans{$/;"	s
_AudioIn	HTKLib/HAudio.c	/^typedef struct _AudioIn {$/;"	s	file:
_AudioOut	HTKLib/HAudio.c	/^typedef struct _AudioOut {$/;"	s	file:
_BSD_SIGNALS	HTKLib/HGraf.c	69;"	d	file:
_BaseClassKind	HTKLib/HModel.h	/^enum _BaseClassKind {MIXBASE, MEANBASE, COVBASE};$/;"	g
_BaseParmKind	HTKLib/HParm.h	/^enum _BaseParmKind{$/;"	g
_BestInfo	HTKLVRec/HDecode.c	/^struct _BestInfo {$/;"	s	file:
_BestInfo	HTKLVRec/HDecode.mod.c	/^struct _BestInfo {$/;"	s	file:
_Block	HTKLib/HMem.h	/^typedef struct _Block{  \/*      MHEAP                     MSTAK           *\/$/;"	s
_CRec	HTKTools/HHEd.c	/^typedef struct _CRec{$/;"	s	file:
_Cell	HTKTools/HResults.c	/^typedef struct _Cell{           \/* used in DP routines below *\/$/;"	s	file:
_ChWtAcc	HTKTools/HSmooth.c	/^typedef struct _ChWtAcc{     \/* attached to StreamElem *\/$/;"	s	file:
_CoList	HTKTools/HHEd.c	/^typedef struct _CoList {$/;"	s	file:
_CompLMlaNode	HTKLVRec/HLVNet.h	/^typedef struct _CompLMlaNode {$/;"	s
_CompressType	HTKLib/HWave.c	/^enum _CompressType{$/;"	g	file:
_ConfigEntry	HTKLib/HShell.c	/^typedef struct _ConfigEntry{$/;"	s	file:
_Context	HTKTools/HLEd.c	/^typedef struct _Context{$/;"	s	file:
_CorrA	HTKLib/HArc.h	/^struct _CorrA{$/;"	s
_CorrN	HTKLib/HArc.h	/^struct _CorrN{$/;"	s
_CorrectArcList	HTKLib/HFBLat.c	/^typedef struct _CorrectArcList{$/;"	s	file:
_DecoderInst	HTKLVRec/HLVRec.h	/^struct _DecoderInst {$/;"	s
_DictEntry	HTKLib/HDict.h	/^typedef struct _DictEntry{$/;"	s
_Direction	HTKTools/HResults.c	/^enum _Direction{DIAG,VERT,HOR,NIL};$/;"	g	file:
_DurKind	HTKLib/HModel.h	/^enum _DurKind {NULLD, POISSOND, GAMMAD, RELD, GEND};$/;"	g
_ESIGNAL_H_	HTKLib/esignal.h	31;"	d
_Equiv	HLMTools/LPlex.c	/^struct _Equiv{$/;"	s	file:
_Equiv	HTKTools/HResults.c	/^struct _Equiv{$/;"	s	file:
_FILE_OFFSET_BITS	HTKLVRec/kenlm/util/file.cc	2;"	d	file:
_FLEntry	HLMLib/LModel.h	/^typedef struct _FLEntry {   \/* Full LM entry, single level of context *\/$/;"	s
_FSLM	HTKLVRec/HLVLM.h	/^struct _FSLM {$/;"	s
_FSLM_LatArc	HTKLVRec/HLVLM.h	/^typedef struct _FSLM_LatArc {$/;"	s
_FSLM_LatNode	HTKLVRec/HLVLM.h	/^struct _FSLM_LatNode {$/;"	s
_FSLM_latlm	HTKLVRec/HLVLM.h	/^struct _FSLM_latlm {$/;"	s
_FSLM_ngram	HTKLVRec/HLVLM.h	/^struct _FSLM_ngram {$/;"	s
_FindAcc	HTKTools/HLEd.c	/^typedef struct _FindAcc{$/;"	s	file:
_FixHMMForICrit	HTKTools/HMMIRest.c	/^static void _FixHMMForICrit(float Tau, Boolean THREEACCS){$/;"	f	file:
_GramEntry	HTKTools/HBuild.c	/^typedef struct _GramEntry{$/;"	s	file:
_HADAPT_H_	HTKLib/HAdapt.h	32;"	d
_HAUDIO_H_	HTKLib/HAudio.h	25;"	d
_HButton	HTKLib/HGraf.h	/^typedef struct _HButton { $/;"	s
_HColour	HTKLib/HGraf.h	/^enum _HColour { WHITE, YELLOW, ORANGE, RED, MAUVE, PURPLE, DARK_BLUE, $/;"	g
_HDICT_H_	HTKLib/HDict.h	25;"	d
_HEvent	HTKLib/HGraf.h	/^enum _HEvent {HMOUSEDOWN,  \/* (left) mouse button pressed *\/$/;"	g
_HFB_H_	HTKLib/HFB.h	25;"	d
_HGRAF_H_	HTKLib/HGraf.h	44;"	d
_HLABEL_H_	HTKLib/HLabel.h	54;"	d
_HLAT_H_	HTKLib/HLat.h	33;"	d
_HLM_H_	HTKLib/HLM.h	38;"	d
_HLVLM_H_	HTKLVRec/HLVLM.h	32;"	d
_HLVMODEL_H_	HTKLVRec/HLVModel.h	31;"	d
_HLVNET_H_	HTKLVRec/HLVNet.h	51;"	d
_HLVREC_H_	HTKLVRec/HLVRec.h	38;"	d
_HMATH_H_	HTKLib/HMath.h	25;"	d
_HMEM_H_	HTKLib/HMem.h	51;"	d
_HMMSet	HTKLib/HModel.h	/^typedef struct _HMMSet{$/;"	s
_HMODEL_H_	HTKLib/HModel.h	38;"	d
_HNET_H_	HTKLib/HNet.h	52;"	d
_HPARM_H_	HTKLib/HParm.h	38;"	d
_HREC_H_	HTKLib/HRec.h	25;"	d
_HSHELL_H_	HTKLib/HShell.h	38;"	d
_HSIGP_H_	HTKLib/HSigP.h	38;"	d
_HSetKind	HTKLib/HModel.h	/^enum _HSetKind {PLAINHS, SHAREDHS, TIEDHS, DISCRETEHS};$/;"	g
_HTRAIN_H_	HTKLib/HTrain.h	38;"	d
_HUTIL_H_	HTKLib/HUtil.h	25;"	d
_HVQ_H_	HTKLib/HVQ.h	50;"	d
_HWAVE_H_	HTKLib/HWave.h	36;"	d
_IPat	HTKTools/HHEd.c	/^typedef struct _IPat{$/;"	s	file:
_ItemBlock	HTKLib/HTrain.h	/^typedef struct _ItemBlock{$/;"	s
_ItemRec	HTKLib/HModel.h	/^typedef struct _ItemRec {$/;"	s
_KeyType	HTKLib/HGraf.h	/^enum _KeyType {NORMALKEY, SHIFTKEY, COMMANDKEY, CONTROLKEY, $/;"	g
_LARGEFILE64_SOURCE	HTKLVRec/kenlm/util/file.cc	1;"	d	file:
_LCMAP_H	HLMLib/LCMap.h	35;"	d
_LGBASE_H_	HLMLib/LGBase.h	35;"	d
_LLFInfo	HTKLib/HLat.c	/^struct _LLFInfo {$/;"	s	file:
_LMCache	HTKLVRec/HLVRec.h	/^struct _LMCache {$/;"	s
_LMCacheLA	HTKLVRec/HLVRec.h	/^struct _LMCacheLA {$/;"	s
_LMLACacheEntry	HTKLVRec/HLVRec.h	/^struct _LMLACacheEntry {$/;"	s
_LMNodeCache	HTKLVRec/HLVRec.h	/^struct _LMNodeCache {$/;"	s
_LMODEL_H	HLMLib/LModel.h	41;"	d
_LMlaNode	HTKLVRec/HLVNet.h	/^typedef struct _LMlaNode {$/;"	s
_LMlaTree	HTKLVRec/HLVNet.h	/^struct _LMlaTree {$/;"	s
_LPCALC_H	HLMLib/LPCalc.h	35;"	d
_LPMERGE_H	HLMLib/LPMerge.h	37;"	d
_LUTIL_H	HLMLib/LUtil.h	35;"	d
_LWMAP_H	HLMLib/LWMap.h	36;"	d
_LabList	HTKLib/HLabel.h	/^typedef struct _LabList{$/;"	s
_Label	HTKLib/HLabel.h	/^typedef struct _Label{     \/* Information for each label *\/$/;"	s
_LayerId	HTKLVRec/HLVNet.h	/^typedef enum _LayerId {$/;"	g
_LayerStats	HTKLVRec/HLVRec-misc.c	/^struct _LayerStats {$/;"	s	file:
_LexLink	HTKLVRec/HLVNet.h	/^struct _LexLink {$/;"	s
_LexNet	HTKLVRec/HLVNet.h	/^typedef struct _LexNet {$/;"	s
_LexNode	HTKLVRec/HLVNet.h	/^struct _LexNode {$/;"	s
_LexNodeInst	HTKLVRec/HLVRec.h	/^struct _LexNodeInst {           \/* attached to active LexNode's, contains info about tokens *\/$/;"	s
_LexNodeType	HTKLVRec/HLVNet.h	/^typedef enum _LexNodeType {$/;"	g
_MLFDefType	HTKLib/HLabel.h	/^enum _MLFDefType {$/;"	g
_MLFEntry	HTKLib/HLabel.h	/^typedef struct _MLFEntry{$/;"	s
_MLFPatType	HTKLib/HLabel.h	/^enum _MLFPatType {$/;"	g
_MMFInfo	HTKLib/HModel.h	/^typedef struct _MMFInfo{$/;"	s
_MPEStruct	HTKLib/HArc.h	/^typedef struct _MPEStruct{$/;"	s
_MacroDef	HTKLib/HModel.h	/^typedef struct _MacroDef{$/;"	s
_MemHeapRec	HTKLib/HMem.c	/^typedef struct _MemHeapRec {$/;"	s	file:
_ModendHyp	HTKLVRec/HLVRec.h	/^struct _ModendHyp {             \/* stores info about one model(end) *\/$/;"	s
_NameCell	HTKLib/HLabel.h	/^typedef struct _NameCell{  \/* Hash Table Linked List Item *\/$/;"	s
_NameHolder	HLMLib/LUtil.h	/^typedef struct _NameHolder{    \/* Hash Table Linked List Item *\/$/;"	s
_NetInst	HTKLib/HRec.c	/^struct _NetInst$/;"	s	file:
_NetLink	HTKLib/HNet.h	/^struct _NetLink{$/;"	s
_NetNode	HTKLib/HNet.h	/^struct _NetNode {$/;"	s
_Node	HTKTools/HHEd.c	/^typedef struct _Node {          \/* Tree Node *\/$/;"	s	file:
_Node	HTKTools/HParse.c	/^typedef struct _Node{$/;"	s	file:
_NodeInfo	HTKTools/HParse.c	/^typedef struct _NodeInfo{$/;"	s	file:
_ObsCache	HTKLib/HAdapt.c	/^typedef struct _ObsCache{$/;"	s	file:
_OutPCache	HTKLVRec/HLVRec.h	/^struct _OutPCache {$/;"	s
_ParmBuf	HTKLib/HParm.c	/^typedef struct _ParmBuf {$/;"	s	file:
_PtrMap	HTKLib/HModel.h	/^typedef struct _PtrMap {   \/* used for finding macros via ptr's *\/$/;"	s
_QEnt	HTKTools/HHEd.c	/^typedef struct _QEnt{           \/* each question stored as both pattern and  *\/$/;"	s	file:
_RegNode	HTKLib/HModel.h	/^typedef struct _RegNode {$/;"	s
_RelToken	HTKLVRec/HLVRec.h	/^struct _RelToken {$/;"	s
_SMEntry	HLMLib/LModel.h	/^typedef struct _SMEntry {$/;"	s
_STLexLink	HTKLVRec/HLVNet.c	/^struct _STLexLink {$/;"	s	file:
_STLexNode	HTKLVRec/HLVNet.c	/^struct _STLexNode {$/;"	s	file:
_STLexNodeType	HTKLVRec/HLVNet.c	/^typedef enum _STLexNodeType {$/;"	g	file:
_STRARR_H_	HTKLib/strarr.h	21;"	d
_ScribeLab	HTKLib/HLabel.c	/^enum _ScribeLab {$/;"	g	file:
_ScriptItem	HTKTools/HDMan.c	/^typedef struct _ScriptItem{     \/* internal rep of a complete edit script *\/$/;"	s	file:
_ScriptItem	HTKTools/HLEd.c	/^typedef struct _ScriptItem{$/;"	s	file:
_SegStoreRec	HTKLib/HTrain.h	/^typedef struct _SegStoreRec{$/;"	s
_Spkr	HTKTools/HResults.c	/^typedef struct _Spkr{           \/* list of spkr records *\/$/;"	s	file:
_SpotRec	HTKTools/HResults.c	/^typedef struct _SpotRec{$/;"	s	file:
_SrcOrder	HTKLib/HWave.c	/^typedef enum _SrcOrder{$/;"	g	file:
_StateInfo_lv	HTKLVRec/HLVModel.h	/^struct _StateInfo_lv {$/;"	s
_Stats	HTKLVRec/HLVRec.h	/^struct _Stats {$/;"	s
_StatsInfo	HTKLib/HLat.c	/^typedef struct _StatsInfo {$/;"	s	file:
_SubLArc	HTKLib/HLat.c	/^struct _SubLArc {$/;"	s	file:
_SubLNode	HTKLib/HLat.c	/^struct _SubLNode {$/;"	s	file:
_SubNetDef	HTKTools/HParse.c	/^typedef struct _SubNetDef{$/;"	s	file:
_Symbol	HTKTools/HParse.c	/^enum _Symbol{NAMESYM, VARSYM, VARATSYM, LPARSYM, RPARSYM, LBRACESYM, $/;"	g	file:
_TLexLink	HTKLVRec/HLVNet.h	/^struct _TLexLink {$/;"	s
_TLexNet	HTKLVRec/HLVNet.h	/^typedef struct _TLexNet {$/;"	s
_TLexNode	HTKLVRec/HLVNet.h	/^struct _TLexNode {$/;"	s
_Token	HTKLVRec/HLVRec.h	/^struct _Token {$/;"	s
_TokenSet	HTKLVRec/HLVRec.h	/^struct _TokenSet {$/;"	s
_TrList	HTKTools/HCopy.c	/^typedef struct _TrList {      $/;"	s	file:
_TrSymbol	HTKLib/HLabel.c	/^enum _TrSymbol{TRNULL,TRNUM,TRSTR,TREOL,TRLEV,TRCOMMA,TREOF};$/;"	g	file:
_Tree	HTKTools/HHEd.c	/^typedef struct _Tree{           \/* A tree *\/$/;"	s	file:
_UPDSet	HTKLib/HTrain.h	/^enum _UPDSet{UPMEANS=1,UPVARS=2,UPTRANS=4,UPMIXES=8,UPXFORM=16,UPMAP=32,UPSEMIT=64};$/;"	g
_VQNodeRec	HTKLib/HVQ.h	/^typedef struct _VQNodeRec{$/;"	s
_VQTabRec	HTKLib/HVQ.h	/^typedef struct _VQTabRec {$/;"	s
_VersionEntry	HTKLib/HShell.c	/^typedef struct _VersionEntry{$/;"	s	file:
_Wave	HTKLib/HWave.c	/^typedef struct _Wave{   \/* Internal wave file representation *\/$/;"	s	file:
_WordFllr	HTKTools/HBuild.c	/^typedef struct _WordFllr{   \/* storage for word followers *\/$/;"	s	file:
_WordPron	HTKLib/HDict.h	/^typedef struct _WordPron{   \/* storage for each pronunciation *\/$/;"	s
_WordendHyp	HTKLVRec/HLVRec.h	/^struct _WordendHyp {            \/* stores info about one word(end) *\/$/;"	s
_XFDirInfo	HTKLib/HModel.c	/^typedef struct _XFDirInfo {$/;"	s	file:
_XFormKind	HTKLib/HModel.h	/^enum _XFormKind {MLLRMEAN, MLLRCOV, MLLRVAR, CMLLR, SEMIT};$/;"	g
_XferMode	HTKLib/HGraf.h	/^enum _XferMode {GCOPY, GOR, GXOR, GINVERT};$/;"	g
a	HTKLib/HParm.c	/^      AudioIn a;        \/* the audio source *\/$/;"	m	union:_ParmBuf::__anon143	file:
a	HTKLib/HParm.c	/^   Vector a,k;        \/* lpc and refc vectors *\/$/;"	m	struct:__anon141	file:
a	HTKLib/HParm.h	/^   AudioIn a;                 \/* the audio source - if any *\/$/;"	m	struct:__anon149
a2l	HTKLib/HWave.c	/^static short a2l[]={$/;"	v	file:
aCollThresh	HTKLib/HRec.h	/^   int aCollThresh;         \/* Max align records created before collection *\/$/;"	m	struct:vrecinfo
aInfo	HLMLib/LModel.h	/^   AccessInfo *aInfo;       \/* access statistics information *\/$/;"	m	struct:__anon13
aInfo	HTKLib/HAdapt.c	/^   AInfo *aInfo;         \/* current transform information *\/$/;"	m	struct:__anon88	file:
aInfo	HTKLib/HFBLat.h	/^  ArcInfo  *aInfo;$/;"	m	struct:__anon102
aNoRef	HTKLib/HRec.c	/^   Align aNoRef;            \/* Head of AlignNoRef linked list *\/$/;"	m	struct:precinfo	file:
aNoTail	HTKLib/HRec.c	/^   Align aNoTail;           \/* Tail of AlignNoRef linked list *\/$/;"	m	struct:precinfo	file:
aSet	HTKTools/HSmooth.c	/^static HLink *aSet;          \/* array[1..aSize]of allophone *\/$/;"	v	file:
aSetStack	HTKTools/HSmooth.c	/^static MemHeap aSetStack;$/;"	v	file:
aSize	HTKTools/HSmooth.c	/^static int aSize;            \/* size of current aSet *\/$/;"	v	file:
aYesRef	HTKLib/HRec.c	/^   Align aYesRef;           \/* Head of AlignYesRef linked list *\/$/;"	m	struct:precinfo	file:
aYesTail	HTKLib/HRec.c	/^   Align aYesTail;          \/* Tail of AlignYesRef linked list *\/$/;"	m	struct:precinfo	file:
ab	HTKLib/HFB.h	/^  AlphaBeta *ab;      \/* Alpha-beta structure for this model *\/$/;"	m	struct:__anon99
abMem	HTKLib/HFB.h	/^  MemHeap abMem;      \/* alpha beta memory heap *\/$/;"	m	struct:__anon98
abortOnError	HTKLib/HShell.c	/^static Boolean abortOnError = FALSE;     \/* causes HError to abort *\/$/;"	v	file:
ac	HTKLib/HArc.h	/^  Acoustic *ac; $/;"	m	struct:_Arc
ac	HTKLib/HArc.h	/^  Acoustic *ac; \/* 1..Q *\/$/;"	m	struct:ArcInfoStruct
ac	HTKLib/HParm.c	/^   Vector as, ac, lp; \/* Auditory, autocorrelation an lp vectors for PLP *\/ $/;"	m	struct:__anon141	file:
acScale	HTKLVRec/HDecode.c	/^static float acScale = 1.0;     \/* acoustic scaling factor *\/$/;"	v	file:
acScale	HTKLVRec/HDecode.mod.c	/^static float acScale = 1.0;     \/* acoustic scaling factor *\/$/;"	v	file:
acScale	HTKLVRec/HLVRec.h	/^   float acScale;               \/* acoustic scaling factor *\/$/;"	m	struct:_DecoderInst
acScale	HTKTools/HLRescore.c	/^static double acScale = 1.0;    \/* acoustic scale factor *\/$/;"	v	file:
acc	HTKTools/HLEd.c	/^   int acc;             \/* num of matches *\/$/;"	m	struct:_FindAcc	file:
accBTriMat	HTKLib/HModel.h	/^  Boolean accBTriMat;  \/* accumulate weighted outer-product of observations *\/$/;"	m	struct:__anon130
accStack	HTKTools/HERest.c	/^static MemHeap accStack;$/;"	v	file:
accStack	HTKTools/HMMIRest.c	/^static MemHeap accStack;           \/* accumulated statistics *\/$/;"	v	file:
accSum	HTKLib/HModel.h	/^  Boolean accSum;      \/* accumulate the sum of the observations *\/$/;"	m	struct:__anon130
accSumSq	HTKLib/HModel.h	/^  Boolean accSumSq;    \/* accumulate sum-squared (diag) of the observations *\/$/;"	m	struct:__anon130
accWin	HTKLib/HParm.c	/^   int accWin;                \/* Accel window halfsize *\/$/;"	m	struct:__anon141	file:
acccaStack	HTKLib/HAdapt.c	/^static MemHeap acccaStack;$/;"	v	file:
accessinfo	HLMLib/LModel.c	/^} accessinfo;$/;"	t	typeref:struct:_AccessInfo	file:
accs	HTKTools/HCompV.c	/^static CovAcc accs[SMAX];           \/* one CovAcc for each stream *\/$/;"	v	file:
accsStack	HTKTools/HRest.c	/^static MemHeap accsStack;        \/* For storage of accumulators *\/$/;"	v	file:
aclike	HTKLib/HArc.h	/^  LogDouble aclike; \/* [unscaled] acoustic likelihood from beginning to end of model. *\/$/;"	m	struct:_Acoustic
aclike	HTKLib/HNet.h	/^   LogFloat aclike;    \/* Acoustic likelihood of word *\/$/;"	m	struct:larc
acscale	HTKLib/HNet.h	/^   float acscale;               \/* Acoustic scale factor *\/$/;"	m	struct:lattice
actfile	HTKLib/HShell.c	/^   char actfile[1024];                  \/* actual file name *\/$/;"	m	struct:__anon150	file:
action	HTKLib/HGraf.h	/^   void (*action)(void);      \/* ptr to function to call whilst button is down *\/$/;"	m	struct:_HButton
action_	HTKLVRec/kenlm/lm/read_arpa.hh	/^    WarningAction action_;$/;"	m	class:lm::PositiveProbWarn
action_	HTKLVRec/kenlm/util/read_compressed.cc	/^    lzma_action action_;$/;"	m	class:util::__anon79::XZip	file:
active	HTKLib/HGraf.h	/^   Boolean active;            \/* if false, stipple gray *\/$/;"	m	struct:_HButton
active_	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    bool active_;$/;"	m	class:util::stream::MultiProgress
actual_	HTKLVRec/kenlm/lm/filter/format.hh	/^    size_t actual_;$/;"	m	class:lm::InputBuffer
actual_base_	HTKLVRec/kenlm/lm/quantize.hh	/^    uint8_t *actual_base_;$/;"	m	class:lm::ngram::SeparatelyQuantize
adapt_ot	HTKLib/HFBLat.h	/^  Observation adapt_ot;   \/* for parent XForm *\/$/;"	m	struct:__anon102
addDither	HTKLib/HParm.c	/^   float addDither;           \/* Additional dither added to file *\/$/;"	m	struct:__anon141	file:
add_index	HTKLib/HFBLat.c	/^static int add_index = 999;   \/* additional index for discriminative training: 3 for MPE with MMI prior *\/$/;"	v	file:
adder_in	HTKLVRec/kenlm/lm/builder/initial_probabilities.hh	/^  util::stream::ChainConfig adder_in;$/;"	m	struct:lm::builder::InitialProbabilitiesConfig
adder_out	HTKLVRec/kenlm/lm/builder/initial_probabilities.hh	/^  util::stream::ChainConfig adder_out;$/;"	m	struct:lm::builder::InitialProbabilitiesConfig
address_	HTKLVRec/kenlm/lm/quantize.hh	/^        util::BitAddress address_;$/;"	m	class:lm::ngram::DontQuantize::LongestPointer
address_	HTKLVRec/kenlm/lm/quantize.hh	/^        util::BitAddress address_;$/;"	m	class:lm::ngram::DontQuantize::MiddlePointer
address_	HTKLVRec/kenlm/lm/quantize.hh	/^        util::BitAddress address_;$/;"	m	class:lm::ngram::SeparatelyQuantize::LongestPointer
address_	HTKLVRec/kenlm/lm/quantize.hh	/^        util::BitAddress address_;$/;"	m	class:lm::ngram::SeparatelyQuantize::MiddlePointer
adevin	HTKLib/HAudio.c	/^   UMSBAUDDevice adevin;$/;"	m	struct:_AudioIn	file:
adevout	HTKLib/HAudio.c	/^   UMSBAUDDevice adevout;$/;"	m	struct:_AudioOut	file:
adjust	HTKLVRec/kenlm/lm/partial.hh	/^  float adjust;$/;"	m	struct:lm::ngram::ExtendReturn
adpLM	HLMTools/LAdapt.c	/^static BackOffLM *adpLM;            \/* the adapted final LM *\/$/;"	v	file:
aentry	HTKTools/HLStats.c	/^typedef struct aentry {          \/* Storage for counts *\/$/;"	s	file:
aetab	HTKTools/HLStats.c	/^static AEntry **aetab;           \/* Hash table for bigram accumulators  *\/$/;"	v	file:
aetabsize	HTKTools/HLStats.c	/^static int aetabsize=0;          \/* Size of hash table selected from .. *\/$/;"	v	file:
after_	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    StringPiece after_;$/;"	m	class:util::TokenIter
aiStatMap	HTKLib/HAudio.c	/^static char * aiStatMap[] = { "AI_CLEARED","AI_WAITSIG",$/;"	v	file:
akind	HTKLib/HModel.h	/^  AdaptKind akind;                  \/* adaptation kind *\/$/;"	m	struct:_AdaptXForm
alCompLevel	HTKLib/HFB.c	/^static Boolean alCompLevel = FALSE;   \/* align model at component level *\/$/;"	v	file:
alXFormDir	HTKLib/HAdapt.h	/^  char *alXFormDir;$/;"	m	struct:__anon89
alXFormExt	HTKLib/HAdapt.h	/^  char *alXFormExt;$/;"	m	struct:__anon89
al_dataStack	HTKLib/HFBLat.h	/^  MemHeap al_dataStack;$/;"	m	struct:__anon102
al_hmmDir	HTKTools/HERest.c	/^static char al_hmmDir[MAXFNAMELEN];  \/* dir to look for alignment hmm defs *\/$/;"	v	file:
al_hmmExt	HTKTools/HERest.c	/^static char al_hmmExt[MAXSTRLEN];  	 \/* alignment hmm def file extension *\/$/;"	v	file:
al_hmmLst	HTKTools/HERest.c	/^static char al_hmmLst[MAXFNAMELEN];  \/* alignment hmm list *\/$/;"	v	file:
al_hmmMMF	HTKTools/HERest.c	/^static char al_hmmMMF[MAXFNAMELEN];  \/* alignment hmm MMF *\/$/;"	v	file:
al_hmmUsed	HTKTools/HERest.c	/^static Boolean al_hmmUsed = FALSE;   \/* Set for 2-model ReEstimation *\/$/;"	v	file:
al_hset	HTKLib/HAdapt.h	/^  HMMSet *al_hset;$/;"	m	struct:__anon89
al_hset	HTKLib/HFB.h	/^  HMMSet *al_hset;    \/* HMMs to use for alignment *\/$/;"	m	struct:__anon99
al_hset	HTKTools/HERest.c	/^static HMMSet al_hset ;      	 \/* Option 2nd set of models for alignment *\/$/;"	v	file:
al_inXForm	HTKLib/HAdapt.h	/^  AdaptXForm *al_inXForm;$/;"	m	struct:__anon89
al_inXForm	HTKLib/HFB.h	/^  AdaptXForm *al_inXForm;\/* current input transform for al_hset (if any) *\/$/;"	m	struct:__anon99
al_info	HTKLib/HFBLat.h	/^  BufferInfo al_info;             \/* info from buffer on second data file *\/$/;"	m	struct:__anon102
al_ot	HTKLib/HFBLat.h	/^  Observation al_ot;$/;"	m	struct:__anon102
al_pbuf	HTKLib/HFBLat.h	/^  ParmBuf al_pbuf;$/;"	m	struct:__anon102
al_qList	HTKLib/HFB.h	/^  HLink *al_qList;    \/* array[1..Q] of active align HMM defs *\/$/;"	m	struct:__anon98
align	HTKLib/HArc.h	/^  short int align; $/;"	m	struct:_CorrN
align	HTKLib/HRec.c	/^  Align *align;$/;"	m	struct:nxtpath	file:
align	HTKLib/HRec.c	/^  Align *align;$/;"	m	struct:reltoken	file:
align	HTKLib/HRec.c	/^struct align$/;"	s	file:
align	HTKLib/HRec.h	/^   Align *align;        \/* Route (state\/model level) through network *\/$/;"	m	struct:token
align	HTKLib/HRec.h	/^   Align *align;        \/* State\/model traceback for this word *\/$/;"	m	struct:path
alignHeap	HTKLib/HRec.c	/^   MemHeap alignHeap;       \/* Align heap *\/$/;"	m	struct:precinfo	file:
alignpsi	HTKTools/HVite.c	/^static PSetInfo *alignpsi;        \/* Private data used by HRec *\/$/;"	v	file:
alignvri	HTKTools/HVite.c	/^static VRecInfo *alignvri;        \/* Visible HRec Info *\/$/;"	v	file:
allocated_	HTKLVRec/kenlm/lm/search_trie.cc	/^    uint8_t *current_, *allocated_;$/;"	m	class:lm::ngram::trie::__anon58::BackoffMessages	file:
allocated_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    std::size_t allocated_;$/;"	m	class:util::AutoProbing
allocated_end_	HTKLVRec/kenlm/util/fixed_array.hh	/^    T *allocated_end_;$/;"	m	class:util::FixedArray
allowCxtExp	HTKLib/HNet.c	/^Boolean allowCxtExp=TRUE;$/;"	v
allowOthers	HTKLib/HModel.c	/^static Boolean allowOthers=TRUE;        \/* allow unseen models in files *\/$/;"	v	file:
allowTMods	HTKLib/HModel.h	/^   Boolean allowTMods;     \/* true if HMMs can have Tee Models *\/$/;"	m	struct:_HMMSet
allowXWrdExp	HTKLib/HNet.c	/^Boolean allowXWrdExp=FALSE;$/;"	v
alpha	HTKLib/HArc.h	/^  double alpha; \/*alpha and betaPlus are for user's use.  *\/$/;"	m	struct:_Arc
alpha	HTKLib/HArc.h	/^  double alpha;$/;"	m	struct:_CorrN
alpha	HTKTools/HRest.c	/^static DMatrix alpha;      \/* array[1..nStates][1..maxT] of forward prob *\/$/;"	v	file:
alphaBetaStack	HTKTools/HRest.c	/^static MemHeap alphaBetaStack;   \/* For storage of alpha and beta probs *\/$/;"	v	file:
alphaCorr	HTKLib/HArc.h	/^  float *alphaCorr; \/* [starti..endi]. *\/$/;"	m	struct:_CorrN
alphaError	HTKLib/HArc.h	/^  float alphaError, betaPlusError; \/*for MPE training.*\/$/;"	m	struct:_MPEStruct
alphat	HTKLib/HArc.h	/^  DVector alphat; \/* 1..Nq *\/$/;"	m	struct:_Acoustic
alphat	HTKLib/HFB.h	/^  DVector *alphat;    \/* array[1..Q][1..Nq] of prob *\/$/;"	m	struct:__anon98
alphat1	HTKLib/HArc.h	/^  DVector alphat1; \/* 1..Nq  [for time t-1] *\/$/;"	m	struct:_Acoustic
alphat1	HTKLib/HFB.h	/^  DVector *alphat1;   \/* alpha[t-1] *\/$/;"	m	struct:__anon98
alreadyFilling	HTKLib/HAudio.c	/^static volatile Boolean alreadyFilling;$/;"	v	file:
alt	HLMLib/LGBase.h	/^   GFLink alt;             \/* ... alt files to open *\/$/;"	m	struct:gramfile
alt	HTKLVRec/HLVRec.h	/^   AltWordendHyp *alt;          \/* alternative paths for lattice traceback *\/$/;"	m	struct:_WordendHyp
altweHypHeap	HTKLVRec/HLVRec.h	/^   MemHeap altweHypHeap;        \/* MHEAP for alt word end hyps (for latgen) *\/$/;"	m	struct:_DecoderInst
amount	HTKLVRec/kenlm/lm/builder/discount.hh	/^  float amount[4];$/;"	m	struct:lm::builder::Discount
anlen	HTKLib/HRec.c	/^   int anlen;               \/* Number of AlignNoRef list *\/$/;"	m	struct:precinfo	file:
annotated_	HTKLVRec/kenlm/lm/filter/format.hh	/^    std::vector<Annotated> annotated_;$/;"	m	class:lm::MultipleOutputBuffer
ans	HTKTools/HHEd.c	/^   Boolean ans;                 \/* TRUE = yes, FALSE = no *\/$/;"	m	struct:_Node	file:
ans	HTKTools/HHEd.c	/^   Boolean ans;                 \/* answer to current question *\/$/;"	m	struct:_CRec	file:
ans	HTKTools/HResults.c	/^static Transcription *ans;            \/* the full set of answers *\/$/;"	v	file:
ansHeap	HTKTools/HVite.c	/^static MemHeap ansHeap;$/;"	v	file:
applyVFloor	HTKTools/HHEd.c	/^static Boolean applyVFloor = TRUE; \/* apply modfied varFloors to vars in model set *\/ $/;"	v	file:
arcStack	HTKLib/HFBLat.h	/^  MemHeap arcStack;$/;"	m	struct:__anon102
arc_compare	HTKLib/HArc.c	/^int arc_compare( const void* a , const void* b )$/;"	f
arc_vc_id	HTKLib/HArc.c	/^char *arc_vc_id = "$Id: HArc.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
arc_version	HTKLib/HArc.c	/^char *arc_version = "!HVER!HArc:   3.4.1 [CUED 12\/03\/09]";$/;"	v
arcs_	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    std::vector<detail::Arc> arcs_;$/;"	m	class:lm::phrase::detail::ConditionCommon
argcount	HTKLib/HShell.c	/^static int argcount;          \/* total args = argc *\/$/;"	v	file:
arglist	HTKLib/HShell.c	/^static char **arglist=defargs;\/* actual arg list *\/$/;"	v	file:
args	HTKTools/HDMan.c	/^   LabId args[MAXARGS];$/;"	m	struct:__anon192	file:
args	HTKTools/HLEd.c	/^   LabId args[MAXARGS];$/;"	m	struct:__anon201	file:
arpa_complain	HTKLVRec/kenlm/lm/config.hh	/^  ARPALoadComplain arpa_complain;$/;"	m	struct:lm::ngram::Config
array	HTKLVRec/kenlm/lm/search_trie.cc	/^  unsigned char array;$/;"	m	struct:lm::ngram::trie::__anon58::ProbPointer	file:
as	HTKLib/HParm.c	/^   Vector as, ac, lp; \/* Auditory, autocorrelation an lp vectors for PLP *\/ $/;"	m	struct:__anon141	file:
as_string	HTKLVRec/kenlm/util/string_piece.hh	/^  std::string as_string() const {$/;"	f	class:StringPiece
assign	HTKLib/HModel.h	/^   IntVec assign;        \/* for hard assignments  *\/$/;"	m	union:__anon131
asterix	HTKTools/HDMan.c	/^static LabId asterix;                \/* LabId of a "*" *\/$/;"	v	file:
asterix	HTKTools/HLEd.c	/^static LabId asterix;               \/* id of an asterix *\/$/;"	v	file:
at_end_	HTKLVRec/kenlm/util/file_piece.hh	/^    bool at_end_;$/;"	m	class:util::FilePiece
attMInfo	HTKLib/HModel.h	/^   Boolean attMInfo;     \/* have the set of adapt info been attached *\/$/;"	m	struct:_HMMSet
attRegAccs	HTKLib/HModel.h	/^   Boolean attRegAccs;   \/* have the set of accumulates been attached *\/$/;"	m	struct:_HMMSet
attXFormInfo	HTKLib/HModel.h	/^   Boolean attXFormInfo; \/* have the set of adapt info been attached *\/$/;"	m	struct:_HMMSet
attention_size_	HTKLVRec/kenlm/lm/trie_sort.cc	/^    const std::size_t attention_size_;$/;"	m	class:lm::ngram::trie::__anon60::PartialViewProxy	file:
attr	HTKLib/HAudio.c	/^   AudioAttributes attr;$/;"	m	struct:_AudioIn	file:
attr	HTKLib/HAudio.c	/^   AudioAttributes attr;$/;"	m	struct:_AudioOut	file:
audSignal	HTKLib/HParm.c	/^   int audSignal;             \/* Signal Number for Audio Control *\/$/;"	m	struct:__anon141	file:
audSignal	HTKLib/HParm.h	/^   int audSignal;             \/* Signal Number for Audio Control *\/$/;"	m	struct:__anon149
audSignal	HTKTools/HList.c	/^static int audSignal;$/;"	v	file:
audStack	HTKTools/HSLab.c	/^static MemHeap audStack;$/;"	v	file:
audio	HTKLib/HAudio.c	/^   Audio *audio;$/;"	m	struct:_AudioIn	file:
audio	HTKLib/HAudio.c	/^   Audio *audio;$/;"	m	struct:_AudioOut	file:
audio_cnt	HTKLib/HAudio.c	/^static int audio_cnt=0;$/;"	v	file:
audio_ctld	HTKLib/HAudio.c	/^   int audio_ctld;$/;"	m	struct:_AudioIn	file:
audio_ctld	HTKLib/HAudio.c	/^   int audio_ctld;$/;"	m	struct:_AudioOut	file:
audio_dev	HTKLib/HAudio.c	/^static Audio *audio_dev=NULL;$/;"	v	file:
audio_fd	HTKLib/HAudio.c	/^static int audio_fd;$/;"	v	file:
audio_info	HTKLib/HAudio.c	/^   audio_info_t audio_info;$/;"	m	struct:_AudioIn	file:
audio_info	HTKLib/HAudio.c	/^   audio_info_t audio_info;$/;"	m	struct:_AudioOut	file:
audio_info	HTKLib/HAudio.c	/^static audio_buf_info audio_info;$/;"	v	file:
audio_io	HTKLib/HAudio.c	/^static unsigned short audio_io = 0x00;$/;"	v	file:
aux	HLMLib/LUtil.h	/^   int aux;                    \/* User flags etc*\/$/;"	m	struct:_NameHolder
aux	HLMLib/LWMap.h	/^   }aux;$/;"	m	struct:MAPENTRY	typeref:union:MAPENTRY::__anon21
aux	HTKLib/HDict.h	/^   void *aux;       \/* hook used by HTK library modules for temp info *\/$/;"	m	struct:_DictEntry
aux	HTKLib/HDict.h	/^   void *aux;      \/* hook for temp info *\/$/;"	m	struct:_WordPron
aux	HTKLib/HLabel.h	/^   Ptr aux;                 \/* User pointer *\/$/;"	m	struct:_NameCell
aux	HTKLib/HNet.h	/^   int aux;$/;"	m	struct:_NetNode
aux	HTKLib/HVQ.h	/^   void * aux;          \/* available to 'user' *\/$/;"	m	struct:_VQNodeRec
auxLab	HTKLib/HLabel.h	/^   LabId *auxLab;           \/* array [1..maxAuxLab] OF LabId *\/$/;"	m	struct:_Label
auxLab	HTKTools/HCopy.c	/^static int auxLab = 0;          \/* auxiliary label to use (0==primary) *\/$/;"	v	file:
auxScore	HTKLib/HLabel.h	/^   float *auxScore;         \/* array [1..maxAuxLab] OF float *\/$/;"	m	struct:_Label
auxflt	HLMLib/LWMap.h	/^      float auxflt;$/;"	m	union:MAPENTRY::__anon21
auxint	HLMLib/LWMap.h	/^      int  auxint;$/;"	m	union:MAPENTRY::__anon21
auxptr	HLMLib/LWMap.h	/^      Ptr auxptr;$/;"	m	union:MAPENTRY::__anon21
avCov	HTKLib/HAdapt.c	/^static TriMat *avCov = NULL;$/;"	v	file:
aveCost	HTKLib/HTrain.h	/^   float aveCost;  \/* average cost of cluster *\/$/;"	m	struct:__anon161
aveCovar	HTKTools/HHEd.c	/^   Vector aveCovar;          \/* node cluster variance *\/$/;"	m	struct:__anon198	file:
aveMean	HTKTools/HHEd.c	/^   Vector aveMean;           \/* node cluster mean *\/$/;"	m	struct:__anon198	file:
axis_names	HTKLib/esignal.h	/^    char        **axis_names;   \/* optional strings identifying axes *\/$/;"	m	struct:FieldSpec
aylen	HTKLib/HRec.c	/^   int aylen;               \/* Number of AlignYesRef list *\/$/;"	m	struct:precinfo	file:
b	HTKLib/HShell.h	/^   Boolean b;$/;"	m	union:__anon156
bCoef	HLMLib/LModel.h	/^   double bCoef;            \/* absolute discounting b coef *\/$/;"	m	union:__anon11
bDiagMat	HTKLib/HAdapt.c	/^   TriMat *bDiagMat;$/;"	m	struct:__anon87	file:
bEndId	HTKTools/HBuild.c	/^static LabId bEndId=NULL;           \/* id of end bracket *\/$/;"	v	file:
bStartId	HTKTools/HBuild.c	/^static LabId bStartId=NULL;         \/* id of start bracket *\/$/;"	v	file:
bSwap	HTKLib/HParm.c	/^   Boolean bSwap;     \/* TRUE if source needs byte swapping *\/$/;"	m	struct:__anon141	file:
bTriMat	HTKLib/HAdapt.c	/^   TriMat  *bTriMat;$/;"	m	struct:_AccCache	file:
bTriMat	HTKLib/HAdapt.c	/^   TriMat *bTriMat;$/;"	m	struct:__anon87	file:
bVector	HTKLib/HAdapt.c	/^   DVector bVector;$/;"	m	struct:_AccCache	file:
bVector	HTKLib/HAdapt.c	/^   DVector bVector;$/;"	m	struct:__anon87	file:
back	HTKLVRec/kenlm/util/fixed_array.hh	/^    T &back() { return *(end() - 1); }$/;"	f	class:util::FixedArray
back	HTKLVRec/kenlm/util/fixed_array.hh	/^    const T &back() const { return *(end() - 1); }$/;"	f	class:util::FixedArray
back_	HTKLVRec/kenlm/util/pcqueue.hh	/^    semaphore_t back_;$/;"	m	class:util::Semaphore
back_	HTKLVRec/kenlm/util/read_compressed.cc	/^    Compression back_;$/;"	m	class:util::__anon79::StreamCompressed	file:
backend_	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^    Filter backend_;$/;"	m	class:lm::ContextFilter
backend_	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^    mutable boost::thread_specific_ptr<nplm::neuralLM> backend_;$/;"	m	class:lm::np::Model
backend_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    Backend backend_;$/;"	m	class:util::AutoProbing
backing_	HTKLVRec/kenlm/lm/model.hh	/^    BinaryFormat backing_;$/;"	m	class:lm::ngram::detail::GenericModel
backing_	HTKLVRec/kenlm/lm/search_trie.cc	/^    util::scoped_malloc backing_;$/;"	m	class:lm::ngram::trie::__anon58::BackoffMessages	file:
backoff	HTKLVRec/kenlm/lm/state.hh	/^    float backoff[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::State
backoff	HTKLVRec/kenlm/lm/weights.hh	/^  float backoff;$/;"	m	struct:lm::ProbBackoff
backoff	HTKLVRec/kenlm/lm/weights.hh	/^  float backoff;$/;"	m	struct:lm::RestWeights
backoff_bits	HTKLVRec/kenlm/lm/config.hh	/^  uint8_t prob_bits, backoff_bits;$/;"	m	struct:lm::ngram::Config
backoff_bits_	HTKLVRec/kenlm/lm/quantize.hh	/^    uint8_t prob_bits_, backoff_bits_;$/;"	m	class:lm::ngram::SeparatelyQuantize
backoffs_	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    util::FixedArray<util::stream::Stream> backoffs_;$/;"	m	class:lm::builder::__anon46::Callback	file:
backoffs_	HTKLVRec/kenlm/lm/builder/interpolate.hh	/^    util::stream::ChainPositions backoffs_;$/;"	m	class:lm::builder::Interpolate
backward	HLMTools/Cluster.c	/^static bigrams     *forward=0, *backward;    \/* Forward and backward bigram tables *\/$/;"	v	file:
backward	HLMTools/Cluster.c	/^static bigrams    *forward, *backward;      \/* Forward and backward bigram tables *\/$/;"	v	file:
badGC	HTKTools/HHEd.c	/^static Boolean badGC = FALSE;          \/* set TRUE if gConst out of date *\/$/;"	v	file:
bad_action	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^  WarningAction bad_action;$/;"	m	struct:lm::builder::DiscountConfig
barc	HTKTools/HList.c	/^static char barc = '-';          \/* bar character *\/$/;"	v	file:
barwidth	HTKTools/HList.c	/^static int barwidth;             \/* width of printed bars *\/$/;"	v	file:
base	HTKLVRec/HLVModel.h	/^   float *base;$/;"	m	struct:_StateInfo_lv
base	HTKLVRec/kenlm/lm/facade.hh	/^namespace base {$/;"	n	namespace:lm
base	HTKLVRec/kenlm/lm/virtual_interface.cc	/^namespace base {$/;"	n	namespace:lm	file:
base	HTKLVRec/kenlm/lm/virtual_interface.hh	/^namespace base {$/;"	n	namespace:lm
base	HTKLVRec/kenlm/util/bit_packing.hh	/^  void *base;$/;"	m	struct:util::BitAddress
baseClass	HTKLib/HAdapt.c	/^   int baseClass;$/;"	m	struct:_AInfo	file:
baseClasses	HTKLib/HModel.h	/^  IntVec baseClasses;       \/* if a terminal node the set of baseclasses else NULL *\/$/;"	m	struct:_RegNode
baseId	HTKTools/HHEd.c	/^   LabId baseId;                \/* base phone name *\/$/;"	m	struct:_Tree	file:
baseLeft	HTKTools/HHEd.c	/^typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;$/;"	e	enum:__anon196	file:
baseMono	HTKTools/HHEd.c	/^typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;$/;"	e	enum:__anon196	file:
baseNorm	HTKTools/HHEd.c	/^typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;$/;"	e	enum:__anon196	file:
baseRight	HTKTools/HHEd.c	/^typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;$/;"	e	enum:__anon196	file:
baseTriMatTime	HTKLib/HAdapt.c	/^static int baseTriMatTime=-1;  $/;"	v	file:
baseType	HTKTools/HHEd.c	/^typedef enum { baseNorm=0, baseLeft, baseRight, baseMono } baseType;$/;"	t	typeref:enum:__anon196	file:
base_	HTKLVRec/kenlm/lm/trie.cc	/^    const uint8_t *const base_;$/;"	m	class:lm::ngram::trie::__anon59::KeyAccessor	file:
base_	HTKLVRec/kenlm/lm/trie.hh	/^    uint8_t *base_;$/;"	m	class:lm::ngram::trie::BitPacked
base_instance_	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^    boost::scoped_ptr<nplm::neuralLM> base_instance_;$/;"	m	class:lm::np::Model
base_sequence_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    uint64_t base_sequence_;$/;"	m	class:lm::OutputWorker
base_vocab_	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    const Vocabulary *base_vocab_;$/;"	m	class:lm::base::Model
baseclass	HTKLib/HAdapt.c	/^   int     baseclass;$/;"	m	struct:_AccCache	file:
basis_	HTKLVRec/kenlm/lm/search_trie.cc	/^    float basis_[KENLM_MAX_ORDER];$/;"	m	class:lm::ngram::trie::__anon58::BlankManager	file:
batch_size_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    const size_t batch_size_;$/;"	m	class:lm::Controller
batches_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    std::vector<Batch> batches_;$/;"	m	class:lm::Controller
bclass	HTKLib/HModel.h	/^  BaseClass *bclass;                \/* base class for which transform applicable *\/$/;"	m	struct:_AdaptXForm
bclass	HTKLib/HModel.h	/^  BaseClass *bclass;   \/* baseclass associated with this regression tree *\/$/;"	m	struct:RegTree
beamLimit	HTKLVRec/HLVRec.h	/^   TokScore beamLimit;          \/* threshold of the main beam (bestScore - beamWidth) *\/$/;"	m	struct:_DecoderInst
beamPruneArcs	HTKLib/HLat.c	/^static Boolean beamPruneArcs = TRUE; \/* apply beam pruning to arcs (rather than just nodes) *\/$/;"	v	file:
beamWidth	HTKLVRec/HDecode.c	/^static LogFloat beamWidth = - LZERO;     \/* pruning global beam width *\/$/;"	v	file:
beamWidth	HTKLVRec/HDecode.mod.c	/^static LogFloat beamWidth = - LZERO;     \/* pruning global beam width *\/$/;"	v	file:
beamWidth	HTKLVRec/HLVRec.h	/^   TokScore beamWidth;          \/* max beamWidth main beam (set by -t cmd line option) *\/$/;"	m	struct:_DecoderInst
been_	HTKLVRec/kenlm/lm/search_trie.cc	/^    WordIndex been_[KENLM_MAX_ORDER];$/;"	m	class:lm::ngram::trie::__anon58::BlankManager	file:
been_length_	HTKLVRec/kenlm/lm/search_trie.cc	/^    unsigned char been_length_;$/;"	m	class:lm::ngram::trie::__anon58::BlankManager	file:
begin	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    WordIndex *begin() { return begin_; }$/;"	f	class:lm::builder::NGram
begin	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    const WordIndex *begin() const { return begin_; }$/;"	f	class:lm::builder::NGram
begin	HTKLVRec/kenlm/lm/search_trie.cc	/^  const WordIndex *begin, *end;$/;"	m	struct:lm::ngram::trie::__anon58::Gram	file:
begin	HTKLVRec/kenlm/lm/trie.hh	/^  uint64_t begin, end;$/;"	m	struct:lm::ngram::trie::NodeRange
begin	HTKLVRec/kenlm/util/fixed_array.hh	/^    T *begin() { return static_cast<T*>(block_.get()); }$/;"	f	class:util::FixedArray
begin	HTKLVRec/kenlm/util/fixed_array.hh	/^    const T *begin() const { return static_cast<const T*>(block_.get()); }$/;"	f	class:util::FixedArray
begin	HTKLVRec/kenlm/util/mmap.hh	/^    const char *begin() const { return reinterpret_cast<char*>(data_); }$/;"	f	class:util::scoped_memory
begin	HTKLVRec/kenlm/util/mmap.hh	/^    const uint8_t *begin() const { return reinterpret_cast<uint8_t*>(data_); }$/;"	f	class:util::scoped_mmap
begin	HTKLVRec/kenlm/util/string_piece.hh	/^  iterator begin() const { return ptr_; }$/;"	f	class:StringPiece
begin_	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    WordIndex *begin_, *end_;$/;"	m	class:lm::builder::NGram
begin_	HTKLVRec/kenlm/lm/quantize.hh	/^        float *begin_;$/;"	m	class:lm::ngram::SeparatelyQuantize::Bins
begin_	HTKLVRec/kenlm/lm/vocab.hh	/^    uint64_t *begin_, *end_;$/;"	m	class:lm::ngram::SortedVocabulary
begin_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    MutableIterator begin_;$/;"	m	class:util::ProbingHashTable
begin_sentence_	HTKLVRec/kenlm/lm/facade.hh	/^    State begin_sentence_, null_context_;$/;"	m	class:lm::base::ModelFacade
begin_sentence_	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    WordIndex begin_sentence_, end_sentence_, not_found_;$/;"	m	class:lm::base::Vocabulary
begin_sentence_memory_	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    const void *begin_sentence_memory_, *null_context_memory_;$/;"	m	class:lm::base::Model
best	HTKLVRec/HLVRec.h	/^   TokScore best;               \/* score of best token in any HMM state and LM state,$/;"	m	struct:_LexNodeInst
bestAlignMLF	HTKLVRec/HDecode.c	/^static char *bestAlignMLF;      \/* MLF with 1-best alignment *\/$/;"	v	file:
bestAlignMLF	HTKLVRec/HDecode.mod.c	/^static char *bestAlignMLF;      \/* MLF with 1-best alignment *\/$/;"	v	file:
bestInst	HTKLVRec/HLVRec.h	/^   LexNodeInst *bestInst;       \/* instance containing best token *\/$/;"	m	struct:_DecoderInst
bestScore	HTKLVRec/HLVRec-misc.c	/^   TokScore bestScore;$/;"	m	struct:_LayerStats	file:
bestScore	HTKLVRec/HLVRec.h	/^   LogFloat bestScore;          \/* score of best token *\/$/;"	m	struct:_DecoderInst
beta	HTKLib/HArc.h	/^  double *beta; \/* [starti..endi]. *\/$/;"	m	struct:_CorrN
beta	HTKLib/HFB.h	/^  DVector **beta;     \/* array[1..T][1..Q][1..Nq] of prob *\/$/;"	m	struct:__anon98
beta	HTKTools/HRest.c	/^static DMatrix beta;       \/* array[1..nStates][1..maxT] of backward prob *\/$/;"	v	file:
betaCorr	HTKLib/HArc.h	/^  float *betaCorr; \/* [starti..endi]. *\/$/;"	m	struct:_CorrN
betaPlus	HTKLib/HArc.h	/^  DVector *betaPlus;  \/* [myArc->t_start..myArc->t_end][1..Nq] *\/$/;"	m	struct:_Acoustic
betaPlus	HTKLib/HArc.h	/^  double betaPlus;$/;"	m	struct:_Arc
betaPlusError	HTKLib/HArc.h	/^  float alphaError, betaPlusError; \/*for MPE training.*\/$/;"	m	struct:_MPEStruct
bg	HTKLib/HGraf.h	/^   HColour fg, bg;            \/* colors *\/$/;"	m	struct:_HButton
bg	HTKTools/HSLab.c	/^   HColour fg, bg;$/;"	m	struct:__anon212	file:
bhiksha_	HTKLVRec/kenlm/lm/trie.hh	/^    Bhiksha bhiksha_;$/;"	m	class:lm::ngram::trie::BitPackedMiddle
bi	HLMTools/Cluster.c	/^   bi_count *bi;   \/* Array of counts *\/$/;"	m	struct:__anon25	file:
bi_count	HLMTools/Cluster.c	/^bi_count;$/;"	t	typeref:struct:__anon24	file:
bias	HTKLib/HModel.h	/^  SVector bias;        \/* bias vector, if no bias equals NULL *\/$/;"	m	struct:__anon132
bigFile	HTKTools/HLStats.c	/^static char *bigFile    = NULL;     \/* file for bigram *\/$/;"	v	file:
bigFloor	HTKTools/HLStats.c	/^static float bigFloor   = 0.0;      \/* floor for matrix bigram probs *\/$/;"	v	file:
bigMat	HTKLib/HLM.h	/^   Matrix bigMat;               \/* Actual probs *\/$/;"	m	struct:matbilm
bigThresh	HTKTools/HLStats.c	/^static int bigThresh    = 0;        \/* threshold for including bigram probs *\/$/;"	v	file:
bigits_	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  Vector<Chunk> bigits_;$/;"	m	class:double_conversion::Bignum
bigits_buffer_	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  Chunk bigits_buffer_[kBigitCapacity];$/;"	m	class:double_conversion::Bignum
bigram_add	HLMTools/Cluster.c	/^void bigram_add(NGram ng, int count)$/;"	f
bigram_added_all	HLMTools/Cluster.c	/^void bigram_added_all(void)$/;"	f
bigram_buffer_grow	HLMTools/Cluster.c	75;"	d	file:
bigram_init	HLMTools/Cluster.c	/^void bigram_init(int words) \/* Pass ->used field from word-map *\/$/;"	f
bigram_pack_	HTKLVRec/kenlm/lm/search_trie.cc	/^    BitPacked &bigram_pack_;$/;"	m	class:lm::ngram::trie::__anon58::WriteEntries	file:
bigrams	HLMTools/Cluster.c	/^bigrams;$/;"	t	typeref:struct:__anon25	file:
binForm	HTKLib/HModel.c	/^   Boolean binForm;     \/* binary form of keyword symbol *\/$/;"	m	struct:__anon119	file:
binMap	HLMLib/LModel.h	/^   NameId  *binMap;          \/* NameId array for decoding binary LMs *\/$/;"	m	struct:__anon15
binTree	HTKLib/HVQ.h	/^   binTree     \/* binary tree - every node has 0 or 2 offspring *\/$/;"	e	enum:__anon171
binary_	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^    Binary binary_;$/;"	m	class:lm::BinaryFilter
binary_exponent	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^  int16_t binary_exponent;$/;"	m	struct:double_conversion::CachedPower	file:
bindir	HLMLib/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	HLMTools/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	HTKLVRec/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	HTKLib/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	HTKTools/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bindir	Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
binfo	HLMTools/LAdapt.c	/^static BuildInfo  binfo;             \/* build parameters *\/$/;"	v	file:
binfo	HLMTools/LBuild.c	/^static BuildInfo  binfo;$/;"	v	file:
bins_	HTKLVRec/kenlm/lm/quantize.hh	/^        const Bins *bins_;$/;"	m	class:lm::ngram::SeparatelyQuantize::MiddlePointer
bipair	HLMTools/Cluster.c	/^static int        *bipair;                  \/* Array of word bigrams (w,w) *\/$/;"	v	file:
bitValue	HTKLib/HWave.c	/^static const unsigned char bitValue[8] = {1,2,4,8,16,32,64,128};$/;"	v	file:
bits	HTKLVRec/kenlm/util/bit_packing.hh	/^  uint8_t bits;$/;"	m	struct:util::BitsMask
bits	HTKLib/HAudio.c	/^   long bits ;$/;"	m	struct:_AudioIn	file:
bits	HTKLib/HAudio.c	/^   long bits ;$/;"	m	struct:_AudioOut	file:
bits_	HTKLVRec/kenlm/lm/quantize.hh	/^        uint8_t bits_;$/;"	m	class:lm::ngram::SeparatelyQuantize::Bins
bk	HTKLib/HParm.h	/^   ParmKind bk;          \/* parm kind of the parm buffer *\/$/;"	m	struct:__anon147
bkind	HTKLib/HModel.h	/^  BaseClassKind bkind; \/* type of parameters applicable to *\/$/;"	m	struct:__anon129
black	HTKLib/HGraf.c	/^static unsigned long black, white;$/;"	v	file:
blkSize	HTKLib/HTrain.h	/^   int blkSize;      \/* size of an item block *\/$/;"	m	struct:__anon160
block	HLMTools/Cluster.c	/^static void        *block=0;                \/* First word of free memory we have *\/$/;"	v	file:
block	HTKLVRec/HLVRec.h	/^   int block;$/;"	m	struct:_OutPCache
blockSize	HTKLib/HAdapt.c	/^   IntVec blockSize;$/;"	m	struct:__anon85	file:
blockSize	HTKLib/HModel.h	/^  IntVec blockSize;    \/* block sizes in the linear transform *\/$/;"	m	struct:__anon132
block_	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    util::stream::Link block_;$/;"	m	class:lm::builder::__anon42::CollapseStream	file:
block_	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    util::stream::Link block_;$/;"	m	class:lm::builder::__anon43::Writer	file:
block_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    util::stream::Link block_;$/;"	m	class:lm::builder::__anon45::PruneNGramStream	file:
block_	HTKLVRec/kenlm/util/fixed_array.hh	/^    util::scoped_malloc block_;$/;"	m	class:util::FixedArray
block_	HTKLVRec/kenlm/util/mmap.hh	/^    std::size_t block_;$/;"	m	class:util::Rolling
block_count	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  std::size_t block_count;$/;"	m	struct:lm::builder::PipelineConfig
block_count	HTKLVRec/kenlm/util/stream/config.hh	/^  std::size_t block_count;$/;"	m	struct:util::stream::ChainConfig
block_count_	HTKLVRec/kenlm/util/stream/sort.hh	/^    uint64_t block_count_;$/;"	m	class:util::stream::Offsets
block_cut_off	HLMTools/Cluster.c	70;"	d	file:
block_end	HLMTools/Cluster.c	/^static void        *block_end=0;            \/* First byte after current block *\/$/;"	v	file:
block_grab_size	HLMTools/Cluster.c	67;"	d	file:
block_it_	HTKLVRec/kenlm/util/stream/stream.hh	/^    Link block_it_;$/;"	m	class:util::stream::Stream
block_size_	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    const std::size_t block_size_;$/;"	m	class:lm::builder::__anon43::Writer	file:
block_size_	HTKLVRec/kenlm/util/stream/chain.hh	/^    std::size_t block_size_;$/;"	m	class:util::stream::Chain
block_size_	HTKLVRec/kenlm/util/stream/stream.hh	/^    std::size_t block_size_;$/;"	m	class:util::stream::Stream
bndId	HTKTools/HVite.c	/^static LabId bndId = NULL;        \/* Boundary word for alignment *\/$/;"	v	file:
boBiGram	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon187	file:
boInfo	HLMLib/LModel.h	/^   BackOffInfo *boInfo;     \/* discounting type *\/$/;"	m	struct:__anon13
boNGram	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, hlmModel } LMType;$/;"	e	enum:__anon105
bobcaStack	HTKLib/HAdapt.c	/^static MemHeap bobcaStack; \/* base obscache *\/$/;"	v	file:
bound	HTKLVRec/kenlm/lm/vocab.cc	/^  WordIndex bound;$/;"	m	struct:lm::ngram::detail::ProbingVocabularyHeader	file:
bound_	HTKLVRec/kenlm/lm/vocab.hh	/^    WordIndex bound_;$/;"	m	class:lm::ngram::ProbingVocabulary
bound_	HTKLVRec/kenlm/lm/vocab.hh	/^    WordIndex bound_;$/;"	m	class:lm::ngram::SortedVocabulary
bowt	HLMLib/LModel.h	/^   float bowt;              \/* LOG10 backoff weight *\/$/;"	m	struct:_FLEntry
bowt	HTKLVRec/HLVLM.h	/^   NGLM_Prob bowt;              \/* Back-off weight *\/$/;"	m	struct:nentry
bowt	HTKLib/HLM.h	/^   float bowt;                  \/* Back-off weight *\/$/;"	m	struct:nentry
btnHeap	HTKLib/HGraf.c	/^static MemHeap btnHeap;      \/* heap for HButton structures *\/$/;"	v	file:
btnHeap	HTKLib/HGraf_WIN32.c	/^static MemHeap btnHeap;           \/* heap for HButton structures *\/$/;"	v	file:
btnList	HTKTools/HSLab.c	/^static HButton *btnList;     \/* the list of buttons displayed on the HSLab window *\/$/;"	v	file:
btn_h	HTKTools/HSLab.c	/^static int btn_h;            \/* calculated button height *\/$/;"	v	file:
btn_h_spc	HTKTools/HSLab.c	/^static int btn_h_spc;        \/* calculated button horizontal spacing *\/$/;"	v	file:
btn_v_spc	HTKTools/HSLab.c	/^static int btn_v_spc;        \/* calculated button vertical spacing *\/$/;"	v	file:
btn_w	HTKTools/HSLab.c	/^static int btn_w;            \/* calculated button width *\/$/;"	v	file:
buckets_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    std::size_t buckets_;$/;"	m	class:util::ProbingHashTable
buf	HLMLib/LGBase.h	/^   Byte buf[GSIZE];         \/* next compressed N-gram to read *\/$/;"	m	struct:__anon3
buf1	HTKLib/HFBLat.c	/^static  char buf1[255];$/;"	v	file:
bufHeap	HTKTools/HVite.c	/^static MemHeap bufHeap;$/;"	v	file:
bufSize	HTKLib/HAudio.c	/^   int bufSize;             \/* Block size for each buffer *\/$/;"	m	struct:_AudioIn	file:
buf_	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    util::scoped_malloc buf_;$/;"	m	class:util::FakeOFStream
buf_	HTKLVRec/kenlm/util/read_compressed.cc	/^    scoped_malloc buf_;$/;"	m	class:util::__anon79::UncompressedWithHeader	file:
buffer	HTKLib/HAudio.c	/^   short buffer[AUDBUFSIZE];$/;"	m	struct:_AudioIn	file:
bufferSize	HTKLib/HAudio.c	/^   int bufferSize;           \/* Size of audio buffer *\/$/;"	m	struct:_AudioIn	file:
bufferStack	HTKTools/HInit.c	/^static MemHeap bufferStack;      \/* For storage of buffer *\/$/;"	v	file:
bufferStack	HTKTools/HRest.c	/^static MemHeap bufferStack;      \/* For storage of buffer *\/$/;"	v	file:
buffer_	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    boost::scoped_array<WordIndex> buffer_;$/;"	m	class:lm::builder::__anon43::Writer	file:
buffer_	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^    boost::scoped_array<char> buffer_;$/;"	m	class:lm::ARPAOutput
buffer_	HTKLVRec/kenlm/lm/filter/count_io.hh	/^    std::vector<char> buffer_;$/;"	m	class:lm::CountBatch
buffer_	HTKLVRec/kenlm/lm/vocab.hh	/^    std::string buffer_;$/;"	m	class:lm::ngram::WriteWordsWrapper
buffer_	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  Vector<char> buffer_;$/;"	m	class:double_conversion::StringBuilder
buffer_end_	HTKLVRec/kenlm/util/stream/sort.hh	/^        uint8_t *current_, *buffer_end_;$/;"	m	class:util::stream::MergeQueue::Entry
buffer_size	HTKLVRec/kenlm/util/stream/config.hh	/^  std::size_t buffer_size;$/;"	m	struct:util::stream::SortConfig
buffer_size_	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    const std::size_t buffer_size_;$/;"	m	class:util::FakeOFStream
buffer_size_	HTKLVRec/kenlm/util/stream/sort.hh	/^    const std::size_t buffer_size_;$/;"	m	class:util::stream::MergeQueue
buffer_size_	HTKLVRec/kenlm/util/stream/sort.hh	/^    std::size_t buffer_size_;$/;"	m	class:util::stream::MergingReader
buildLatSE	HTKLVRec/HLVRec.c	/^static Boolean buildLatSE = FALSE;\/* build lat from single tok in SENTEND node *\/$/;"	v	file:
buildStack	HTKTools/HBuild.c	/^MemHeap buildStack;$/;"	v
builder	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^namespace builder {$/;"	n	namespace:lm	file:
builder	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/discount.hh	/^namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/hash_gamma.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	HTKLVRec/kenlm/lm/builder/initial_probabilities.hh	/^namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	HTKLVRec/kenlm/lm/builder/interpolate.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/joint_order.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/ngram.hh	/^namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/output.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	HTKLVRec/kenlm/lm/builder/output.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/print.cc	/^namespace lm { namespace builder {$/;"	n	namespace:lm	file:
builder	HTKLVRec/kenlm/lm/builder/print.hh	/^namespace lm { namespace builder {$/;"	n	namespace:lm
builder	HTKLVRec/kenlm/lm/builder/sort.hh	/^namespace builder {$/;"	n	namespace:lm
builder_	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    double_conversion::StringBuilder builder_;$/;"	m	class:util::FakeOFStream
building_memory	HTKLVRec/kenlm/lm/config.hh	/^  std::size_t building_memory;$/;"	m	struct:lm::ngram::Config
bw	HTKTools/HSLab.c	/^   int x, y, w, h, bw;    \/* x-pos, y-pos, width, height, fg and bg colours *\/$/;"	m	struct:__anon212	file:
bwlike	HTKLib/HLat.h	/^   LogDouble bwlike;     \/* backward likelihood *\/$/;"	m	struct:FBlnodeInfo
c	HTKLib/HAudio.c	/^   CRITICAL_SECTION c;$/;"	m	struct:_AudioIn	file:
c	HTKLib/HAudio.c	/^   CRITICAL_SECTION c;$/;"	m	struct:_AudioOut	file:
c	HTKLib/HGraf.h	/^   unsigned char c;  \/* keypress char *\/$/;"	m	struct:__anon103
c	HTKLib/HParm.c	/^   Vector c;          \/* cepstral vector *\/$/;"	m	struct:__anon141	file:
c	HTKLib/HTrain.h	/^   Vector c;         \/* array[1..M] of mixture weight *\/$/;"	m	struct:__anon164
c	HTKTools/HSmooth.c	/^   Vector c;         \/* array[1..M] of mixture weight *\/$/;"	m	struct:_ChWtAcc	file:
cCount	HTKLib/HWave.c	/^static int cCount;   \/* num bytes read *\/$/;"	v	file:
cMeanDN	HTKLib/HParm.c	/^   char* cMeanDN;             \/* dir to find cepstral mean files *\/$/;"	m	struct:__anon141	file:
cMeanMask	HTKLib/HParm.c	/^   char* cMeanMask;           \/* cepstral mean selection mask *\/$/;"	m	struct:__anon141	file:
cMeanPathMask	HTKLib/HParm.c	/^   char* cMeanPathMask;       \/* cepstral mean path selection mask *\/$/;"	m	struct:__anon141	file:
cMeanVector	HTKLib/HParm.c	/^   Vector cMeanVector;   \/* vector loaded from cmean dir *\/$/;"	m	struct:__anon141	file:
cNIST	HTKLib/HWave.c	/^static int cNIST;    \/* current input char *\/$/;"	v	file:
cOutP	HTKLVRec/HLVRec-outP.c	/^static LogFloat cOutP (DecoderInst *dec, Observation *x, HLink hmm, int state)$/;"	f	file:
cPOutP	HTKLib/HRec.c	/^static LogFloat cPOutP(PSetInfo *psi,Observation *obs,StateInfo *si,int id)$/;"	f	file:
cParm	HLMLib/LCMap.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLMLib/LGBase.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLMLib/LModel.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLMLib/LPCalc.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMLib/LPMerge.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMLib/LUtil.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HLMLib/LWMap.c	/^static ConfParam *cParm[MAXGLOBS];   \/* config parameters *\/$/;"	v	file:
cParm	HLMTools/Cluster.c	/^static ConfParam   *cParm[MAXGLOBS];        \/* configuration script parameters *\/$/;"	v	file:
cParm	HLMTools/HLMCopy.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LAdapt.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LBuild.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LFoF.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LGCopy.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LGList.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LGPrep.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LLink.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LMerge.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LNewMap.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LNorm.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LPlex.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HLMTools/LSubset.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKLVRec/HDecode.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKLVRec/HDecode.mod.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKLVRec/HLVLM.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLVRec/HLVModel.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLVRec/HLVNet.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLVRec/HLVRec.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HAdapt.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HArc.c	/^static ConfParam *cParm[MAXGLOBS];  \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HAudio.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HDict.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HExactMPE.c	/^static ConfParam *cParm[MAXGLOBS];  \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HFB.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HFBLat.c	/^static ConfParam *cParm[MAXGLOBS];  \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HGraf.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HGraf.null.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HGraf_WIN32.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HLM.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HLabel.c	/^static ConfParam *cParm[MAXGLOBS];        \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HLat.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HMap.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HMath.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HMem.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HModel.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HNet.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HParm.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HRec.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HShell.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HSigP.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HTrain.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HUtil.c	/^static ConfParam *cParm[MAXGLOBS];      \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HVQ.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKLib/HWave.c	/^static ConfParam *cParm[MAXGLOBS];       \/* config parameters *\/$/;"	v	file:
cParm	HTKTools/HBuild.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HCompV.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HCopy.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HDMan.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HERest.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HHEd.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HInit.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HLEd.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HLRescore.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HLStats.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HList.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HMMIRest.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HParse.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HQuant.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HRest.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HResults.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HSGen.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HSLab.c	/^static ConfParam *cParm[MAXGLOBS];   \/* configuration parameters *\/$/;"	v	file:
cParm	HTKTools/HSmooth.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cParm	HTKTools/HVite.c	/^static ConfParam *cParm[MAXGLOBS];$/;"	v	file:
cSOutP	HTKLib/HRec.c	/^static LogFloat cSOutP(HMMSet *hset, int s, Observation *x, StreamElem *se,$/;"	f	file:
cStack	HTKTools/HCopy.c	/^static MemHeap cStack;          \/* chop stack *\/$/;"	v	file:
cStack	HTKTools/HQuant.c	/^static MemHeap cStack;             \/* cluster stack *\/$/;"	v	file:
cacheHit	HTKLVRec/HLVRec.h	/^   int cacheHit;$/;"	m	struct:_OutPCache
cacheMiss	HTKLVRec/HLVRec.h	/^   int cacheMiss;$/;"	m	struct:_OutPCache
cacheMixoccHeap	HTKLib/HFBLat.c	/^MemHeap cacheMixoccHeap;$/;"	v
cache_size_	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^    const std::size_t cache_size_;$/;"	m	class:lm::np::Model
calcArc	HTKLib/HArc.h	/^  HArc *calcArc; \/*An identical arc (in hmm, start, end), which we use for purposes of forward-backward alignment [only if id==0].*\/$/;"	m	struct:_Arc
calcStats	HTKTools/HLRescore.c	/^static Boolean calcStats = FALSE;   \/* -c *\/$/;"	v	file:
calign	HTKLib/HRec.c	/^   int calign;              \/* Number of align records after last collection *\/$/;"	m	struct:precinfo	file:
callBackEvent	HTKLib/HAudio.c	/^   HANDLE callBackEvent;$/;"	m	struct:_AudioIn	file:
callBackEvent	HTKLib/HAudio.c	/^   HANDLE callBackEvent;$/;"	m	struct:_AudioOut	file:
callBackIn	HTKLib/HAudio.c	/^void CALLBACK callBackIn(HWAVE hwaveIn, UINT msg, DWORD magic, $/;"	f
callBackOut	HTKLib/HAudio.c	/^void CALLBACK callBackOut(HWAVE hwaveIn, UINT msg, $/;"	f
call_realloc	HTKLVRec/kenlm/util/mmap.cc	/^void scoped_memory::call_realloc(std::size_t size) {$/;"	f	class:util::scoped_memory
call_realloc	HTKLVRec/kenlm/util/scoped.cc	/^void scoped_malloc::call_realloc(std::size_t requested) {$/;"	f	class:util::scoped_malloc
capacity	HTKLVRec/kenlm/util/string_piece.hh	/^  size_type capacity() const { return length_; }$/;"	f	class:StringPiece
cbSizes	HTKTools/HQuant.c	/^static int cbSizes[SMAX];           \/* codebook sizes, per stream *\/$/;"	v	file:
ccs	HTKLib/HTrain.c	/^static ClusterSet *ccs; \/* current cluster set *\/$/;"	v	file:
cdef	HTKTools/HLEd.c	/^   LabId cdef[MAXARGS];$/;"	m	struct:_Context	file:
cepLifter	HTKLib/HParm.c	/^   int cepLifter;             \/* Cepstral liftering coef *\/$/;"	m	struct:__anon141	file:
cepScale	HTKLib/HParm.c	/^   float cepScale;            \/* Scaling factor to avoid arithmetic problems *\/$/;"	m	struct:__anon141	file:
cepWin	HTKLib/HSigP.c	/^static Vector cepWin = NULL;        \/* Current cepstral weight window *\/$/;"	v	file:
cepWinL	HTKLib/HSigP.c	/^static int cepWinL=0;               \/* Current liftering coeff *\/$/;"	v	file:
cepWinSize	HTKLib/HSigP.c	/^static int cepWinSize=0;            \/* Size of current cepstral weight window *\/$/;"	v	file:
cf	HTKLib/HParm.c	/^   IOConfig cf;        \/* configuration for this channel *\/$/;"	m	struct:_ParmBuf	file:
cf	HTKLib/HParm.c	/^   IOConfigRec cf;        \/* Channel configuration *\/$/;"	m	struct:channelinfo	file:
cf	HTKLib/HSigP.h	/^   Vector cf;           \/* array[1..pOrder+1] of centre freqs *\/$/;"	m	struct:__anon159
cfHSKind	HTKLib/HModel.c	/^static HSetKind cfHSKind;$/;"	v	file:
cfWordBoundary	HTKLib/HNet.c	/^Boolean cfWordBoundary=TRUE;$/;"	v
cfkmap	HTKLib/HShell.c	/^static char *cfkmap[] = { $/;"	v	file:
cfs	HTKLib/HNet.h	/^   LabId *cfs;     \/* Sorted array of context free labids *\/$/;"	m	struct:hmmsetcxtinfo
ch	HTKLib/HUtil.c	/^static int ch;                 \/* Current character from source *\/$/;"	v	file:
ch	HTKTools/HParse.c	/^static char ch;                     \/* Current character *\/$/;"	v	file:
chClear	HTKLib/HParm.c	/^   Boolean chClear;    \/* End of channel reached *\/$/;"	m	struct:_ParmBuf	file:
chOffset	HTKLib/HParm.c	/^   float chOffset;        \/* Average sample offset (-32768..32767) *\/$/;"	m	struct:channelinfo	file:
chPeak	HTKLib/HParm.c	/^   float chPeak;          \/* Scaled peak-to-peak range 0.0-1.0 *\/$/;"	m	struct:channelinfo	file:
chPeak	HTKLib/HParm.h	/^   float chPeak;              \/* Peak-to-peak input level for channel *\/$/;"	m	struct:__anon149
chType	HTKLib/HParm.c	/^   ChannelType chType; \/* type of input channel *\/$/;"	m	struct:_ParmBuf	file:
ch_ext_parm	HTKLib/HParm.c	/^   ch_ext_parm    \/* Externally defined parameterised source *\/$/;"	e	enum:channeltype	file:
ch_ext_wave	HTKLib/HParm.c	/^   ch_ext_wave,   \/* Externally defined waveform source *\/$/;"	e	enum:channeltype	file:
ch_haudio	HTKLib/HParm.c	/^   ch_haudio=4,   \/* The HAudio interface *\/$/;"	e	enum:channeltype	file:
ch_hparm	HTKLib/HParm.c	/^   ch_hparm,      \/* A parmeterised file *\/$/;"	e	enum:channeltype	file:
ch_hrfe	HTKLib/HParm.c	/^   ch_hrfe,       \/* The RFE is not yet reimplemented *\/$/;"	e	enum:channeltype	file:
ch_hwave	HTKLib/HParm.c	/^   ch_hwave,      \/* A waveform file *\/$/;"	e	enum:channeltype	file:
chain	HLMLib/LGBase.h	/^   GFLink chain;           \/* linked list of all files *\/$/;"	m	struct:gramfile
chain	HTKLVRec/HLVNet.h	/^   TLexNode *chain;              \/* global chain of all TLexNodes *\/$/;"	m	struct:_TLexNode
chain	HTKLib/HNet.c	/^   NetNode *chain;  \/* Chain of other nodes in word *\/$/;"	m	struct:pronholder	file:
chain	HTKLib/HNet.h	/^   NetNode *chain;$/;"	m	struct:_NetNode
chain	HTKLib/HNet.h	/^   NetNode *chain;$/;"	m	struct:__anon139
chain	HTKLib/HNet.h	/^   struct lattice *chain;       \/* Linked list used for various jobs *\/$/;"	m	struct:lattice	typeref:struct:lattice::lattice
chain	HTKLib/HNet.h	/^   struct sublatdef *chain; \/* Next sublat referring to lat *\/$/;"	m	struct:sublatdef	typeref:struct:sublatdef::sublatdef
chain	HTKLib/HRec.c	/^   NxtPath *chain;      \/* Next of NBest Paths *\/$/;"	m	struct:nxtpath	file:
chain	HTKLib/HRec.h	/^   NxtPath *chain;      \/* Next of NBest Paths *\/$/;"	m	struct:path
chain	HTKTools/HParse.c	/^   Link chain;       \/* simple linked list of all nodes *\/  $/;"	m	struct:_Node	file:
chain	HTKTools/HParse.c	/^   Link chain;$/;"	m	struct:__anon204	file:
chain_	HTKLVRec/kenlm/util/stream/chain.hh	/^    Chain *chain_;$/;"	m	class:util::stream::ChainPosition
chains_	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    util::stream::Chains chains_;$/;"	m	class:lm::builder::__anon47::Master	file:
chan	HTKLib/HParm.c	/^   ChannelInfo *chan;  \/* input channel for this buffer *\/$/;"	m	struct:_ParmBuf	file:
channelinfo	HTKLib/HParm.c	/^typedef struct channelinfo {$/;"	s	file:
channels	HTKLib/HAudio.c	/^   long channels ;$/;"	m	struct:_AudioIn	file:
channels	HTKLib/HAudio.c	/^   long channels ;$/;"	m	struct:_AudioOut	file:
channeltype	HTKLib/HParm.c	/^typedef enum channeltype {$/;"	g	file:
character_	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    char character_;$/;"	m	class:util::stream::WorkerProgress
character_handout_	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    std::size_t character_handout_;$/;"	m	class:util::stream::MultiProgress
chars_	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    StringPiece chars_;$/;"	m	class:util::AnyCharacter
chars_	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    StringPiece chars_;$/;"	m	class:util::AnyCharacterLast
chcount	HTKLib/HShell.h	/^   int chcount;         \/* num chars from start *\/$/;"	m	struct:__anon154
checkOrder	HLMLib/LGBase.c	/^static Boolean checkOrder = FALSE;      \/* Check n-gram ordering *\/$/;"	v	file:
check_counts_sum	HLMTools/Cluster.c	/^void check_counts_sum(void)$/;"	f
check_file	HLMTools/Cluster.c	/^void check_file(FILE *file, char *fname, char *function)$/;"	f
check_file	HLMTools/LLink.c	/^FILE *check_file(FILE *file, char *fname)$/;"	f
checking	HTKLib/HModel.c	/^static Boolean checking   = TRUE;       \/* check HMM defs *\/$/;"	v	file:
child	HTKLib/HModel.h	/^  struct _RegNode **child;  \/* children of this node NULL if terminal *\/$/;"	m	struct:_RegNode	typeref:struct:_RegNode::_RegNode
choose_class	HLMTools/Cluster.c	/^static int choose_class(UInt w)$/;"	f	file:
chopF	HTKTools/HCopy.c	/^static Boolean chopF = FALSE;   \/* set if we should truncate files\/trans *\/$/;"	v	file:
ci	HLMLib/LUtil.c	/^const static int ci[28]={ 28,0,0,2,1,0,0,1,2,3,0,0,3,0,$/;"	v	file:
cis	HTKLib/HNet.h	/^   LabId *cis;     \/* Sorted array of context independent labids *\/$/;"	m	struct:hmmsetcxtinfo
ck	HTKLib/HTrain.h	/^   CovKind ck;     \/* type of covariance if any *\/$/;"	m	struct:__anon162
ck	HTKTools/HQuant.c	/^CovKind ck = NULLC;                \/* determines distance metric *\/$/;"	v
ckUsage	HTKLib/HModel.h	/^   int ckUsage[NUMCKIND];  \/* Number of components using given ckind *\/$/;"	m	struct:_HMMSet
ckind	HTKLib/HModel.h	/^   CovKind ckind;          \/* cov kind - only global in V1.X *\/$/;"	m	struct:_HMMSet
ckind	HTKLib/HModel.h	/^   CovKind ckind;       \/* kind of covariance *\/$/;"	m	struct:__anon120
ckind	HTKLib/HVQ.h	/^   CovKind ckind;       \/* kind of covariance used, if any*\/$/;"	m	struct:_VQTabRec
cl	HTKLib/HTrain.h	/^   Cluster *cl;    \/* array[1..numClust]of Cluster *\/$/;"	m	struct:__anon162
clCnt	HLMTools/Cluster.c	/^static int       **clCnt=NULL;              \/* Array of arrays; index with count[c1][c2]$/;"	v	file:
clEntry	HLMLib/LCMap.h	/^typedef struct clEntry { \/* class map entry *\/$/;"	s
clMemb	HLMTools/Cluster.c	/^static int	  *clMemb=NULL;             \/* Class membership [words]$/;"	v	file:
clSum	HLMTools/Cluster.c	/^static int        *clSum=NULL;              \/* Class unigram [classes]$/;"	v	file:
classBM	HLMLib/LModel.h	/^   NameId *classBM;          \/* Hash table (similar to binMap) *\/$/;"	m	struct:__anon15
classCounts	HLMLib/LModel.h	/^   Boolean classCounts;      \/* TRUE if LM file gives class counts not probs *\/$/;"	m	struct:__anon15
classH	HLMLib/LModel.h	/^   HashTab *classH;          \/* If a class-based LM then use this hash table *\/$/;"	m	struct:__anon15
classId	HLMTools/LPlex.c	/^   LabId classId;$/;"	m	struct:_Equiv	file:
classId	HTKTools/HResults.c	/^   LabId classId;$/;"	m	struct:_Equiv	file:
classLM	HLMLib/LModel.h	/^   Boolean classLM;          \/* TRUE if a class-based LM (toggle on backoff) *\/$/;"	m	struct:__anon15
classW	HLMLib/LModel.h	/^   int classW;               \/* Number of words *\/$/;"	m	struct:__anon15
class_sort	HLMTools/Cluster.c	/^static UInt        *class_sort;	            \/* Used to sort output alphabetically *\/$/;"	v	file:
classes_change	HLMTools/Cluster.c	/^static void classes_change(UInt w, int g)$/;"	f	file:
classes_get_default	HLMTools/Cluster.c	/^int classes_get_default(void)$/;"	f
classes_init	HLMTools/Cluster.c	/^void classes_init(int numb_words)$/;"	f
classes_keep_unk_separate	HLMTools/Cluster.c	/^void classes_keep_unk_separate(int keep_separate)$/;"	f
classes_set_number	HLMTools/Cluster.c	/^void classes_set_number(int numb)$/;"	f
classes_showMLV	HLMTools/Cluster.c	/^void classes_showMLV(int on)$/;"	f
clear	HTKLVRec/kenlm/util/fixed_array.hh	/^    void clear() {$/;"	f	class:util::FixedArray
clear	HTKLVRec/kenlm/util/string_piece.hh	/^  void clear() { ptr_ = NULL; length_ = 0; }$/;"	f	class:StringPiece
clen	HTKLib/HNet.c	/^   int clen;        \/* Number of non-cf phones in pronunciation *\/$/;"	m	struct:pronholder	file:
clist	HTKTools/HHEd.c	/^   CLink clist;                 \/* list of cluster items *\/$/;"	m	struct:_Node	file:
clt	HLMLib/LWMap.h	/^   LookupTable *clt;     \/* class lookup table *\/$/;"	m	struct:__anon23
clustAcc	HTKTools/HHEd.c	/^   float  clustAcc;          \/* accumulates in this cluster *\/$/;"	m	struct:__anon198	file:
clustSetStack	HTKTools/HInit.c	/^static MemHeap clustSetStack;    \/* For storage of cluster sets *\/$/;"	v	file:
clusterScore	HTKTools/HHEd.c	/^   float  clusterScore;      \/* node cluster score *\/$/;"	m	struct:__anon198	file:
cluster_words	HLMTools/Cluster.c	/^void cluster_words(int iterations)$/;"	f
cm	HTKLib/HParm.c	/^   DMatrix cm;        \/* Cosine matrix for IDFT *\/ $/;"	m	struct:__anon141	file:
cmDir	HTKTools/HCompV.c	/^static char cmDir[MAXSTRLEN];            \/* directory to export CMV *\/$/;"	v	file:
cmap	HLMTools/LGCopy.c	/^static ClassMap   cmap;             \/* word list for OOV mapping *\/$/;"	v	file:
cmap	HLMTools/LSubset.c	/^static ClassMap cmap;            \/* class map *\/$/;"	v	file:
cmap	HTKLib/HTrain.c	/^static ShortVec cmap;   \/* array[1..cvp->nItems]of cluster index *\/$/;"	v	file:
cmapFN	HLMTools/LGCopy.c	/^static char *cmapFN  = NULL;        \/* word list file name *\/$/;"	v	file:
cmd	HTKTools/HDMan.c	/^   EditCmd cmd;$/;"	m	struct:_ScriptItem	file:
cmd	HTKTools/HLEd.c	/^   EditCmd cmd;$/;"	m	struct:_ScriptItem	file:
cmdMap	HTKTools/HDMan.c	/^static char *cmdMap[] = { "UW","UP","LW","LP","DW","DD","FW","DC",$/;"	v	file:
cmdNum	HTKTools/HHEd.c	/^cmdNum;$/;"	t	typeref:enum:__anon199	file:
cmdTrace	HTKTools/HHEd.c	/^static int  cmdTrace    = 0;     \/* trace level from command line *\/$/;"	v	file:
cmdmap	HTKTools/HHEd.c	/^static char *cmdmap[] = {"AT","RT","SS","CL","CO","JO","MU","TI","UF","NC",$/;"	v	file:
cmdmap	HTKTools/HLEd.c	/^static char *cmdmap[] = {"","RE","CH","FI","ME","DE","DC","IT",$/;"	v	file:
cmllrAdaptKind	HTKLib/HAdapt.c	/^static AdaptKind cmllrAdaptKind = BASE;$/;"	v	file:
cmllrBaseClass	HTKLib/HAdapt.c	/^static char *cmllrBaseClass = NULL;$/;"	v	file:
cmllrBlockSize	HTKLib/HAdapt.c	/^static IntVec cmllrBlockSize = NULL;$/;"	v	file:
cmllrRegTree	HTKLib/HAdapt.c	/^static char *cmllrRegTree = NULL;$/;"	v	file:
cmllrSplitThresh	HTKLib/HAdapt.c	/^static float cmllrSplitThresh = 1000.0;$/;"	v	file:
cmpMix	HTKTools/HHEd.c	/^static int cmpMix(const void *v1,const void *v2)$/;"	f	file:
cmuId	HTKTools/HDMan.c	/^static LabId cmuId;                  \/* "cmu" *\/$/;"	v	file:
cn	HTKLib/HArc.h	/^  CorrN *cn; \/* if doing dynamic MPE. *\/$/;"	m	struct:_MPEStruct
cname	HTKTools/HLEd.c	/^   LabId cname;$/;"	m	struct:_Context	file:
cntr	HTKTools/HLStats.c	/^typedef struct cntr{             \/* Physical Label Occurrence Counters *\/$/;"	s	file:
coef	HLMLib/LModel.h	/^   float *coef;             \/* discounting coefs *\/$/;"	m	struct:__anon10
colours	HTKLib/HGraf.c	/^static int colours[MAX_COLOURS];$/;"	v	file:
colours	HTKLib/HGraf_WIN32.c	/^static unsigned char colours[MAX_COLOURS][3];    \/* r,g,b *\/$/;"	v	file:
combine_	HTKLVRec/kenlm/util/stream/sort.hh	/^    Combine combine_;$/;"	m	class:util::stream::MergingReader
combine_	HTKLVRec/kenlm/util/stream/sort.hh	/^    const Combine combine_;$/;"	m	class:util::stream::Sort
command_map	HTKTools/HSLab.c	/^static char *command_map[] = {$/;"	v	file:
commentChars	HTKTools/HDMan.c	/^static char commentChars[10] = "#";  \/* default dictionary comment char *\/$/;"	v	file:
compNode	HTKLVRec/HLVNet.h	/^   CompLMlaNode *compNode;      \/* [0..nCompNodes-1] arry of entries *\/$/;"	m	struct:_LMlaTree
comp_stll	HTKLVRec/HLVNet.c	/^int comp_stll (const void *v1, const void *v2) {$/;"	f
compare	HTKLVRec/kenlm/util/string_piece.hh	/^  int compare(const StringPiece& x) const {$/;"	f	class:StringPiece
compare_	HTKLVRec/kenlm/util/stream/sort.hh	/^        const Compare compare_;$/;"	m	class:util::stream::MergeQueue::Greater
compare_	HTKLVRec/kenlm/util/stream/sort.hh	/^    Compare compare_;$/;"	m	class:util::stream::MergingReader
compare_	HTKLVRec/kenlm/util/stream/sort.hh	/^    SizedCompare<Compare> compare_;$/;"	m	class:util::stream::BlockSorter
compare_	HTKLVRec/kenlm/util/stream/sort.hh	/^    const Compare compare_;$/;"	m	class:util::stream::Sort
compatMode	HTKLib/HLabel.c	/^static Boolean compatMode = FALSE;  \/* Allow spaces around . or \/\/\/ *\/$/;"	v	file:
complete	HTKLVRec/kenlm/lm/builder/ngram.hh	/^  ProbBackoff complete;$/;"	m	union:lm::builder::Payload
complete_	HTKLVRec/kenlm/util/ersatz_progress.hh	/^    uint64_t current_, next_, complete_;$/;"	m	class:util::ErsatzProgress
complete_	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    uint64_t complete_;$/;"	m	class:util::stream::MultiProgress
complete_called_	HTKLVRec/kenlm/util/stream/chain.hh	/^    bool complete_called_;$/;"	m	class:util::stream::Chain
compressFact	HTKLib/HParm.c	/^   float compressFact;        \/* Compression factor for PLP *\/  $/;"	m	struct:__anon141	file:
compressMerge	HTKLib/HLat.c	/^static Boolean compressMerge = TRUE; \/* compressing lattice scores when merging duplicates *\/$/;"	v	file:
conDel	HTKTools/HResults.c	/^static ShortVec conDel,conIns; \/* corresponding deletion and insertion counts *\/$/;"	v	file:
conIns	HTKTools/HResults.c	/^static ShortVec conDel,conIns; \/* corresponding deletion and insertion counts *\/$/;"	v	file:
conMat	HTKTools/HResults.c	/^static ShortVec *conMat;  \/* confusion matrix, conMat[i][j] is the number of$/;"	v	file:
confList	HTKLib/HShell.c	/^static ConfigEntry *confList = NULL;$/;"	v	file:
confName	HTKLib/HParm.c	/^   char *confName;        \/* Configuration name associated with mean *\/$/;"	m	struct:channelinfo	file:
config	HTKLib/HAudio.c	/^   ALconfig config;          \/* configuration record *\/$/;"	m	struct:_AudioIn	file:
config	HTKLib/HAudio.c	/^   ALconfig config;          \/* configuration record *\/$/;"	m	struct:_AudioOut	file:
config_	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    PipelineConfig &config_;$/;"	m	class:lm::builder::__anon47::Master	file:
config_	HTKLVRec/kenlm/util/stream/chain.hh	/^    ChainConfig config_;$/;"	m	class:util::stream::Chain
config_	HTKLVRec/kenlm/util/stream/sort.hh	/^    SortConfig config_;$/;"	m	class:util::stream::Sort
const_iterator	HTKLVRec/kenlm/util/string_piece.hh	/^  typedef const char* const_iterator;$/;"	t	class:StringPiece
const_reference	HTKLVRec/kenlm/util/string_piece.hh	/^  typedef const char& const_reference;$/;"	t	class:StringPiece
const_reverse_iterator	HTKLVRec/kenlm/util/string_piece.hh	/^  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:StringPiece
consume_at_	HTKLVRec/kenlm/util/pcqueue.hh	/^  T *consume_at_;$/;"	m	class:util::PCQueue
consume_at_mutex_	HTKLVRec/kenlm/util/pcqueue.hh	/^  boost::mutex consume_at_mutex_;$/;"	m	class:util::PCQueue
context_	HTKLVRec/kenlm/lm/trie_sort.hh	/^    util::scoped_FILE full_[KENLM_MAX_ORDER - 1], context_[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::trie::SortedFiles
contexts	HTKTools/HDMan.c	/^   EditCmd contexts[MAXCONS];   \/* array of context defs *\/$/;"	m	struct:__anon195	file:
contexts_	HTKLVRec/kenlm/lm/search_trie.cc	/^    RecordReader *contexts_;$/;"	m	class:lm::ngram::trie::__anon58::WriteEntries	file:
convert_	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    double_conversion::DoubleToStringConverter convert_;$/;"	m	class:util::FakeOFStream
copy_from_	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    uint8_t *copy_from_;$/;"	m	class:lm::builder::__anon42::CollapseStream	file:
correctness	HTKLib/HArc.h	/^  float correctness;  \/* for inexact MPE. *\/$/;"	m	struct:_MPEStruct
count	HLMLib/LModel.c	/^   int count;           \/* count for access *\/$/;"	m	struct:_AccessInfo	file:
count	HLMLib/LWMap.h	/^   int count;              \/* word frequency count *\/$/;"	m	struct:MAPENTRY
count	HLMTools/Cluster.c	/^   int  count;	  \/* Bigram count *\/$/;"	m	struct:__anon24	file:
count	HLMTools/LPlex.c	/^   int count;$/;"	m	struct:__anon33	file:
count	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^      uint64_t count;$/;"	m	struct:lm::builder::__anon42::StatCollector::OrderStat	file:
count	HTKLVRec/kenlm/lm/builder/ngram.hh	/^  uint64_t count;$/;"	m	union:lm::builder::Payload
count	HTKTools/HLStats.c	/^   int count;                    \/* Count *\/$/;"	m	struct:aentry	file:
count	HTKTools/HLStats.c	/^   int count;                    \/* Times seen *\/$/;"	m	struct:cntr	file:
count	HTKTools/HLStats.c	/^   int count;                    \/* Times seen *\/$/;"	m	struct:wordinfo	file:
count_	HTKLVRec/kenlm/lm/search_hashed.hh	/^        uint64_t count_;$/;"	m	class:lm::ngram::detail::HashedSearch::Unigram
count_pruned	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^      uint64_t count_pruned;$/;"	m	struct:lm::builder::__anon42::StatCollector::OrderStat	file:
counts	HTKLVRec/HLVLM.h	/^   int counts[NSIZE+1];         \/* Number of [n]grams *\/$/;"	m	struct:_FSLM_ngram
counts	HTKLVRec/kenlm/lm/binary_format.hh	/^  std::vector<uint64_t> counts;$/;"	m	struct:lm::ngram::Parameters
counts	HTKLib/HLM.h	/^   int counts[NSIZE+1];         \/* Number of [n]grams *\/$/;"	m	struct:ngramlm
counts_	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    std::vector<uint64_t> &counts_;$/;"	m	class:lm::builder::__anon42::StatCollector	file:
counts_	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^    std::vector<uint64_t> &counts_;$/;"	m	class:lm::builder::AdjustCounts
counts_	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^    std::vector<uint64_t> counts_;$/;"	m	class:lm::ARPAOutput
counts_	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^    std::vector<uint64_t> counts_;$/;"	m	class:lm::interpolate::ARPAToStream
counts_	HTKLVRec/kenlm/lm/search_trie.cc	/^    std::vector<uint64_t> counts_;$/;"	m	class:lm::ngram::trie::__anon58::FindBlanks	file:
counts_pruned	HTKLVRec/kenlm/lm/builder/header_info.hh	/^  std::vector<uint64_t> counts_pruned;$/;"	m	struct:HeaderInfo
counts_pruned_	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    std::vector<uint64_t> &counts_pruned_;$/;"	m	class:lm::builder::__anon42::StatCollector	file:
counts_pruned_	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^    std::vector<uint64_t> &counts_pruned_;$/;"	m	class:lm::builder::AdjustCounts
cov	HTKLib/HAdapt.c	/^   Covariance cov;$/;"	m	struct:__anon86	file:
cov	HTKLib/HModel.h	/^   Covariance cov;      \/* covariance matrix or vector *\/$/;"	m	struct:__anon120
cov	HTKLib/HTrain.h	/^   Covariance cov;   \/* covariance counts *\/$/;"	m	struct:__anon166
cov	HTKLib/HTrain.h	/^   Covariance cov; \/* covariance of cluster *\/$/;"	m	struct:__anon161
cov	HTKLib/HVQ.h	/^   Covariance cov;      \/* null or inverse variance or covariance *\/$/;"	m	struct:_VQNodeRec
cov	HTKTools/HQuant.c	/^Covariance cov[SMAX];              \/* Global stream covariance  *\/$/;"	v
covarChanged	HTKLib/HAdapt.c	/^static Boolean covarChanged = FALSE;$/;"	v	file:
covarPChanged	HTKLib/HAdapt.c	/^static Boolean covarPChanged = FALSE;$/;"	v	file:
cpdf	HTKLib/HModel.h	/^   MixtureElem *cpdf;    \/* PLAINHS or SHAREDHS *\/$/;"	m	union:__anon122
cprob	HTKTools/HHEd.c	/^static float  cprob;            \/* complete likelihood at current node *\/$/;"	v	file:
cpth	HTKLib/HRec.c	/^   int cpth;                \/* Number of path records after last collection *\/$/;"	m	struct:precinfo	file:
crcc	HTKLib/HParm.c	/^   unsigned short crcc; \/* Running CRCC *\/$/;"	m	struct:__anon141	file:
crcc	HTKLib/HParm.c	/^   unsigned short crcc;\/* Put crcc here when we read it !! *\/$/;"	m	struct:_ParmBuf	file:
cs	HTKTools/HQuant.c	/^ClusterSet *cs[SMAX];              \/* stores vector clusters *\/$/;"	v
csize	HTKLib/HTrain.h	/^   int csize;      \/* num items in this cluster *\/$/;"	m	struct:__anon161
cur	HTKLib/HAudio.c	/^   int cur;               \/* Current sample index *\/$/;"	m	struct:mmapibuf	file:
curBeamWidth	HTKLVRec/HLVRec.h	/^   TokScore curBeamWidth;       \/* current dynamic beamWidth (due to max model pruning) *\/$/;"	m	struct:_DecoderInst
curChain	HTKTools/HParse.c	/^static Link curChain;       \/* current network being built *\/$/;"	v	file:
curChan	HTKLib/HParm.c	/^static ChannelInfo *curChan=NULL;$/;"	v	file:
curElem	HTKLib/HMem.h	/^   size_t curElem;      \/*  current #elems per blk   curr #bytes per blk  *\/$/;"	m	struct:__anon116
curId	HTKTools/HParse.c	/^LabId curId;         \/* name of current variable def, if any *\/$/;"	v
curMeanVec	HTKLib/HParm.c	/^   Vector curMeanVec;     \/* Current mean *\/$/;"	m	struct:meanrec	file:
curNumCl	HTKLib/HTrain.c	/^static int curNumCl;    \/* num clust currently created *\/$/;"	v	file:
curPK	HTKLib/HParm.c	/^   ParmKind curPK;    \/* Used to track conversion from srcPK to tgtPK *\/$/;"	m	struct:__anon141	file:
curVol	HTKLib/HAudio.c	/^   float curVol;             \/* Current volume of input speech *\/$/;"	m	struct:_AudioIn	file:
curVol	HTKLib/HParm.c	/^   float curVol;      \/* current volume dB (0.0-100.0) *\/$/;"	m	struct:__anon141	file:
curVol	HTKLib/HParm.h	/^   float curVol;              \/* Volume level of last frame (0.0-100.0dB) *\/$/;"	m	struct:__anon149
curXForm	HTKLib/HModel.h	/^   AdaptXForm *curXForm;$/;"	m	struct:_HMMSet
cur_	HTKLVRec/kenlm/util/stream/sort.hh	/^    Entry cur_;$/;"	m	class:util::stream::Offsets
curch	HTKLib/HLabel.c	/^static int curch = ' ';$/;"	v	file:
curenidx	HTKTools/HCopy.c	/^static int curenidx=0;          \/* label end index (if set) *\/$/;"	v	file:
curlen	HTKTools/HParse.c	/^static int curlen;                  \/* Current length of input line *\/$/;"	v	file:
curpos	HTKTools/HParse.c	/^static int curpos;                  \/* Current position in input line *\/$/;"	v	file:
curr_MLV	HLMTools/Cluster.c	/^static double      curr_MLV=0;              \/* ...and its current value *\/$/;"	v	file:
curr_bistore_size	HLMTools/Cluster.c	/^static int          curr_bistore_size;      \/* Current size of bigram buffer store *\/$/;"	v	file:
curr_class	HLMTools/Cluster.c	/^static int         curr_class;              \/* Temporary value, saves passing *\/$/;"	v	file:
current	HTKLib/HAudio.c	/^   int current;             \/* Index of current buffer *\/$/;"	m	struct:_AudioIn	file:
current	HTKLib/HAudio.c	/^   int current;             \/* Index of current buffer *\/$/;"	m	struct:_AudioOut	file:
currentCount_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    uint64_t currentCount_;$/;"	m	class:lm::builder::__anon45::PruneNGramStream	file:
current_	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    NGram current_;$/;"	m	class:lm::builder::__anon42::CollapseStream	file:
current_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    NGram current_; \/\/ input iterator$/;"	m	class:lm::builder::__anon45::PruneNGramStream	file:
current_	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    const Sentence *current_;$/;"	m	class:lm::phrase::detail::Arc	file:
current_	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    unsigned int current_;$/;"	m	class:lm::phrase::detail::Vertex	file:
current_	HTKLVRec/kenlm/lm/search_trie.cc	/^    uint8_t *current_, *allocated_;$/;"	m	class:lm::ngram::trie::__anon58::BackoffMessages	file:
current_	HTKLVRec/kenlm/util/ersatz_progress.hh	/^    uint64_t current_, next_, complete_;$/;"	m	class:util::ErsatzProgress
current_	HTKLVRec/kenlm/util/pool.hh	/^    uint8_t *current_, *current_end_;$/;"	m	class:util::Pool
current_	HTKLVRec/kenlm/util/stream/chain.hh	/^    Block current_;$/;"	m	class:util::stream::Link
current_	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    uint64_t current_, next_;$/;"	m	class:util::stream::WorkerProgress
current_	HTKLVRec/kenlm/util/stream/sort.hh	/^        uint8_t *current_, *buffer_end_;$/;"	m	class:util::stream::MergeQueue::Entry
current_	HTKLVRec/kenlm/util/stream/stream.hh	/^    uint8_t *current_, *end_;$/;"	m	class:util::stream::Stream
current_	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    StringPiece current_;$/;"	m	class:util::TokenIter
current_begin_	HTKLVRec/kenlm/util/mmap.hh	/^    uint64_t current_begin_;$/;"	m	class:util::Rolling
current_end_	HTKLVRec/kenlm/util/mmap.hh	/^    uint64_t current_end_;$/;"	m	class:util::Rolling
current_end_	HTKLVRec/kenlm/util/pool.hh	/^    uint8_t *current_, *current_end_;$/;"	m	class:util::Pool
curstidx	HTKTools/HCopy.c	/^static int curstidx=0;          \/* label start index (if set) *\/$/;"	v	file:
cutOff	HLMLib/LModel.h	/^   int cutOff;              \/* cut-off *\/$/;"	m	struct:__anon12
cutOff	HLMLib/LPCalc.h	/^   int          cutOff[LM_NSIZE+1];   \/* n-gram cut-off array *\/$/;"	m	struct:__anon16
cutOff	HLMTools/HLMCopy.c	/^static int       cutOff[LM_NSIZE+1];     \/* new cutoffs *\/$/;"	v	file:
cutOff	HLMTools/LNorm.c	/^static int       cutOff[LM_NSIZE+1];     \/* new cutoff's *\/$/;"	v	file:
cutOff	HLMTools/LPlex.c	/^static int cutOff[LM_NSIZE+1];      \/* new cutoffs for COUNT-models *\/$/;"	v	file:
cvp	HTKLib/HTrain.c	/^static Sequence cvp;    \/* current vector pool being clustered *\/$/;"	v	file:
cxs	HTKLib/HNet.h	/^   LabId *cxs;     \/* Sorted array of labids indexed by context *\/$/;"	m	struct:hmmsetcxtinfo
d32_	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  const uint32_t d32_;$/;"	m	class:double_conversion::Single
d64_	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  const uint64_t d64_;$/;"	m	class:double_conversion::Double
dList	HLMTools/HLMCopy.c	/^static dictList  *dList = NULL;          \/* list of dictionaries *\/$/;"	v	file:
dSeq	HTKTools/HQuant.c	/^Sequence dSeq[SMAX];               \/* main data pools; one per stream *\/$/;"	v
dShort	HTKLib/HParm.c	/^   Boolean dShort;     \/* data is array of shorts not floats (DISCRETE) *\/$/;"	m	struct:_ParmBuf	file:
dStack	HTKTools/HQuant.c	/^static MemHeap dStack;             \/* sequence stack *\/$/;"	v	file:
datFN	HTKTools/HVite.c	/^static char *datFN;               \/* Speech file *\/$/;"	v	file:
data	HTKLVRec/HLVLM.h	/^   } data;$/;"	m	struct:_FSLM	typeref:union:_FSLM::__anon36
data	HTKLVRec/HLVNet.c	/^   } data;$/;"	m	struct:_STLexNode	typeref:union:_STLexNode::__anon37	file:
data	HTKLVRec/HLVNet.h	/^   } data;$/;"	m	struct:_LexNode	typeref:union:_LexNode::__anon38
data	HTKLVRec/kenlm/util/string_piece.hh	/^  const char* data() const { return ptr_; }$/;"	f	class:StringPiece
data	HTKLib/HAudio.c	/^   short *data;          \/* actual data buffer *\/$/;"	m	struct:__anon92	file:
data	HTKLib/HLM.h	/^   data;$/;"	m	struct:lmodel	typeref:union:lmodel::__anon106
data	HTKLib/HLat.c	/^   } data;$/;"	m	struct:_SubLNode	typeref:union:_SubLNode::__anon111	file:
data	HTKLib/HMem.h	/^   Ptr   data;          \/*        actual data for this block              *\/$/;"	m	struct:_Block
data	HTKLib/HParm.c	/^   void *data;       \/* parameterised data for this block *\/$/;"	m	struct:pblock	file:
data	HTKLib/HWave.c	/^   short *data;         \/* Actual data (always short once loaded) *\/$/;"	m	struct:_Wave	file:
data	HTKLib/esignal.h	/^    void        *data;          \/* GLOBAL data area *\/$/;"	m	struct:FieldSpec
data	HTKLib/esignal.h	/^    void        *data;          \/* storage area for data *\/$/;"	m	struct:Array
data	HTKTools/HSLab.c	/^static short *data;          \/* the data samples *\/$/;"	v	file:
dataForm	HTKLVRec/HDecode.c	/^static FileFormat dataForm = UNDEFF; \/* data input file format *\/$/;"	v	file:
dataForm	HTKLVRec/HDecode.mod.c	/^static FileFormat dataForm = UNDEFF; \/* data input file format *\/$/;"	v	file:
dataFormat	HTKLib/HWave.c	/^   int32 dataFormat;     \/* format code *\/$/;"	m	struct:__anon176	file:
dataLocation	HTKLib/HWave.c	/^   int32 dataLocation;   \/* offset to start of data *\/$/;"	m	struct:__anon176	file:
dataSize	HTKLib/HWave.c	/^   int32 dataSize;       \/* number of bytes of data *\/$/;"	m	struct:__anon176	file:
dataStack	HTKLib/HFB.h	/^  MemHeap dataStack;  \/* utterance data information heap *\/$/;"	m	struct:__anon96
dataStack2	HTKLib/HFB.h	/^  MemHeap dataStack2; \/* utterance data2 information heap *\/$/;"	m	struct:__anon96
data_	HTKLVRec/kenlm/lm/trie_sort.hh	/^    util::scoped_malloc data_;$/;"	m	class:lm::ngram::trie::RecordReader
data_	HTKLVRec/kenlm/util/file_piece.hh	/^    scoped_memory data_;$/;"	m	class:util::FilePiece
data_	HTKLVRec/kenlm/util/mmap.hh	/^    void *data_;$/;"	m	class:util::scoped_memory
data_	HTKLVRec/kenlm/util/mmap.hh	/^    void *data_;$/;"	m	class:util::scoped_mmap
data_	HTKLVRec/kenlm/util/stream/sort.hh	/^    int data_;$/;"	m	class:util::stream::OwningMergingReader
data_	HTKLVRec/kenlm/util/stream/sort.hh	/^    scoped_fd data_;$/;"	m	class:util::stream::Sort
datadir	HLMLib/Makefile	/^datadir = ${prefix}\/share$/;"	m
datadir	HLMTools/Makefile	/^datadir = ${prefix}\/share$/;"	m
datadir	HTKLVRec/Makefile	/^datadir = ${prefix}\/share$/;"	m
datadir	HTKLib/Makefile	/^datadir = ${prefix}\/share$/;"	m
datadir	HTKTools/Makefile	/^datadir = ${prefix}\/share$/;"	m
datadir	Makefile	/^datadir = ${prefix}\/share$/;"	m
dbsDir	HLMTools/LAdapt.c	/^static char *dbsDir  = NULL;        \/* directory to store gbase files *\/$/;"	v	file:
dbsDir	HLMTools/LGCopy.c	/^static char *dbsDir  = NULL;        \/* directory to store gbase files *\/$/;"	v	file:
dbsDir	HLMTools/LGPrep.c	/^static char *dbsDir  = NULL;        \/* directory to store gbase files *\/$/;"	v	file:
dcInfo	HLMLib/LModel.h	/^   DiscountInfo dcInfo;     \/* discounting coefficients, etc *\/$/;"	m	struct:__anon12
dcType	HLMLib/LModel.h	/^   DiscountType dcType;     \/* discounting type *\/$/;"	m	struct:__anon12
dcTypeName	HLMLib/LModel.c	/^static char *dcTypeName[] = {$/;"	v	file:
dck	HTKLib/HTrain.c	/^static CovKind dck;     \/* defines type of distance calc *\/$/;"	v	file:
dcov	HTKLib/HTrain.c	/^static Covariance dcov; \/* covariance to use in distance calc *\/$/;"	v	file:
dctype	HLMLib/LPCalc.h	/^   DiscountType dctype;               \/* discount type *\/$/;"	m	struct:__anon16
debug	HTKLib/HArc.c	/^static int debug=0;$/;"	v	file:
debug_bestcorr	HTKLib/HExactMPE.c	/^static int debug_bestcorr = 1000;$/;"	v	file:
debug_level	HTKLib/HMem.c	/^int debug_level = 0;               \/* For esps linking *\/$/;"	v
debug_stderr	HTKLVRec/HDecode.mod.c	/^FILE *debug_stderr = stderr;$/;"	v
debug_stdout	HTKLVRec/HDecode.mod.c	/^FILE *debug_stdout = stdout;$/;"	v
decimal_exponent	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^  int16_t decimal_exponent;$/;"	m	struct:double_conversion::CachedPower	file:
decimal_in_shortest_high_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const int decimal_in_shortest_high_;$/;"	m	class:double_conversion::DoubleToStringConverter
decimal_in_shortest_low_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const int decimal_in_shortest_low_;$/;"	m	class:double_conversion::DoubleToStringConverter
dedupe_	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    Dedupe dedupe_;$/;"	m	class:lm::builder::__anon43::Writer	file:
dedupe_invalid_	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    std::vector<WordIndex> dedupe_invalid_;$/;"	m	class:lm::builder::__anon43::Writer	file:
dedupe_mem_	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^    util::scoped_malloc dedupe_mem_;$/;"	m	class:lm::builder::CorpusCount
dedupe_mem_size_	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^    std::size_t dedupe_mem_size_;$/;"	m	class:lm::builder::CorpusCount
def	HTKLib/HLabel.h	/^   MLFDef def;          \/* the actual def *\/$/;"	m	struct:_MLFEntry
defChan	HTKLib/HParm.c	/^static ChannelInfo *defChan=NULL;$/;"	v	file:
defConf	HTKLib/HParm.c	/^static const IOConfigRec defConf = {$/;"	v	file:
defIntID	HLMLib/LModel.c	/^static Boolean defIntID = FALSE;        \/* Don't use 4-byte IDs *\/$/;"	v	file:
defList	HTKTools/HDMan.c	/^static LabId defList[MAXPVOC];       \/* list of predefined phones *\/$/;"	v	file:
defMapName	HLMTools/LAdapt.c	/^static char *defMapName = "LAdapt";   \/* map name *\/$/;"	v	file:
defMeanVec	HTKLib/HParm.c	/^   Vector defMeanVec;     \/* Default mean vector for reset *\/$/;"	m	struct:meanrec	file:
defargs	HTKLib/HShell.c	/^static char *defargs[2]={ "<Uninitialised>", "" };$/;"	v	file:
default_map_size_	HTKLVRec/kenlm/util/file_piece.hh	/^    std::size_t default_map_size_;$/;"	m	class:util::FilePiece
defs	HTKTools/HParse.c	/^static SubNetDef *defs;$/;"	v	file:
del	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Cell	file:
del	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Spkr	file:
del	HTKTools/HResults.c	/^static long del   = 0;     \/* Total deletions *\/$/;"	v	file:
delPen	HTKTools/HResults.c	/^static const int delPen = 7;$/;"	v	file:
delPenNIST	HTKTools/HResults.c	/^static const int delPenNIST = 3;$/;"	v	file:
delWin	HTKLib/HParm.c	/^   int delWin;                \/* Delta window halfsize *\/$/;"	m	struct:__anon141	file:
delegate_	HTKLVRec/kenlm/util/sized_iterator.hh	/^    const Delegate delegate_;$/;"	m	class:util::SizedCompare
delim_	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    char delim_;$/;"	m	class:util::SingleCharacter
delimiter_	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    StringPiece delimiter_;$/;"	m	class:util::MultiCharacter
delimiter_	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    const bool *delimiter_;$/;"	m	class:util::BoolCharacter
delta	HTKLVRec/HLVRec.h	/^   RelTokScore  delta;          \/* delta score relative to main token, $/;"	m	struct:_RelToken
denLatDir	HTKTools/HMMIRest.c	/^static char *denLatDir [MAXLATS];  \/*MMI lattices.*\/$/;"	v	file:
denLatSubDirPat	HTKTools/HMMIRest.c	/^static char denLatSubDirPat[MAXSTRLEN] = "\\0";  \/* path mask of denominator lattices *\/$/;"	v	file:
den_index	HTKLib/HFBLat.h	/^  float den_index; \/*only for MPE. *\/ \/*make sure set. *\/$/;"	m	struct:__anon102
denominator	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^  float denominator;$/;"	m	struct:lm::builder::__anon45::BufferEntry	file:
dereference	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    const StringPiece &dereference() const {$/;"	f	class:util::TokenIter
description	HLMLib/LUtil.h	/^  char *description;           \/* hash table description *\/$/;"	m	struct:__anon20
dest	HTKLVRec/HLVLM.h	/^   FSLM_LatNode *dest;$/;"	m	struct:_FSLM_LatArc
dest_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    NGram dest_;    \/\/ output iterator$/;"	m	class:lm::builder::__anon45::PruneNGramStream	file:
det	HTKLib/HAdapt.c	/^   float det;$/;"	m	struct:_ObsCache	file:
det	HTKLib/HModel.h	/^  float det;           \/* determinant of linxform *\/$/;"	m	struct:__anon132
detail	HTKLVRec/kenlm/lm/filter/phrase.cc	/^namespace detail { $/;"	n	namespace:lm::phrase	file:
detail	HTKLVRec/kenlm/lm/filter/phrase.cc	/^namespace detail {$/;"	n	namespace:lm::phrase	file:
detail	HTKLVRec/kenlm/lm/filter/phrase.hh	/^namespace detail {$/;"	n	namespace:lm::phrase
detail	HTKLVRec/kenlm/lm/model.cc	/^namespace detail {$/;"	n	namespace:lm::ngram	file:
detail	HTKLVRec/kenlm/lm/model.hh	/^namespace detail {$/;"	n	namespace:lm::ngram
detail	HTKLVRec/kenlm/lm/search_hashed.cc	/^namespace detail {$/;"	n	namespace:lm::ngram	file:
detail	HTKLVRec/kenlm/lm/search_hashed.hh	/^namespace detail {$/;"	n	namespace:lm::ngram
detail	HTKLVRec/kenlm/lm/vocab.cc	/^namespace detail {$/;"	n	namespace:lm::ngram	file:
detail	HTKLVRec/kenlm/lm/vocab.hh	/^namespace detail {$/;"	n	namespace:lm::ngram
detail	HTKLVRec/kenlm/util/joint_sort.hh	/^namespace detail {$/;"	n	namespace:util
detail	HTKLVRec/kenlm/util/multi_intersection.hh	/^namespace detail {$/;"	n	namespace:util
dff	HTKTools/HCompV.c	/^static FileFormat dff=UNDEFF;       \/* data file format *\/$/;"	v	file:
dff	HTKTools/HERest.c	/^static FileFormat dff=UNDEFF;       \/* data file format *\/$/;"	v	file:
dff	HTKTools/HInit.c	/^static FileFormat dff=UNDEFF;       \/* data file format *\/$/;"	v	file:
dff	HTKTools/HMMIRest.c	/^static FileFormat dff=UNDEFF;       \/* data file format *\/$/;"	v	file:
dff	HTKTools/HQuant.c	/^static FileFormat dff=UNDEFF;       \/* data file format *\/$/;"	v	file:
dff	HTKTools/HRest.c	/^static FileFormat dff=UNDEFF;    \/* data file format *\/$/;"	v	file:
dfmt	HTKTools/HVite.c	/^static FileFormat dfmt=UNDEFF;    \/* Data input file format *\/$/;"	v	file:
diagCovXForm	HTKLib/HAdapt.c	/^static AdaptXForm* diagCovXForm = NULL;$/;"	v	file:
dictFN	HTKTools/HMMIRest.c	/^static char *dictFN=0;             \/* not needed at the moment. *\/$/;"	v	file:
dictFn	HTKTools/HLEd.c	/^static char *dictFn = NULL;         \/* Dictionary used for EX command *\/$/;"	v	file:
dictFn	HTKTools/HVite.c	/^static char *dictFn;              \/* Dictionary *\/$/;"	v	file:
dictList	HLMTools/HLMCopy.c	/^dictList;$/;"	t	typeref:struct:dictlist	file:
dictfn	HTKLVRec/HDecode.c	/^static char *dictfn;		\/* dict filename from commandline *\/$/;"	v	file:
dictfn	HTKLVRec/HDecode.mod.c	/^static char *dictfn;		\/* dict filename from commandline *\/$/;"	v	file:
dictfn	HTKTools/HLRescore.c	/^static char *dictfn;		\/* dict filename from commandline *\/$/;"	v	file:
dictlist	HLMTools/HLMCopy.c	/^typedef struct dictlist {$/;"	s	file:
difference_type	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    typedef std::ptrdiff_t difference_type;$/;"	t	class:util::ProxyIterator
difference_type	HTKLVRec/kenlm/util/string_piece.hh	/^  typedef ptrdiff_t difference_type;$/;"	t	class:StringPiece
dim	HTKLib/HAdapt.c	/^   int dim;$/;"	m	struct:__anon85	file:
dim	HTKLib/esignal.h	/^    long        *dim;           \/* vector of dimensions *\/$/;"	m	struct:Array
dim	HTKLib/esignal.h	/^    long        *dim;           \/* vector of dimensions *\/$/;"	m	struct:FieldSpec
dir	HTKTools/HResults.c	/^   Direction dir;$/;"	m	struct:_Cell	file:
dirName	HTKLib/HModel.c	/^  char *dirName;           \/* input XForm directory name *\/$/;"	m	struct:_XFDirInfo	file:
disCount	HTKTools/HLStats.c	/^static float disCount = 0.5;        \/* discount for backoff *\/$/;"	v	file:
disallowed_symbol_action	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  WarningAction disallowed_symbol_action;$/;"	m	struct:lm::builder::PipelineConfig
disallowed_symbol_action_	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^    WarningAction disallowed_symbol_action_;$/;"	m	class:lm::builder::CorpusCount
discount	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  DiscountConfig discount;$/;"	m	struct:lm::builder::PipelineConfig
discount_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    Discount discount_;$/;"	m	class:lm::builder::__anon45::MergeRight	file:
discount_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    const Discount &discount_;$/;"	m	class:lm::builder::__anon45::AddRight	file:
discount_config_	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^    DiscountConfig discount_config_;$/;"	m	class:lm::builder::AdjustCounts
discounts_	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    std::vector<Discount> &discounts_;$/;"	m	class:lm::builder::__anon42::StatCollector	file:
discounts_	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^    std::vector<Discount> &discounts_;$/;"	m	class:lm::builder::AdjustCounts
discreteLZero	HTKLib/HModel.c	/^static Boolean discreteLZero=FALSE;     \/* map DLOGZERO to LZERO *\/$/;"	v	file:
dispDEEP	HTKLib/HGraf.c	/^static unsigned int  ncells, dispWIDE, dispHIGH, dispDEEP;$/;"	v	file:
dispDEEP	HTKLib/HGraf_WIN32.c	/^static int   dispDEEP,dispWIDE,dispHIGH;$/;"	v	file:
dispHIGH	HTKLib/HGraf.c	/^static unsigned int  ncells, dispWIDE, dispHIGH, dispDEEP;$/;"	v	file:
dispHIGH	HTKLib/HGraf_WIN32.c	/^static int   dispDEEP,dispWIDE,dispHIGH;$/;"	v	file:
dispWIDE	HTKLib/HGraf.c	/^static unsigned int  ncells, dispWIDE, dispHIGH, dispDEEP;$/;"	v	file:
dispWIDE	HTKLib/HGraf_WIN32.c	/^static int   dispDEEP,dispWIDE,dispHIGH;$/;"	v	file:
display_	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    char display_[kWidth + 1];$/;"	m	class:util::stream::MultiProgress
dkind	HTKLib/HModel.h	/^   DurKind dkind;          \/* kind of duration model (model or state) *\/$/;"	m	struct:_HMMSet
doBOff	HTKTools/HLStats.c	/^static Boolean doBOff   = FALSE;$/;"	v	file:
doBigram	HTKTools/HLStats.c	/^static Boolean doBigram = FALSE;    \/* do what? *\/$/;"	v	file:
doDurs	HTKTools/HLStats.c	/^static Boolean doDurs   = FALSE;$/;"	v	file:
doLCount	HTKTools/HLStats.c	/^static Boolean doLCount = FALSE;$/;"	v	file:
doList	HTKTools/HLStats.c	/^static Boolean doList   = FALSE;$/;"	v	file:
doPCount	HTKTools/HLStats.c	/^static Boolean doPCount = FALSE; $/;"	v	file:
do_one_iteration	HLMTools/Cluster.c	/^static void do_one_iteration(int w_period, int start_word)$/;"	f	file:
do_recovery	HLMTools/Cluster.c	/^void do_recovery(char *fname, int words)$/;"	f
doing_	HTKLVRec/kenlm/lm/search_trie.cc	/^    Doing &doing_;$/;"	m	class:lm::ngram::trie::__anon58::BlankManager	file:
done_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    util::PCQueue<Request> &done_;$/;"	m	class:lm::FilterWorker
done_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    util::PCQueue<Request> &done_;$/;"	m	class:lm::OutputWorker
doubleFFT	HTKLib/HParm.c	/^   Boolean doubleFFT;         \/* use twice the required FFT size *\/$/;"	m	struct:__anon141	file:
double_conversion	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	HTKLVRec/kenlm/util/double-conversion/bignum-dtoa.h	/^namespace double_conversion {$/;"	n
double_conversion	HTKLVRec/kenlm/util/double-conversion/bignum.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^namespace double_conversion {$/;"	n
double_conversion	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	HTKLVRec/kenlm/util/double-conversion/cached-powers.h	/^namespace double_conversion {$/;"	n
double_conversion	HTKLVRec/kenlm/util/double-conversion/diy-fp.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^namespace double_conversion {$/;"	n
double_conversion	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^namespace double_conversion {$/;"	n
double_conversion	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.h	/^namespace double_conversion {$/;"	n
double_conversion	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.h	/^namespace double_conversion {$/;"	n
double_conversion	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^namespace double_conversion {$/;"	n
double_conversion	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^namespace double_conversion {$/;"	n	file:
double_conversion	HTKLVRec/kenlm/util/double-conversion/strtod.h	/^namespace double_conversion {$/;"	n
double_conversion	HTKLVRec/kenlm/util/double-conversion/utils.h	/^namespace double_conversion {$/;"	n
double_to_uint64	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^static uint64_t double_to_uint64(double d) { return BitCast<uint64_t>(d); }$/;"	f	namespace:double_conversion
dpdf	HTKLib/HModel.h	/^   ShortVec dpdf;        \/* DISCRETE *\/$/;"	m	union:__anon122
dumpOfs	HLMTools/LGCopy.c	/^static int dumpOfs   = 0;           \/* initial numeric ext of gbase files *\/$/;"	v	file:
dumpOfs	HLMTools/LGPrep.c	/^static int  dumpOfs  = 0;           \/* initial numeric ext of gbase files *\/$/;"	v	file:
dur	HTKLib/HModel.h	/^   SVector dur;            \/* vector of model duration params, if any *\/   $/;"	m	struct:__anon128
dur	HTKLib/HModel.h	/^   SVector dur;         \/* vector of state duration params, if any *\/   $/;"	m	struct:__anon126
dur	HTKLib/HNet.h	/^   float dur;         \/* Duration of segment in seconds *\/$/;"	m	struct:lalign
dwLength	HTKLVRec/kenlm/util/usage.cc	/^  DWORD dwLength;$/;"	m	struct:__anon82	file:
dwMemoryLoad	HTKLVRec/kenlm/util/usage.cc	/^  DWORD dwMemoryLoad;$/;"	m	struct:__anon82	file:
dynBeamInc	HTKLVRec/HLVRec.c	/^static float dynBeamInc = 1.3;          \/* dynamic beam increment for max model pruning *\/$/;"	v	file:
e	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  int e() const { return e_; }$/;"	f	class:double_conversion::DiyFp
eNormalise	HTKLib/HParm.c	/^   Boolean eNormalise;        \/* Normalise log energy *\/$/;"	m	struct:__anon141	file:
eScale	HTKLib/HParm.c	/^   float eScale;              \/* Energy scale factor *\/$/;"	m	struct:__anon141	file:
eSep	HTKLib/HFBLat.c	/^static  Boolean eSep;$/;"	v	file:
eSep	HTKLib/HParm.h	/^   Boolean eSep;         \/* Energy is in separate stream *\/$/;"	m	struct:__anon147
e_	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  int e_;$/;"	m	class:double_conversion::DiyFp
editBuf	HLMTools/LGPrep.c	/^static LabId editBuf[MAX_FIELDS];   \/* edit buffer for input text *\/$/;"	v	file:
editUsed	HLMTools/LGPrep.c	/^static int editUsed;                \/* number of words in editPipe *\/$/;"	v	file:
editWinSize	HLMTools/LGPrep.c	/^static int editWinSize = 0;         \/* size of edit window *\/$/;"	v	file:
egbSize	HLMTools/LGPrep.c	/^static int egbSize   =  100000;     \/* edited ngram buffer size *\/$/;"	v	file:
elemSize	HTKLib/HMem.h	/^   size_t elemSize;     \/*  size of each elem              1 always       *\/$/;"	m	struct:__anon116
empty	HTKLVRec/kenlm/util/fixed_array.hh	/^    bool empty() const { return begin() == end(); }$/;"	f	class:util::FixedArray
empty	HTKLVRec/kenlm/util/string_piece.hh	/^  bool empty() const { return length_ == 0; }$/;"	f	class:StringPiece
empty_	HTKLVRec/kenlm/util/pcqueue.hh	/^  Semaphore empty_;$/;"	m	class:util::PCQueue
empty_string_value_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const double empty_string_value_;$/;"	m	class:double_conversion::StringToDoubleConverter
en	HTKTools/HCopy.c	/^static HTime en=0.0;            \/* end of samples to copy *\/$/;"	v	file:
en	HTKTools/HSLab.c	/^   long st, en;            \/* start and end sample of the previous zoom level *\/$/;"	m	struct:__anon209	file:
enableBlockAdapt	HTKLib/HAdapt.c	/^static IntVec enableBlockAdapt = NULL;$/;"	v	file:
encrypt	HLMLib/LModel.h	/^   Boolean encrypt;          \/* flag for encryption *\/$/;"	m	struct:__anon15
end	HTKLVRec/HDecode.c	/^   int end;$/;"	m	struct:_BestInfo	file:
end	HTKLVRec/HDecode.mod.c	/^   int end;$/;"	m	struct:_BestInfo	file:
end	HTKLVRec/HLVNet.h	/^   LexNode *end;                \/* single end node *\/$/;"	m	struct:_LexNet
end	HTKLVRec/HLVNet.h	/^   LexNode *end;$/;"	m	struct:_LexLink
end	HTKLVRec/HLVNet.h	/^   TLexNode *end;       \/* end node of network *\/$/;"	m	struct:_TLexNet
end	HTKLVRec/HLVNet.h	/^   TLexNode *end;$/;"	m	struct:_TLexLink
end	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    WordIndex *end() { return end_; }$/;"	f	class:lm::builder::NGram
end	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    const WordIndex *end() const { return end_; }$/;"	f	class:lm::builder::NGram
end	HTKLVRec/kenlm/lm/search_trie.cc	/^  const WordIndex *begin, *end;$/;"	m	struct:lm::ngram::trie::__anon58::Gram	file:
end	HTKLVRec/kenlm/lm/trie.hh	/^  uint64_t begin, end;$/;"	m	struct:lm::ngram::trie::NodeRange
end	HTKLVRec/kenlm/util/fixed_array.hh	/^    T *end() { return newed_end_; }$/;"	f	class:util::FixedArray
end	HTKLVRec/kenlm/util/fixed_array.hh	/^    const T *end() const { return newed_end_; }$/;"	f	class:util::FixedArray
end	HTKLVRec/kenlm/util/mmap.hh	/^    const char *end() const { return reinterpret_cast<char*>(data_) + size_; }$/;"	f	class:util::scoped_memory
end	HTKLVRec/kenlm/util/mmap.hh	/^    const uint8_t *end() const { return reinterpret_cast<uint8_t*>(data_) + size_; }$/;"	f	class:util::scoped_mmap
end	HTKLVRec/kenlm/util/string_piece.hh	/^  iterator end() const { return ptr_ + length_; }$/;"	f	class:StringPiece
end	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    static TokenIter<Find, SkipEmpty> end() {$/;"	f	class:util::TokenIter
end	HTKLib/HArc.h	/^  CorrN *end;$/;"	m	struct:_CorrA
end	HTKLib/HArc.h	/^  HArc *end;$/;"	m	struct:ArcInfoStruct
end	HTKLib/HArc.h	/^  HArc *end;$/;"	m	struct:_ArcTrans
end	HTKLib/HFBLat.c	/^   int end;$/;"	m	struct:__anon100	file:
end	HTKLib/HLabel.h	/^   HTime start,end;         \/* Start and end times in 100ns units *\/$/;"	m	struct:_Label
end	HTKLib/HLat.c	/^   SubLNode *end;$/;"	m	struct:_SubLArc	file:
end	HTKLib/HNet.h	/^   NodeId end;         \/* Node at end of word *\/$/;"	m	struct:larc
end	HTKLib/HNet.h	/^   NodeId end;         \/* Node at end of word *\/$/;"	m	struct:larc_e
end	HTKLib/HNet.h	/^   NodeId end;$/;"	m	struct:larc_s
endId	HTKLVRec/HLVNet.h	/^   LabId endId;         \/* id of ENDWORD (from config) *\/$/;"	m	struct:_TLexNet
endLMWord	HTKLib/HLat.c	/^static LabId endLMWord;         \/* word at end in LM (<\/s>) *\/$/;"	v	file:
endLMWord	HTKTools/HLRescore.c	/^static char *endLMWord;         \/* word at end in LM (<\/s>) *\/$/;"	v	file:
endLab	HTKLVRec/HDecode.c	/^static LabId endLab;            \/*   corresponding LabId *\/$/;"	v	file:
endLab	HTKLVRec/HDecode.mod.c	/^static LabId endLab;            \/*   corresponding LabId *\/$/;"	v	file:
endLab	HTKTools/HLRescore.c	/^static LabId endLab;            \/* corresponding LabId *\/$/;"	v	file:
endPron	HTKLVRec/HLVNet.h	/^   PronId endPron;              \/* pron of <\/s> *\/$/;"	m	struct:_LexNet
endPronId	HTKLVRec/HLVLM.h	/^   PronId endPronId;$/;"	m	struct:_FSLM
endWord	HTKLVRec/HDecode.c	/^static char *endWord = "<\/s>";  \/* word used at end of network *\/$/;"	v	file:
endWord	HTKLVRec/HDecode.mod.c	/^static char *endWord = "<\/s>";  \/* word used at end of network *\/$/;"	v	file:
endWord	HTKLib/HLat.c	/^static LabId endWord;           \/* word at end of Lattice (!SENT_END) *\/$/;"	v	file:
endWord	HTKTools/HLRescore.c	/^static char *endWord;           \/* word at end of Lattice (!SENT_END) *\/$/;"	v	file:
end_	HTKLVRec/kenlm/lm/builder/ngram.hh	/^    WordIndex *begin_, *end_;$/;"	m	class:lm::builder::NGram
end_	HTKLVRec/kenlm/lm/quantize.hh	/^        const float *end_;$/;"	m	class:lm::ngram::SeparatelyQuantize::Bins
end_	HTKLVRec/kenlm/lm/vocab.hh	/^    uint64_t *begin_, *end_;$/;"	m	class:lm::ngram::SortedVocabulary
end_	HTKLVRec/kenlm/util/pcqueue.hh	/^  T *const end_;$/;"	m	class:util::PCQueue
end_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    MutableIterator end_;$/;"	m	class:util::ProbingHashTable
end_	HTKLVRec/kenlm/util/read_compressed.cc	/^    uint8_t *end_;$/;"	m	class:util::__anon79::UncompressedWithHeader	file:
end_	HTKLVRec/kenlm/util/stream/stream.hh	/^    uint8_t *current_, *end_;$/;"	m	class:util::stream::Stream
end_foll	HTKLib/HArc.h	/^  ArcTrans *end_foll;  \/*similarly for the end_{foll,prec}. *\/$/;"	m	struct:_ArcTrans
end_foll	HTKLib/HArc.h	/^  CorrA *end_foll;$/;"	m	struct:_CorrA
end_id	HLMTools/Cluster.c	/^static int         start_id=-1, end_id=-1;  \/* Start and end word ids *\/$/;"	v	file:
end_prec	HTKLib/HArc.h	/^  ArcTrans *end_prec; $/;"	m	struct:_ArcTrans
end_sentence_	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    WordIndex begin_sentence_, end_sentence_, not_found_;$/;"	m	class:lm::base::Vocabulary
endi	HTKLib/HArc.h	/^  int endi;$/;"	m	struct:_CorrN
ends	HTKLib/HNet.c	/^   NetNode *ends;   \/* Chain of final models *\/$/;"	m	struct:pronholder	file:
ends_with	HTKLVRec/kenlm/util/string_piece.hh	/^  bool ends_with(const StringPiece& x) const {$/;"	f	class:StringPiece
enindex	HTKLib/HShell.c	/^   long enindex;                        \/* end sample to extract *\/$/;"	m	struct:__anon150	file:
ent2	HTKTools/HLStats.c	627;"	d	file:
enterExitId	HTKTools/HParse.c	/^static LabId  enterExitId;   \/* for use in RemoveGlue *\/$/;"	v	file:
enterId	HTKTools/HBuild.c	/^static LabId enterId;               \/* id of !ENTRY label in ngram *\/$/;"	v	file:
enterId	HTKTools/HLStats.c	/^static LabId enterId;               \/* id of ENTRY label in ngram *\/$/;"	v	file:
enterId	HTKTools/HParse.c	/^static LabId enterId;                 \/* LabId of the ENTER node name *\/$/;"	v	file:
entries	HLMLib/LCMap.h	/^   int entries;    	     	\/* total classes (or unk entries) in map *\/$/;"	m	struct:__anon1
entries_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    std::size_t entries_;$/;"	m	class:util::ProbingHashTable
entry	HTKTools/HBuild.c	/^   WordFllr *entry;$/;"	m	struct:_GramEntry	file:
entryHeap	HTKTools/HBuild.c	/^   MemHeap entryHeap;$/;"	m	struct:__anon188	file:
entryNode	HTKTools/HParse.c	/^   Link entryNode;$/;"	m	struct:__anon204	file:
entry_size	HTKLVRec/kenlm/util/stream/config.hh	/^  std::size_t entry_size;$/;"	m	struct:util::stream::ChainConfig
entry_size_	HTKLVRec/kenlm/lm/search_trie.cc	/^    std::size_t entry_size_;$/;"	m	class:lm::ngram::trie::__anon58::BackoffMessages	file:
entry_size_	HTKLVRec/kenlm/lm/trie_sort.hh	/^    std::size_t entry_size_;$/;"	m	class:lm::ngram::trie::RecordReader
entry_size_	HTKLVRec/kenlm/util/stream/sort.hh	/^    const std::size_t entry_size_;$/;"	m	class:util::stream::MergeQueue
entry_size_	HTKLVRec/kenlm/util/stream/sort.hh	/^    const std::size_t entry_size_;$/;"	m	class:util::stream::Sort
entry_size_	HTKLVRec/kenlm/util/stream/stream.hh	/^    std::size_t entry_size_;$/;"	m	class:util::stream::Stream
enumerate_	HTKLVRec/kenlm/lm/vocab.hh	/^    EnumerateVocab *enumerate_;$/;"	m	class:lm::ngram::ProbingVocabulary
enumerate_	HTKLVRec/kenlm/lm/vocab.hh	/^    EnumerateVocab *enumerate_;$/;"	m	class:lm::ngram::SortedVocabulary
enumerate_vocab	HTKLVRec/kenlm/lm/config.hh	/^  EnumerateVocab *enumerate_vocab;$/;"	m	struct:lm::ngram::Config
epsilon	HTKTools/HInit.c	/^static float epsilon = 1.0E-4;      \/* convergence criterion *\/$/;"	v	file:
epsilon	HTKTools/HRest.c	/^static float epsilon = 1.0E-4;   \/* convergence criterion *\/$/;"	v	file:
epsilon	HTKTools/HSmooth.c	/^static float epsilon = 0.0001;   \/* binary chop convergence criterion *\/$/;"	v	file:
eqId	HLMTools/LPlex.c	/^static LabId  *eqId;                \/* label equivalence lookup table *\/$/;"	v	file:
eqList	HLMTools/LPlex.c	/^static Equiv *eqList = NULL;          \/* List of equivalent label ids *\/$/;"	v	file:
eql	HTKLib/HParm.c	/^   Vector eql;        \/* Equal loundness curve *\/$/;"	m	struct:__anon141	file:
eqlist	HTKTools/HResults.c	/^static Equiv *eqlist=NULL;            \/* List of equivalent label ids *\/$/;"	v	file:
equal	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    bool equal(const TokenIter<Find, SkipEmpty> &other) const {$/;"	f	class:util::TokenIter
equal_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    Equal equal_;$/;"	m	class:util::ProbingHashTable
equivId	HLMTools/LPlex.c	/^   LabId equivId;$/;"	m	struct:_Equiv	file:
equivId	HTKTools/HResults.c	/^   LabId equivId;$/;"	m	struct:_Equiv	file:
equivState	HTKTools/HHEd.c	/^static Boolean equivState = TRUE;      \/* TRUE if states can be equivalent *\/$/;"	v	file:
errno_	HTKLVRec/kenlm/util/exception.hh	/^    int errno_;$/;"	m	class:util::ErrnoException
event	HTKLib/HGraf.h	/^   HEvent event;     \/* type of event *\/$/;"	m	struct:__anon103
eventT	HTKLVRec/HLVNet.h	/^   int eventT;          \/* frame # of last (de)activation *\/$/;"	m	struct:_LexNode
evin	HTKLib/HAudio.c	/^   Environment *evin;$/;"	m	struct:_AudioIn	file:
evout	HTKLib/HAudio.c	/^   Environment *evout;$/;"	m	struct:_AudioOut	file:
exact_powers_of_ten	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static const double exact_powers_of_ten[] = {$/;"	m	namespace:double_conversion	file:
exec_prefix	HLMLib/Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	HLMTools/Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	HTKLVRec/Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	HTKLib/Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	HTKTools/Makefile	/^exec_prefix = ${prefix}$/;"	m
exec_prefix	Makefile	/^exec_prefix = ${prefix}$/;"	m
exit	HTKLib/HRec.c	/^   TokenSet *exit;      \/* TokenSet in exit state *\/$/;"	m	struct:_NetInst	file:
exitId	HTKTools/HBuild.c	/^static LabId exitId;                \/* id of !EXIT label in ngram *\/$/;"	v	file:
exitId	HTKTools/HLStats.c	/^static LabId exitId;                \/* id of EXIT label in ngram *\/$/;"	v	file:
exitId	HTKTools/HParse.c	/^static LabId exitId;                  \/* LabId of the EXIT node name *\/$/;"	v	file:
exitNode	HTKTools/HParse.c	/^   Link exitNode;$/;"	m	struct:__anon204	file:
expandLat	HTKTools/HLRescore.c	/^static Boolean expandLat = FALSE;   \/* -n *\/$/;"	v	file:
exponent_	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  int exponent_;$/;"	m	class:double_conversion::Bignum
exponent_character_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const char exponent_character_;$/;"	m	class:double_conversion::DoubleToStringConverter
export_classes	HLMTools/Cluster.c	/^void export_classes(int recovery)$/;"	f
export_index	HLMTools/Cluster.c	/^static int         export_index=0;          \/* What iteration is this? *\/$/;"	v	file:
export_prefix	HLMTools/Cluster.c	/^static char       *export_prefix="cluster"; \/* Prefix of export filenames *\/$/;"	v	file:
ext	HTKLib/HParm.c	/^   HParmSrcDef ext;     \/* external source functions *\/$/;"	m	struct:_ParmBuf	file:
extFileNext	HTKLib/HShell.c	/^static int extFileNext = 0;             \/* next slot to save into *\/$/;"	v	file:
extFileUsed	HTKLib/HShell.c	/^static int extFileUsed = 0;             \/* total ext files in buffer *\/$/;"	v	file:
extFiles	HTKLib/HShell.c	/^static ExtFile extFiles[MAXEFS];        \/* circ buf of ext file names *\/$/;"	v	file:
extName	HTKTools/HParse.c	/^   LabId extName;    \/* external name (used in compatability mode) *\/$/;"	m	struct:_Node	file:
extend_left	HTKLVRec/kenlm/lm/return.hh	/^  uint64_t extend_left; \/\/ Defined only if independent_left$/;"	m	struct:lm::FullScoreReturn
extendedFileNames	HTKLib/HShell.c	/^static Boolean extendedFileNames = TRUE; \/* allow extended file names *\/$/;"	v	file:
f	HTKLVRec/kenlm/util/bit_packing.hh	/^typedef union { float f; uint32_t i; } FloatEnc;$/;"	m	union:util::__anon65
f	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  uint64_t f() const { return f_; }$/;"	f	class:double_conversion::DiyFp
f	HTKLib/HShell.h	/^   FILE *f;             \/* input stream *\/$/;"	m	struct:__anon154
f	HTKLib/HShell.h	/^   double f;$/;"	m	union:__anon156
f	HTKTools/HParse.c	/^static FILE *f;                     \/* Input stream *\/$/;"	v	file:
fClose	HTKLib/HParm.c	/^   void (*fClose)(Ptr xInfo,Ptr bInfo);  \/* Close buffer and free resources *\/$/;"	m	struct:hparmsrcdef	file:
fCnt	HTKLib/HParm.c	/^   int fCnt;              \/* Number of files processed for this channel *\/$/;"	m	struct:channelinfo	file:
fGetData	HTKLib/HParm.c	/^   int (*fGetData)(Ptr xInfo,Ptr bInfo,int n,Ptr data);  \/* Read samples *\/$/;"	m	struct:hparmsrcdef	file:
fGetWaveData	HTKLib/HParm.c	/^static int fGetWaveData(int n,void *data,short *res,$/;"	f	file:
fHead	HTKLib/HAudio.c	/^   mmApiBuf *fHead;         \/* Head of filled buffer list *\/$/;"	m	struct:_AudioIn	file:
fName	HTKLib/HModel.h	/^   char *fName;            \/* MMF file name *\/$/;"	m	struct:_MMFInfo
fNumSamp	HTKLib/HParm.c	/^   int (*fNumSamp)(Ptr xInfo,Ptr bInfo);  \/* Query samples readable without blocking *\/$/;"	m	struct:hparmsrcdef	file:
fOpen	HTKLib/HParm.c	/^   Ptr (*fOpen)(Ptr xInfo,char *fn,BufferInfo *info);  \/* Open new buffer *\/$/;"	m	struct:hparmsrcdef	file:
fShort	HTKLib/HParm.c	/^   Boolean fShort;     \/* file is array of shorts (DISCRETE, COMPX or IREFC) *\/$/;"	m	struct:_ParmBuf	file:
fStart	HTKLib/HParm.c	/^   void (*fStart)(Ptr xInfo,Ptr bInfo);  \/* Start data capture for real-time sources *\/$/;"	m	struct:hparmsrcdef	file:
fStop	HTKLib/HParm.c	/^   void (*fStop)(Ptr xInfo,Ptr bInfo);  \/* Stop data capture for real-time sources *\/$/;"	m	struct:hparmsrcdef	file:
fTail	HTKLib/HAudio.c	/^   mmApiBuf *fTail;         \/* Tail of filled buffer list *\/$/;"	m	struct:_AudioIn	file:
f_	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  uint64_t f_;$/;"	m	class:double_conversion::DiyFp
f_FIELD	HLMTools/LGPrep.c	/^   f_FIELD,                   \/* slot contents *\/$/;"	e	enum:__anon27	file:
f_NONE	HLMTools/LGPrep.c	/^   f_NONE$/;"	e	enum:__anon27	file:
f_NWSET	HLMTools/LGPrep.c	/^   f_NWSET,                   \/* not in word set *\/$/;"	e	enum:__anon27	file:
f_WILD	HLMTools/LGPrep.c	/^   f_WILD,                    \/* wildcard *\/$/;"	e	enum:__anon27	file:
f_WORD	HLMTools/LGPrep.c	/^   f_WORD,                    \/* literal word *\/$/;"	e	enum:__anon27	file:
f_WSET	HLMTools/LGPrep.c	/^   f_WSET,                    \/* in word set *\/$/;"	e	enum:__anon27	file:
faTimeUnit	HTKTools/HResults.c	/^static float faTimeUnit = 1.0;        \/* unit for measuring false alarms *\/$/;"	v	file:
facc	HTKTools/HLEd.c	/^static FindAcc *facc = NULL;$/;"	v	file:
factorLM	HTKLib/HNet.c	/^Boolean factorLM=FALSE;$/;"	v
fallback	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^  Discount fallback;$/;"	m	struct:lm::builder::DiscountConfig
fallback_to_read_	HTKLVRec/kenlm/util/file_piece.hh	/^    bool fallback_to_read_;$/;"	m	class:util::FilePiece
farc	HTKLib/HNet.h	/^   ArcId farc;         \/* Next arc following start node *\/$/;"	m	struct:larc
farc	HTKLib/HNet.h	/^   ArcId farc;$/;"	m	struct:larc_s
farc	HTKLib/HNet.h	/^   EArcId farc;        \/* Next arc following start node *\/$/;"	m	struct:larc_e
fast_counter_	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^    size_t fast_counter_;$/;"	m	class:lm::ARPAOutput
fastlmla	HTKLVRec/HLVRec.h	/^   Boolean fastlmla;            \/* use fast LM lookahead, i.e. back-off to bigram states *\/$/;"	m	struct:_DecoderInst
fastlmlaBeam	HTKLVRec/HDecode.c	/^static LogFloat fastlmlaBeam = - LZERO;  \/* do fast LM la outside this beam *\/$/;"	v	file:
fastlmlaBeam	HTKLVRec/HDecode.mod.c	/^static LogFloat fastlmlaBeam = - LZERO;  \/* do fast LM la outside this beam *\/$/;"	v	file:
fastlmlaBeam	HTKLVRec/HLVRec.h	/^   LogFloat fastlmlaBeam;       \/* beam in which to use full lmla *\/$/;"	m	struct:_DecoderInst
fbInfo	HTKLib/HFBLat.c	/^static FBLatInfo *fbInfo; \/* current fbInfo, so don't have to pass it around. *\/$/;"	v	file:
fbInfo	HTKLib/HParm.c	/^   FBankInfo fbInfo;  \/* FBank info used for filterbank analysis *\/$/;"	m	struct:__anon141	file:
fbInfo	HTKTools/HMMIRest.c	/^static FBLatInfo  fbInfo;            \/* Structure for discriminative forward-backward. *\/$/;"	v	file:
fbInfo	HTKTools/HVite.c	/^static FBInfo *fbInfo;            \/* forward-backward info for alignment *\/$/;"	v	file:
fbInfoStack	HTKTools/HERest.c	/^static MemHeap fbInfoStack;$/;"	v	file:
fbank	HTKLib/HParm.c	/^   Vector fbank;      \/* filterbank vector *\/$/;"	m	struct:__anon141	file:
fc	HTKLib/HNet.c	/^   int fc;          \/* Final context - cache saves finding for all links *\/$/;"	m	struct:pronholder	file:
fci	HTKLib/HNet.c	/^   Boolean fci;     \/* Final phone context independent *\/$/;"	m	struct:pronholder	file:
fcmp	HTKLib/HParm.c	/^static int fcmp(const void *v1,const void *v2)$/;"	f	file:
fcra	HTKLib/HNet.h	/^   EArcId fcra;        \/* List linked in both directions *\/$/;"	m	struct:larc_e
fct	HTKLib/HNet.c	/^   LogFloat fct;    \/* LM likelihood to be factored into each phone *\/$/;"	m	struct:pronholder	file:
fd_	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    int fd_;$/;"	m	class:util::FakeOFStream
fd_	HTKLVRec/kenlm/util/file.hh	/^    int fd_;$/;"	m	class:util::FDException
fd_	HTKLVRec/kenlm/util/file.hh	/^    int fd_;$/;"	m	class:util::scoped_fd
fd_	HTKLVRec/kenlm/util/mmap.hh	/^    int fd_;$/;"	m	class:util::Rolling
fd_	HTKLVRec/kenlm/util/parallel_read.cc	/^    int fd_;$/;"	m	class:util::__anon78::Reader	file:
fd_	HTKLVRec/kenlm/util/read_compressed.cc	/^    scoped_fd fd_;$/;"	m	class:util::__anon79::Uncompressed	file:
fd_	HTKLVRec/kenlm/util/read_compressed.cc	/^    scoped_fd fd_;$/;"	m	class:util::__anon79::UncompressedWithHeader	file:
fd_	HTKLVRec/kenlm/util/stream/line_input.hh	/^    int fd_;$/;"	m	class:util::stream::LineInput
fdt	HLMTools/LGPrep.c	/^   FieldItem fdt[MAX_FIELDS]; \/* actual data in each field *\/$/;"	m	struct:__anon30	file:
fe_buff	HLMLib/LModel.h	/^   FLEntry *fe_buff;         \/* temp buffer *\/$/;"	m	struct:__anon15
fea	HLMLib/LModel.h	/^   struct _FLEntry *fea;    \/* sorted array [0..nfe-1] of FLEntry *\/$/;"	m	struct:_FLEntry	typeref:struct:_FLEntry::_FLEntry
fell_back_	HTKLVRec/kenlm/util/file_piece.hh	/^    ReadCompressed fell_back_;$/;"	m	class:util::FilePiece
ff	HTKTools/HLStats.c	/^static FileFormat ff=UNDEFF;        \/* Label file format *\/$/;"	v	file:
ff	HTKTools/HList.c	/^static FileFormat ff = UNDEFF;   \/* Source File format *\/$/;"	v	file:
fftN	HTKLib/HSigP.h	/^   int fftN;            \/* fft size *\/$/;"	m	struct:__anon159
fg	HTKLib/HGraf.h	/^   HColour fg, bg;            \/* colors *\/$/;"	m	struct:_HButton
fg	HTKTools/HSLab.c	/^   HColour fg, bg;$/;"	m	struct:__anon212	file:
fg	HTKTools/HSLab.c	/^   HColour fg;$/;"	m	struct:__anon213	file:
fidx	HTKLib/HLabel.h	/^   int fidx;      \/* MLF file index in mlfile *\/$/;"	m	struct:__anon109
fidx	HTKLib/HModel.h	/^   int fidx;               \/* MMF file index *\/$/;"	m	struct:_MMFInfo
fidx	HTKLib/HModel.h	/^   short fidx;             \/* idx of MMF file (0 = SMF) *\/$/;"	m	struct:_MacroDef
fidx	HTKTools/HHEd.c	/^static int fidx;           \/* current macro file id *\/$/;"	v	file:
figures	HTKBook/Makefile	/^figures =    HTKFigs\/Blocking.eps      HTKFigs\/melfbank.eps		    \\$/;"	m
file	HTKLib/HLabel.c	/^   FILE *file;$/;"	m	struct:__anon107	file:
fileLimit	HTKTools/HResults.c	/^static int fileLimit = INT_MAX;       \/* max num of label files to process *\/$/;"	v	file:
fileSize	HTKLib/HWave.c	/^   int32 fileSize;    \/* num samples * 2 *\/$/;"	m	struct:__anon175	file:
fileWin	HTKTools/HSLab.c	/^static RectWin fileWin;      \/* the window for file names and other info *\/$/;"	v	file:
file_	HTKLVRec/kenlm/lm/binary_format.hh	/^    util::scoped_fd file_;$/;"	m	class:lm::ngram::BinaryFormat
file_	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^    std::fstream file_;$/;"	m	class:lm::ARPAOutput
file_	HTKLVRec/kenlm/lm/filter/count_io.hh	/^    util::FakeOFStream file_;$/;"	m	class:lm::CountOutput
file_	HTKLVRec/kenlm/lm/trie_sort.hh	/^    FILE *file_;$/;"	m	class:lm::ngram::trie::RecordReader
file_	HTKLVRec/kenlm/util/file_piece.hh	/^    scoped_fd file_;$/;"	m	class:util::FilePiece
file_	HTKLVRec/kenlm/util/read_compressed.cc	/^    scoped_fd file_;$/;"	m	class:util::__anon79::StreamCompressed	file:
file_	HTKLVRec/kenlm/util/stream/io.hh	/^    int file_;$/;"	m	class:util::stream::PRead
file_	HTKLVRec/kenlm/util/stream/io.hh	/^    int file_;$/;"	m	class:util::stream::PWriteAndRecycle
file_	HTKLVRec/kenlm/util/stream/io.hh	/^    int file_;$/;"	m	class:util::stream::Read
file_	HTKLVRec/kenlm/util/stream/io.hh	/^    int file_;$/;"	m	class:util::stream::Write
file_	HTKLVRec/kenlm/util/stream/io.hh	/^    int file_;$/;"	m	class:util::stream::WriteAndRecycle
file_	HTKLVRec/kenlm/util/stream/io.hh	/^    scoped_fd file_;$/;"	m	class:util::stream::FileBuffer
file_begin_	HTKLVRec/kenlm/util/mmap.hh	/^    uint64_t file_begin_;$/;"	m	class:util::Rolling
file_end_	HTKLVRec/kenlm/util/mmap.hh	/^    uint64_t file_end_;$/;"	m	class:util::Rolling
file_name_	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^    const std::string file_name_;$/;"	m	class:lm::ARPAOutput
file_name_	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^    const std::string file_name_;$/;"	m	class:lm::ARPAOutputException
file_name_	HTKLVRec/kenlm/util/file_piece.hh	/^    std::string file_name_;$/;"	m	class:util::FilePiece
files_	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    util::FixedArray<util::stream::FileBuffer> files_;$/;"	m	class:lm::builder::__anon47::Master	file:
files_	HTKLVRec/kenlm/lm/filter/format.hh	/^    Singles files_;$/;"	m	class:lm::MultipleOutput
files_	HTKLVRec/kenlm/lm/trie_sort.cc	/^    std::deque<FILE*> &files_;$/;"	m	class:lm::ngram::trie::__anon61::Closer	file:
fill	HTKLib/HWave.c	/^   char fill[832];$/;"	m	struct:__anon175	file:
fill1	HTKLib/HWave.c	/^   char fill1[182];$/;"	m	struct:__anon175	file:
filtList	HLMTools/LGList.c	/^static FItem *filtList = NULL;$/;"	v	file:
filter_	HTKLVRec/kenlm/lm/filter/format.hh	/^    Filter &filter_;$/;"	m	class:lm::DispatchInput
filter_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    Filter filter_;$/;"	m	class:lm::FilterWorker
filter_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    util::ThreadPool<FilterWorker<Batch, Filter> > filter_;$/;"	m	class:lm::Controller
filtermap	HTKLib/HShell.c	/^static char *filtermap[] = {$/;"	v	file:
final	HTKLib/HNet.h	/^   NetNode final;     \/* Final (dummy) node *\/$/;"	m	struct:__anon139
find	HTKLVRec/kenlm/util/string_piece.cc	/^size_type StringPiece::find(char c, size_type pos) const {$/;"	f	class:StringPiece
find	HTKLVRec/kenlm/util/string_piece.cc	/^size_type StringPiece::find(const StringPiece& s, size_type pos) const {$/;"	f	class:StringPiece
findBest	HTKTools/HLRescore.c	/^static Boolean findBest = FALSE;    \/* -f *\/$/;"	v	file:
find_first_not_of	HTKLVRec/kenlm/util/string_piece.cc	/^size_type StringPiece::find_first_not_of(char c, size_type pos) const {$/;"	f	class:StringPiece
find_first_not_of	HTKLVRec/kenlm/util/string_piece.cc	/^size_type StringPiece::find_first_not_of(const StringPiece& s,$/;"	f	class:StringPiece
find_first_of	HTKLVRec/kenlm/util/string_piece.cc	/^size_type StringPiece::find_first_of(const StringPiece& s,$/;"	f	class:StringPiece
find_first_of	HTKLVRec/kenlm/util/string_piece.hh	/^  size_type find_first_of(char c, size_type pos = 0) const {$/;"	f	class:StringPiece
find_last_not_of	HTKLVRec/kenlm/util/string_piece.cc	/^size_type StringPiece::find_last_not_of(char c, size_type pos) const {$/;"	f	class:StringPiece
find_last_not_of	HTKLVRec/kenlm/util/string_piece.cc	/^size_type StringPiece::find_last_not_of(const StringPiece& s,$/;"	f	class:StringPiece
find_last_of	HTKLVRec/kenlm/util/string_piece.cc	/^size_type StringPiece::find_last_of(const StringPiece& s, size_type pos) const {$/;"	f	class:StringPiece
find_last_of	HTKLVRec/kenlm/util/string_piece.hh	/^  size_type find_last_of(char c, size_type pos = npos) const {$/;"	f	class:StringPiece
finder_	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    Find finder_;$/;"	m	class:util::TokenIter
finite	HTKLib/HTrain.h	49;"	d
first	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  T& first() { return start_[0]; }$/;"	f	class:double_conversion::Vector
firstElem	HTKLib/HModel.h	/^   Boolean *firstElem;     \/* first element added to hmem during MakeHMMSet*\/$/;"	m	struct:_HMMSet
firstFree	HTKLib/HMem.h	/^   size_t firstFree;    \/* idx of 1st free elem      idx of stack top     *\/$/;"	m	struct:_Block
firstGram	HLMLib/LGBase.h	/^   LabId firstGram[MAXNG];  \/* first entry in file *\/$/;"	m	struct:__anon3
firstGram	HLMLib/LGBase.h	/^   LabId firstGram[MAXNG];  \/* first entry in file *\/$/;"	m	struct:gramfile
firstNdx	HLMLib/LWMap.h	/^   int     firstNdx;     \/* ndx of entry which is first in sort order *\/$/;"	m	struct:__anon23
firstOnly	HLMTools/HLMCopy.c	/^static Boolean   firstOnly = FALSE;      \/* Only use first dictionary with pron *\/$/;"	v	file:
firstTime	HTKLib/HFBLat.h	/^  Boolean firstTime ;     \/* Flag used to enable creation of ot *\/$/;"	m	struct:__anon102
firstTime	HTKTools/HERest.c	/^static Boolean firstTime = TRUE;    \/* Flag used to enable creation of ot *\/$/;"	v	file:
firstTime	HTKTools/HInit.c	/^static Boolean firstTime = TRUE;    \/* Flag used to enable InitSegStore *\/$/;"	v	file:
firstTime	HTKTools/HRest.c	/^static Boolean firstTime = TRUE; \/* Flag used to enable InitSegStore *\/$/;"	v	file:
fitem	HLMTools/LGList.c	/^typedef struct fitem {$/;"	s	file:
fixBadLats	HTKTools/HLRescore.c	/^static Boolean fixBadLats = FALSE;         \/* fix final word in lattices *\/$/;"	v	file:
fixPronprobs	HTKTools/HLRescore.c	/^static Boolean fixPronprobs = FALSE; \/* get pron probs from dict *\/$/;"	v	file:
fixed	HTKLVRec/kenlm/lm/binary_format.hh	/^  FixedWidthParameters fixed;$/;"	m	struct:lm::ngram::Parameters
fixed	HTKTools/HCompV.c	/^   Covariance   fixed;              \/* fixed (co)variance values *\/$/;"	m	struct:__anon189	file:
flags	HTKLVRec/HLVNet.h	/^   unsigned char flags;         \/* flags like LEFT_RIGHT *\/$/;"	m	struct:_LexNode
flags	HTKLib/HRec.c	/^   int flags;           \/* Flags, active ... *\/$/;"	m	struct:_NetInst	file:
flags_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const int flags_;$/;"	m	class:double_conversion::DoubleToStringConverter
flags_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const int flags_;$/;"	m	class:double_conversion::StringToDoubleConverter
flid	HLMTools/LGPrep.c	/^   int   flid;                \/* field index *\/$/;"	m	union:__anon28	file:
flist	HLMLib/LCMap.h	/^   ClassEntry *flist;	        \/* free list of ClassEntry records *\/$/;"	m	struct:__anon1
fllrHeap	HTKTools/HBuild.c	/^   MemHeap fllrHeap;$/;"	m	struct:__anon188	file:
float_to_uint32	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^static uint32_t float_to_uint32(float f) { return BitCast<uint32_t>(f); }$/;"	f	namespace:double_conversion
floatsPerBlock	HTKLVRec/HLVModel.h	/^   size_t floatsPerBlock;        \/* mixPerBlock * floatsPerMix *\/$/;"	m	struct:_StateInfo_lv
floatsPerMix	HTKLVRec/HLVModel.h	/^   size_t floatsPerMix;$/;"	m	struct:_StateInfo_lv
fltcompare	HTKTools/HERest.c	/^static  int fltcompare(const void *_i, const void *_j)$/;"	f	file:
fltcompare	HTKTools/HMMIRest.c	/^static  int fltcompare(const void *_i, const void *_j)$/;"	f	file:
fmem	HLMTools/LGList.c	/^static MemHeap fmem;$/;"	v	file:
fmt	HLMLib/LModel.h	/^   LMFileFmt fmt;           \/* indicates LM section stored in binary *\/$/;"	m	struct:__anon13
fmt	HTKLib/HWave.c	/^   FileFormat fmt;      \/* Format of associated source file *\/$/;"	m	struct:_Wave	file:
fmt	HTKTools/HList.c	/^   FileFormat fmt;$/;"	m	struct:__anon202	file:
fmtmap	HTKLib/HWave.c	/^static char *fmtmap[] = {$/;"	v	file:
fn	HLMLib/LGBase.h	/^   char *fn;               \/* basename of output file name *\/$/;"	m	struct:__anon5
fn	HLMLib/LGBase.h	/^   char fn[MAXSTRLEN];     \/* file name *\/$/;"	m	struct:gramfile
fn	HLMLib/LPMerge.h	/^   char *fn;                \/* LM filename *\/$/;"	m	struct:__anon18
fname	HLMTools/HLMCopy.c	/^   char *fname;$/;"	m	struct:dictlist	file:
fname	HTKLib/HModel.h	/^  char *fname;                      \/* filename of where the xform was loaded *\/$/;"	m	struct:_AdaptXForm
fname	HTKLib/HModel.h	/^  char *fname;         \/* filename of where the baseclass was loaded *\/$/;"	m	struct:__anon129
fname	HTKLib/HModel.h	/^  char *fname;         \/* filename of where the input xform was loaded *\/$/;"	m	struct:__anon134
fname	HTKLib/HModel.h	/^  char *fname;         \/* filename of where the regTree was loaded *\/$/;"	m	struct:RegTree
fndx	HLMLib/LGBase.h	/^   int fndx;               \/* index of next output file *\/$/;"	m	struct:__anon5
fof	HLMLib/LGBase.h	/^   UInt **fof;             \/* array[1..N][1..size] of count *\/$/;"	m	struct:__anon6
fofFN	HLMTools/LBuild.c	/^static char *fofFN   = NULL;        \/* FoF table filename *\/$/;"	v	file:
fofFN	HLMTools/LFoF.c	/^static char       *fofFN = NULL;    \/* output FoF file name *\/$/;"	v	file:
fofSize	HLMTools/LFoF.c	/^static int        fofSize = 128;    \/* size of fof table *\/$/;"	v	file:
fofTab	HLMTools/LFoF.c	/^static FoFTab     *fofTab;          \/* FoF Table *\/$/;"	v	file:
foll	HTKLVRec/HLVLM.h	/^   FSLM_LatArc *foll;$/;"	m	struct:_FSLM_LatNode
foll	HTKLVRec/HLVNet.h	/^   LexNode **foll;		\/* array of following nodes *\/$/;"	m	struct:_LexNode
foll	HTKLib/HArc.h	/^  HArc *foll;$/;"	m	struct:_Arc
foll	HTKLib/HLat.c	/^   SubLArc *foll;$/;"	m	struct:_SubLNode	file:
foll	HTKLib/HNet.h	/^   ArcId foll;         \/* Linked list of arcs following node *\/$/;"	m	struct:lnode
follTrans	HTKLib/HArc.h	/^  ArcTrans *follTrans;  \/*Arcs which follow.*\/$/;"	m	struct:_Arc
follTrans	HTKLib/HArc.h	/^  CorrA *follTrans;$/;"	m	struct:_CorrN
fomA	HTKTools/HResults.c	/^static float fomA;            \/* interpolation factor *\/$/;"	v	file:
fomN	HTKTools/HResults.c	/^static int fomN;              \/* num FA levels needed *\/$/;"	v	file:
fomTab	HTKTools/HResults.c	/^static Matrix fomTab;         \/* array[1..kn+1,1..fomN+1] of hitRate *\/$/;"	v	file:
fop	HLMTools/LGPrep.c	/^   FieldOp   fop[MAX_FIELDS]; \/* tag\/operation for each field *\/$/;"	m	struct:__anon30	file:
for_write_	HTKLVRec/kenlm/util/mmap.hh	/^    bool for_write_;$/;"	m	class:util::Rolling
forceCnts	HLMTools/LGPrep.c	/^static Boolean forceCnts = FALSE;   \/* force the output of word counts *\/$/;"	v	file:
forceCxtExp	HTKLib/HNet.c	/^Boolean forceCxtExp=FALSE;$/;"	v
forceHSKind	HTKLib/HModel.c	/^static Boolean forceHSKind= FALSE;      \/* force HMM Set Kind *\/$/;"	v	file:
forceLatOut	HTKLVRec/HLVRec.c	/^static Boolean forceLatOut = TRUE;\/* always output lattice, even when no token survived *\/$/;"	v	file:
forceLeftBiphones	HTKLib/HNet.c	/^Boolean forceLeftBiphones=FALSE;$/;"	v
forceOutput	HTKLib/HRec.c	/^static Boolean forceOutput=FALSE;$/;"	v	file:
forceRightBiphones	HTKLib/HNet.c	/^Boolean forceRightBiphones=FALSE;$/;"	v
formType	HTKLib/HWave.c	/^   int32 formType;    \/* must be 'AIFF' *\/$/;"	m	struct:__anon177	file:
format	HTKLib/HNet.h	/^   LatFormat format;	       	\/* indicate which fields are valid *\/$/;"	m	struct:lattice
forward	HLMTools/Cluster.c	/^static bigrams     *forward=0, *backward;    \/* Forward and backward bigram tables *\/$/;"	v	file:
forward	HLMTools/Cluster.c	/^static bigrams    *forward, *backward;      \/* Forward and backward bigram tables *\/$/;"	v	file:
fourthWin	HTKLib/HParm.c	/^   int fourthWin;             \/* Fourth order differential halfsize *\/$/;"	m	struct:__anon141	file:
frBuf	HTKLib/HAudio.c	/^   short * frBuf;            \/* buffer for constructing frames *\/$/;"	m	struct:_AudioIn	file:
frIdx	HTKLib/HWave.c	/^   int frIdx;           \/* Start of next frame *\/$/;"	m	struct:_Wave	file:
frMax	HTKLib/HParm.c	/^   float frMax;           \/* Measured maximum frame energy for channel (dB) *\/$/;"	m	struct:channelinfo	file:
frMin	HTKLib/HParm.c	/^   float frMin;           \/* Measured minimum frame energy for channel (dB) *\/$/;"	m	struct:channelinfo	file:
frOLap	HTKLib/HAudio.c	/^   Vector frOLap;            \/* frame overlap buffer used by GetAudio *\/$/;"	m	struct:_AudioIn	file:
frRate	HTKLib/HAudio.c	/^   int frRate;               \/* num samples between speech frames *\/$/;"	m	struct:_AudioIn	file:
frRate	HTKLib/HParm.c	/^   int frRate;        \/* Number of waveform samples advanced each frame *\/$/;"	m	struct:__anon141	file:
frRate	HTKLib/HParm.h	/^   int frRate;                \/* Number of source samples forward each frame *\/$/;"	m	struct:__anon149
frRate	HTKLib/HWave.c	/^   int frRate;          \/* Frame rate *\/$/;"	m	struct:_Wave	file:
frSize	HTKLib/HAudio.c	/^   int frSize;               \/* num samples per speech frame *\/$/;"	m	struct:_AudioIn	file:
frSize	HTKLib/HParm.c	/^   int frSize;        \/* Total number of waveform samples in frame *\/$/;"	m	struct:__anon141	file:
frSize	HTKLib/HParm.h	/^   int frSize;                \/* Number of source samples in each frame *\/$/;"	m	struct:__anon149
frSize	HTKLib/HWave.c	/^   int frSize;          \/* Num samples per frame *\/$/;"	m	struct:_Wave	file:
frag_size	HTKLib/HAudio.c	/^static int frag_size;$/;"	v	file:
frame	HTKLVRec/HLVRec.h	/^   int frame;                   \/* current frame number *\/$/;"	m	struct:_DecoderInst
frame	HTKLVRec/HLVRec.h	/^   short frame;                 \/* end frame number of this model *\/$/;"	m	struct:_ModendHyp
frame	HTKLVRec/HLVRec.h	/^   short frame;                 \/* end frame number of this word *\/$/;"	m	struct:_WordendHyp
frame	HTKLib/HRec.c	/^   int frame;               \/* Current frame number *\/$/;"	m	struct:precinfo	file:
frame	HTKLib/HRec.c	/^   int frame;           \/* Frame number upon entering state\/model end *\/$/;"	m	struct:align	file:
frame	HTKLib/HRec.h	/^   int frame;               \/* Current frame number *\/$/;"	m	struct:vrecinfo
frame	HTKLib/HRec.h	/^   int frame;           \/* Time (frame) of boundary (end of word) *\/$/;"	m	struct:path
frameDur	HTKLVRec/HLVRec.h	/^   HTime frameDur;              \/* Duration of one frame in seconds *\/$/;"	m	struct:_DecoderInst
frameDur	HTKLib/HRec.h	/^   HTime frameDur;          \/* Sample rate (to convert frame to time) *\/$/;"	m	struct:vrecinfo
frameSize	HTKLib/HSigP.h	/^   int frameSize;       \/* speech frameSize *\/$/;"	m	struct:__anon159
framedur	HTKLib/HArc.h	/^  float framedur;$/;"	m	struct:ArcInfoStruct
framedur	HTKLib/HNet.h	/^   HTime framedur;              \/* Frame duration in 100ns units *\/$/;"	m	struct:lattice
frames	HTKLib/HParm.c	/^   int frames;            \/* Number of frames processed in session *\/$/;"	m	struct:meanrec	file:
frcDisc	HTKTools/HList.c	/^static Boolean frcDisc = FALSE;  \/* List VQ symbols from cont file *\/$/;"	v	file:
frcSil	HTKLib/HNet.c	/^char *frcSil=NULL,frcSilBuf[MAXSTRLEN];$/;"	v
frcSilBuf	HTKLib/HNet.c	/^char *frcSil=NULL,frcSilBuf[MAXSTRLEN];$/;"	v
freeSlots	HLMTools/LBuild.c	/^static int  freeSlots = 10;$/;"	v	file:
freeSlots	HLMTools/LGCopy.c	/^static int freeSlots = 100;         \/* free class slots *\/$/;"	v	file:
free_list_	HTKLVRec/kenlm/util/pool.hh	/^    std::vector<void *> free_list_;$/;"	m	class:util::Pool
freq_sort_order	HLMTools/Cluster.c	/^static int freq_sort_order(int *in1, int *in2)$/;"	f	file:
fres	HTKLib/HSigP.h	/^   float fres;          \/* scaled fft resolution *\/$/;"	m	struct:__anon159
from_	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^    util::FilePiece &from_;$/;"	m	class:lm::builder::CorpusCount
from_	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    detail::Vertex *from_;$/;"	m	class:lm::phrase::detail::Arc	file:
from_adder_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    util::stream::ChainPosition from_adder_;$/;"	m	class:lm::builder::__anon45::MergeRight	file:
fslm_latlm	HTKLVRec/HLVLM.h	/^typedef enum {fslm_ngram, fslm_latlm, kenlm} FSLMType;$/;"	e	enum:__anon35
fslm_ngram	HTKLVRec/HLVLM.h	/^typedef enum {fslm_ngram, fslm_latlm, kenlm} FSLMType;$/;"	e	enum:__anon35
fslmln	HTKLVRec/HLVLM.h	/^   FSLM_LatNode *fslmln;$/;"	m	struct:_FSLM_latlm
ftab	HLMLib/LPCalc.h	/^   FoFTab       *ftab;                \/* FoF table *\/$/;"	m	struct:__anon16
full	HTKLVRec/kenlm/lm/state.hh	/^  bool full;$/;"	m	struct:lm::ngram::Left
fullResults	HTKTools/HResults.c	/^static Boolean fullResults = FALSE;   \/* enable full Results *\/$/;"	v	file:
full_	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    OrderStat &full_;$/;"	m	class:lm::builder::__anon42::StatCollector	file:
full_	HTKLVRec/kenlm/lm/trie_sort.hh	/^    util::scoped_FILE full_[KENLM_MAX_ORDER - 1], context_[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::trie::SortedFiles
fullcNeeded	HTKTools/HCompV.c	/^static Boolean fullcNeeded[SMAX];   \/* true for each stream that needs full$/;"	v	file:
fullname	HTKLib/esignal.h	/^    char	*fullname;	\/* name including parent name, if any,$/;"	m	struct:FieldSpec
fv	HTKLib/HParm.h	/^   Vector fv[SMAX];      \/* array[1..swidth[0]] of Vector *\/$/;"	m	struct:__anon147
fvSegs	HTKLib/HTrain.h	/^   Sequence fvSegs;     \/* each seg is a sequence of fv[SMAX] *\/$/;"	m	struct:_SegStoreRec
fwlike	HTKLib/HLat.h	/^   LogDouble fwlike;     \/* forward likelihood *\/$/;"	m	struct:FBlnodeInfo
gConst	HTKLib/HAdapt.c	/^   float gConst;$/;"	m	struct:__anon86	file:
gConst	HTKLib/HModel.h	/^   float gConst;        \/* Precomputed component of b(x) *\/$/;"	m	struct:__anon120
gGw	HLMTools/Cluster.c	/^static int         GwGw, gGw, Gwg, gg;      \/* Special-case class counts *\/$/;"	v	file:
gInfo	HLMLib/LModel.h	/^   NGramInfo gInfo[LM_NSIZE];\/* information for each n-gram component *\/$/;"	m	struct:__anon15
gScale	HLMLib/LModel.h	/^   float   gScale;           \/* grammar scale factor *\/$/;"	m	struct:__anon15
gScriptFN	HTKTools/HDMan.c	/^static char *gScriptFN = NULL;       \/* name of global edit script *\/$/;"	v	file:
gains	HTKLib/HAudio.c	/^   AGainEntry gains[4];$/;"	m	struct:_AudioIn	file:
gains	HTKLib/HAudio.c	/^   AGainEntry gains[4];$/;"	m	struct:_AudioOut	file:
gamma	HTKLVRec/kenlm/lm/builder/hash_gamma.hh	/^    float gamma;$/;"	m	struct:lm::builder::HashGamma
gamma	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^  float gamma;$/;"	m	struct:lm::builder::__anon45::BufferEntry	file:
gamma	HTKLVRec/kenlm/lm/builder/ngram.hh	/^  float gamma; \/\/ Interpolation weight for lower order.$/;"	m	struct:lm::builder::Uninterpolated
gbGen	HLMTools/LGPrep.c	/^static Boolean gbGen = TRUE;        \/* flag to enable GBase generation *\/$/;"	v	file:
gcFreq	HTKLVRec/HLVRec.c	/^static int gcFreq = 100;          \/* run Garbage Collection every gcFreq frames *\/$/;"	v	file:
gcheap	HTKLib/HMem.c	/^MemHeap gcheap;   \/* global CHEAP for general purpose use *\/$/;"	v
gconst	HTKLib/HVQ.h	/^   float gconst;        \/* const part of log prob for INVDIAGC & FULLC *\/$/;"	m	struct:_VQNodeRec
gconst_cmp	HTKLib/HModel.c	/^static int gconst_cmp(const void *v1,const void *v2)$/;"	f	file:
gcs	HTKLib/HGraf.c	/^static GC            gcs[MAX_GC];$/;"	v	file:
gen	HTKTools/HList.c	/^static long gen = -1;             \/* end sample to list *\/$/;"	v	file:
genBeam	HTKLib/HRec.h	/^   LogFloat genBeam;        \/* Global beam width *\/$/;"	m	struct:vrecinfo
genBeam	HTKTools/HVite.c	/^static LogDouble genBeam = -LZERO;\/* genBeam threshold *\/$/;"	v	file:
genBeamInc	HTKTools/HVite.c	/^static LogDouble genBeamInc  = 0.0;       \/* increment         *\/$/;"	v	file:
genBeamLim	HTKTools/HVite.c	/^static LogDouble genBeamLim = -LZERO;     \/* max value       *\/$/;"	v	file:
genMaxNode	HTKLib/HRec.c	/^   NetNode *genMaxNode;     \/* Most likely node in network *\/$/;"	m	struct:precinfo	file:
genMaxNode	HTKLib/HRec.h	/^   NetNode *genMaxNode;     \/* Most likely node in network *\/$/;"	m	struct:vrecinfo
genMaxTok	HTKLib/HRec.c	/^   Token genMaxTok;         \/* Most likely token *\/$/;"	m	struct:precinfo	file:
genMaxTok	HTKLib/HRec.h	/^   Token genMaxTok;         \/* Most likely token *\/$/;"	m	struct:vrecinfo
genThresh	HTKLib/HRec.c	/^   LogFloat genThresh;      \/* Cutoff from global beam *\/$/;"	m	struct:precinfo	file:
get	HTKLVRec/kenlm/util/file.hh	/^    int get() const { return fd_; }$/;"	f	class:util::scoped_fd
get	HTKLVRec/kenlm/util/file_piece.hh	/^    char get() {$/;"	f	class:util::FilePiece
get	HTKLVRec/kenlm/util/mmap.hh	/^    void *get() const { return data_; }$/;"	f	class:util::scoped_memory
get	HTKLVRec/kenlm/util/mmap.hh	/^    void *get() const { return data_; }$/;"	f	class:util::scoped_mmap
get	HTKLVRec/kenlm/util/mmap.hh	/^    void *get() const { return ptr_; }$/;"	f	class:util::Rolling
get	HTKLVRec/kenlm/util/scoped.hh	/^    T *get() { return p_; }$/;"	f	class:util::scoped_base
get	HTKLVRec/kenlm/util/scoped.hh	/^    const T *get() const { return p_; }$/;"	f	class:util::scoped_base
get_id_from_word	HLMTools/Cluster.c	/^UInt get_id_from_word(char *word)$/;"	f
get_space	HLMTools/Cluster.c	/^static void *get_space(int size)$/;"	f	file:
getopt	HTKLVRec/kenlm/util/getopt.c	/^getopt(argc, argv, opts)$/;"	f
gf	HLMLib/LGBase.h	/^   GFLink gf[MAXINF];      \/* list of ptrs to gram files *\/$/;"	m	struct:__anon4
gfsort	HLMLib/LGBase.h	/^   int gfsort[MAXINF];     \/* idx's of sorted gram files *\/$/;"	m	struct:__anon4
gg	HLMTools/Cluster.c	/^static int         GwGw, gGw, Gwg, gg;      \/* Special-case class counts *\/$/;"	v	file:
glist	HTKTools/HBuild.c	/^   GramEntry *glist;   $/;"	m	struct:__anon188	file:
globClustVar	HTKTools/HQuant.c	/^static Boolean globClustVar = FALSE;\/*Output global variance of data to$/;"	v	file:
global_heap	HLMTools/Cluster.c	/^static MemHeap     global_heap;             \/* Claim fixed block memory from here *\/$/;"	v	file:
global_stack	HLMTools/Cluster.c	/^static MemHeap     global_stack;            \/* Claim other memory from here *\/$/;"	v	file:
gram_	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    NGram gram_;$/;"	m	class:lm::builder::__anon43::Writer	file:
gram_	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    NGram gram_;$/;"	m	class:lm::builder::NGramStream
gramfile	HLMLib/LGBase.h	/^typedef struct gramfile{ \/* info record for a packed gram file *\/$/;"	s
greys	HTKLib/HGraf.c	/^static int greys[MAX_GREYS];$/;"	v	file:
greys	HTKLib/HGraf_WIN32.c	/^static unsigned char greys[MAX_GREYS];$/;"	v	file:
grid	HTKTools/HResults.c	/^static CellPtr *grid;     \/* matrix of cells *\/$/;"	v	file:
growf	HTKLib/HMem.h	/^   float growf;         \/*           succ blocks grow as 1+growf          *\/$/;"	m	struct:__anon116
gst	HTKTools/HList.c	/^static long gst = -1;             \/* start sample to list *\/$/;"	v	file:
gstack	HTKLib/HMem.c	/^MemHeap gstack;   \/* global MSTAK for general purpose use *\/$/;"	v
h	HTKLib/HArc.c	/^   HArc *h;$/;"	m	struct:_ArcList	file:
h	HTKLib/HFBLat.c	/^   CorrectArc *h;$/;"	m	struct:_CorrectArcList	file:
h	HTKLib/HGraf.h	/^   int x, y, w, h;            \/* size of button rectangle *\/$/;"	m	struct:_HButton
h	HTKLib/HUtil.h	/^   int h;            \/* current mtab slot *\/$/;"	m	struct:__anon169
h	HTKTools/HSLab.c	/^   int x, y, w, h, bw;    \/* x-pos, y-pos, width, height, fg and bg colours *\/$/;"	m	struct:__anon212	file:
hRedrawWindow	HTKTools/HSLab.c	/^void hRedrawWindow(void)$/;"	f
hSet	HTKTools/HHEd.c	/^static HMMSet hSet;        \/* current HMM set *\/$/;"	v	file:
hSize	HTKTools/HLStats.c	/^static int hSize = 0;               \/* hash table size, small(0), med(1), large(2)  *\/$/;"	v	file:
hadapt_vc_id	HTKLib/HAdapt.c	/^char *hadapt_vc_id =  "$Id: HAdapt.c,v 1.2 2006\/12\/07 11:09:07 mjfg Exp $";$/;"	v
hadapt_version	HTKLib/HAdapt.c	/^char *hadapt_version = "!HVER!HAdapt:   3.4.1  [CUED 12\/03\/09]";$/;"	v
hamWin	HTKLib/HSigP.c	/^static Vector hamWin = NULL;        \/* Current Hamming window *\/$/;"	v	file:
hamWinSize	HTKLib/HSigP.c	/^static int hamWinSize = 0;          \/* Size of current Hamming window *\/$/;"	v	file:
handler_	HTKLVRec/kenlm/util/thread_pool.hh	/^    boost::optional<Handler> handler_;$/;"	m	class:util::Worker
hasCnts	HLMLib/LWMap.h	/^   Boolean hasCnts;      \/* has word freq cnts, map option only *\/$/;"	m	struct:__anon23
has_vocabulary	HTKLVRec/kenlm/lm/binary_format.hh	/^  bool has_vocabulary;$/;"	m	struct:lm::ngram::FixedWidthParameters
hasfv	HTKLib/HTrain.h	/^   Boolean hasfv;$/;"	m	struct:_SegStoreRec
hashSize	HLMLib/LUtil.h	/^  int hashSize;                \/* hash size - prime number *\/$/;"	m	struct:__anon20
hashTableHeap	HLMLib/LUtil.c	/^static MemHeap hashTableHeap;           \/* heap for hash tables *\/$/;"	v	file:
hash_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    Hash hash_;$/;"	m	class:util::ProbingHashTable
hash_value	HTKLVRec/kenlm/lm/builder/hash_gamma.hh	/^    uint64_t hash_value;$/;"	m	struct:lm::builder::HashGamma
hash_value	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^  uint64_t hash_value;$/;"	m	struct:lm::builder::__anon45::HashBufferEntry	file:
hash_value	HTKLVRec/kenlm/lm/state.hh	/^inline uint64_t hash_value(const ChartState &state) {$/;"	f	namespace:lm::ngram
hash_value	HTKLVRec/kenlm/lm/state.hh	/^inline uint64_t hash_value(const Left &left) {$/;"	f	namespace:lm::ngram
hash_value	HTKLVRec/kenlm/lm/state.hh	/^inline uint64_t hash_value(const State &state, uint64_t seed = 0) {$/;"	f	namespace:lm::ngram
hash_value	HTKLVRec/kenlm/util/string_piece_hash.hh	/^inline size_t hash_value(const StringPiece &str) {$/;"	f
hashes_	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    std::vector<Hash> hashes_;$/;"	m	class:lm::phrase::detail::ConditionCommon
hashsize	HTKLVRec/HLVLM.h	/^   unsigned int hashsize;       \/* Size of hashtab (adjusted by lm counts) *\/$/;"	m	struct:_FSLM_ngram
hashsize	HTKLib/HLM.h	/^   unsigned int hashsize;       \/* Size of hashtab (adjusted by lm counts) *\/$/;"	m	struct:ngramlm
hashsizes	HTKTools/HLStats.c	/^static int hashsizes[4]={ 87793, 188281, 715249 };$/;"	v	file:
hashtab	HTKLVRec/HLVLM.h	/^   NEntry **hashtab;            \/* Hash table for finding NEntries *\/$/;"	m	struct:_FSLM_ngram
hashtab	HTKLib/HLM.h	/^   NEntry **hashtab;            \/* Hash table for finding NEntries *\/$/;"	m	struct:ngramlm
hashtab	HTKLib/HLabel.c	/^static NameCell *hashtab[HASHSIZE];  \/* the actual table *\/$/;"	v	file:
hasvq	HTKLib/HTrain.h	/^   Boolean hasvq;$/;"	m	struct:_SegStoreRec
haudio_vc_id	HTKLib/HAudio.c	/^char *haudio_vc_id = "$Id: HAudio.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
haudio_version	HTKLib/HAudio.c	/^char *haudio_version = "!HVER!HAudio:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hbuild_vc_id	HTKTools/HBuild.c	/^char *hbuild_vc_id = "$Id: HBuild.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hbuild_version	HTKTools/HBuild.c	/^char *hbuild_version = "!HVER!HBuild:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hcompv_vc_id	HTKTools/HCompV.c	/^char *hcompv_vc_id = "$Id: HCompV.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hcompv_version	HTKTools/HCompV.c	/^char *hcompv_version = "!HVER!HCompV:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hcopy_vc_id	HTKTools/HCopy.c	/^char *hcopy_vc_id = "$Id: HCopy.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hcopy_version	HTKTools/HCopy.c	/^char *hcopy_version = "!HVER!HCopy:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hcrit	HTKTools/HMMIRest.c	/^static float hcrit = 1.0; \/* Scale on denominator (MMI) part. Not really useful.  *\/$/;"	v	file:
hd	HTKLib/HTrain.h	/^   IBLink hd;        \/* head of list of item blocks *\/$/;"	m	struct:__anon160
hdecode_sccs_id	HTKLVRec/HDecode.c	/^char *hdecode_sccs_id = "$Id: HDecode.c,v 1.1.1.1 2006\/10\/11 09:54:55 jal58 Exp $";$/;"	v
hdecode_sccs_id	HTKLVRec/HDecode.mod.c	/^char *hdecode_sccs_id = "$Id: HDecode.mod.c,v 1.1.1.1 2006\/10\/11 09:54:55 jal58 Exp $";$/;"	v
hdecode_version	HTKLVRec/HDecode.c	/^char *hdecode_version = "!HVER!HDecode:   3.4.1 [GE 12\/03\/09]";$/;"	v
hdecode_version	HTKLVRec/HDecode.mod.c	/^char *hdecode_version = "!HVER!HDecode:   3.4.1 [GE 12\/03\/09]";$/;"	v
hdict_vc_id	HTKLib/HDict.c	/^char *hdict_vc_id = "$Id: HDict.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hdict_version	HTKLib/HDict.c	/^char *hdict_version = "!HVER!HDict:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hdman_vc_id	HTKTools/HDMan.c	/^char *hdman_vc_id = "$Id: HDMan.c,v 1.2 2006\/12\/07 11:09:08 mjfg Exp $";$/;"	v
hdman_version	HTKTools/HDMan.c	/^char *hdman_version = "!HVER!HDMan:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hdrField	HLMLib/LUtil.c	/^typedef struct hdrField{$/;"	s	file:
hdrSize	HTKLib/HWave.c	/^   int  hdrSize;        \/* Header size in bytes *\/$/;"	m	struct:_Wave	file:
hdrSize	HTKLib/HWave.c	/^   short hdrSize;    \/* should be 1336 *\/$/;"	m	struct:__anon175	file:
hdrSize	HTKLib/HWave.c	/^   short hdrSize;$/;"	m	struct:__anon173	file:
hdrSize	HTKLib/HWave.c	/^   short hdrSize;$/;"	m	struct:__anon174	file:
hdrless	HLMLib/LCMap.h	/^   Boolean hdrless;	     	\/* if true, nentries is size of unk class *\/$/;"	m	struct:__anon1
head	HLMLib/LGBase.h	/^   GramFile head;          \/* dummy head of tree *\/$/;"	m	struct:__anon4
head	HLMTools/LGPrep.c	/^   RuleDef * head;            \/* head of list of rules *\/$/;"	m	struct:__anon31	file:
head	HTKLib/HLabel.h	/^   LLink head;              \/* Pointer to head of List *\/$/;"	m	struct:_LabList
head	HTKLib/HLabel.h	/^   LabList *head;          \/* Pointer to head of Label List *\/$/;"	m	struct:__anon108
head	HTKLib/HRec.c	/^   NetInst head;            \/* Head (oldest) of Inst linked list *\/$/;"	m	struct:precinfo	file:
headSkip	HTKTools/HDMan.c	/^   int headSkip;                \/* num header lines to skip on input *\/$/;"	m	struct:__anon195	file:
headac	HTKLib/HAdapt.c	/^static AccCache *headac = NULL;$/;"	v	file:
headboc	HTKLib/HAdapt.c	/^static ObsCache *headboc = NULL; $/;"	v	file:
headerPrinted	HTKTools/HResults.c	/^static Boolean headerPrinted = FALSE;  \/* delay header as long as poss *\/$/;"	v	file:
header_	HTKLVRec/kenlm/lm/builder/output.hh	/^    HeaderInfo header_;$/;"	m	class:lm::builder::Output
header_	HTKLVRec/kenlm/lm/vocab.hh	/^    detail::ProbingVocabularyHeader *header_;$/;"	m	class:lm::ngram::ProbingVocabulary
header_size_	HTKLVRec/kenlm/lm/binary_format.hh	/^    std::size_t header_size_, vocab_size_, vocab_pad_;$/;"	m	class:lm::ngram::BinaryFormat
headpoc	HTKLib/HAdapt.c	/^static ObsCache *headpoc = NULL; $/;"	v	file:
heap	HLMLib/LModel.h	/^   MemHeap *heap;            \/* heap for storage *\/$/;"	m	struct:__anon15
heap	HTKLVRec/HLVLM.h	/^   MemHeap *heap;$/;"	m	struct:_FSLM
heap	HTKLVRec/HLVLM.h	/^   MemHeap *heap;$/;"	m	struct:_FSLM_ngram
heap	HTKLVRec/HLVNet.h	/^   MemHeap *heap;$/;"	m	struct:_LexNet
heap	HTKLVRec/HLVNet.h	/^   MemHeap *heap;$/;"	m	struct:_TLexNet
heap	HTKLVRec/HLVRec.h	/^   MemHeap heap;                \/* MSTACK for general allocation *\/$/;"	m	struct:_DecoderInst
heap	HTKLib/HDict.h	/^   MemHeap heap;        \/* storage for dictionary *\/$/;"	m	struct:__anon94
heap	HTKLib/HLM.h	/^   MemHeap *heap;               \/* Heap for allocating lm structs *\/$/;"	m	struct:lmodel
heap	HTKLib/HLM.h	/^   MemHeap *heap;               \/* Pointer to heap *\/$/;"	m	struct:matbilm
heap	HTKLib/HLM.h	/^   MemHeap *heap;               \/* Pointer to heap *\/$/;"	m	struct:ngramlm
heap	HTKLib/HMem.c	/^   MemHeap *heap;$/;"	m	struct:_MemHeapRec	file:
heap	HTKLib/HMem.h	/^   BlockP heap;         \/*               linked list of blocks            *\/$/;"	m	struct:__anon116
heap	HTKLib/HNet.h	/^   MemHeap *heap;               \/* Heap lattice uses *\/$/;"	m	struct:lattice
heap	HTKLib/HNet.h	/^   MemHeap *heap;     \/* heap for allocating network *\/$/;"	m	struct:__anon139
heap	HTKLib/HRec.c	/^   MemHeap heap;            \/* Memory for this set of pre-comps *\/$/;"	m	struct:psetinfo	file:
heap	HTKLib/HRec.h	/^   MemHeap heap;            \/* General storage CHEAP (inc vri) *\/$/;"	m	struct:vrecinfo
heapList	HTKLib/HMem.c	/^static MemHeapRec *heapList = NULL;$/;"	v	file:
herest_vc_id	HTKTools/HERest.c	/^char *herest_vc_id = "$Id: HERest.c,v 1.2 2006\/12\/07 11:09:08 mjfg Exp $";$/;"	v
herest_version	HTKTools/HERest.c	/^char *herest_version = "!HVER!HERest:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hexactmpe_vc_id	HTKLib/HExactMPE.c	/^char *hexactmpe_vc_id = "$Id: HExactMPE.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hexactmpe_version	HTKLib/HExactMPE.c	/^char *hexactmpe_version = "!HVER!HExactMPE:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hfb_vc_id	HTKLib/HFB.c	/^char *hfb_vc_id = "$Id: HFB.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hfb_version	HTKLib/HFB.c	/^char *hfb_version = "!HVER!HFB:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hfblat_vc_id	HTKLib/HFBLat.c	/^char *hfblat_vc_id = "$Id: HFBLat.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hfblat_version	HTKLib/HFBLat.c	/^char *hfblat_version = "!HVER!HFBLat:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hfwdbkwd_totalProbScale	HTKLib/HFBLat.c	/^float hfwdbkwd_totalProbScale = 1.0;          \/* (not a config.) Product of all scales affecting lm likelihoods.   Also read in HFBExactMPE.c and possibly$/;"	v
hgraf_vc_id	HTKLib/HGraf.c	/^char *hgraf_vc_id = "$Id: HGraf.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hgraf_vc_id	HTKLib/HGraf.null.c	/^char *hgraf_vc_id = "$Id: HGraf.null.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hgraf_vc_id	HTKLib/HGraf_WIN32.c	/^char *hgraf_vc_id = "$Id: HGraf_WIN32.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hgraf_version	HTKLib/HGraf.c	/^char *hgraf_version = "!HVER!HGraf(X):   3.4.1 [CUED 12\/03\/09]";$/;"	v
hgraf_version	HTKLib/HGraf.null.c	/^char *hgraf_version = "!HVER!HGraf(null):   3.4.1 [CUED 12\/03\/09]";$/;"	v
hgraf_version	HTKLib/HGraf_WIN32.c	/^char *hgraf_version = "!HVER!HGraf(NT):   3.4.1 [CUED 12\/03\/09]";$/;"	v
hhed_vc_id	HTKTools/HHEd.c	/^char *hhed_vc_id = "$Id: HHEd.c,v 1.2 2006\/12\/07 11:09:08 mjfg Exp $";$/;"	v
hhed_version	HTKTools/HHEd.c	/^char *hhed_version = "!HVER!HHEd:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hiFBankFreq	HTKLib/HParm.c	/^   float hiFBankFreq;         \/* Fbank hi frequency cut-off *\/$/;"	m	struct:__anon141	file:
hiWE	HTKLVRec/HLVNet.h	/^   LMId hiWE;$/;"	m	struct:_LMlaNode
hiWE	HTKLVRec/HLVNet.h	/^   int hiWE;            \/* highest WE LMId reachable from here *\/$/;"	m	struct:_TLexNode
highDiff	HTKLib/HParm.c	/^static Boolean highDiff = (Boolean)FALSE;   \/* compute higher oder differentials, only up to fourth *\/$/;"	v	file:
high_bits_	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^  uint64_t high_bits_;$/;"	m	class:double_conversion::UInt128	file:
hinit_vc_id	HTKTools/HInit.c	/^char *hinit_vc_id = "$Id: HInit.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hinit_version	HTKTools/HInit.c	/^char *hinit_version = "!HVER!HInit:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hints	HTKLib/HGraf.c	/^static XSizeHints    hints;$/;"	v	file:
history	HTKTools/HParse.c	/^   Link history;     \/* used for word pronunciation expansion *\/$/;"	m	struct:_NodeInfo	file:
hit	HTKTools/HResults.c	/^   Boolean hit;                 \/* true if real occurrence *\/$/;"	m	struct:_SpotRec	file:
hit	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Cell	file:
hit	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Spkr	file:
hits	HTKTools/HResults.c	/^static long hits  = 0;     \/* Total hits *\/$/;"	v	file:
hlabel_vc_id	HTKLib/HLabel.c	/^char *hlabel_vc_id = "$Id: HLabel.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hlabel_version	HTKLib/HLabel.c	/^char *hlabel_version = "!HVER!HLabel:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hlat_vc_id	HTKLib/HLat.c	/^char *hlat_vc_id = "$Id: HLat.c,v 1.2 2006\/12\/07 11:09:08 mjfg Exp $";$/;"	v
hlat_version	HTKLib/HLat.c	/^char *hlat_version = "!HVER!HLat:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hled_vc_id	HTKTools/HLEd.c	/^char *hled_vc_id = "$Id: HLEd.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hled_version	HTKTools/HLEd.c	/^char *hled_version = "!HVER!HLEd:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hlib	HLMTools/Makefile	/^hlib    = 	..\/HTKLib$/;"	m
hlib	HTKLib/Makefile	/^hlib = .$/;"	m
hlist_vc_id	HTKTools/HList.c	/^char *hlist_vc_id = "$Id: HList.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hlist_version	HTKTools/HList.c	/^char *hlist_version = "!HVER!HList:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hlmModel	HTKLib/HLM.h	/^      void *hlmModel;$/;"	m	union:lmodel::__anon106
hlmModel	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, hlmModel } LMType;$/;"	e	enum:__anon105
hlm_vc_id	HTKLib/HLM.c	/^char *hlm_vc_id = "$Id: HLM.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hlm_version	HTKLib/HLM.c	/^char *hlm_version = "!HVER!HLM:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hlrescore_vc_id	HTKTools/HLRescore.c	/^char *hlrescore_vc_id = "$Id: HLRescore.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hlrescore_version	HTKTools/HLRescore.c	/^char *hlrescore_version = "!HVER!HLRescore:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hlstats_vc_id	HTKTools/HLStats.c	/^char *hlstats_vc_id = "$Id: HLStats.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hlstats_version	HTKTools/HLStats.c	/^char *hlstats_version = "!HVER!HLStats:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hlvlm_vc_id	HTKLVRec/HLVLM.c	/^char *hlvlm_vc_id = "$Id: HLVLM.c,v 1.1.1.1 2006\/10\/11 09:54:55 jal58 Exp $";$/;"	v
hlvlm_version	HTKLVRec/HLVLM.c	/^char *hlvlm_version = "!HVER!HLVLM:   3.4.1 [GE 12\/03\/09]";$/;"	v
hlvmodel_vc_id	HTKLVRec/HLVModel.c	/^char *hlvmodel_vc_id = "$Id: HLVModel.c,v 1.1.1.1 2006\/10\/11 09:54:55 jal58 Exp $";$/;"	v
hlvmodel_version	HTKLVRec/HLVModel.c	/^char *hlvmodel_version = "!HVER!HLVmodel:   3.4.1 [GE 12\/03\/09]";$/;"	v
hlvnet_vc_id	HTKLVRec/HLVNet.c	/^char *hlvnet_vc_id = "$Id: HLVNet.c,v 1.1.1.1 2006\/10\/11 09:54:55 jal58 Exp $";$/;"	v
hlvnet_version	HTKLVRec/HLVNet.c	/^char *hlvnet_version = "!HVER!HLVNet:   3.4.1 [GE 12\/03\/09]";$/;"	v
hlvrec_prop_vc_id	HTKLVRec/HLVRec-propagate.c	/^char *hlvrec_prop_vc_id = "$Id: HLVRec-propagate.c,v 1.1.1.1 2006\/10\/11 09:54:56 jal58 Exp $";$/;"	v
hlvrec_vc_id	HTKLVRec/HLVRec.c	/^char *hlvrec_vc_id = "$Id: HLVRec.c,v 1.1.1.1 2006\/10\/11 09:54:56 jal58 Exp $";$/;"	v
hlvrec_version	HTKLVRec/HLVRec.c	/^char *hlvrec_version = "!HVER!HLVRec:   3.4.1 [GE 12\/03\/09]";$/;"	v
hmap_vc_id	HTKLib/HMap.c	/^char *hmap_vc_id = "$Id: HMap.c,v 1.1.1.1 2006\/10\/11 09:54:57 jal58 Exp $";$/;"	v
hmap_version	HTKLib/HMap.c	/^char *hmap_version = "!HVER!HMap: 3.4.1 [CUED 12\/03\/09]";$/;"	v
hmath_vc_id	HTKLib/HMath.c	/^char *hmath_vc_id = "$Id: HMath.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hmath_version	HTKLib/HMath.c	/^char *hmath_version = "!HVER!HMath:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hmem	HTKLib/HModel.h	/^   MemHeap *hmem;          \/* memory heap for this HMM Set *\/   $/;"	m	struct:_HMMSet
hmem_vc_id	HTKLib/HMem.c	/^char *hmem_vc_id = "$Id: HMem.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hmem_version	HTKLib/HMem.c	/^char *hmem_version = "!HVER!HMem:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hmm	HTKLVRec/HLVNet.h	/^      HLink hmm;                \/* #### switch to HMM Ids (2 byte ints) *\/$/;"	m	union:_LexNode::__anon38
hmm	HTKLVRec/HLVNet.h	/^   HLink hmm;$/;"	m	struct:_TLexNode
hmm	HTKLib/HArc.h	/^  HLink hmm; \/*For comparison, to see whether the physical hmm is the same.  Only used (at time of writing) for the exact-time$/;"	m	struct:_Arc
hmm	HTKLib/HArc.h	/^  HLink hmm;$/;"	m	struct:_Acoustic
hmm	HTKLib/HNet.h	/^      HLink  hmm;       \/* HMM (physical) definition *\/$/;"	m	union:_NetNode::__anon138
hmm	HTKLib/HUtil.h	/^   HLink hmm;        \/* -> current hmm *\/$/;"	m	struct:__anon169
hmm	HTKTools/HRest.c	/^static HLink hmm;          \/* link to the hmm itself *\/$/;"	v	file:
hmmDir	HTKLVRec/HDecode.c	/^static char *hmmDir = NULL;     \/* directory to look for HMM def files *\/$/;"	v	file:
hmmDir	HTKLVRec/HDecode.mod.c	/^static char *hmmDir = NULL;     \/* directory to look for HMM def files *\/$/;"	v	file:
hmmDir	HTKTools/HERest.c	/^static char * hmmDir = NULL;     \/* directory to look for hmm def files *\/$/;"	v	file:
hmmDir	HTKTools/HHEd.c	/^static char * hmmDir = NULL;     \/* directory to look for hmm def files *\/$/;"	v	file:
hmmDir	HTKTools/HMMIRest.c	/^static char * hmmDir = NULL;     \/* directory to look for hmm def files *\/$/;"	v	file:
hmmDir	HTKTools/HSmooth.c	/^static char * hmmDir = NULL;     \/* directory to look for hmm def files *\/$/;"	v	file:
hmmDir	HTKTools/HVite.c	/^static char * hmmDir = NULL;      \/* directory to look for hmm def files *\/$/;"	v	file:
hmmExt	HTKLVRec/HDecode.c	/^static char *hmmExt = NULL;     \/* HMM def file extension *\/$/;"	v	file:
hmmExt	HTKLVRec/HDecode.mod.c	/^static char *hmmExt = NULL;     \/* HMM def file extension *\/$/;"	v	file:
hmmExt	HTKTools/HERest.c	/^static char * hmmExt = NULL;     \/* hmm def file extension *\/$/;"	v	file:
hmmExt	HTKTools/HHEd.c	/^static char * hmmExt = NULL;     \/* hmm def file extension *\/$/;"	v	file:
hmmExt	HTKTools/HMMIRest.c	/^static char * hmmExt = NULL;     \/* hmm def file extension *\/$/;"	v	file:
hmmExt	HTKTools/HSmooth.c	/^static char * hmmExt = NULL;     \/* hmm def file extension *\/$/;"	v	file:
hmmExt	HTKTools/HVite.c	/^static char * hmmExt = NULL;      \/* hmm def file extension *\/$/;"	v	file:
hmmHeap	HTKTools/HHEd.c	/^static MemHeap hmmHeap;     \/* Heap holds all hmm related info *\/$/;"	v	file:
hmmId	HTKTools/HCompV.c	/^static LabId  hmmId  = NULL;        \/* id of model *\/$/;"	v	file:
hmmLink	HTKTools/HCompV.c	/^static HLink hmmLink;               \/* Link to the physical HMM *\/$/;"	v	file:
hmmLink	HTKTools/HInit.c	/^static HLink hmmLink;            \/* link to the hmm itself *\/$/;"	v	file:
hmmListFn	HTKTools/HVite.c	/^static char *hmmListFn;           \/* HMMs *\/$/;"	v	file:
hmmListfn	HTKLVRec/HDecode.c	/^static char *hmmListfn;		\/* model list filename from commandline *\/$/;"	v	file:
hmmListfn	HTKLVRec/HDecode.mod.c	/^static char *hmmListfn;		\/* model list filename from commandline *\/$/;"	v	file:
hmmName	HTKTools/HHEd.c	/^   char   *hmmName;          \/* Physical hmm name for this component *\/$/;"	m	struct:_CoList	file:
hmmSP	HTKLVRec/HLVNet.h	/^   HLink hmmSP;                 \/* pointer to "sp" hmm for spSkipLayer handling *\/$/;"	m	struct:_LexNet
hmmSetId	HTKLib/HModel.h	/^   char *hmmSetId;         \/* identifier for the hmm set *\/$/;"	m	struct:_HMMSet
hmmStack	HTKTools/HERest.c	/^static MemHeap hmmStack;   \/*For Storage of all dynamic structures created...*\/$/;"	v	file:
hmmStack	HTKTools/HMMIRest.c	/^static MemHeap hmmStack;           \/* HMM defs and related structures *\/$/;"	v	file:
hmmStack	HTKTools/HSmooth.c	/^static MemHeap hmmStack;     \/*For Storage of dynamic data structures *\/$/;"	v	file:
hmmfn	HTKTools/HCompV.c	/^static char *hmmfn=NULL;            \/* HMM definition file name *\/$/;"	v	file:
hmmfn	HTKTools/HInit.c	/^static char *hmmfn;                 \/* HMM definition file name (& part dir)*\/$/;"	v	file:
hmmfn	HTKTools/HRest.c	/^static char *hmmfn;              \/* HMM definition file name *\/$/;"	v	file:
hmmirest_vc_id	HTKTools/HMMIRest.c	/^char *hmmirest_vc_id = "$Id: HMMIRest.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hmmirest_version	HTKTools/HMMIRest.c	/^char *hmmirest_version = "!HVER!HMMIRest:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hmms	HTKLib/HNet.h	/^   char *hmms;			\/* MMF file name (NULL==unknown) *\/$/;"	m	struct:lattice
hmmsetcxtinfo	HTKLib/HNet.h	/^typedef struct hmmsetcxtinfo {$/;"	s
hmodel_vc_id	HTKLib/HModel.c	/^char *hmodel_vc_id = "$Id: HModel.c,v 1.2 2006\/12\/07 11:09:08 mjfg Exp $";$/;"	v
hmodel_version	HTKLib/HModel.c	/^char *hmodel_version = "!HVER!HModel:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hnet_vc_id	HTKLib/HNet.c	/^char *hnet_vc_id = "$Id: HNet.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hnet_version	HTKLib/HNet.c	/^char *hnet_version = "!HVER!HNet:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hook	HTKLib/HModel.h	/^   Ptr hook;               \/* general hook *\/$/;"	m	struct:__anon128
hook	HTKLib/HModel.h	/^   Ptr hook;            \/* general hook *\/$/;"	m	struct:__anon120
hook	HTKLib/HModel.h	/^   Ptr hook;            \/* general hook *\/$/;"	m	struct:__anon125
hook	HTKLib/HModel.h	/^   Ptr hook;            \/* general hook *\/$/;"	m	struct:__anon126
hook	HTKLib/HNet.h	/^   Ptr hook;                    \/* User definable hook *\/$/;"	m	struct:lattice
hook	HTKLib/HNet.h	/^   Ptr hook;           \/* User definable hook *\/$/;"	m	struct:lnode
hparmBin	HTKLib/HParm.c	/^static Boolean hparmBin=(Boolean)TRUE; \/* HTK format files are binary *\/$/;"	v	file:
hparm_vc_id	HTKLib/HParm.c	/^char *hparm_vc_id = "$Id: HParm.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hparm_version	HTKLib/HParm.c	/^char *hparm_version = "!HVER!HParm:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hparmsrcdef	HTKLib/HParm.c	/^typedef struct hparmsrcdef {$/;"	s	file:
hparse_vc_id	HTKTools/HParse.c	/^char *hparse_vc_id = "$Id: HParse.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hparse_version	HTKTools/HParse.c	/^char *hparse_version = "!HVER!HParse:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hquant_vc_id	HTKTools/HQuant.c	/^char *hquant_vc_id = "$Id: HQuant.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hquant_version	HTKTools/HQuant.c	/^char *hquant_version = "!HVER!HQuant:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hrec_vc_id	HTKLib/HRec.c	/^char *hrec_vc_id = "$Id: HRec.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hrec_version	HTKLib/HRec.c	/^char *hrec_version = "!HVER!HRec:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hrest_vc_id	HTKTools/HRest.c	/^char *hrest_vc_id = "$Id: HRest.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hrest_version	HTKTools/HRest.c	/^char *hrest_version = "!HVER!HRest:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hresults_vc_id	HTKTools/HResults.c	/^char *hresults_vc_id = "$Id: HResults.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hresults_version	HTKTools/HResults.c	/^char *hresults_version = "!HVER!HResults:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hsKind	HTKLib/HFB.h	/^  HSetKind hsKind;    \/* kind of the alignment HMM system *\/$/;"	m	struct:__anon99
hsKind	HTKLib/HFBLat.h	/^  HSetKind hsKind;              \/* kind of the alignment HMM system *\/$/;"	m	struct:__anon102
hsKind	HTKLib/HModel.h	/^   HSetKind hsKind;        \/* kind of HMM set *\/$/;"	m	struct:_HMMSet
hsKind	HTKTools/HMMIRest.c	/^static HSetKind hsKind;          \/* kind of the HMM system *\/ \/*!Must be PLAINHS | SHAREDHS (|TIEDHS?) *\/$/;"	v	file:
hsKind	HTKTools/HRest.c	/^static HSetKind hsKind;          \/* kind of the HMM system *\/$/;"	v	file:
hsKind	HTKTools/HSmooth.c	/^static HSetKind hsKind;          \/* kind of loaded hmm set *\/$/;"	v	file:
hset	HTKLVRec/HDecode.c	/^static HMMSet hset;		\/* HMM set *\/$/;"	v	file:
hset	HTKLVRec/HDecode.mod.c	/^static HMMSet hset;		\/* HMM set *\/$/;"	v	file:
hset	HTKLVRec/HLVModel.h	/^   HMMSet *hset;$/;"	m	struct:_StateInfo_lv
hset	HTKLVRec/HLVNet.h	/^   HMMSet *hset;$/;"	m	struct:_LexNet
hset	HTKLVRec/HLVNet.h	/^   HMMSet *hset;$/;"	m	struct:_TLexNet
hset	HTKLVRec/HLVRec.h	/^   HMMSet *hset;$/;"	m	struct:_DecoderInst
hset	HTKLib/HFBLat.h	/^  HMMSet *hset;$/;"	m	struct:__anon102
hset	HTKLib/HModel.h	/^  struct _HMMSet *hset;                     \/* transform is linked with a model set *\/$/;"	m	struct:_AdaptXForm	typeref:struct:_AdaptXForm::_HMMSet
hset	HTKLib/HNet.h	/^   HMMSet *hset;   \/* HMMSet *\/$/;"	m	struct:hmmsetcxtinfo
hset	HTKLib/HParm.c	/^static HMMSet *hset = NULL;        \/* hmmset to be used for frontend *\/$/;"	v	file:
hset	HTKLib/HRec.c	/^   HMMSet *hset;            \/* HMM Set for recognition *\/$/;"	m	struct:psetinfo	file:
hset	HTKLib/HUtil.h	/^   HMMSet *hset;     \/* HMM set *\/$/;"	m	struct:__anon169
hset	HTKTools/HCompV.c	/^static HMMSet hset;                 \/* HMM to be initialised with *\/$/;"	v	file:
hset	HTKTools/HHEd.c	/^static HMMSet *hset;       \/* current HMM set *\/$/;"	v	file:
hset	HTKTools/HInit.c	/^static HMMSet hset;              \/* The current unitary hmm set *\/$/;"	v	file:
hset	HTKTools/HMMIRest.c	/^static HMMSet hset;                  \/* Set of HMMs to be re-estimated *\/$/;"	v	file:
hset	HTKTools/HRest.c	/^static HMMSet hset;        \/* The current unitary hmm set *\/$/;"	v	file:
hset	HTKTools/HSmooth.c	/^static HMMSet hset;        \/* Set of HMMs to be re-estimated *\/$/;"	v	file:
hset	HTKTools/HVite.c	/^static HMMSet hset;               \/* the HMM set *\/$/;"	v	file:
hset_prior	HTKTools/HMMIRest.c	/^static HMMSet hset_prior;            \/* Usually uninitialised, except for MMI-MAP\/MPE-MAP *\/$/;"	v	file:
hset_prior_dir	HTKTools/HMMIRest.c	/^static char *hset_prior_dir = NULL;$/;"	v	file:
hset_prior_initialised	HTKTools/HMMIRest.c	/^Boolean hset_prior_initialised = FALSE;$/;"	v
hsgen_vc_id	HTKTools/HSGen.c	/^char *hsgen_vc_id = "$Id: HSGen.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hsgen_version	HTKTools/HSGen.c	/^char *hsgen_version = "!HVER!HSGen:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hshell_vc_id	HTKLib/HShell.c	/^char *hshell_vc_id = "$Id: HShell.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hshell_version	HTKLib/HShell.c	/^char *hshell_version = "!HVER!HShell:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hsigp_vc_id	HTKLib/HSigP.c	/^char *hsigp_vc_id = "$Id: HSigP.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
hsigp_version	HTKLib/HSigP.c	/^char *hsigp_version = "!HVER!HSigP:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hslab_vc_id	HTKTools/HSLab.c	/^char *hslab_vc_id = "$Id: HSLab.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hslab_version	HTKTools/HSLab.c	/^char *hslab_version = "!HVER!HSLab:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hsmooth_vc_id	HTKTools/HSmooth.c	/^char *hsmooth_vc_id = "$Id: HSmooth.c,v 1.1.1.1 2006\/10\/11 09:55:01 jal58 Exp $";$/;"	v
hsmooth_version	HTKTools/HSmooth.c	/^char *hsmooth_version = "!HVER!HSmooth:   3.4.1 [CUED 12\/03\/09]";$/;"	v
htab	HLMLib/LCMap.h	/^   ClassEntry *htab[CLMHASHSIZE];  \/* hash table of ClassEntrys *\/$/;"	m	struct:__anon1
htab	HLMLib/LModel.h	/^   HashTab *htab;            \/* hash table for names *\/$/;"	m	struct:__anon15
htkEsc	HLMLib/LCMap.h	/^   Boolean htkEsc;              \/* has HTK escaping *\/$/;"	m	struct:__anon1
htkEsc	HLMLib/LModel.c	/^static Boolean htkEsc = FALSE;          \/* Don't use HTK quoting and escapes *\/$/;"	v	file:
htkEsc	HLMLib/LWMap.h	/^   Boolean htkEsc;       \/* has HTK escaping *\/$/;"	m	struct:__anon23
htkEscape	HLMTools/LAdapt.c	/^static Boolean htkEscape = TRUE;      \/* string escaping for output word map *\/$/;"	v	file:
htkEscape	HLMTools/LGPrep.c	/^static Boolean htkEscape = TRUE;    \/* default escaping *\/$/;"	v	file:
htkLabelTimeScale	HTKLib/HLabel.c	/^static double htkLabelTimeScale = 1; \/* multiply all times in HTK format labels by this on reading *\/$/;"	v	file:
htkWidth	HTKTools/HResults.c	/^static int  htkWidth  = 66;     \/* width of output banners *\/$/;"	v	file:
htool HDecode	HTKBook/htkoview.tex	/^\\subsubsection{\\htool{HDecode}}$/;"	b
htool HLRescore	HTKBook/htkoview.tex	/^\\subsubsection{\\htool{HLRescore}}$/;"	b
htool HVite	HTKBook/htkoview.tex	/^\\subsubsection{\\htool{HVite}}$/;"	b
htrain_vc_id	HTKLib/HTrain.c	/^char *htrain_vc_id = "$Id: HTrain.c,v 1.1.1.1 2006\/10\/11 09:54:58 jal58 Exp $";$/;"	v
htrain_version	HTKLib/HTrain.c	/^char *htrain_version = "!HVER!HTrain:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hutil_vc_id	HTKLib/HUtil.c	/^char *hutil_vc_id = "$Id: HUtil.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hutil_version	HTKLib/HUtil.c	/^char *hutil_version = "!HVER!HUtil:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hvite_vc_id	HTKTools/HVite.c	/^char *hvite_vc_id = "$Id: HVite.c,v 1.1.1.1 2006\/10\/11 09:55:02 jal58 Exp $";$/;"	v
hvite_version	HTKTools/HVite.c	/^char *hvite_version = "!HVER!HVite:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hvq_vc_id	HTKLib/HVQ.c	/^char *hvq_vc_id = "$Id: HVQ.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hvq_version	HTKLib/HVQ.c	/^char *hvq_version = "!HVER!HVQ:   3.4.1 [CUED 12\/03\/09]";$/;"	v
hvs	HTKLVRec/HLVLM.c	/^static int hvs[]= { 165902236, 220889002, 32510287, 117809592,$/;"	v	file:
hvs	HTKLib/HLM.c	/^static int hvs[]= { 165902236, 220889002, 32510287, 117809592,$/;"	v	file:
hwave_vc_id	HTKLib/HWave.c	/^char *hwave_vc_id = "$Id: HWave.c,v 1.1.1.1 2006\/10\/11 09:54:59 jal58 Exp $";$/;"	v
hwave_version	HTKLib/HWave.c	/^char *hwave_version = "!HVER!HWave:   3.4.1 [CUED 12\/03\/09]";$/;"	v
i	HTKLVRec/kenlm/util/bit_packing.hh	/^typedef union { float f; uint32_t i; } FloatEnc;$/;"	m	union:util::__anon65
i	HTKLib/HParm.c	/^      Ptr i;            \/* data for external source *\/$/;"	m	union:_ParmBuf::__anon143	file:
i	HTKLib/HParm.h	/^   Ptr i;                     \/* the other input - if any *\/$/;"	m	struct:__anon149
i	HTKLib/HShell.h	/^   int i;$/;"	m	union:__anon156
i	HTKLib/HUtil.h	/^   int i;            \/* current state index 2..N-1 *\/$/;"	m	struct:__anon169
iStack	HTKTools/HCompV.c	/^static MemHeap iStack;$/;"	v	file:
iStack	HTKTools/HCopy.c	/^static MemHeap iStack;          \/* input stack *\/$/;"	v	file:
iStack	HTKTools/HQuant.c	/^static MemHeap iStack;             \/* input buffer  *\/$/;"	v	file:
i_label	HTKLib/HFBLat.c	/^   int i_label;$/;"	m	struct:__anon100	file:
ic	HTKLib/HNet.c	/^   int ic;          \/* Initial context - cache saves finding for all links *\/$/;"	m	struct:pronholder	file:
id	HLMLib/LCMap.h	/^   LabId id;		   \/* name of class id->aux points here *\/$/;"	m	struct:clEntry
id	HLMLib/LModel.h	/^  int    id;                 \/* private ID used for dynamic count lookups *\/$/;"	m	struct:__anon14
id	HLMLib/LWMap.h	/^   LabId    *id;         \/* array[0..used-1] of labid: aux-> MapEntry *\/$/;"	m	struct:__anon23
id	HLMTools/Cluster.c	/^   UInt id;	  \/* Word id *\/$/;"	m	struct:__anon24	file:
id	HTKLVRec/HLVRec.h	/^   unsigned int id;             \/*####  should be only 2byte short! *\/$/;"	m	struct:_TokenSet
id	HTKLib/HArc.h	/^  int id;   \/*numbering from 1..nArcs for arcs which will be used for forward-backward alignment; $/;"	m	struct:_Arc
id	HTKLib/HGraf.h	/^   ButtonId id; $/;"	m	struct:_HButton
id	HTKLib/HModel.h	/^   LabId id;               \/* name of macro *\/$/;"	m	struct:_MacroDef
id	HTKLib/HRec.c	/^   int id;                  \/* Unique identifier for current frame *\/$/;"	m	struct:precomp	file:
id	HTKLib/HRec.c	/^   int id;                  \/* Unique observation identifier *\/$/;"	m	struct:precinfo	file:
id	HTKLib/HWave.c	/^   int32 id;          \/* must be 'FORM' *\/$/;"	m	struct:__anon177	file:
id	HTKLib/HWave.c	/^   int32 id;$/;"	m	struct:__anon178	file:
id_sort	HLMTools/Cluster.c	/^int id_sort(UInt *in1, UInt *in2)$/;"	f
ident	HTKTools/HParse.c	/^static LabId ident;                 \/* Current identifier, if any *\/$/;"	v	file:
idx	HTKLVRec/HLVRec.h	/^   int idx;$/;"	m	struct:_LMNodeCache
idx	HTKLVRec/HLVRec.h	/^   unsigned int idx;$/;"	m	struct:_LMLACacheEntry
idx	HTKTools/HHEd.c	/^   int idx;                     \/* index of this item *\/$/;"	m	struct:_CRec	file:
ifmt	HTKTools/HLEd.c	/^static FileFormat ifmt=UNDEFF;      \/* Label input file format *\/$/;"	v	file:
ifmt	HTKTools/HLRescore.c	/^static FileFormat ifmt=UNDEFF;  \/* Label input file format *\/$/;"	v	file:
ifmt	HTKTools/HSLab.c	/^static FileFormat ifmt=UNDEFF;      \/* Label input file format *\/$/;"	v	file:
ifmt	HTKTools/HVite.c	/^static FileFormat ifmt=UNDEFF;    \/* Label input file format *\/$/;"	v	file:
ignoreCase	HTKTools/HResults.c	/^static Boolean ignoreCase = FALSE;    \/* true converts labels to upper case *\/$/;"	v	file:
ilist	HTKLib/HModel.h	/^  ILink *ilist;        \/* 1..numClasses of ilists *\/$/;"	m	struct:__anon129
ilist	HTKTools/HHEd.c	/^   ILink ilist;$/;"	m	struct:_QEnt	file:
imag	HTKLib/esignal.h	/^typedef struct {Schar	real, imag;}	ScharComplex;$/;"	m	struct:__anon186
imag	HTKLib/esignal.h	/^typedef struct {double	real, imag;}	DoubleComplex;$/;"	m	struct:__anon182
imag	HTKLib/esignal.h	/^typedef struct {float	real, imag;}	FloatComplex;$/;"	m	struct:__anon183
imag	HTKLib/esignal.h	/^typedef struct {long	real, imag;}	LongComplex;$/;"	m	struct:__anon184
imag	HTKLib/esignal.h	/^typedef struct {short	real, imag;}	ShortComplex;$/;"	m	struct:__anon185
imapFN	HLMTools/LGPrep.c	/^static char *imapFN  = NULL;        \/* input word map filename *\/$/;"	v	file:
imem	HLMTools/Cluster.c	/^static MemHeap      imem;                   \/* memory for input gram file set *\/$/;"	v	file:
imem2	HLMTools/Cluster.c	/^static MemHeap      imem2;                  \/* memory for input gram file set (copy) *\/$/;"	v	file:
immed	HTKLib/HLabel.h	/^   ImmDef immed;     \/* Immediate Definition for MLF_IMMEDIATE *\/$/;"	m	union:__anon110
import_classmap	HLMTools/Cluster.c	/^void import_classmap(char *fname, int numb_words)$/;"	f
in	HTKLib/HParm.c	/^   in;$/;"	m	struct:_ParmBuf	typeref:union:_ParmBuf::__anon143	file:
inBinary	HTKTools/HHEd.c	/^static Boolean inBinary = FALSE; \/* set to save models in binary *\/$/;"	v	file:
inBufPos	HTKLib/HAudio.c	/^   int inBufPos;             \/* Position to write in to buffer *\/$/;"	m	struct:_AudioIn	file:
inCMapRaw	HLMLib/LCMap.c	/^static Boolean inCMapRaw = FALSE;        \/* Read input files in raw mode *\/$/;"	v	file:
inCMapRaw	HLMTools/Cluster.c	/^static Boolean     inCMapRaw = FALSE;       \/* Input classes in raw mode *\/$/;"	v	file:
inCMapRawTrap	HLMTools/Cluster.c	/^static Boolean     inCMapRawTrap = FALSE;   \/* Has this been changed by config file? *\/$/;"	v	file:
inClass	HLMLib/LCMap.h	/^   Boolean inClass;	   \/* "in class" class *\/$/;"	m	struct:clEntry
inConn	HTKLib/HAudio.c	/^   char inConn[30];   $/;"	m	struct:_AudioIn	file:
inOLap	HTKLib/HAudio.c	/^   int inOLap;               \/* num samples in frOLap *\/$/;"	m	struct:_AudioIn	file:
inRow	HTKLib/HParm.c	/^   int inRow;          \/* Absolute row number of next to read (nRows+stRow) *\/$/;"	m	struct:_ParmBuf	file:
inSet	HLMLib/LPCalc.h	/^   NGInputSet   *inSet;               \/* input n-gram file set *\/$/;"	m	struct:__anon16
inSet	HLMTools/LAdapt.c	/^static NGInputSet inSet;             \/* input set of files *\/$/;"	v	file:
inSet	HLMTools/LBuild.c	/^static NGInputSet inSet;$/;"	v	file:
inSet	HLMTools/LFoF.c	/^static NGInputSet inSet;            \/* input file set *\/$/;"	v	file:
inSpkrPat	HTKLib/HAdapt.h	/^  char *inSpkrPat;$/;"	m	struct:__anon89
inWMapRaw	HLMLib/LWMap.c	/^static Boolean inWMapRaw = FALSE;    \/* Read input files in raw mode *\/$/;"	v	file:
inXForm	HTKLVRec/HLVRec.c	/^static AdaptXForm *inXForm;$/;"	v	file:
inXForm	HTKLib/HAdapt.h	/^  AdaptXForm *inXForm;$/;"	m	struct:__anon89
inXForm	HTKLib/HFB.h	/^  AdaptXForm *inXForm;\/* current input transform (if any) *\/$/;"	m	struct:__anon99
inXForm	HTKLib/HFBLat.h	/^  AdaptXForm *inXForm;\/* current input transform (if any) *\/$/;"	m	struct:__anon102
inXForm	HTKLib/HRec.c	/^static AdaptXForm *inXForm;$/;"	v	file:
inXFormExt	HTKLib/HAdapt.h	/^  char *inXFormExt;$/;"	m	struct:__anon89
in_	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^    util::FilePiece in_;$/;"	m	class:lm::interpolate::ARPAToStream
in_	HTKLVRec/kenlm/util/stream/chain.hh	/^    PCQueue<Block> *in_, *out_;$/;"	m	class:util::stream::ChainPosition
in_	HTKLVRec/kenlm/util/stream/chain.hh	/^    PCQueue<Block> *in_, *out_;$/;"	m	class:util::stream::Link
in_	HTKLVRec/kenlm/util/stream/sort.hh	/^    const int in_;$/;"	m	class:util::stream::MergeQueue
in_	HTKLVRec/kenlm/util/stream/sort.hh	/^    int in_;$/;"	m	class:util::stream::MergingReader
in_	HTKLVRec/kenlm/util/thread_pool.hh	/^    PCQueue<Request> &in_;$/;"	m	class:util::Worker
in_	HTKLVRec/kenlm/util/thread_pool.hh	/^    PCQueue<Request> in_;$/;"	m	class:util::ThreadPool
in_buffer_	HTKLVRec/kenlm/util/read_compressed.cc	/^    scoped_malloc in_buffer_;$/;"	m	class:util::__anon79::StreamCompressed	file:
in_offsets_	HTKLVRec/kenlm/util/stream/sort.hh	/^    Offsets *in_offsets_;$/;"	m	class:util::stream::MergingReader
inbuf	HTKTools/HDMan.c	/^static DBuffer inbuf[MAXDICTS];      \/* the input buffers and associated scripts *\/$/;"	v	file:
inc	HLMTools/Makefile	/^inc     = 	..\/HTKLib$/;"	m
inc	HTKLVRec/Makefile	/^inc     = 	..\/HTKLib$/;"	m
inc	HTKTools/Makefile	/^inc = ..\/HTKLib$/;"	m
incLab	HTKTools/HSLab.c	/^static Boolean incLab       = FALSE;   \/* increment global label *\/$/;"	v	file:
incOutSyms	HTKTools/HDMan.c	/^static Boolean incOutSyms = FALSE;   \/* write out extra field *\/$/;"	v	file:
incProbs	HTKTools/HDMan.c	/^static Boolean incProbs = FALSE;     \/* write out extra field *\/$/;"	v	file:
incSpaces	HTKLib/HLabel.c	/^static Boolean incSpaces;$/;"	v	file:
include_vocab	HTKLVRec/kenlm/lm/config.hh	/^  bool include_vocab;$/;"	m	struct:lm::ngram::Config
includedir	HLMLib/Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	HLMTools/Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	HTKLVRec/Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	HTKLib/Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	HTKTools/Makefile	/^includedir = ${prefix}\/include$/;"	m
includedir	Makefile	/^includedir = ${prefix}\/include$/;"	m
incoming_	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    std::priority_queue<Arc*, std::vector<Arc*>, ArcGreater> incoming_;$/;"	m	class:lm::phrase::detail::Vertex	file:
increment	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    void increment() {$/;"	f	class:util::TokenIter
indent	HTKLib/esignal.h	/^    int     indent;$/;"	m	struct:Annot
independent_left	HTKLVRec/kenlm/lm/return.hh	/^  bool independent_left;$/;"	m	struct:lm::FullScoreReturn
index	HTKLVRec/kenlm/lm/search_trie.cc	/^  uint64_t index;$/;"	m	struct:lm::ngram::trie::__anon58::ProbPointer	file:
index	HTKLib/HAudio.c	/^   int index;             \/* Index of buffer *\/$/;"	m	struct:mmapibuf	file:
index	HTKLib/HModel.h	/^   short index;          \/* mixture index *\/$/;"	m	struct:__anon123
indexSet	HTKLib/HModel.c	/^static Boolean indexSet = FALSE;        \/* have the indexes been set for the model set *\/$/;"	v	file:
indx	HTKLib/HTrain.h	/^   int indx;$/;"	m	struct:__anon167
infinity_symbol_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const char* const infinity_symbol_;$/;"	m	class:double_conversion::DoubleToStringConverter
infinity_symbol_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const char* const infinity_symbol_;$/;"	m	class:double_conversion::StringToDoubleConverter
info	HLMLib/LGBase.h	/^   NGInfo info;             \/* ngram size information *\/$/;"	m	struct:__anon3
info	HLMLib/LGBase.h	/^   NGInfo info;            \/* N-gram size and related byte sizes *\/$/;"	m	struct:__anon5
info	HTKLib/HModel.h	/^   Ptr info;            \/* hook to hang information from *\/$/;"	m	struct:__anon120
info	HTKLib/HModel.h	/^   StateInfo *info;     \/* information for this state *\/$/;"	m	struct:__anon127
info	HTKLib/HModel.h	/^  Ptr info;                 \/* hook to hang information from *\/$/;"	m	struct:_RegNode
info	HTKLib/HModel.h	/^  XFormAccInfo *info;               \/* information abbout the accumulates for this transform *\/$/;"	m	struct:_AdaptXForm
info	HTKLib/HNet.h	/^   info;                \/* Extra information specific to type of node *\/$/;"	m	struct:_NetNode	typeref:union:_NetNode::__anon138
info	HTKLib/HWave.c	/^   char info[4];  $/;"	m	struct:__anon176	file:
info	HTKTools/HQuant.c	/^static BufferInfo info;             \/* global observation format, etc. *\/$/;"	v	file:
infoPrinted	HTKLib/HShell.c	/^static Boolean infoPrinted = FALSE;      \/* set when -A -B or -V is used *\/$/;"	v	file:
infoStack	HTKLib/HAdapt.c	/^static MemHeap infoStack;$/;"	v	file:
infodir	HLMLib/Makefile	/^infodir = ${prefix}\/share\/info$/;"	m
infodir	HLMTools/Makefile	/^infodir = ${prefix}\/share\/info$/;"	m
infodir	HTKLVRec/Makefile	/^infodir = ${prefix}\/share\/info$/;"	m
infodir	HTKLib/Makefile	/^infodir = ${prefix}\/share\/info$/;"	m
infodir	HTKTools/Makefile	/^infodir = ${prefix}\/share\/info$/;"	m
infodir	Makefile	/^infodir = ${prefix}\/share\/info$/;"	m
initNuisanceFR	HTKLib/HAdapt.c	/^static Boolean initNuisanceFR = TRUE;$/;"	v	file:
initNuisanceFRIdent	HTKLib/HAdapt.c	/^static Boolean initNuisanceFRIdent = FALSE;$/;"	v	file:
initial	HTKLVRec/HLVLM.h	/^   LMState initial;$/;"	m	struct:_FSLM
initial	HTKLib/HNet.h	/^   NetNode initial;   \/* Initial (dummy) node *\/$/;"	m	struct:__anon139
initial_bigram_buffer	HLMTools/Cluster.c	73;"	d	file:
initial_cluster	HLMTools/Cluster.c	/^void initial_cluster(void)$/;"	f
initial_probs	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  InitialProbabilitiesConfig initial_probs;$/;"	m	struct:lm::builder::PipelineConfig
initial_read_	HTKLVRec/kenlm/lm/filter/count_io.hh	/^    std::streamsize initial_read_;$/;"	m	class:lm::CountBatch
initialized_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    bool initialized_;$/;"	m	class:util::ProbingHashTable
inlyne	HTKTools/HParse.c	/^static char inlyne[SCANBUFMAX+1];   \/* (Portion of) current input line *\/$/;"	v	file:
inner_	HTKLVRec/kenlm/lm/trie_sort.cc	/^    InnerIterator inner_;$/;"	m	class:lm::ngram::trie::__anon60::PartialViewProxy	file:
inner_	HTKLVRec/kenlm/lm/vocab.hh	/^    EnumerateVocab *inner_;$/;"	m	class:lm::ngram::WriteWordsWrapper
inner_	HTKLVRec/kenlm/util/joint_sort.hh	/^    InnerIterator inner_;$/;"	m	class:util::detail::JointProxy
inner_	HTKLVRec/kenlm/util/sized_iterator.hh	/^    InnerIterator inner_;$/;"	m	class:util::SizedProxy
inputBufHeap	HTKLVRec/HDecode.c	/^static MemHeap inputBufHeap;$/;"	v	file:
inputBufHeap	HTKLVRec/HDecode.mod.c	/^static MemHeap inputBufHeap;$/;"	v	file:
input_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    const util::stream::ChainPosition input_;$/;"	m	class:lm::builder::__anon45::AddRight	file:
input_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    InputBuffer *input_;$/;"	m	class:lm::Controller
input_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    InputBuffer input_;$/;"	m	class:lm::ThreadBatch
input_file	HTKLVRec/kenlm/lm/builder/header_info.hh	/^  std::string input_file;$/;"	m	struct:HeaderInfo
ins	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Cell	file:
ins	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Spkr	file:
ins	HTKTools/HResults.c	/^static long ins   = 0;     \/* Total insertions *\/$/;"	v	file:
insPen	HTKLVRec/HDecode.c	/^static LogFloat insPen = 0.0;   \/* word insertion penalty *\/$/;"	v	file:
insPen	HTKLVRec/HDecode.mod.c	/^static LogFloat insPen = 0.0;   \/* word insertion penalty *\/$/;"	v	file:
insPen	HTKLVRec/HLVRec.h	/^   LogFloat insPen;             \/* word insertion penalty *\/$/;"	m	struct:_DecoderInst
insPen	HTKLib/HArc.h	/^  float insPen; $/;"	m	struct:ArcInfoStruct
insPen	HTKTools/HResults.c	/^static const int insPen = 7;$/;"	v	file:
insPenNIST	HTKTools/HResults.c	/^static const int insPenNIST = 3;$/;"	v	file:
insert_index_	HTKLVRec/kenlm/lm/trie.hh	/^    uint64_t insert_index_, max_vocab_;$/;"	m	class:lm::ngram::trie::BitPacked
inset	HLMTools/Cluster.c	/^static NGInputSet   inset;                  \/* input gram file set *\/$/;"	v	file:
inset	HLMTools/LGCopy.c	/^static NGInputSet inset;            \/* input file set *\/$/;"	v	file:
inset2	HLMTools/Cluster.c	/^static NGInputSet   inset2;                 \/* input gram file set (copy) *\/$/;"	v	file:
inst	HTKLVRec/HLVNet.h	/^   LexNodeInst *inst;		\/* model instance or NULL if inactive *\/$/;"	m	struct:_LexNode
inst	HTKLib/HNet.h	/^   NetInst *inst;       \/* Model Instance (if one exists, else NULL) *\/   $/;"	m	struct:_NetNode
instHeap	HTKLib/HRec.c	/^   MemHeap instHeap;        \/* Inst heap *\/$/;"	m	struct:precinfo	file:
instsLayer	HTKLVRec/HLVRec.h	/^   LexNodeInst **instsLayer;    \/* array of pointers to the linked list of $/;"	m	struct:_DecoderInst
int16_t	HTKLVRec/kenlm/util/double-conversion/utils.h	/^typedef short int16_t;  \/\/ NOLINT$/;"	t
int32	HTKLib/HShell.h	/^typedef int int32;$/;"	t
int32_t	HTKLVRec/kenlm/util/double-conversion/utils.h	/^typedef int int32_t;$/;"	t
int64_t	HTKLVRec/kenlm/util/double-conversion/utils.h	/^typedef __int64 int64_t;$/;"	t
int8_t	HTKLVRec/kenlm/util/double-conversion/utils.h	/^typedef signed char int8_t;$/;"	t
internal_	HTKLVRec/kenlm/util/read_compressed.hh	/^    scoped_ptr<ReadBase> internal_;$/;"	m	class:util::ReadCompressed
interpolate	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.cc	/^namespace lm { namespace interpolate {$/;"	n	namespace:lm	file:
interpolate	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^namespace interpolate {$/;"	n	namespace:lm
interpolate_unigrams	HTKLVRec/kenlm/lm/builder/initial_probabilities.hh	/^  bool interpolate_unigrams;$/;"	m	struct:lm::builder::InitialProbabilitiesConfig
interpolate_unigrams_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    bool interpolate_unigrams_;$/;"	m	class:lm::builder::__anon45::MergeRight	file:
inv	HTKLib/HMath.h	/^   STriMat inv;         \/* if FULLC or LLTC *\/$/;"	m	union:__anon114
invVarOffset	HTKLVRec/HLVModel.h	/^   size_t invVarOffset;         \/* 4 + nDim * floatsPerMix*\/$/;"	m	struct:_StateInfo_lv
invalid_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    Key invalid_;$/;"	m	class:util::ProbingHashTable
invalid_header	HLMTools/Cluster.c	/^static void invalid_header(void)$/;"	f	file:
inx	HTKLib/HAudio.c	/^   int inx,outx;         \/* in\/out indices - wrap modulo size *\/$/;"	m	struct:__anon92	file:
ioConfName	HTKLib/HParm.c	/^static char * ioConfName[CFGSIZE] = {$/;"	v	file:
io_Win	HTKTools/HSLab.c	/^static RectWin io_Win;       \/* the I\/O window used for messages and inputing strings *\/$/;"	v	file:
iphone	HTKLib/HArc.h	/^  int iphone; \/* (int) correct phone. *\/$/;"	m	struct:_CorrN
ipos	HTKLib/HRec.c	/^   int ipos;                \/* Current inst position *\/$/;"	m	struct:precinfo	file:
ipos	HTKLib/HRec.c	/^   int ipos;$/;"	m	struct:_NetInst	file:
isActive	HTKLib/HAudio.c	/^   AudioDevStatus isActive;  \/* indicates when device active *\/$/;"	m	struct:_AudioIn	file:
isActive	HTKLib/HAudio.c	/^   Boolean isActive;         \/* true when device active *\/$/;"	m	struct:_AudioOut	file:
isActive	HTKLib/HAudio.c	/^   Boolean isActive;     \/* true if in use *\/$/;"	m	struct:__anon92	file:
isAudio	HTKTools/HList.c	/^   Boolean isAudio;$/;"	m	struct:__anon202	file:
isCont	HTKLib/HUtil.h	/^   Boolean isCont;   \/* true PLAINHS or SHAREDHS *\/$/;"	m	struct:__anon169
isDigit	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^static bool isDigit(int x, int radix) {$/;"	f	namespace:double_conversion
isLoaded	HTKLib/HModel.h	/^   Boolean isLoaded;       \/* true if contents are loaded *\/$/;"	m	struct:_MMFInfo
isLogging	HTKTools/HDMan.c	/^static Boolean isLogging = FALSE;$/;"	v	file:
isMap	HLMLib/LWMap.h	/^   Boolean isMap;        \/* true if map, false if word list *\/$/;"	m	struct:__anon23
isPipe	HTKLib/HShell.h	/^   Boolean isPipe;      \/* input is a pipe *\/$/;"	m	struct:__anon154
isPipe	HTKLib/HWave.c	/^   Boolean isPipe;      \/* Source is a pipe *\/$/;"	m	struct:_Wave	file:
isPipe	HTKTools/HDMan.c	/^   Boolean isPipe;              \/* dictionary is input thru pipe *\/$/;"	m	struct:__anon195	file:
isSorted	HLMLib/LWMap.h	/^   Boolean isSorted;     \/* used to avoid redundant sorts *\/$/;"	m	struct:__anon23
isSource	HTKTools/HList.c	/^   Boolean isSource;$/;"	m	struct:__anon202	file:
isTree	HTKLib/HTrain.h	/^   Boolean isTree; \/* true if tree clustered *\/$/;"	m	struct:__anon162
is_empty	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  bool is_empty() const { return length_ == 0; }$/;"	f	class:double_conversion::Vector
is_finalized	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  bool is_finalized() const { return position_ < 0; }$/;"	f	class:double_conversion::StringBuilder
is_nonsil	HTKLib/HFBLat.c	/^   int is_nonsil;  \/* used in SetCorrectnessAsError *\/$/;"	m	struct:__anon100	file:
isnan	HTKLib/HMath.h	30;"	d
it_	HTKLVRec/kenlm/lm/search_trie.cc	/^    float *it_[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::trie::__anon58::SRISucks	file:
item	HLMTools/LGPrep.c	/^   LabId item[MAX_ITEMS];     \/* list of words *\/$/;"	m	struct:__anon29	file:
item	HTKLib/HModel.h	/^   Ptr item;         \/* -> to a HMM structure *\/$/;"	m	struct:_ItemRec
item	HTKTools/HHEd.c	/^   ILink item;                  \/* a single item in this cluster (group) *\/$/;"	m	struct:_CRec	file:
itemHeap	HTKLib/HUtil.c	/^static MemHeap itemHeap;$/;"	v	file:
items	HTKLib/HTrain.h	/^   Ptr *items;       \/* array[0..blkSize-1] of items *\/$/;"	m	struct:_ItemBlock
iterator	HTKLVRec/kenlm/util/string_piece.hh	/^  typedef const char* iterator;$/;"	t	class:StringPiece
iterator_category	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    typedef std::random_access_iterator_tag iterator_category;$/;"	t	class:util::ProxyIterator
jMatHeap	HTKTools/HParse.c	/^MemHeap  jMatHeap;$/;"	v
jmCols	HTKTools/HParse.c	/^static int jmRows,jmCols;      \/* size of JoinMatrix *\/$/;"	v	file:
jmRows	HTKTools/HParse.c	/^static int jmRows,jmCols;      \/* size of JoinMatrix *\/$/;"	v	file:
jmat	HTKTools/HParse.c	/^static JoinMatrix jmat;        \/* binary join matrix *\/$/;"	v	file:
joinFloor	HTKTools/HHEd.c	/^static float joinFloor;                \/* join mix weight floor (* MINMIX) *\/$/;"	v	file:
joinHeap	HTKTools/HParse.c	/^MemHeap  joinHeap;$/;"	v
joinSet	HTKTools/HHEd.c	/^static MixtureElem *joinSet;           \/* current join Mix Set *\/$/;"	v	file:
joinSize	HTKTools/HHEd.c	/^static int joinSize=0;                 \/* number of mixes in a joined pdf *\/$/;"	v	file:
junk_string_value_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const double junk_string_value_;$/;"	m	class:double_conversion::StringToDoubleConverter
k	HTKLib/HParm.c	/^   Vector a,k;        \/* lpc and refc vectors *\/$/;"	m	struct:__anon141	file:
kARPASpaces	HTKLVRec/kenlm/lm/read_arpa.cc	/^const bool kARPASpaces[256] = {0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};$/;"	m	namespace:lm	file:
kArrayAdd	HTKLVRec/kenlm/lm/model_type.hh	/^const static ModelType kArrayAdd = static_cast<ModelType>(ARRAY_TRIE - TRIE);$/;"	m	namespace:lm::ngram
kArrayBhikshaVersion	HTKLVRec/kenlm/lm/bhiksha.cc	/^const uint8_t kArrayBhikshaVersion = 0;$/;"	m	namespace:lm::ngram::trie	file:
kBOS	HTKLVRec/kenlm/lm/builder/ngram.hh	/^const WordIndex kBOS = 1;$/;"	m	namespace:lm::builder
kBadProb	HTKLVRec/kenlm/lm/search_trie.cc	/^const float kBadProb = std::numeric_limits<float>::infinity();$/;"	m	namespace:lm::ngram::trie::__anon58	file:
kBadSize	HTKLVRec/kenlm/util/file.hh	/^const uint64_t kBadSize = (uint64_t)-1;$/;"	m	namespace:util
kBase10MaximalLength	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  static const int kBase10MaximalLength = 17;$/;"	m	class:double_conversion::DoubleToStringConverter
kBigitCapacity	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static const int kBigitCapacity = kMaxSignificantBits \/ kBigitSize;$/;"	m	class:double_conversion::Bignum
kBigitMask	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static const Chunk kBigitMask = (1 << kBigitSize) - 1;$/;"	m	class:double_conversion::Bignum
kBigitSize	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static const int kBigitSize = 28;$/;"	m	class:double_conversion::Bignum
kBinaryMagic	HTKLVRec/kenlm/lm/read_arpa.cc	/^const char kBinaryMagic[] = "mmap lm http:\/\/kheafield.com\/code";$/;"	m	namespace:lm::__anon56	file:
kCachedPowers	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^static const CachedPower kCachedPowers[] = {$/;"	m	namespace:double_conversion	file:
kCachedPowersLength	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^static const int kCachedPowersLength = ARRAY_SIZE(kCachedPowers);$/;"	m	namespace:double_conversion	file:
kCachedPowersOffset	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^static const int kCachedPowersOffset = 348;  \/\/ -1 * the first decimal_exponent.$/;"	m	namespace:double_conversion	file:
kCharSize	HTKLVRec/kenlm/util/double-conversion/utils.h	/^static const int kCharSize = sizeof(char);$/;"	m	namespace:double_conversion
kChunkSize	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static const int kChunkSize = sizeof(Chunk) * 8;$/;"	m	class:double_conversion::Bignum
kD_1_LOG2_10	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^static const double kD_1_LOG2_10 = 0.30102999566398114;  \/\/  1 \/ lg(10)$/;"	m	namespace:double_conversion	file:
kDecimalExponentDistance	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^const int PowersOfTenCache::kDecimalExponentDistance = 8;$/;"	m	class:double_conversion::PowersOfTenCache	file:
kDecimalExponentDistance	HTKLVRec/kenlm/util/double-conversion/cached-powers.h	/^  static const int kDecimalExponentDistance;$/;"	m	class:double_conversion::PowersOfTenCache
kDenormalExponent	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const int kDenormalExponent = -kExponentBias + 1;$/;"	m	class:double_conversion::Double
kDenormalExponent	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const int kDenormalExponent = -kExponentBias + 1;$/;"	m	class:double_conversion::Single
kDifferentRest	HTKLVRec/kenlm/lm/search_hashed.hh	/^    static const bool kDifferentRest = Value::kDifferentRest;$/;"	m	class:lm::ngram::detail::HashedSearch
kDifferentRest	HTKLVRec/kenlm/lm/search_trie.hh	/^    static const bool kDifferentRest = false;$/;"	m	class:lm::ngram::trie::TrieSearch
kDifferentRest	HTKLVRec/kenlm/lm/value.hh	/^  const static bool kDifferentRest = false;$/;"	m	struct:lm::ngram::BackoffValue
kDifferentRest	HTKLVRec/kenlm/lm/value.hh	/^  const static bool kDifferentRest = true;$/;"	m	struct:lm::ngram::RestValue
kDisplayCharacters	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^const char kDisplayCharacters[] = "-+*#0123456789";$/;"	m	namespace:util::stream::__anon81	file:
kDoubleChunkSize	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static const int kDoubleChunkSize = sizeof(DoubleChunk) * 8;$/;"	m	class:double_conversion::Bignum
kDoubleSignificandSize	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^static const int kDoubleSignificandSize = 53;  \/\/ Includes the hidden bit.$/;"	m	namespace:double_conversion	file:
kEOS	HTKLVRec/kenlm/lm/builder/ngram.hh	/^const WordIndex kEOS = 2;$/;"	m	namespace:lm::builder
kExactPowersOfTenSize	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static const int kExactPowersOfTenSize = ARRAY_SIZE(exact_powers_of_ten);$/;"	m	namespace:double_conversion	file:
kExponentBias	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const int kExponentBias = 0x3FF + kPhysicalSignificandSize;$/;"	m	class:double_conversion::Double
kExponentBias	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const int kExponentBias = 0x7F + kPhysicalSignificandSize;$/;"	m	class:double_conversion::Single
kExponentMask	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kExponentMask = 0x7F800000;$/;"	m	class:double_conversion::Single
kExponentMask	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kExponentMask = UINT64_2PART_C(0x7FF00000, 00000000);$/;"	m	class:double_conversion::Double
kExtensionBackoff	HTKLVRec/kenlm/lm/blank.hh	/^const float kExtensionBackoff = 0.0;$/;"	m	namespace:lm::ngram
kExtensionQuant	HTKLVRec/kenlm/lm/blank.hh	/^const uint64_t kExtensionQuant = 1;$/;"	m	namespace:lm::ngram
kFastDtoaMaximalLength	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.h	/^static const int kFastDtoaMaximalLength = 17;$/;"	m	namespace:double_conversion
kFastDtoaMaximalSingleLength	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.h	/^static const int kFastDtoaMaximalSingleLength = 9;$/;"	m	namespace:double_conversion
kFileFlags	HTKLVRec/kenlm/util/mmap.cc	/^const int kFileFlags =$/;"	m	namespace:util	file:
kHiddenBit	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kHiddenBit = 0x00800000;$/;"	m	class:double_conversion::Single
kHiddenBit	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kHiddenBit = UINT64_2PART_C(0x00100000, 00000000);$/;"	m	class:double_conversion::Double
kInfinity	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kInfinity = 0x7F800000;$/;"	m	class:double_conversion::Single
kInfinity	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kInfinity = UINT64_2PART_C(0x7FF00000, 00000000);$/;"	m	class:double_conversion::Double
kInputBuffer	HTKLVRec/kenlm/util/read_compressed.cc	/^static const std::size_t kInputBuffer = 16384;$/;"	m	namespace:util::__anon79	file:
kInvalidOffset	HTKLVRec/kenlm/lm/binary_format.hh	/^    static const uint64_t kInvalidOffset = (uint64_t)-1;$/;"	m	class:lm::ngram::BinaryFormat
kInvalidSize	HTKLVRec/kenlm/lm/binary_format.cc	/^const std::size_t kInvalidSize = static_cast<std::size_t>(-1);$/;"	m	namespace:lm::ngram	file:
kMagicBeforeVersion	HTKLVRec/kenlm/lm/binary_format.cc	/^const char kMagicBeforeVersion[] = "mmap lm http:\/\/kheafield.com\/code format version";$/;"	m	namespace:lm::ngram::__anon41	file:
kMagicBytes	HTKLVRec/kenlm/lm/binary_format.cc	/^const char kMagicBytes[] = "mmap lm http:\/\/kheafield.com\/code format version 5\\n\\0";$/;"	m	namespace:lm::ngram::__anon41	file:
kMagicIncomplete	HTKLVRec/kenlm/lm/binary_format.cc	/^const char kMagicIncomplete[] = "mmap lm http:\/\/kheafield.com\/code incomplete\\n";$/;"	m	namespace:lm::ngram::__anon41	file:
kMagicSize	HTKLVRec/kenlm/util/read_compressed.hh	/^    static const std::size_t kMagicSize = 6;$/;"	m	class:util::ReadCompressed
kMagicVersion	HTKLVRec/kenlm/lm/binary_format.cc	/^const long int kMagicVersion = 5;$/;"	m	namespace:lm::ngram::__anon41	file:
kMarkEvenLower	HTKLVRec/kenlm/lm/value_build.hh	/^    const static bool kMarkEvenLower = false;$/;"	m	class:lm::ngram::LowerRestBuild
kMarkEvenLower	HTKLVRec/kenlm/lm/value_build.hh	/^    const static bool kMarkEvenLower = false;$/;"	m	class:lm::ngram::NoRestBuild
kMarkEvenLower	HTKLVRec/kenlm/lm/value_build.hh	/^    const static bool kMarkEvenLower = true;$/;"	m	class:lm::ngram::MaxRestBuild
kMask32	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^  static const uint64_t kMask32 = 0xFFFFFFFF;$/;"	m	class:double_conversion::UInt128	file:
kMatchOffset	HTKLVRec/kenlm/lm/builder/sort.hh	/^    static const unsigned kMatchOffset = 0;$/;"	m	class:lm::builder::PrefixOrder
kMatchOffset	HTKLVRec/kenlm/lm/builder/sort.hh	/^    static const unsigned kMatchOffset = 1;$/;"	m	class:lm::builder::SuffixOrder
kMaxDWORD	HTKLVRec/kenlm/util/file.cc	/^const std::size_t kMaxDWORD = static_cast<std::size_t>(4294967295UL);$/;"	m	namespace:util::__anon69	file:
kMaxDecimalExponent	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^const int PowersOfTenCache::kMaxDecimalExponent = 340;$/;"	m	class:double_conversion::PowersOfTenCache	file:
kMaxDecimalExponent	HTKLVRec/kenlm/util/double-conversion/cached-powers.h	/^  static const int kMaxDecimalExponent;$/;"	m	class:double_conversion::PowersOfTenCache
kMaxDecimalPower	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static const int kMaxDecimalPower = 309;$/;"	m	namespace:double_conversion	file:
kMaxExactDoubleIntegerDecimalDigits	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static const int kMaxExactDoubleIntegerDecimalDigits = 15;$/;"	m	namespace:double_conversion	file:
kMaxExponent	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const int kMaxExponent = 0x7FF - kExponentBias;$/;"	m	class:double_conversion::Double
kMaxExponent	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const int kMaxExponent = 0xFF - kExponentBias;$/;"	m	class:double_conversion::Single
kMaxExponentialDigits	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  static const int kMaxExponentialDigits = 120;$/;"	m	class:double_conversion::DoubleToStringConverter
kMaxFixedDigitsAfterPoint	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  static const int kMaxFixedDigitsAfterPoint = 60;$/;"	m	class:double_conversion::DoubleToStringConverter
kMaxFixedDigitsBeforePoint	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  static const int kMaxFixedDigitsBeforePoint = 60;$/;"	m	class:double_conversion::DoubleToStringConverter
kMaxPrecisionDigits	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  static const int kMaxPrecisionDigits = 120;$/;"	m	class:double_conversion::DoubleToStringConverter
kMaxSignificantBits	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  static const int kMaxSignificantBits = 3584;$/;"	m	class:double_conversion::Bignum
kMaxSignificantDecimalDigits	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static const int kMaxSignificantDecimalDigits = 780;$/;"	m	namespace:double_conversion	file:
kMaxSignificantDigits	HTKLVRec/kenlm/util/double-conversion/double-conversion.cc	/^const int kMaxSignificantDigits = 772;$/;"	m	namespace:double_conversion	file:
kMaxUint64	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static const uint64_t kMaxUint64 = UINT64_2PART_C(0xFFFFFFFF, FFFFFFFF);$/;"	m	namespace:double_conversion	file:
kMaxUint64DecimalDigits	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static const int kMaxUint64DecimalDigits = 19;$/;"	m	namespace:double_conversion	file:
kMaxWordIndex	HTKLVRec/kenlm/lm/word_index.hh	/^const WordIndex kMaxWordIndex = UINT_MAX;$/;"	m	namespace:lm
kMaximalTargetExponent	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^static const int kMaximalTargetExponent = -32;$/;"	m	namespace:double_conversion	file:
kMinDecimalExponent	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^const int PowersOfTenCache::kMinDecimalExponent = -348;$/;"	m	class:double_conversion::PowersOfTenCache	file:
kMinDecimalExponent	HTKLVRec/kenlm/util/double-conversion/cached-powers.h	/^  static const int kMinDecimalExponent;$/;"	m	class:double_conversion::PowersOfTenCache
kMinDecimalPower	HTKLVRec/kenlm/util/double-conversion/strtod.cc	/^static const int kMinDecimalPower = -324;$/;"	m	namespace:double_conversion	file:
kMinPrecisionDigits	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  static const int kMinPrecisionDigits = 1;$/;"	m	class:double_conversion::DoubleToStringConverter
kMinimalTargetExponent	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^static const int kMinimalTargetExponent = -60;$/;"	m	namespace:double_conversion	file:
kModelNames	HTKLVRec/kenlm/lm/binary_format.cc	/^const char *kModelNames[6] = {"probing hash tables", "probing hash tables with rest costs", "trie", "trie with quantization", "trie with array-compressed pointers", "trie with quantization and array-compressed pointers"};$/;"	m	namespace:lm::ngram	file:
kModelType	HTKLVRec/kenlm/lm/model.cc	/^template <class Search, class VocabularyT> const ModelType GenericModel<Search, VocabularyT>::kModelType = Search::kModelType;$/;"	m	class:lm::ngram::detail::GenericModel	file:
kModelType	HTKLVRec/kenlm/lm/model.hh	/^    static const ModelType kModelType;$/;"	m	class:lm::ngram::detail::GenericModel
kModelType	HTKLVRec/kenlm/lm/search_hashed.hh	/^    static const ModelType kModelType = Value::kProbingModelType;$/;"	m	class:lm::ngram::detail::HashedSearch
kModelType	HTKLVRec/kenlm/lm/search_trie.hh	/^    static const ModelType kModelType = static_cast<ModelType>(TRIE_SORTED + Quant::kModelTypeAdd + Bhiksha::kModelTypeAdd);$/;"	m	class:lm::ngram::trie::TrieSearch
kModelTypeAdd	HTKLVRec/kenlm/lm/bhiksha.hh	/^    static const ModelType kModelTypeAdd = kArrayAdd;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
kModelTypeAdd	HTKLVRec/kenlm/lm/bhiksha.hh	/^    static const ModelType kModelTypeAdd = static_cast<ModelType>(0);$/;"	m	class:lm::ngram::trie::DontBhiksha
kModelTypeAdd	HTKLVRec/kenlm/lm/quantize.hh	/^    static const ModelType kModelTypeAdd = kQuantAdd;$/;"	m	class:lm::ngram::SeparatelyQuantize
kModelTypeAdd	HTKLVRec/kenlm/lm/quantize.hh	/^    static const ModelType kModelTypeAdd = static_cast<ModelType>(0);$/;"	m	class:lm::ngram::DontQuantize
kNaN	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kNaN = 0x7FC00000;$/;"	m	class:double_conversion::Single
kNaN	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kNaN = UINT64_2PART_C(0x7FF80000, 00000000);$/;"	m	class:double_conversion::Double
kNoExtensionBackoff	HTKLVRec/kenlm/lm/blank.hh	/^const float kNoExtensionBackoff = -0.0;$/;"	m	namespace:lm::ngram
kNoExtensionQuant	HTKLVRec/kenlm/lm/blank.hh	/^const uint64_t kNoExtensionQuant = 0;$/;"	m	namespace:lm::ngram
kPhysicalSignificandSize	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const int kPhysicalSignificandSize = 23;  \/\/ Excludes the hidden bit.$/;"	m	class:double_conversion::Single
kPhysicalSignificandSize	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const int kPhysicalSignificandSize = 52;  \/\/ Excludes the hidden bit.$/;"	m	class:double_conversion::Double
kProbingModelType	HTKLVRec/kenlm/lm/value.hh	/^  static const ModelType kProbingModelType = PROBING;$/;"	m	struct:lm::ngram::BackoffValue
kProbingModelType	HTKLVRec/kenlm/lm/value.hh	/^  static const ModelType kProbingModelType = REST_PROBING;$/;"	m	struct:lm::ngram::RestValue
kProbingMultiplier	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^const float kProbingMultiplier = 1.5;$/;"	m	namespace:lm::builder::__anon43	file:
kProbingVocabularyVersion	HTKLVRec/kenlm/lm/vocab.cc	/^const unsigned int kProbingVocabularyVersion = 0;$/;"	m	namespace:lm::ngram::__anon63	file:
kProgressBanner	HTKLVRec/kenlm/util/ersatz_progress.cc	/^const char kProgressBanner[] = "----5---10---15---20---25---30---35---40---45---50---55---60---65---70---75---80---85---90---95--100\\n";$/;"	m	namespace:util	file:
kQuantAdd	HTKLVRec/kenlm/lm/model_type.hh	/^const static ModelType kQuantAdd = static_cast<ModelType>(QUANT_TRIE - TRIE);$/;"	m	namespace:lm::ngram
kRange	HLMLib/LModel.h	/^   int kRange;              \/* discounting range *\/$/;"	m	struct:__anon10
kRange	HLMLib/LPCalc.h	/^   int          kRange;               \/* discounting range for Turing-Good scheme *\/$/;"	m	struct:__anon16
kRecordStart	HTKLVRec/kenlm/util/usage.cc	/^const RecordStart kRecordStart;$/;"	m	namespace:util::__anon83	file:
kRecycle	HTKLVRec/kenlm/util/stream/chain.cc	/^const Recycler kRecycle = Recycler();$/;"	m	namespace:util::stream	file:
kSeparatelyQuantizeVersion	HTKLVRec/kenlm/lm/quantize.cc	/^const char kSeparatelyQuantizeVersion = 2;$/;"	m	namespace:lm::ngram::__anon55	file:
kSignBit	HTKLVRec/kenlm/util/bit_packing.hh	/^const uint32_t kSignBit = 0x80000000;$/;"	m	namespace:util
kSignMask	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kSignMask = 0x80000000;$/;"	m	class:double_conversion::Single
kSignMask	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kSignMask = UINT64_2PART_C(0x80000000, 00000000);$/;"	m	class:double_conversion::Double
kSignificandMask	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint32_t kSignificandMask = 0x007FFFFF;$/;"	m	class:double_conversion::Single
kSignificandMask	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const uint64_t kSignificandMask = UINT64_2PART_C(0x000FFFFF, FFFFFFFF);$/;"	m	class:double_conversion::Double
kSignificandSize	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  static const int kSignificandSize = 64;$/;"	m	class:double_conversion::DiyFp
kSignificandSize	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const int kSignificandSize = 24;$/;"	m	class:double_conversion::Single
kSignificandSize	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  static const int kSignificandSize = 53;$/;"	m	class:double_conversion::Double
kSmallPowersOfTen	HTKLVRec/kenlm/util/double-conversion/fast-dtoa.cc	/^static unsigned int const kSmallPowersOfTen[] =$/;"	m	namespace:double_conversion	file:
kSpaces	HTKLVRec/kenlm/util/file_piece.cc	/^const bool kSpaces[256] = {0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};$/;"	m	namespace:util	file:
kTrain	HTKLVRec/kenlm/lm/quantize.hh	/^    static const bool kTrain = false;$/;"	m	class:lm::ngram::DontQuantize
kTrain	HTKLVRec/kenlm/lm/quantize.hh	/^    static const bool kTrain = true;$/;"	m	class:lm::ngram::SeparatelyQuantize
kUNK	HTKLVRec/kenlm/lm/builder/ngram.hh	/^const WordIndex kUNK = 0;$/;"	m	namespace:lm::builder
kUint64MSB	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  static const uint64_t kUint64MSB = UINT64_2PART_C(0x80000000, 00000000);$/;"	m	class:double_conversion::DiyFp
kUnknownCapHash	HTKLVRec/kenlm/lm/vocab.cc	/^const uint64_t kUnknownCapHash = detail::HashForVocab("<UNK>", 5);$/;"	m	namespace:lm::ngram::__anon62	file:
kUnknownHash	HTKLVRec/kenlm/lm/vocab.cc	/^const uint64_t kUnknownHash = detail::HashForVocab("<unk>", 5);$/;"	m	namespace:lm::ngram::__anon62	file:
kVersion	HTKLVRec/kenlm/lm/model.hh	/^    static const unsigned int kVersion = Search::kVersion;$/;"	m	class:lm::ngram::detail::GenericModel
kVersion	HTKLVRec/kenlm/lm/search_hashed.hh	/^    static const unsigned int kVersion = 0;$/;"	m	class:lm::ngram::detail::HashedSearch
kVersion	HTKLVRec/kenlm/lm/search_trie.hh	/^    static const unsigned int kVersion = 1;$/;"	m	class:lm::ngram::trie::TrieSearch
kWidth	HTKLVRec/kenlm/util/ersatz_progress.cc	/^namespace { const unsigned char kWidth = 100; }$/;"	m	namespace:util::__anon66	file:
kWidth	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    static const unsigned char kWidth = 100;$/;"	m	class:util::stream::MultiProgress
keepDistinct	HTKLib/HModel.c	/^static Boolean keepDistinct=FALSE;      \/* keep orphan HMMs distinct *\/$/;"	v	file:
keepXFormDistinct	HTKLib/HAdapt.c	/^static Boolean keepXFormDistinct = TRUE;$/;"	v	file:
kenlm	HTKLVRec/HLVLM.h	/^typedef enum {fslm_ngram, fslm_latlm, kenlm} FSLMType;$/;"	e	enum:__anon35
key	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  Key key;$/;"	m	struct:lm::builder::__anon43::DedupeEntry	file:
key	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  uint64_t key;$/;"	m	struct:lm::builder::__anon43::VocabEntry	file:
key	HTKLVRec/kenlm/lm/search_hashed.hh	/^  uint64_t key;$/;"	m	struct:lm::ngram::detail::ProbEntry
key	HTKLVRec/kenlm/lm/value.hh	/^    Key key;$/;"	m	struct:lm::ngram::RestValue::ProbingEntry
key	HTKLVRec/kenlm/lm/value.hh	/^    uint64_t key;$/;"	m	struct:lm::ngram::BackoffValue::ProbingEntry
key	HTKLVRec/kenlm/lm/vocab.hh	/^  uint64_t key;$/;"	m	struct:lm::ngram::ProbingVocabularyEntry
key	HTKLVRec/kenlm/util/joint_sort.hh	/^      typename std::iterator_traits<KeyIter>::value_type key;$/;"	m	struct:util::detail::JointProxy::__anon74
keyOccs	HTKTools/HResults.c	/^static int *keyOccs;          \/* array[1..kn] of actual keyword occurrences *\/$/;"	v	file:
key_	HTKLVRec/kenlm/util/joint_sort.hh	/^    KeyIter key_;$/;"	m	class:util::detail::JointIter
key_bits_	HTKLVRec/kenlm/lm/trie.cc	/^    const uint8_t key_bits_, total_bits_;$/;"	m	class:lm::ngram::trie::__anon59::KeyAccessor	file:
key_mask_	HTKLVRec/kenlm/lm/trie.cc	/^    const WordIndex key_mask_;$/;"	m	class:lm::ngram::trie::__anon59::KeyAccessor	file:
keymap	HTKLib/HUtil.c	/^static char *keymap[] = {$/;"	v	file:
khi	HTKLib/HSigP.h	/^   int klo,khi;         \/* lopass to hipass cut-off fft indices *\/$/;"	m	struct:__anon159
kind	HTKLib/HShell.h	/^   ConfKind kind;       \/* kind of config param value *\/$/;"	m	struct:__anon157
kind	HTKTools/HList.c	/^   ParmKind kind;$/;"	m	struct:__anon202	file:
klo	HTKLib/HSigP.h	/^   int klo,khi;         \/* lopass to hipass cut-off fft indices *\/$/;"	m	struct:__anon159
knil	HTKLib/HRec.c	/^   Align *knil;         \/* Prev align in list *\/$/;"	m	struct:align	file:
knil	HTKLib/HRec.c	/^   NBestEntry *knil;$/;"	m	struct:nbestentry	file:
knil	HTKLib/HRec.c	/^   struct _NetInst *knil; \/* Doubly linked list of instances, backward *\/$/;"	m	struct:_NetInst	typeref:struct:_NetInst::_NetInst	file:
knil	HTKLib/HRec.h	/^   Path *knil;          \/* Prev path in list *\/$/;"	m	struct:path
ktype	HTKLib/HGraf.h	/^   KeyType ktype;    \/* type of key pressed *\/$/;"	m	struct:__anon103
l	HTKTools/HParse.c	/^   LabId l;$/;"	m	struct:__anon206	file:
l2nId	HLMLib/LPMerge.c	/^   int     **l2nId;          \/* array of LabId -> NameId lookup tables *\/$/;"	m	struct:__anon17	file:
l2nId	HLMTools/LPlex.c	/^static NameId **l2nId;              \/* array of LabId -> NameId lookup tables *\/$/;"	v	file:
lAlign	HTKLib/HNet.h	/^   LAlign *lAlign;     \/* Array[0..nAlign-1] of alignment records *\/$/;"	m	struct:larc
lCountLimit	HTKTools/HLStats.c	/^static int lCountLimit  = -1;       \/* max occurrences to list for lCount *\/$/;"	v	file:
lMEMORYSTATUSEX	HTKLVRec/kenlm/util/usage.cc	/^} lMEMORYSTATUSEX;$/;"	t	typeref:struct:__anon82	file:
lRef	HTKTools/HResults.c	/^static LabId *lRef,*lTest;$/;"	v	file:
lSize	HTKTools/HLStats.c	/^static int lSize;                \/* Number of logical labels *\/$/;"	v	file:
lStack	HTKTools/HCopy.c	/^static MemHeap lStack;          \/* label i\/o  stack *\/$/;"	v	file:
lTab	HTKTools/HLStats.c	/^static WordInfo *lTab;           \/* Table of logical counts\/durations *\/$/;"	v	file:
lTest	HTKTools/HResults.c	/^static LabId *lRef,*lTest;$/;"	v	file:
la	HTKLVRec/HLVRec.h	/^   LMCacheLA la[LMCACHE_NLA];$/;"	m	struct:_LMNodeCache
la	HTKLib/HLat.c	/^   LArc *la;$/;"	m	struct:_SubLArc	file:
laHit	HTKLVRec/HLVRec.h	/^   int laHit;$/;"	m	struct:_LMCache
laMiss	HTKLVRec/HLVRec.h	/^   int laMiss;$/;"	m	struct:_LMCache
laTree	HTKLVRec/HLVNet.h	/^   LMlaTree *laTree;            \/* look ahead tree *\/$/;"	m	struct:_LexNet
la_cmp	HTKLVRec/HLVLM.c	/^static int la_cmp(const void *v1,const void *v2)$/;"	f	file:
lab	HTKTools/HSLab.c	/^   Label lab;           \/* the label prior to change *\/$/;"	m	struct:__anon211	file:
lab2Lat	HTKTools/HLRescore.c	/^static Boolean lab2Lat = FALSE;     \/* -I *\/$/;"	v	file:
labDir	HTKLVRec/HDecode.c	/^static char *labDir = NULL;	\/* output label file directory *\/$/;"	v	file:
labDir	HTKLVRec/HDecode.mod.c	/^static char *labDir = NULL;	\/* output label file directory *\/$/;"	v	file:
labDir	HTKTools/HCompV.c	/^static char *labDir = NULL;         \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HCopy.c	/^static char *labDir = NULL;     \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HERest.c	/^static char * labDir = NULL;     \/* label (transcription) file directory *\/$/;"	v	file:
labDir	HTKTools/HInit.c	/^static char * labDir = NULL;        \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HQuant.c	/^static char *labDir = NULL;         \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HRest.c	/^static char * labDir = NULL;     \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HResults.c	/^static char * labDir    = NULL;       \/* label file directory *\/$/;"	v	file:
labDir	HTKTools/HSLab.c	/^static char *labDir = NULL;                \/* directory for label files *\/$/;"	v	file:
labDir	HTKTools/HVite.c	/^static char * labDir = NULL;      \/* output label file directory *\/$/;"	v	file:
labExt	HTKLVRec/HDecode.c	/^static char *labExt = "rec";	\/* output label file extension *\/$/;"	v	file:
labExt	HTKLVRec/HDecode.mod.c	/^static char *labExt = "rec";	\/* output label file extension *\/$/;"	v	file:
labExt	HTKTools/HCompV.c	/^static char *labExt = "lab";        \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HCopy.c	/^static char *labExt = "lab";    \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HERest.c	/^static char * labExt = "lab";    \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HInit.c	/^static char * labExt = "lab";       \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HQuant.c	/^static char *labExt = "lab";        \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HRest.c	/^static char * labExt = "lab";    \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HResults.c	/^static char * labExt    = "lab";      \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HSLab.c	/^static char *labExt = "lab";               \/* label file extension *\/$/;"	v	file:
labExt	HTKTools/HVite.c	/^static char * labExt = "rec";     \/* output label file extension *\/$/;"	v	file:
labF	HTKTools/HCopy.c	/^static Boolean labF=FALSE;      \/* set if we should  process label files too *\/$/;"	v	file:
labFile	HTKTools/HCopy.c	/^static char labFile[255];       \/* current source of trans *\/$/;"	v	file:
labFileMask	HTKTools/HERest.c	/^static char *labFileMask = NULL;$/;"	v	file:
labFileMask	HTKTools/HVite.c	/^static char * labFileMask = NULL; \/* mask for reading lablels (lattices) *\/$/;"	v	file:
labForm	HTKLVRec/HDecode.c	/^static char *labForm = NULL;	\/* output label format *\/$/;"	v	file:
labForm	HTKLVRec/HDecode.mod.c	/^static char *labForm = NULL;	\/* output label format *\/$/;"	v	file:
labForm	HTKTools/HVite.c	/^static char * labForm = NULL;     \/* output label reformat *\/$/;"	v	file:
labHeap	HTKTools/HLRescore.c	/^static MemHeap labHeap;$/;"	v	file:
labIdStack	HTKTools/HSmooth.c	/^static MemHeap labIdStack;$/;"	v	file:
labInDir	HTKTools/HLRescore.c	/^static char *labInDir = NULL;   \/* Label input dir, set by -L  *\/$/;"	v	file:
labInDir	HTKTools/HVite.c	/^static char * labInDir = NULL;    \/* input network\/label file directory *\/$/;"	v	file:
labInExt	HTKTools/HLRescore.c	/^static char *labInExt = "lab";  \/* Label Extension, set by -X *\/$/;"	v	file:
labInExt	HTKTools/HVite.c	/^static char * labInExt = "lab";   \/* input network\/label file extension *\/$/;"	v	file:
labName	HTKTools/HCopy.c	/^static LabId labName = NULL;    \/* name of label to extract (if set) *\/$/;"	v	file:
labOutDir	HTKTools/HLRescore.c	/^static char *labOutDir = NULL;  \/* output label file directory *\/$/;"	v	file:
labOutExt	HTKTools/HLRescore.c	/^static char *labOutExt = "rec"; \/* output label file extension *\/$/;"	v	file:
labOutForm	HTKTools/HLRescore.c	/^static char *labOutForm = NULL; \/* output label format *\/$/;"	v	file:
labRep	HTKTools/HCopy.c	/^static int labRep=1;            \/* repetition of named label *\/$/;"	v	file:
labSet	HTKTools/HSLab.c	/^static int labSet;              \/* the number of the current label list *\/$/;"	v	file:
labStack	HTKTools/HSLab.c	/^static MemHeap labStack;     \/* storage for label objects *\/$/;"	v	file:
labWin1	HTKTools/HSLab.c	/^static RectWin labWin1;      \/* the label window *\/$/;"	v	file:
label	HTKLib/HNet.h	/^   LabId label;       \/* Segment label ('phys_hmm[state]' or 'phys_hmm') *\/$/;"	m	struct:lalign
labelQuote	HTKLib/HLabel.c	/^static char labelQuote = 0;        \/* How do we quote label names *\/$/;"	v	file:
labenidx	HTKTools/HCopy.c	/^static int labenidx=0;          \/* label end index (if set) *\/$/;"	v	file:
labfn	HTKTools/HResults.c	/^static char labfn[255];               \/* lab file name (reference) *\/$/;"	v	file:
labfn	HTKTools/HSLab.c	/^static char labfn[SLEN];                   \/* the label file name *\/$/;"	v	file:
labid	HTKLib/HLabel.h	/^   LabId labid;             \/* primary label id *\/$/;"	m	struct:_Label
lablist	HTKLVRec/HLVLM.h	/^   LabId *lablist;              \/* Lookup table for LabIds from LMId *\/ $/;"	m	struct:_FSLM_ngram
labsModified	HTKTools/HSLab.c	/^static Boolean labsModified = FALSE;   \/* tracks any changes made to the labels *\/$/;"	v	file:
labstidx	HTKTools/HCopy.c	/^static int labstidx=0;          \/* label start index (if set) *\/$/;"	v	file:
labstr	HTKTools/HSLab.c	/^static char labstr[LAB_BUF_LEN] = "Speech";$/;"	v	file:
labstr_btn	HTKTools/HSLab.c	/^static HButton *labstr_btn;$/;"	v	file:
ladapt_vc_id	HLMTools/LAdapt.c	/^char *ladapt_vc_id = "$Id: LAdapt.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
ladapt_version	HLMTools/LAdapt.c	/^char *ladapt_version = "!HVER!LAdapt:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lalign	HTKLib/HNet.h	/^typedef struct lalign $/;"	s
lang	HLMLib/LCMap.h	/^   char *lang;     	     	\/* language *\/$/;"	m	struct:__anon1
lang	HLMLib/LWMap.h	/^   char    *lang;        \/* language *\/$/;"	m	struct:__anon23
langHeap	HLMTools/HLMCopy.c	/^static MemHeap   langHeap;               \/* Stores global stats *\/$/;"	v	file:
langHeap	HLMTools/LAdapt.c	/^static MemHeap langHeap;            \/* memory for NGBuffers and LMs*\/$/;"	v	file:
langHeap	HLMTools/LBuild.c	/^static MemHeap langHeap;            \/* memory for NGBuffers *\/$/;"	v	file:
langHeap	HLMTools/LMerge.c	/^static MemHeap   langHeap;               \/* Stores global stats *\/$/;"	v	file:
langHeap	HLMTools/LNorm.c	/^static MemHeap   langHeap;               \/* Stores global stats *\/$/;"	v	file:
langProbScale	HTKLib/HFBLat.c	/^static float langProbScale = 1.0;             \/* Extra scale on lm probabilities.   Leave this alone for normal usage. *\/$/;"	v	file:
langfn	HTKLVRec/HDecode.c	/^static char *langfn;		\/* LM filename from commandline *\/$/;"	v	file:
langfn	HTKLVRec/HDecode.mod.c	/^static char *langfn;		\/* LM filename from commandline *\/$/;"	v	file:
larc	HTKLib/HNet.h	/^typedef struct larc$/;"	s
larc	HTKLib/HRec.c	/^   LArc *larc;$/;"	m	struct:nbestentry	file:
larc_e	HTKLib/HNet.h	/^typedef struct larc_e$/;"	s
larc_s	HTKLib/HNet.h	/^typedef struct larc_s$/;"	s
larcs	HTKLib/HNet.h	/^   LArc *larcs;                 \/* Array of lattice arcs *\/$/;"	m	struct:lattice
last	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  T& last() { return start_[length_ - 1]; }$/;"	f	class:double_conversion::Vector
lastAccess	HTKLib/HLat.c	/^   int lastAccess;$/;"	m	struct:_LLFInfo	file:
lastCommand	HTKTools/HHEd.c	/^static int lastCommand=0;              \/* index of previous command *\/$/;"	v	file:
lastGram	HLMLib/LGBase.h	/^   LabId lastGram[MAXNG];   \/* last entry in file *\/$/;"	m	struct:__anon3
lastGram	HLMLib/LGBase.h	/^   LabId lastGram[MAXNG];   \/* last entry in file *\/$/;"	m	struct:gramfile
lastP	HTKTools/HInit.c	/^static Vector   thisP,lastP;     \/* Columns of log probabilities *\/$/;"	v	file:
lastRow	HTKLib/HParm.c	/^   int lastRow;        \/*   of final row (if we know it) *\/$/;"	m	struct:_ParmBuf	file:
lastUsed	HLMLib/LWMap.h	/^   int     lastUsed;     \/* last word index *\/$/;"	m	struct:__anon23
lastWpos	HTKTools/HSLab.c	/^static int thisWpos, lastWpos;      \/* the positions of the waveform pointer *\/$/;"	v	file:
last_	HTKLVRec/kenlm/lm/filter/format.hh	/^    StringPiece last_;$/;"	m	class:lm::MultipleOutputBuffer
last_	HTKLVRec/kenlm/lm/filter/phrase.cc	/^    const Sentence *last_;$/;"	m	class:lm::phrase::detail::Arc	file:
last_space_	HTKLVRec/kenlm/util/file_piece.hh	/^    const char *position_, *last_space_, *position_end_;$/;"	m	class:util::FilePiece
last_word	HLMTools/Cluster.c	/^static UInt         last_word;              \/* ID of last word (w,?) read in *\/$/;"	v	file:
lat	HTKLib/HArc.h	/^  Lattice *lat[MAXLATS]; \/*only needed if we are creating an Arc. Array starts from zero.*\/$/;"	m	struct:ArcInfoStruct
lat	HTKLib/HNet.h	/^   struct lattice *lat;     \/* Lattice this refers to (may be shared) *\/$/;"	m	struct:sublatdef	typeref:struct:sublatdef::lattice
lat	HTKTools/HSGen.c	/^static Lattice *lat;    \/* The defining syntax Lattice *\/$/;"	v	file:
latExt	HTKTools/HMMIRest.c	/^static char *latExt    = "lat";$/;"	v	file:
latExt	HTKTools/HVite.c	/^static char * latExt = NULL;      \/* output lattice file extension *\/$/;"	v	file:
latFileMask	HTKLVRec/HDecode.c	/^static char *latFileMask = NULL; \/* mask for reading lattice *\/$/;"	v	file:
latFileMask	HTKTools/HMMIRest.c	/^static char *latFileMask = NULL;$/;"	v	file:
latForm	HTKTools/HVite.c	/^static char * latForm = NULL;     \/* output lattice format *\/$/;"	v	file:
latGen	HTKLVRec/HDecode.c	/^static Boolean latGen = FALSE;  \/* output lattice? *\/$/;"	v	file:
latGen	HTKLVRec/HDecode.mod.c	/^static Boolean latGen = FALSE;  \/* output lattice? *\/$/;"	v	file:
latHeap	HTKTools/HLRescore.c	/^static MemHeap latHeap;$/;"	v	file:
latInDir	HTKLVRec/HDecode.c	/^static char *latInDir = NULL;   \/* lattice input directory *\/$/;"	v	file:
latInDir	HTKLVRec/HDecode.mod.c	/^static char *latInDir = NULL;   \/* lattice input directory *\/$/;"	v	file:
latInDir	HTKTools/HLRescore.c	/^static char *latInDir = NULL;   \/* Lattice input dir, set by -L  *\/$/;"	v	file:
latInExt	HTKLVRec/HDecode.c	/^static char *latInExt = "lat";  \/* latttice input extension *\/$/;"	v	file:
latInExt	HTKLVRec/HDecode.mod.c	/^static char *latInExt = "lat";  \/* latttice input extension *\/$/;"	v	file:
latInExt	HTKTools/HLRescore.c	/^static char *latInExt = "lat";  \/* Lattice Extension, set by -X *\/$/;"	v	file:
latOutDir	HTKLVRec/HDecode.c	/^static char *latOutDir = NULL;  \/* lattice output directory *\/$/;"	v	file:
latOutDir	HTKLVRec/HDecode.mod.c	/^static char *latOutDir = NULL;  \/* lattice output directory *\/$/;"	v	file:
latOutExt	HTKLVRec/HDecode.c	/^static char *latOutExt = "lat"; \/* latttice output extension *\/$/;"	v	file:
latOutExt	HTKLVRec/HDecode.mod.c	/^static char *latOutExt = "lat"; \/* latttice output extension *\/$/;"	v	file:
latOutForm	HTKLVRec/HDecode.c	/^static char *latOutForm = NULL;  \/* lattice output format *\/$/;"	v	file:
latOutForm	HTKLVRec/HDecode.mod.c	/^static char *latOutForm = NULL;  \/* lattice output format *\/$/;"	v	file:
latOutForm	HTKTools/HLRescore.c	/^static char *latOutForm = NULL; \/* output lattice format *\/$/;"	v	file:
latProbScale	HTKLib/HExactMPE.c	/^static float latProbScale = 1.0; \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
latProbScale	HTKLib/HFBLat.c	/^static float latProbScale = 1.0; \/*IMPORTANT*\/  \/* Scales the lattice-arc and lm probabilities.  Normally set to e.g. 1\/12 or 1\/15, the inverse$/;"	v	file:
latPruneAPS	HTKLVRec/HDecode.c	/^static LogFloat latPruneAPS = 0;;        \/* lattice pruning arcs per sec limit *\/$/;"	v	file:
latPruneAPS	HTKLVRec/HDecode.mod.c	/^static LogFloat latPruneAPS = 0;;        \/* lattice pruning arcs per sec limit *\/$/;"	v	file:
latPruneBeam	HTKLVRec/HDecode.c	/^static LogFloat latPruneBeam = - LZERO;  \/* lattice pruning beam width *\/$/;"	v	file:
latPruneBeam	HTKLVRec/HDecode.mod.c	/^static LogFloat latPruneBeam = - LZERO;  \/* lattice pruning beam width *\/$/;"	v	file:
latRescore	HTKLVRec/HDecode.c	/^static Boolean latRescore = FALSE; \/* read lattice for each utterance and rescore? *\/$/;"	v	file:
latRescore	HTKLVRec/HDecode.mod.c	/^static Boolean latRescore = FALSE; \/* read lattice for each utterance and rescore? *\/$/;"	v	file:
latStack	HTKTools/HMMIRest.c	/^static MemHeap latStack;           \/* Lattices. *\/$/;"	v	file:
latgen	HTKLVRec/HLVRec.h	/^   Boolean latgen;              \/* generate lattices or just 1-bet? *\/$/;"	m	struct:_DecoderInst
latlm	HTKLVRec/HLVLM.h	/^      FSLM_latlm *latlm;$/;"	m	union:_FSLM::__anon36
lattice	HTKLib/HNet.h	/^typedef struct lattice$/;"	s
lattices	HTKLib/HFBLat.h	/^  ArcInfo lattices; $/;"	m	struct:__anon102
layerId	HTKLVRec/HLVNet.h	/^   int layerId;$/;"	m	struct:_TLexNode
layerStart	HTKLVRec/HLVNet.h	/^   LexNode **layerStart;        \/* array of pointers to the first node in each layer *\/$/;"	m	struct:_LexNet
lbuild_vc_id	HLMTools/LBuild.c	/^char *lbuild_vc_id = "$Id: LBuild.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lbuild_version	HLMTools/LBuild.c	/^char *lbuild_version = "!HVER!LBuild:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lc	HTKLVRec/HLVNet.h	/^   LabId lc;            \/* left context phone *\/$/;"	m	struct:_TLexNode
lc	HTKLib/HNet.c	/^   NetNode **lc;    \/* Left contexts - linked to word initial models *\/$/;"	m	struct:pronholder	file:
lcmap_vc_id	HLMLib/LCMap.c	/^char *lcmap_vc_id = "$Id: LCMap.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lcmap_version	HLMLib/LCMap.c	/^char *lcmap_version = "!HVER!LCMap:   3.4.1 [CUED 12\/03\/09]";$/;"	v
ldBinary	HTKLib/HTrain.c	/^static Boolean ldBinary = TRUE;        \/* load\/dump in binary *\/$/;"	v	file:
ldBinary	HTKTools/HERest.c	/^static Boolean ldBinary = TRUE;        \/* load\/dump in binary *\/$/;"	v	file:
ldBinary	HTKTools/HSmooth.c	/^static Boolean ldBinary = TRUE;     \/* load in binary *\/$/;"	v	file:
leaf	HTKTools/HHEd.c	/^   Node *leaf;                  \/* chain of leaf nodes *\/$/;"	m	struct:_Tree	file:
left	HTKLVRec/kenlm/lm/filter/phrase.hh	/^      std::vector<unsigned int> substring, left, right, phrase;$/;"	m	struct:lm::phrase::Substrings::SentenceRelation
left	HTKLVRec/kenlm/lm/state.hh	/^  Left left;$/;"	m	struct:lm::ngram::ChartState
left	HTKLib/HVQ.h	/^   VQNode left,right;   \/* offspring, only right is used in linTree *\/$/;"	m	struct:_VQNodeRec
left	HTKTools/HHEd.c	/^   HLink left,right;            \/* physical names of constituent biphones *\/$/;"	m	struct:__anon197	file:
left_done_	HTKLVRec/kenlm/lm/left.hh	/^    bool left_done_;$/;"	m	class:lm::ngram::RuleScore
lenSum	HTKTools/HSGen.c	/^static long lenSum;     \/* total length of all sentences *\/$/;"	v	file:
lendian	HTKLib/HWave.c	/^   int32  lendian;$/;"	m	struct:__anon174	file:
length	HTKLVRec/kenlm/lm/state.hh	/^    unsigned char length;$/;"	m	class:lm::ngram::State
length	HTKLVRec/kenlm/lm/state.hh	/^  unsigned char length;$/;"	m	struct:lm::ngram::Left
length	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  int length() const { return length_; }$/;"	f	class:double_conversion::Vector
length	HTKLVRec/kenlm/util/stream/sort.hh	/^      uint64_t length;$/;"	m	struct:util::stream::Offsets::Entry
length	HTKLVRec/kenlm/util/string_piece.hh	/^  size_type length() const { return length_; }$/;"	f	class:StringPiece
length_	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  int length_;$/;"	m	class:double_conversion::Vector
length_	HTKLVRec/kenlm/util/string_piece.hh	/^  size_type     length_;$/;"	m	class:StringPiece
less_	HTKLVRec/kenlm/util/joint_sort.hh	/^    const Less less_;$/;"	m	class:util::detail::LessWrapper
letters	HTKLVRec/kenlm/util/file.cc	/^static const char letters[] =$/;"	m	namespace:util	file:
levSplit	HTKTools/HLEd.c	/^static Boolean levSplit = FALSE;    \/* Split levels into lists *\/$/;"	v	file:
levStr	HTKTools/HSLab.c	/^static char levStr[10];      \/* the level button string *\/$/;"	v	file:
lev_btn	HTKTools/HSLab.c	/^static HButton *lev_btn;     \/* the level button *\/$/;"	v	file:
level	HTKLib/HAdapt.c	/^   int level;$/;"	m	struct:_AInfo	file:
lexA	HTKLVRec/HLVNet.h	/^   LabId *lexA;$/;"	m	struct:_TLexNet
lexABhash	HTKLVRec/HLVNet.h	/^   TLexNode *lexABhash[LEX_CON_HASH_SIZE];$/;"	m	struct:_TLexNet
lexP	HTKLVRec/HLVNet.h	/^   LabId *lexP;$/;"	m	struct:_TLexNet
lexSAhash	HTKLVRec/HLVNet.h	/^   TLexNode *lexSAhash[LEX_CON_HASH_SIZE];$/;"	m	struct:_TLexNet
lexYZhash	HTKLVRec/HLVNet.h	/^   TLexNode *lexYZhash[LEX_CON_HASH_SIZE];$/;"	m	struct:_TLexNet
lexZ	HTKLVRec/HLVNet.h	/^   LabId *lexZ;$/;"	m	struct:_TLexNet
lexZShash	HTKLVRec/HLVNet.h	/^   TLexNode *lexZShash[LEX_CON_HASH_SIZE];$/;"	m	struct:_TLexNet
lff	HLMTools/LPlex.c	/^static FileFormat lff = UNDEFF;     \/* label file format *\/$/;"	v	file:
lff	HTKTools/HCompV.c	/^static FileFormat lff=UNDEFF;       \/* label file format *\/$/;"	v	file:
lff	HTKTools/HERest.c	/^static FileFormat lff=UNDEFF;       \/* label file format *\/$/;"	v	file:
lff	HTKTools/HInit.c	/^static FileFormat lff=UNDEFF;       \/* label file format *\/$/;"	v	file:
lff	HTKTools/HQuant.c	/^static FileFormat lff=UNDEFF;       \/* label file format *\/$/;"	v	file:
lff	HTKTools/HRest.c	/^static FileFormat lff=UNDEFF;    \/* label file format *\/$/;"	v	file:
lfof_vc_id	HLMTools/LFoF.c	/^char *lfof_vc_id = "$Id: LFoF.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lfof_version	HLMTools/LFoF.c	/^char *lfof_version = "!HVER!LFoF:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lgain	HTKLib/HAudio.c	/^   long lgain;$/;"	m	struct:_AudioIn	file:
lgain	HTKLib/HAudio.c	/^   long lgain;$/;"	m	struct:_AudioOut	file:
lgbase_vc_id	HLMLib/LGBase.c	/^char *lgbase_vc_id = "$Id: LGBase.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lgbase_version	HLMLib/LGBase.c	/^char *lgbase_version = "!HVER!LGBase:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lgcopy_vc_id	HLMTools/LGCopy.c	/^char *lgcopy_vc_id = "$Id: LGCopy.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lgcopy_version	HLMTools/LGCopy.c	/^char *lgcopy_version = "!HVER!LGCopy:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lglist_vc_id	HLMTools/LGList.c	/^char *lglist_vc_id = "$Id: LGList.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lglist_version	HLMTools/LGList.c	/^char *lglist_version = "!HVER!LGList:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lgprep_vc_id	HLMTools/LGPrep.c	/^char *lgprep_vc_id = "$Id: LGPrep.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lgprep_version	HLMTools/LGPrep.c	/^char *lgprep_version = "!HVER!LGPrep:   3.4.1 [CUED 12\/03\/09]";$/;"	v
libdir	HLMLib/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	HLMTools/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	HTKLVRec/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	HTKLib/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	HTKTools/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libdir	Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libexecdir	HLMLib/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	HLMTools/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	HTKLVRec/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	HTKLib/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	HTKTools/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
libexecdir	Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
lid	HTKLib/HVQ.h	/^   short nid,lid,rid;   \/* used for mapping between mem and ext def *\/$/;"	m	struct:_VQNodeRec
like	HTKLib/HNet.h	/^   LogFloat like;       \/* Transition likelihood *\/$/;"	m	struct:_NetLink
like	HTKLib/HNet.h	/^   LogFloat like;     \/* Total aclike of label (inc trans within + out) *\/$/;"	m	struct:lalign
like	HTKLib/HRec.c	/^   LogDouble like;      \/* Likelihood at boundary *\/$/;"	m	struct:nxtpath	file:
like	HTKLib/HRec.c	/^   LogDouble like;      \/* Likelihood upon entering state\/model end *\/$/;"	m	struct:align	file:
like	HTKLib/HRec.c	/^   LogFloat like;       \/* Relative Likelihood of token *\/$/;"	m	struct:reltoken	file:
like	HTKLib/HRec.c	/^   double like;$/;"	m	struct:nbestentry	file:
like	HTKLib/HRec.h	/^   LogDouble like;	\/* Likelihood of token *\/$/;"	m	struct:token
like	HTKLib/HRec.h	/^   LogDouble like;      \/* Likelihood at boundary *\/$/;"	m	struct:path
linTree	HTKLib/HVQ.h	/^   linTree,    \/* linear flat codebook (right branching tree) *\/$/;"	e	enum:__anon171
line	HTKLVRec/kenlm/lm/filter/format.hh	/^      StringPiece line;$/;"	m	struct:lm::MultipleOutputBuffer::Annotated
line	HTKLVRec/kenlm/lm/filter/format.hh	/^      std::string line;$/;"	m	struct:lm::InputBuffer::Line
lineIn	HTKLib/HAudio.c	/^static Boolean lineIn = TRUE;$/;"	v	file:
lineOut	HTKLib/HAudio.c	/^static Boolean lineOut = TRUE;$/;"	v	file:
line_	HTKLVRec/kenlm/lm/filter/vocab.hh	/^        const StringPiece &line_;$/;"	m	class:lm::vocab::Multiple::Callback
lines_	HTKLVRec/kenlm/lm/filter/format.hh	/^    std::vector<Line> lines_;$/;"	m	class:lm::InputBuffer
lines_	HTKLVRec/kenlm/lm/filter/format.hh	/^    std::vector<StringPiece> lines_;$/;"	m	class:lm::BinaryOutputBuffer
link	HTKLVRec/HLVLM.h	/^   struct nentry *link;         \/* Next entry in hash table *\/$/;"	m	struct:nentry	typeref:struct:nentry::nentry
link	HTKLVRec/HLVNet.c	/^   STLexLink *link[2];$/;"	m	struct:_STLexNode	file:
link	HTKLVRec/HLVNet.h	/^   TLexLink *link;		\/* linked list of  TLexLinks to successor nodes *\/$/;"	m	struct:_TLexNode
link	HTKLib/HLM.h	/^   struct nentry *link;         \/* Next entry in hash table *\/$/;"	m	struct:nentry	typeref:struct:nentry::nentry
link	HTKLib/HRec.c	/^   Align *link;         \/* Next align in list *\/$/;"	m	struct:align	file:
link	HTKLib/HRec.c	/^   NBestEntry *link;$/;"	m	struct:nbestentry	file:
link	HTKLib/HRec.c	/^   struct _NetInst *link; \/* Doubly linked list of instances, forward *\/$/;"	m	struct:_NetInst	typeref:struct:_NetInst::_NetInst	file:
link	HTKLib/HRec.h	/^   Path *link;          \/* Next path in list *\/$/;"	m	struct:path
link	HTKTools/HLStats.c	/^   struct aentry *link;          \/* Next entry in hash table *\/$/;"	m	struct:aentry	typeref:struct:aentry::aentry	file:
linkHeap	HTKLib/HNet.h	/^   MemHeap linkHeap;  \/* a stack for adding the links as needed *\/$/;"	m	struct:__anon139
links	HTKLib/HNet.h	/^   NetLink *links;      \/* Array[0..nlinks-1] of links to connected nodes *\/$/;"	m	struct:_NetNode
links	HTKTools/HParse.c	/^   Link *links;      \/* array[1..numLinks]of Link *\/$/;"	m	struct:__anon203	file:
list	HLMLib/LUtil.c	/^   struct hdrField *list;$/;"	m	struct:lmFileHdrRec	typeref:struct:lmFileHdrRec::hdrField	file:
list	HTKTools/HHEd.c	/^   CoList *list;             \/* linked list of the mixture components *\/$/;"	m	struct:__anon198	file:
listFile	HTKTools/HLStats.c	/^static char *listFile   = NULL;     \/* file for label list *\/$/;"	v	file:
lit	HTKLib/HGraf.h	/^   Boolean lit;               \/* if true, invert colors *\/$/;"	m	struct:_HButton
ll	HTKLVRec/HDecode.c	/^   LLink ll;           \/* get rid of this? currently start\/end are redundant *\/$/;"	m	struct:_BestInfo	file:
ll	HTKLVRec/HDecode.mod.c	/^   LLink ll;           \/* get rid of this? currently start\/end are redundant *\/$/;"	m	struct:_BestInfo	file:
llfExt	HTKLib/HLat.c	/^static char *llfExt = "LLF";    \/* extension for LLF lattice files *\/$/;"	v	file:
llfHeap	HTKLib/HLat.c	/^static MemHeap llfHeap;$/;"	v	file:
llfInfo	HTKLib/HLat.c	/^static LLFInfo *llfInfo = NULL;$/;"	v	file:
llib	HLMTools/Makefile	/^llib    = 	..\/HLMLib$/;"	m
llink_vc_id	HLMTools/LLink.c	/^char *llink_vc_id = "$Id: LLink.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
llink_version	HLMTools/LLink.c	/^char *llink_version = "!HVER!LLink:   3.4.1 [CUED 12\/03\/09]";$/;"	v
llist	HTKTools/HSLab.c	/^static LabList *llist;          \/* the current label list edited *\/$/;"	v	file:
lm	HLMLib/LPMerge.c	/^   BackOffLM *lm;            \/* target model *\/$/;"	m	struct:__anon17	file:
lm	HLMLib/LPMerge.h	/^   BackOffLM *lm;           \/* the language model *\/$/;"	m	struct:__anon18
lm	HLMTools/HLMCopy.c	/^static BackOffLM *lm;                    \/* the language model *\/$/;"	v	file:
lm	HLMTools/LNorm.c	/^static BackOffLM *lm;                    \/* the language model *\/$/;"	v	file:
lm	HTKLVRec/HLVRec.h	/^   FSLM *lm;$/;"	m	struct:_DecoderInst
lm	HTKLVRec/HLVRec.h	/^   LMTokScore lm;               \/* LM likelihood of this word given history *\/$/;"	m	struct:_AltWordendHyp
lm	HTKLVRec/HLVRec.h	/^   LMTokScore lm;               \/* LM likelihood of this word given history *\/$/;"	m	struct:_WordendHyp
lm	HTKLVRec/kenlm/lm/bhiksha.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/bhiksha.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/binary_format.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/binary_format.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/blank.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/discount.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/hash_gamma.hh	/^namespace lm { namespace builder {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/builder/initial_probabilities.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/builder/interpolate.hh	/^namespace lm { namespace builder {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/joint_order.hh	/^namespace lm { namespace builder {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/ngram.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^namespace lm { namespace builder {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/output.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/builder/output.hh	/^namespace lm { namespace builder {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^namespace lm { namespace builder {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/print.cc	/^namespace lm { namespace builder {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/builder/print.hh	/^namespace lm { namespace builder {$/;"	n
lm	HTKLVRec/kenlm/lm/builder/sort.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/config.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/config.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/enumerate_vocab.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/facade.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/filter/count_io.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/filter/format.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/filter/phrase.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/filter/phrase.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/filter/thread.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/filter/vocab.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/filter/vocab.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/filter/wrapper.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.cc	/^namespace lm { namespace interpolate {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/left.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/lm_exception.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/lm_exception.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/model.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/model.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/model_type.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/neural/wordvecs.cc	/^namespace lm { namespace neural {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/neural/wordvecs.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/ngram_query.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/partial.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/quantize.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/quantize.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/read_arpa.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/read_arpa.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/return.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/search_hashed.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/search_hashed.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/search_trie.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/search_trie.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/sizes.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/sizes.hh	/^namespace lm { namespace ngram {$/;"	n
lm	HTKLVRec/kenlm/lm/state.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/trie.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/trie.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/trie_sort.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/trie_sort.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/value.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/value_build.cc	/^namespace lm { $/;"	n	file:
lm	HTKLVRec/kenlm/lm/value_build.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/virtual_interface.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/virtual_interface.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/vocab.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/vocab.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/weights.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/word_index.hh	/^namespace lm {$/;"	n
lm	HTKLVRec/kenlm/lm/wrappers/nplm.cc	/^namespace lm {$/;"	n	file:
lm	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^namespace lm {$/;"	n
lm	HTKLib/HRec.c	/^   LogFloat lm;         \/* LM likelihood of current word *\/$/;"	m	struct:nxtpath	file:
lm	HTKLib/HRec.c	/^   LogFloat lm;         \/* LM likelihood of token *\/$/;"	m	struct:reltoken	file:
lm	HTKLib/HRec.h	/^   LogFloat lm;         \/* LM likelihood of current word *\/$/;"	m	struct:path
lm	HTKLib/HRec.h	/^   LogFloat lm;         \/* LM likelihood of token *\/$/;"	m	struct:token
lm	HTKTools/HLRescore.c	/^static LModel *lm;              \/* LM for expandin lattices *\/$/;"	v	file:
lmCache	HTKLVRec/HLVRec.h	/^   LMCache *lmCache;$/;"	m	struct:_DecoderInst
lmCnt	HTKLib/HLM.h	/^typedef unsigned short lmCnt;   \/* Type used by lm to count wds 0..MAX_LMID *\/$/;"	t
lmFile	HTKTools/HLRescore.c	/^static char *lmFile = NULL;     \/* LM filename *\/$/;"	v	file:
lmFileHdrRec	HLMLib/LUtil.c	/^typedef struct lmFileHdrRec {$/;"	s	file:
lmHeap	HTKLVRec/HDecode.c	/^static MemHeap lmHeap;$/;"	v	file:
lmHeap	HTKLVRec/HDecode.mod.c	/^static MemHeap lmHeap;$/;"	v	file:
lmHeap	HTKTools/HLRescore.c	/^static MemHeap lmHeap;$/;"	v	file:
lmId	HTKLib/HLM.h	/^typedef unsigned short lmId;    \/* Type used by lm to id words  1..MAX_LMID *\/$/;"	t
lmInfo	HLMLib/LPMerge.c	/^   LMInfo  *lmInfo;          \/* array of LMs to merge *\/$/;"	m	struct:__anon17	file:
lmInfo	HLMTools/LAdapt.c	/^static LMInfo  lmInfo[MAX_LMODEL];          \/* array of loaded LMs *\/$/;"	v	file:
lmInfo	HLMTools/LMerge.c	/^static LMInfo    lmInfo[MAX_LMODEL];     \/* array of loaded LMs *\/$/;"	v	file:
lmInfo	HLMTools/LPlex.c	/^static LMInfo  lmInfo[MAX_LMODEL];  \/* array of loaded LMs *\/$/;"	v	file:
lmScale	HTKLVRec/HDecode.c	/^static float lmScale = 1.0;     \/* LM scaling factor *\/$/;"	v	file:
lmScale	HTKLVRec/HDecode.mod.c	/^static float lmScale = 1.0;     \/* LM scaling factor *\/$/;"	v	file:
lmScale	HTKLVRec/HLVRec.h	/^   float lmScale;               \/* LM scaling factor *\/$/;"	m	struct:_DecoderInst
lmScale	HTKLib/HArc.h	/^  float lmScale; \/*This functions as a prscale (pronunciation$/;"	m	struct:ArcInfoStruct
lmScale	HTKTools/HLRescore.c	/^static double lmScale = 1.0;    \/* LM scale factor *\/$/;"	v	file:
lmScale	HTKTools/HVite.c	/^static double lmScale = 1.0;      \/* bigram and log(1\/NSucc) scale factor *\/$/;"	v	file:
lmState	HTKLVRec/HLVRec.h	/^   LMState lmState;$/;"	m	struct:_RelToken
lmState	HTKLVRec/HLVRec.h	/^   LMState lmState;$/;"	m	struct:_Token
lmState_kenlm	HTKLVRec/HLVRec.h	/^   lm::ngram::State lmState_kenlm;$/;"	m	struct:_RelToken
lm_htk	HTKLVRec/HDecode.c	/^static FSLM *lm_htk;                \/* language model *\/$/;"	v	file:
lm_htk	HTKLVRec/HDecode.mod.c	/^static FSLM *lm_htk;                \/* language model *\/$/;"	v	file:
lm_kenlm	HTKLVRec/HDecode.c	/^lm::base::Model *lm_kenlm;         \/* language model using kenlm*\/$/;"	v
lm_kenlm	HTKLVRec/HLVRec.h	/^   lm::base::Model *lm_kenlm;$/;"	m	struct:_DecoderInst
lmerge_vc_id	HLMTools/LMerge.c	/^char *lmerge_vc_id = "$Id: LMerge.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lmerge_version	HLMTools/LMerge.c	/^char *lmerge_version = "!HVER!LMerge:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lmlaCount	HTKLVRec/HLVNet.h	/^   int lmlaCount;       \/* number of unique look ahead intervals *\/$/;"	m	struct:_TLexNet
lmlaIdx	HTKLVRec/HLVNet.h	/^   int *lmlaIdx;$/;"	m	struct:_CompLMlaNode
lmlaIdx	HTKLVRec/HLVNet.h	/^   int lmlaIdx;         \/* index of node in (compressed) LMlaTree *\/$/;"	m	struct:_TLexNode
lmlaIdx	HTKLVRec/HLVNet.h	/^   unsigned int lmlaIdx;        \/* Idx of corresponding node in compressed LM $/;"	m	struct:_LexNode
lmlike	HTKLib/HArc.h	/^  LogFloat lmlike;  \/*This is the lmprob + the prlike [not scaled].*\/$/;"	m	struct:_ArcTrans
lmlike	HTKLib/HNet.h	/^   LogFloat lmlike;    \/* Language model likelihood of word *\/$/;"	m	struct:larc
lmlike	HTKLib/HNet.h	/^   LogFloat lmlike;    \/* Language model likelihood of word *\/$/;"	m	struct:larc_e
lmlike	HTKLib/HNet.h	/^   LogFloat lmlike;$/;"	m	struct:larc_s
lmodel	HTKLib/HLM.h	/^typedef struct lmodel {$/;"	s
lmodel_vc_id	HLMLib/LModel.c	/^char *lmodel_vc_id = "$Id: LModel.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lmodel_version	HLMLib/LModel.c	/^char *lmodel_version = "!HVER!LModel:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lmprob	HTKLib/HLat.c	/^   LogFloat lmprob;$/;"	m	struct:_SubLArc	file:
lmscale	HTKLib/HNet.h	/^   float lmscale;		\/* LM scale factor *\/$/;"	m	struct:lattice
lmscore	HTKLVRec/HLVRec.h	/^   LMTokScore lmscore;          \/* LM lookahead score for current word *\/$/;"	m	struct:_RelToken
lmscore	HTKLVRec/HLVRec.h	/^   LMTokScore lmscore;          \/* LM lookahead score for current word *\/$/;"	m	struct:_Token
lmstate	HTKLib/HLat.c	/^      LMState lmstate;$/;"	m	union:_SubLNode::__anon111	file:
lmvec	HLMLib/LModel.h	/^   float *lmvec;             \/* vector for storing vector n-grams *\/$/;"	m	struct:__anon15
ln	HTKLVRec/HDecode.c	/^   LexNode *ln;$/;"	m	struct:_BestInfo	file:
ln	HTKLVRec/HDecode.mod.c	/^   LexNode *ln;$/;"	m	struct:_BestInfo	file:
ln	HTKLVRec/HLVNet.h	/^   LexNode *ln;        \/* the actual Lexicon Node *\/$/;"	m	struct:_TLexNode
ln	HTKLVRec/HLVRec.h	/^   LexNode *ln;                 \/* lexnode that finished *\/$/;"	m	struct:_ModendHyp
ln	HTKLib/HNet.c	/^   LNode *ln;       \/* Node that created this instance *\/$/;"	m	struct:pronholder	file:
lnDeadT	HTKLVRec/HLVRec.h	/^   unsigned long lnDeadT[STATS_MAXT+1];$/;"	m	struct:_Stats
lnINF	HTKLVRec/HLVRec.h	/^   unsigned long lnINF;$/;"	m	struct:_Stats
lnLiveT	HTKLVRec/HLVRec.h	/^   unsigned long lnLiveT[STATS_MAXT+1];$/;"	m	struct:_Stats
lnSEsil	HTKLVRec/HLVNet.h	/^   LexNode *lnSEsil;            \/* sil lexnode leading to SENT_END *\/$/;"	m	struct:_LexNet
lnSEsil	HTKLVRec/HLVNet.h	/^   TLexNode *lnSEsil;            \/* sil lexnode leading to SENT_END *\/$/;"	m	struct:_TLexNet
lnSEsp	HTKLVRec/HLVNet.h	/^   LexNode *lnSEsp;             \/* sp lexnode leading to SENT_END *\/$/;"	m	struct:_LexNet
lnSEsp	HTKLVRec/HLVNet.h	/^   TLexNode *lnSEsp;             \/* sp lexnode leading to SENT_END *\/$/;"	m	struct:_TLexNet
lnewmap_vc_id	HLMTools/LNewMap.c	/^char *lnewmap_vc_id = "$Id: LNewMap.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lnewmap_version	HLMTools/LNewMap.c	/^char *lnewmap_version = "!HVER!LNewMap:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lnode	HTKLib/HNet.h	/^typedef struct lnode$/;"	s
lnode	HTKLib/HRec.c	/^   LNode *lnode;$/;"	m	struct:nbestentry	file:
lnodes	HTKLib/HNet.h	/^   LNode *lnodes;               \/* Array of lattice nodes *\/$/;"	m	struct:lattice
lnorm_vc_id	HLMTools/LNorm.c	/^char *lnorm_vc_id = "$Id: LNorm.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lnorm_version	HLMTools/LNorm.c	/^char *lnorm_version = "!HVER!LNorm:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lnum	HTKTools/HSGen.c	/^static Boolean lnum = FALSE;        \/* enable line numbers *\/$/;"	v	file:
loChan	HTKLib/HSigP.h	/^   ShortVec loChan;     \/* array[1..fftN\/2] of loChan index *\/$/;"	m	struct:__anon159
loFBankFreq	HTKLib/HParm.c	/^   float loFBankFreq;         \/* Fbank lo frequency cut-off *\/$/;"	m	struct:__anon141	file:
loWE	HTKLVRec/HLVNet.h	/^   LMId loWE;$/;"	m	struct:_LMlaNode
loWE	HTKLVRec/HLVNet.h	/^   int loWE;            \/* lowest WE LMId reachable from here *\/$/;"	m	struct:_TLexNode
loWt	HTKLib/HSigP.h	/^   Vector loWt;         \/* array[1..fftN\/2] of loChan weighting *\/$/;"	m	struct:__anon159
loadLabels	HTKTools/HVite.c	/^static Boolean loadLabels = FALSE; \/* Load network for each file *\/$/;"	v	file:
loadNetworks	HTKTools/HVite.c	/^static Boolean loadNetworks = FALSE; \/* Load network for each file *\/$/;"	v	file:
load_method	HTKLVRec/kenlm/lm/config.hh	/^  util::LoadMethod load_method;$/;"	m	struct:lm::ngram::Config
load_method_	HTKLVRec/kenlm/lm/binary_format.hh	/^    util::LoadMethod load_method_;$/;"	m	class:lm::ngram::BinaryFormat
local_read_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    std::stack<Batch*> local_read_;$/;"	m	class:lm::Controller
localstatedir	HLMLib/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	HLMTools/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	HTKLVRec/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	HTKLib/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	HTKTools/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
localstatedir	Makefile	/^localstatedir = ${prefix}\/var$/;"	m
locc	HTKLib/HArc.h	/^  LogFloat locc;$/;"	m	struct:_Acoustic
locc	HTKLib/HArc.h	/^  LogFloat locc;$/;"	m	struct:_ArcTrans
log2	HTKTools/HLStats.c	626;"	d	file:
logF	HTKTools/HDMan.c	/^static FILE *logF = NULL;            \/* log file if any *\/$/;"	v	file:
logWt	HTKLib/HModel.h	/^   Boolean logWt;       \/* Component weights are stored as Logs *\/$/;"	m	struct:_HMMSet
log_	HTKLVRec/kenlm/util/stream/sort.hh	/^    int log_;$/;"	m	class:util::stream::Offsets
logbase	HTKLib/HNet.h	/^   float logbase;               \/* base of logarithm for likelihoods in lattice files$/;"	m	struct:lattice
logfile	HLMTools/Cluster.c	/^static FILE       *logfile=NULL;            \/* Log progress to this file *\/$/;"	v	file:
logfile	HTKLib/HShell.c	/^   char logfile[1024];                  \/* logical name *\/$/;"	m	struct:__anon150	file:
logpp	HLMTools/LPlex.c	/^   double logpp;            \/* accumulated LM score *\/$/;"	m	struct:__anon34	file:
logpp2	HLMTools/LPlex.c	/^   double logpp2;           \/* accumulated logp^2 score *\/$/;"	m	struct:__anon34	file:
longest_	HTKLVRec/kenlm/lm/quantize.hh	/^    Bins longest_;$/;"	m	class:lm::ngram::SeparatelyQuantize
longest_	HTKLVRec/kenlm/lm/search_hashed.hh	/^    Longest longest_;$/;"	m	class:lm::ngram::detail::HashedSearch
longest_	HTKLVRec/kenlm/lm/search_trie.cc	/^    BitPackedLongest &longest_;$/;"	m	class:lm::ngram::trie::__anon58::WriteEntries	file:
longest_	HTKLVRec/kenlm/lm/search_trie.hh	/^    Longest longest_;$/;"	m	class:lm::ngram::trie::TrieSearch
lookahead	HTKLVRec/HLVLM.h	/^   LogFloat (*lookahead) (FSLM *lm, LMState src, PronId minPron, PronId maxPron);$/;"	m	struct:_FSLM
lookup_	HTKLVRec/kenlm/lm/vocab.hh	/^    Lookup lookup_;$/;"	m	class:lm::ngram::GrowableVocab
lookup_	HTKLVRec/kenlm/lm/vocab.hh	/^    Lookup lookup_;$/;"	m	class:lm::ngram::ProbingVocabulary
low_bits_	HTKLVRec/kenlm/util/double-conversion/fixed-dtoa.cc	/^  uint64_t low_bits_;$/;"	m	class:double_conversion::UInt128	file:
lp	HTKLib/HParm.c	/^   Vector as, ac, lp; \/* Auditory, autocorrelation an lp vectors for PLP *\/ $/;"	m	struct:__anon141	file:
lpcOrder	HTKLib/HParm.c	/^   int lpcOrder;              \/* Order of lpc analysis *\/$/;"	m	struct:__anon141	file:
lpcalc_vc_id	HLMLib/LPCalc.c	/^char *lpcalc_vc_id = "$Id: LPCalc.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lpcalc_version	HLMLib/LPCalc.c	/^char *lpcalc_version = "!HVER!LPCalc:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lplex_vc_id	HLMTools/LPlex.c	/^char *lplex_vc_id = "$Id: LPlex.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lplex_version	HLMTools/LPlex.c	/^char *lplex_version = "!HVER!LPlex:     3.4.1 [CUED 12\/03\/09]";$/;"	v
lpmerge_vc_id	HLMLib/LPMerge.c	/^char *lpmerge_vc_id = "$Id: LPMerge.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lpmerge_version	HLMLib/LPMerge.c	/^char *lpmerge_version = "!HVER!LPMerge:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lrelTokHeap	HTKLVRec/HLVRec.h	/^   MemHeap lrelTokHeap;         \/* MHEAP for larger size RelToken arrays (e.g. 6 * dec->nTok-1 elements) *\/$/;"	m	struct:_DecoderInst
lsChunkHeap	HTKTools/HParse.c	/^static MemHeap lsChunkHeap;$/;"	v	file:
lsHeap	HTKTools/HParse.c	/^static MemHeap lsHeap;$/;"	v	file:
lsLargeHeap	HTKTools/HParse.c	/^static MemHeap lsLargeHeap;$/;"	v	file:
lset	HTKTools/HSLab.c	/^   int lset;            \/* label set *\/$/;"	m	struct:__anon211	file:
lsubset_vc_id	HLMTools/LSubset.c	/^char *lsubset_vc_id = "$Id: LSubset.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
lsubset_version	HLMTools/LSubset.c	/^char *lsubset_version = "!HVER!LSubset:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lutil_vc_id	HLMLib/LUtil.c	/^char *lutil_vc_id = "$Id: LUtil.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lutil_version	HLMLib/LUtil.c	/^char *lutil_version = "!HVER!LUtil:   3.4.1 [CUED 12\/03\/09]";$/;"	v
lvobjects	HTKLib/Makefile	/^lvobjects = $(basename HGraf.o).lv.o esig_asc.lv.o \\$/;"	m
lwmap_vc_id	HLMLib/LWMap.c	/^char *lwmap_vc_id = "$Id: LWMap.c,v 1.1.1.1 2006\/10\/11 09:54:43 jal58 Exp $";$/;"	v
lwmap_version	HLMLib/LWMap.c	/^char *lwmap_version = "!HVER!LWMap:   3.4.1 [CUED 12\/03\/09]";$/;"	v
m	HTKLib/HModel.h	/^   MLink m;                \/* macro def for this structure *\/$/;"	m	struct:_PtrMap
m	HTKLib/HUtil.h	/^   int m;            \/* current mixture index 1..M *\/$/;"	m	struct:__anon169
m	HTKTools/HParse.c	/^   LabId m;$/;"	m	struct:__anon206	file:
mId	HLMLib/LPMerge.c	/^   int     *mId;             \/* map array for speedy FE\/SE copying *\/$/;"	m	struct:__anon17	file:
mIdx	HTKLib/HModel.h	/^   int mIdx;            \/* MixPDF index *\/$/;"	m	struct:__anon120
mInfo	HTKLib/HAdapt.c	/^   MInfo *mInfo;         \/* any original model information *\/$/;"	m	struct:__anon88	file:
mPre	HTKLib/HRec.c	/^   PreComp *mPre;           \/* Array[1..nmp] Shared mixture PreComps *\/$/;"	m	struct:psetinfo	file:
mac	HTKLib/HUtil.h	/^   MLink mac;        \/* current macro *\/$/;"	m	struct:__anon169
macro	HTKTools/HHEd.c	/^   MLink macro;                 \/* macro used for tie *\/$/;"	m	struct:_Node	file:
macroLink	HTKTools/HCompV.c	/^static MLink macroLink;             \/* Link to specific HMM macro *\/$/;"	v	file:
macroLink	HTKTools/HInit.c	/^static MLink macroLink;          \/* Access to macro in HMMSet *\/$/;"	v	file:
macroType	HTKLib/HModel.c	/^   char macroType;      \/* current macro type if sym==MACRO *\/$/;"	m	struct:__anon119	file:
magic	HTKLVRec/kenlm/lm/binary_format.cc	/^  char magic[ALIGN8(sizeof(kMagicBytes))];$/;"	m	struct:lm::ngram::__anon41::Sanity	file:
magic	HTKLVRec/kenlm/lm/binary_format.cc	/^  char magic[sizeof(kMagicBytes)];$/;"	m	struct:lm::ngram::__anon41::OldSanity	file:
magic	HTKLib/HAudio.c	/^   DWORD magic;             \/* Magic number identifying this instance *\/$/;"	m	struct:_AudioIn	file:
magic	HTKLib/HAudio.c	/^   DWORD magic;             \/* Magic number identifying this instance *\/$/;"	m	struct:_AudioOut	file:
magic	HTKLib/HVQ.h	/^   short magic;         \/* magic num, usually the ParmKind *\/$/;"	m	struct:_VQTabRec
magic	HTKLib/HWave.c	/^   int32 magic;          \/* magic number 0x2e736e64 *\/$/;"	m	struct:__anon176	file:
main	HLMTools/Cluster.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/HLMCopy.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LAdapt.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LBuild.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LFoF.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LGCopy.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LGList.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LGPrep.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LLink.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LMerge.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LNewMap.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LNorm.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LPlex.c	/^int main(int argc, char *argv[])$/;"	f
main	HLMTools/LSubset.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKLVRec/HDecode.c	/^main (int argc, char *argv[])$/;"	f
main	HTKLVRec/HDecode.mod.c	/^main (int argc, char *argv[])$/;"	f
main	HTKLib/HParm.c	/^   PBlock main;        \/* Main block of data (next points to first block) *\/$/;"	m	struct:_ParmBuf	file:
main	HTKTools/HBuild.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HCompV.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HCopy.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HDMan.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HERest.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HHEd.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HInit.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HLEd.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HLRescore.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HLStats.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HList.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HMMIRest.c	/^int main(int argc, char *argv[]) $/;"	f
main	HTKTools/HParse.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HQuant.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HRest.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HResults.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HSGen.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HSLab.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HSmooth.c	/^int main(int argc, char *argv[])$/;"	f
main	HTKTools/HVite.c	/^int main(int argc, char *argv[])$/;"	f
maintex	HTKBook/Makefile	/^maintex =    htkbook.tex HTK.tex errors.tex hlmtutorial.tex labels.tex      \\$/;"	m
make_full	HTKLVRec/kenlm/lm/partial.hh	/^  bool make_full;$/;"	m	struct:lm::ngram::ExtendReturn
mandir	HLMLib/Makefile	/^mandir = ${prefix}\/share\/man$/;"	m
mandir	HLMTools/Makefile	/^mandir = ${prefix}\/share\/man$/;"	m
mandir	HTKLVRec/Makefile	/^mandir = ${prefix}\/share\/man$/;"	m
mandir	HTKLib/Makefile	/^mandir = ${prefix}\/share\/man$/;"	m
mandir	HTKTools/Makefile	/^mandir = ${prefix}\/share\/man$/;"	m
mandir	Makefile	/^mandir = ${prefix}\/share\/man$/;"	m
mapFN	HLMLib/LPMerge.c	/^   char    *mapFN;           \/* LM symbol map file *\/$/;"	m	struct:__anon17	file:
mapFN	HLMTools/LFoF.c	/^static char       *mapFN = NULL;    \/* word map file name *\/$/;"	v	file:
mapFN	HLMTools/LGCopy.c	/^static char *mapFN   = NULL;        \/* word map file name *\/$/;"	v	file:
mapTau	HTKLib/HMap.c	/^static float mapTau     = 20.0;                \/* Guides the MAP process *\/$/;"	v	file:
mapUpdated	HLMTools/LAdapt.c	/^static Boolean mapUpdated;            \/* used optimise sort\/saving *\/$/;"	v	file:
mapUpdated	HLMTools/LGPrep.c	/^static Boolean mapUpdated;          \/* used optimise sort\/saving *\/$/;"	v	file:
mapWords	HLMTools/LGCopy.c	/^static Boolean mapWords = FALSE;    \/* map words to classes *\/$/;"	v	file:
map_	HTKLVRec/kenlm/lm/builder/print.hh	/^    std::vector<const char*> map_;$/;"	m	class:lm::builder::VocabReconstitute
mapped_offset_	HTKLVRec/kenlm/util/file_piece.hh	/^    uint64_t mapped_offset_;$/;"	m	class:util::FilePiece
mapping_	HTKLVRec/kenlm/lm/binary_format.hh	/^    util::scoped_memory mapping_;$/;"	m	class:lm::ngram::BinaryFormat
marginCount	HTKLib/HParm.c	/^   int marginCount;           \/*   of sil around speech to process *\/$/;"	m	struct:__anon141	file:
markA	HTKTools/HSLab.c	/^static int markA, markB;               \/* boundaries of a marked region *\/$/;"	v	file:
markB	HTKTools/HSLab.c	/^static int markA, markB;               \/* boundaries of a marked region *\/$/;"	v	file:
mask	HTKLVRec/kenlm/util/bit_packing.hh	/^  uint64_t mask;$/;"	m	struct:util::BitsMask
mask_	HTKLVRec/kenlm/lm/quantize.hh	/^        uint64_t mask_;$/;"	m	class:lm::ngram::SeparatelyQuantize::Bins
master_	HTKLVRec/kenlm/lm/builder/output.hh	/^    const Output *master_;$/;"	m	class:lm::builder::OutputHook
matBiGram	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon187	file:
matBigram	HTKLib/HLM.h	/^typedef enum { boNGram=1, matBigram, hlmModel } LMType;$/;"	e	enum:__anon105
matPK	HTKLib/HParm.c	/^   ParmKind matPK;$/;"	m	struct:__anon141	file:
matTranFN	HTKLib/HParm.h	/^   char *matTranFN;           \/* Matrix transformation name *\/$/;"	m	struct:__anon149
matbi	HTKLib/HLM.h	/^      MatBiLM *matbi;$/;"	m	union:lmodel::__anon106
matbilm	HTKLib/HLM.h	/^typedef struct matbilm {$/;"	s
max	HTKLVRec/kenlm/util/string_piece.hh	91;"	d
max	HTKLib/HRec.c	/^   LogFloat max;        \/* Likelihood for pruning of instance *\/$/;"	m	struct:_NetInst	file:
max	HTKLib/HRec.c	/^   int max;                 \/* Max states in HMM set *\/$/;"	m	struct:psetinfo	file:
maxActive	HTKTools/HVite.c	/^static int maxActive = 0;         \/* max active phone instances *\/$/;"	v	file:
maxAlphaBeta	HTKLib/HFB.h	/^  LogDouble maxAlphaBeta;   \/* max alpha\/beta product along beam ridge *\/$/;"	m	struct:__anon97
maxAuxLab	HTKLib/HLabel.h	/^   int maxAuxLab;           \/* max aux labels (default=0) *\/$/;"	m	struct:_LabList
maxBeam	HTKLib/HRec.h	/^   int maxBeam;             \/* Maximum model instance beam *\/$/;"	m	struct:vrecinfo
maxBeamWidth	HTKLib/HFB.h	/^  int maxBeamWidth;         \/* max width of beam in model units *\/$/;"	m	struct:__anon97
maxClndx	HLMLib/LCMap.h	/^   int maxClndx;   	     	\/* highest class index in map *\/$/;"	m	struct:__anon1
maxDur	HTKTools/HLStats.c	/^   float maxDur;                 \/* Max duration *\/$/;"	m	struct:wordinfo	file:
maxElem	HTKLib/HMem.h	/^   size_t maxElem;      \/*  max #elems per block     max #bytes per blk   *\/$/;"	m	struct:__anon116
maxId	HLMLib/LWMap.h	/^   int maxId;            \/* max index (mapped to size-1) *\/$/;"	m	struct:__anon22
maxIter	HTKLib/HTrain.c	/^static int maxIter = 10;               \/* max num cluster iterations *\/$/;"	v	file:
maxIter	HTKTools/HInit.c	/^static int  maxIter  = 20;          \/* max iterations in param estimation *\/$/;"	v	file:
maxIter	HTKTools/HRest.c	/^static int  maxIter  = 20;       \/* max iterations in parameter estimation *\/$/;"	v	file:
maxLLFs	HTKLib/HLat.c	/^static int maxLLFs = 5; $/;"	v	file:
maxLMLA	HTKLVRec/HLVRec.c	/^static LogFloat maxLMLA = -LZERO; \/* maximum jump in LM lookahead per model *\/$/;"	v	file:
maxLMLA	HTKLVRec/HLVRec.h	/^   float maxLMLA;               \/* maximum jump in LM lookahead per model *\/$/;"	m	struct:_DecoderInst
maxLNBeamFlr	HTKLVRec/HLVRec.c	/^static float maxLNBeamFlr = 0.8;        \/* maximum percentile of glogal beam for max model pruning *\/$/;"	v	file:
maxLinks	HTKTools/HParse.c	/^   short maxLinks;   \/* max number of links *\/$/;"	m	struct:__anon203	file:
maxM	HTKLib/HFB.h	/^  int maxM;           \/* maximum number of mixtures in hmmset *\/$/;"	m	struct:__anon99
maxM	HTKLib/HMap.c	/^static int maxM;$/;"	v	file:
maxM	HTKTools/HMMIRest.c	/^static int maxM = 0;             \/* max mixtures in any model *\/$/;"	v	file:
maxM	HTKTools/HVite.c	/^static int maxM = 0;              \/* max mixtures in any model *\/$/;"	v	file:
maxMixInS	HTKLib/HFB.h	/^  int maxMixInS[SMAX];\/* array[1..swidth[0]] of max mixes *\/$/;"	m	struct:__anon99
maxMixInS	HTKTools/HInit.c	/^static int maxMixInS[SMAX];      \/* array[1..swidth[0]] of max mixes *\/$/;"	v	file:
maxMixInS	HTKTools/HRest.c	/^static int maxMixInS[SMAX];\/* array[1..swidth[0]] of max mixes *\/$/;"	v	file:
maxMixInS	HTKTools/HVite.c	/^static int maxMixInS[SMAX];       \/* array[1..swidth[0]] of max mixes *\/$/;"	v	file:
maxMixes	HTKLib/HUtil.c	/^static int maxMixes;           \/*  and max number of mix comps *\/$/;"	v	file:
maxMixes	HTKTools/HHEd.c	/^static int maxMixes;       \/* max number of mixes in current HMM set *\/$/;"	v	file:
maxMixes	HTKTools/HRest.c	/^static int maxMixes;       \/* max num mixtures across all streams *\/$/;"	v	file:
maxMixes	HTKTools/HSmooth.c	/^static int maxMixes = 0;         \/* max mixtures in any model *\/$/;"	v	file:
maxModel	HTKLVRec/HDecode.c	/^static int maxModel = 0;        \/* max model pruning *\/$/;"	v	file:
maxModel	HTKLVRec/HDecode.mod.c	/^static int maxModel = 0;        \/* max model pruning *\/$/;"	v	file:
maxModel	HTKLVRec/HLVRec.h	/^   int maxModel;                \/* for max model pruning (set by -u cmd line option) *\/$/;"	m	struct:_DecoderInst
maxNDepth	HTKTools/HResults.c	/^static int maxNDepth=1;               \/* find best of 1..max lists *\/$/;"	v	file:
maxNOpen	HLMLib/LGBase.h	/^   int maxNOpen;           \/* max number of open files *\/$/;"	m	struct:__anon4
maxNStates	HTKLVRec/HLVRec.h	/^   int maxNStates;              \/* max number of states in a HMM in HMMSet *\/$/;"	m	struct:_DecoderInst
maxP	HTKLib/HModel.h	/^   LogFloat maxP;        \/* max log mixture prob *\/$/;"	m	struct:__anon124
maxRows	HTKLib/HParm.c	/^   int maxRows;      \/* total number of rows in this block *\/$/;"	m	struct:pblock	file:
maxSemiTiedIter	HTKLib/HAdapt.c	/^static int maxSemiTiedIter = 10;$/;"	v	file:
maxSpUtt	HTKTools/HERest.c	/^static int maxSpUtt = 0;$/;"	v	file:
maxStates	HTKLib/HUtil.c	/^static int maxStates;          \/*  and its max number of states *\/$/;"	v	file:
maxStates	HTKTools/HHEd.c	/^static int maxStates;      \/* max number of states in current HMM set *\/$/;"	v	file:
maxStates	HTKTools/HSmooth.c	/^static int maxStates = 0;        \/* max states in any model *\/$/;"	v	file:
maxStep	HTKTools/HSmooth.c	/^static int maxStep   = 16;       \/* max number of binary chops *\/$/;"	v	file:
maxT	HTKTools/HRest.c	/^static int maxT,minT,T;    \/* max,min and current segment lengths *\/$/;"	v	file:
maxTry	HTKLib/HShell.c	/^static int maxTry = 1;$/;"	v	file:
maxWordLen	HTKTools/HResults.c	/^static int maxWordLen = 5;$/;"	v	file:
maxXFormIter	HTKLib/HAdapt.c	/^static double maxXFormIter = 10; \/* something big, for CMLLR *\/ $/;"	v	file:
max_leading_padding_zeroes_in_precision_mode_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const int max_leading_padding_zeroes_in_precision_mode_;$/;"	m	class:double_conversion::DoubleToStringConverter
max_likelihood_check	HLMTools/Cluster.c	/^static void max_likelihood_check(void)$/;"	f	file:
max_likelihood_init	HLMTools/Cluster.c	/^static void max_likelihood_init(void)$/;"	f	file:
max_line_len	HLMTools/Cluster.c	1228;"	d	file:
max_size	HTKLVRec/kenlm/util/string_piece.hh	/^  size_type max_size() const { return length_; }$/;"	f	class:StringPiece
max_trailing_padding_zeroes_in_precision_mode_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const int max_trailing_padding_zeroes_in_precision_mode_;$/;"	m	class:double_conversion::DoubleToStringConverter
max_vocab_	HTKLVRec/kenlm/lm/trie.hh	/^    uint64_t insert_index_, max_vocab_;$/;"	m	class:lm::ngram::trie::BitPacked
max_word_index	HTKLVRec/kenlm/lm/binary_format.cc	/^  WordIndex one_word_index, max_word_index, padding_to_8;$/;"	m	struct:lm::ngram::__anon41::Sanity	file:
max_word_index	HTKLVRec/kenlm/lm/binary_format.cc	/^  WordIndex one_word_index, max_word_index;$/;"	m	struct:lm::ngram::__anon41::OldSanity	file:
max_words	HLMTools/Cluster.c	/^static int          max_words;              \/* Maximum number of words *\/$/;"	v	file:
me	HLMLib/LWMap.h	/^   MapEntry *me;         \/* array[0..used-1] of mapentry *\/$/;"	m	struct:__anon23
me	HTKLib/HUtil.h	/^   MixtureElem *me;  \/* ->current mixtureElem *\/$/;"	m	struct:__anon169
me_end	HTKLib/HArc.h	/^  HArc *me_start; HArc *me_end;\/* first & last arc. *\/$/;"	m	struct:_CorrN
me_start	HTKLib/HArc.h	/^  HArc *me_start; HArc *me_end;\/* first & last arc. *\/$/;"	m	struct:_CorrN
mean	HTKLib/HAdapt.c	/^   Vector mean;$/;"	m	struct:__anon86	file:
mean	HTKLib/HModel.h	/^   SVector mean;        \/* mean vector *\/$/;"	m	struct:__anon120
mean	HTKLib/HParm.c	/^   Vector mean;       \/* Running mean shared by this config *\/$/;"	m	struct:__anon141	file:
mean	HTKLib/HVQ.h	/^   Vector mean;         \/* centre of this node *\/$/;"	m	struct:_VQNodeRec
mean	HTKTools/HQuant.c	/^Vector mean[SMAX];                 \/* Global stream mean  *\/$/;"	v
meanGC	HTKTools/HHEd.c	/^static float meanGC,stdGC;             \/* mean and stdev of GConst *\/$/;"	v	file:
meanSum	HTKTools/HCompV.c	/^   Vector       meanSum;            \/* acc for mean vector value *\/$/;"	m	struct:__anon189	file:
meanSum	HTKTools/HCompV.c	/^   Vector meanSum;                       \/* mean accumulate structure for speaker *\/$/;"	m	struct:__anon190	file:
meanUpdate	HTKTools/HCompV.c	/^static Boolean meanUpdate = FALSE;  \/* update means  *\/$/;"	v	file:
meanrec	HTKLib/HParm.c	/^typedef struct meanrec $/;"	s	file:
measureSil	HTKLib/HParm.c	/^   Boolean measureSil;        \/* Measure Silence *\/$/;"	m	struct:__anon141	file:
mem	HLMLib/LCMap.h	/^   MemHeap mem;    	     	\/* memory heap for this class map *\/$/;"	m	struct:__anon1
mem	HLMLib/LGBase.h	/^   MemHeap *mem;           \/* memory stack for this input set *\/$/;"	m	struct:__anon4
mem	HLMLib/LUtil.c	/^   MemHeap *mem;$/;"	m	struct:lmFileHdrRec	file:
mem	HLMLib/LWMap.h	/^   MemHeap mem;          \/* memory heap for this word map *\/$/;"	m	struct:__anon23
mem	HLMTools/LGPrep.c	/^   MemHeap mem;               \/* Memory for this ruleset *\/$/;"	m	struct:__anon31	file:
mem	HTKLib/HArc.h	/^  MemHeap *mem;$/;"	m	struct:ArcInfoStruct
mem	HTKLib/HAudio.c	/^   MemHeap *mem;             \/* memory heap for this audio rec *\/$/;"	m	struct:_AudioIn	file:
mem	HTKLib/HAudio.c	/^   MemHeap *mem;             \/* memory heap for this audio rec *\/$/;"	m	struct:_AudioOut	file:
mem	HTKLib/HModel.h	/^  MemHeap *mem;                     \/* heap used for storing transform *\/$/;"	m	struct:_AdaptXForm
mem	HTKLib/HParm.c	/^   MemHeap *mem;       \/* Memory heap for this parm buf *\/$/;"	m	struct:_ParmBuf	file:
mem	HTKLib/HTrain.h	/^   MemHeap *mem;        \/* memory for this seg store *\/$/;"	m	struct:_SegStoreRec
mem	HTKLib/HTrain.h	/^   MemHeap *mem;     \/* memory stack for this sequence *\/$/;"	m	struct:__anon160
mem	HTKLib/HWave.c	/^   MemHeap *mem;        \/* memory heap for this wave rec *\/$/;"	m	struct:_Wave	file:
memDC	HTKLib/HGraf_WIN32.c	/^static HDC memDC = NULL;          \/* A handle to the memory device context *\/$/;"	v	file:
memStak	HTKTools/HDMan.c	/^static MemHeap memStak;              \/* all storage allocated in this *\/$/;"	v	file:
mem_	HTKLVRec/kenlm/util/mmap.hh	/^    scoped_memory mem_;$/;"	m	class:util::Rolling
mem_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    util::scoped_malloc mem_;$/;"	m	class:util::AutoProbing
mem_	HTKLVRec/kenlm/util/stream/block.hh	/^    void *mem_;$/;"	m	class:util::stream::Block
memory_	HTKLVRec/kenlm/lm/builder/print.hh	/^    util::scoped_memory memory_;$/;"	m	class:lm::builder::VocabReconstitute
memory_	HTKLVRec/kenlm/util/stream/chain.hh	/^    scoped_malloc memory_;$/;"	m	class:util::stream::Chain
memory_search_	HTKLVRec/kenlm/lm/binary_format.hh	/^    util::scoped_memory memory_vocab_, memory_search_;$/;"	m	class:lm::ngram::BinaryFormat
memory_vocab_	HTKLVRec/kenlm/lm/binary_format.hh	/^    util::scoped_memory memory_vocab_, memory_search_;$/;"	m	class:lm::ngram::BinaryFormat
mergeDir	HTKTools/HLRescore.c	/^static char *mergeDir;          \/* lattice merging direction *\/$/;"	v	file:
mergeLat	HTKTools/HLRescore.c	/^static Boolean mergeLat = FALSE;    \/* -m *\/$/;"	v	file:
mergeProns	HTKTools/HDMan.c	/^static Boolean mergeProns = FALSE;   \/* merge prons from all sources *\/$/;"	v	file:
mergeTokOnly	HTKLVRec/HLVRec.c	/^static Boolean mergeTokOnly = TRUE;     \/* if merge token set with pruning *\/$/;"	v	file:
messages	HTKLVRec/kenlm/lm/config.hh	/^  std::ostream *messages;$/;"	m	struct:lm::ngram::Config
messages_	HTKLVRec/kenlm/lm/search_trie.cc	/^    BackoffMessages messages_[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::trie::__anon58::SRISucks	file:
micIn	HTKLib/HAudio.c	/^static Boolean micIn = FALSE;$/;"	v	file:
middle_	HTKLVRec/kenlm/lm/search_hashed.hh	/^    std::vector<Middle> middle_;$/;"	m	class:lm::ngram::detail::HashedSearch
middle_	HTKLVRec/kenlm/lm/search_trie.cc	/^    BitPackedMiddle<Bhiksha> *const middle_;$/;"	m	class:lm::ngram::trie::__anon58::WriteEntries	file:
middle_begin_	HTKLVRec/kenlm/lm/search_trie.hh	/^    Middle *middle_begin_, *middle_end_;$/;"	m	class:lm::ngram::trie::TrieSearch
middle_end_	HTKLVRec/kenlm/lm/search_trie.hh	/^    Middle *middle_begin_, *middle_end_;$/;"	m	class:lm::ngram::trie::TrieSearch
min	HTKLVRec/kenlm/util/string_piece.hh	92;"	d
minAlphaBeta	HTKLib/HFB.h	/^  LogDouble minAlphaBeta;   \/* min alpha\/beta product along beam ridge *\/$/;"	m	struct:__anon97
minClustSize	HTKLib/HTrain.c	/^static int minClustSize = 3;           \/* min num vectors in cluster *\/$/;"	v	file:
minDur	HTKLib/HTrain.h	/^   int minDur;       \/* Min no of frames to get through trans mat *\/$/;"	m	struct:__anon163
minDur	HTKTools/HLStats.c	/^   float minDur;                 \/* Min duration *\/$/;"	m	struct:wordinfo	file:
minEgs	HTKLib/HMap.c	/^static int minEgs    = 0;        \/* min examples to train a model *\/$/;"	v	file:
minEgs	HTKTools/HERest.c	/^static int minEgs    = 3;        \/* min examples to train a model *\/$/;"	v	file:
minEgs	HTKTools/HSmooth.c	/^static int minEgs    = 3;        \/* min examples to train a model *\/$/;"	v	file:
minElem	HTKLib/HMem.h	/^   size_t minElem;      \/*  init #elems per blk      init #bytes per blk  *\/$/;"	m	struct:__anon116
minFrwdP	HTKLib/HFB.c	/^   float minFrwdP;           \/* mix prune threshold *\/$/;"	m	struct:__anon95	file:
minFrwdP	HTKLib/HFBLat.c	/^static float minFrwdP = 10.0;            \/* mix prune threshold *\/$/;"	v	file:
minFrwdP	HTKTools/HERest.c	/^static float minFrwdP = NOPRUNE;         \/* mix prune threshold *\/$/;"	v	file:
minGap	HTKTools/HLEd.c	/^static HTime minGap = 50000.0;      \/* minimum interword gap *\/$/;"	v	file:
minId	HLMLib/LWMap.h	/^   int minId;            \/* min index (mapped to 0) *\/$/;"	m	struct:__anon22
minLogExp	HTKLib/HMath.c	/^static LogDouble minLogExp;$/;"	v	file:
minObs	HTKLib/HMap.c	/^static float minObs  = 0;        \/* min observations  to train a model *\/$/;"	v	file:
minOccThresh	HTKLib/HAdapt.c	/^static float minOccThresh = 0.0;       \/* minimum occupancy to accumulate stats to estimate xform *\/$/;"	v	file:
minRows	HTKLib/HParm.c	/^   int minRows;        \/* min rows to keep in main block *\/$/;"	m	struct:_ParmBuf	file:
minSeg	HTKTools/HInit.c	/^static int minSeg    = 3;           \/* min segments to train a model *\/$/;"	v	file:
minSeg	HTKTools/HRest.c	/^static int minSeg    = 3;        \/* min segments to train a model *\/$/;"	v	file:
minT	HTKTools/HRest.c	/^static int maxT,minT,T;    \/* max,min and current segment lengths *\/$/;"	v	file:
minVar	HTKLib/HMap.c	/^static float minVar  = 0.0;      \/* minimum variance (diagonal only) *\/$/;"	v	file:
minVar	HTKTools/HCompV.c	/^static float minVar  = 0.0;         \/* minimum variance *\/$/;"	v	file:
minVar	HTKTools/HERest.c	/^static float minVar  = 0.0;      \/* minimum variance (diagonal only) *\/$/;"	v	file:
minVar	HTKTools/HInit.c	/^static float minVar  = 1.0E-2;      \/* minimum variance *\/$/;"	v	file:
minVar	HTKTools/HMMIRest.c	/^static float minVar  = 0.0;      \/* minimum variance (diagonal only). $/;"	v	file:
minVar	HTKTools/HRest.c	/^static float minVar  = 0.0;      \/* minimum variance *\/$/;"	v	file:
minVar	HTKTools/HSmooth.c	/^static float minVar  = 0.0;      \/* minimum variance (diagonal only) *\/$/;"	v	file:
minab	HTKLib/HMath.c	685;"	d	file:
minimum_block	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  std::size_t minimum_block;$/;"	m	struct:lm::builder::PipelineConfig
minus_half_f	HTKLVRec/kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon41::OldSanity	file:
minus_half_f	HTKLVRec/kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon41::Sanity	file:
miscStack	HTKLib/HFBLat.h	/^  MemHeap miscStack;$/;"	m	struct:__anon102
mix	HTKTools/HHEd.c	/^   int    mix;               \/* mixture for this component *\/$/;"	m	struct:_CoList	file:
mixId	HTKLib/HModel.h	/^   LabId mixId;          \/* id of macro base name *\/$/;"	m	struct:__anon124
mixOutP	HTKLVRec/HLVRec.h	/^   LogFloat *mixOutP;$/;"	m	struct:_OutPCache
mixPerBlock	HTKLVRec/HLVModel.h	/^   unsigned long mixPerBlock;$/;"	m	struct:_StateInfo_lv
mixShared	HTKLib/HRec.c	/^   Boolean mixShared;$/;"	m	struct:psetinfo	file:
mixT	HTKLVRec/HLVRec.h	/^   int *mixT;$/;"	m	struct:_OutPCache
mixWeightFloor	HTKLib/HMap.c	/^static float mixWeightFloor=0.0; \/* Floor for mixture weights *\/$/;"	v	file:
mixWeightFloor	HTKTools/HERest.c	/^static float mixWeightFloor=0.0; \/* Floor for mixture weights *\/$/;"	v	file:
mixWeightFloor	HTKTools/HInit.c	/^static float mixWeightFloor=0.0;    \/*Floor for mixture\/discrete prob weights*\/$/;"	v	file:
mixWeightFloor	HTKTools/HMMIRest.c	/^static float mixWeightFloor=MINMIX*2; \/* Floor for mixture weights *\/$/;"	v	file:
mixWeightFloor	HTKTools/HRest.c	/^static float mixWeightFloor=0.0; \/* Floor for mixture weights *\/$/;"	v	file:
mixWeightFloor	HTKTools/HSmooth.c	/^static float mixWeightFloor=0.0; \/* Floor for mixture weights *\/$/;"	v	file:
mixer_fd	HTKLib/HAudio.c	/^static int mixer_fd;$/;"	v	file:
mixes	HTKLib/HModel.h	/^   MixPDF ** mixes;      \/* array[1..M] of MixPDF *\/$/;"	m	struct:__anon124
mixoutp	HTKTools/HRest.c	/^static Matrix **mixoutp;   \/* array[2..nStates-1][1..maxT][1..nStreams]$/;"	v	file:
mkinstalldirs	Makefile	/^mkinstalldirs = $(SHELL) $(top_srcdir)\/mkinstalldirs$/;"	m
mkstemp_and_unlink	HTKLVRec/kenlm/util/file.cc	/^mkstemp_and_unlink(char *tmpl) {$/;"	f	namespace:util
mkstemp_and_unlink	HTKLVRec/kenlm/util/file.cc	/^mkstemp_and_unlink(char *tmpl)$/;"	f	namespace:util
ml	HTKTools/HHEd.c	/^   MLink ml;$/;"	m	struct:__anon197	file:
ml_cnt	HTKLib/HParm.c	/^   ml_cnt      \/* Total size of ml results array *\/$/;"	e	enum:__anon144	file:
ml_max	HTKLib/HParm.c	/^   ml_max,     \/* Max frame energy *\/$/;"	e	enum:__anon144	file:
ml_min	HTKLib/HParm.c	/^   ml_min,     \/* Min frame energy *\/$/;"	e	enum:__anon144	file:
ml_off	HTKLib/HParm.c	/^   ml_off,     \/* Average sample offset *\/$/;"	e	enum:__anon144	file:
ml_range	HTKLib/HParm.c	/^   ml_range,   \/* Peak to peak sample range (% of max) *\/$/;"	e	enum:__anon144	file:
ml_sil	HTKLib/HParm.c	/^   ml_sil,     \/* Average silence energy *\/$/;"	e	enum:__anon144	file:
ml_snr	HTKLib/HParm.c	/^   ml_snr,     \/* Assumed SNR ratio *\/$/;"	e	enum:__anon144	file:
ml_sp	HTKLib/HParm.c	/^   ml_sp,      \/* Average speeck energy *\/$/;"	e	enum:__anon144	file:
ml_thresh	HTKLib/HParm.c	/^   ml_thresh,  \/* Threshold for speech detector *\/$/;"	e	enum:__anon144	file:
mlfHead	HTKLib/HLabel.c	/^static MLFEntry *mlfHead = NULL; \/* head of linked list of MLFEntry *\/$/;"	v	file:
mlfHeap	HTKLib/HLabel.c	/^static MemHeap mlfHeap;          \/* memory heap for MLF stuff *\/$/;"	v	file:
mlfTail	HTKLib/HLabel.c	/^static MLFEntry *mlfTail = NULL; \/* tail of linked list of MLFEntry *\/$/;"	v	file:
mlfUsed	HTKLib/HLabel.c	/^static int      mlfUsed = 0;     \/* number of entries in mlfTab *\/$/;"	v	file:
mlfile	HTKLib/HLabel.c	/^static FILE   * mlfile[MAXMLFS]; \/* array [0..numMLFs-1] of MLF file *\/$/;"	v	file:
mllrCov2CMLLR	HTKLib/HAdapt.c	/^static Boolean mllrCov2CMLLR= FALSE;   \/* apply mllrcov transforms as cmllr transform *\/ $/;"	v	file:
mllrCovAdaptKind	HTKLib/HAdapt.c	/^static AdaptKind mllrCovAdaptKind = BASE;$/;"	v	file:
mllrCovBaseClass	HTKLib/HAdapt.c	/^static char *mllrCovBaseClass = NULL;$/;"	v	file:
mllrCovBlockSize	HTKLib/HAdapt.c	/^static IntVec mllrCovBlockSize = NULL;$/;"	v	file:
mllrCovRegTree	HTKLib/HAdapt.c	/^static char *mllrCovRegTree = NULL;$/;"	v	file:
mllrCovSplitThresh	HTKLib/HAdapt.c	/^static float mllrCovSplitThresh = 1000.0;$/;"	v	file:
mllrDiagCov	HTKLib/HAdapt.c	/^static Boolean mllrDiagCov = FALSE;    \/* perform diagonal covariance adaptation *\/$/;"	v	file:
mllrMeanAdaptKind	HTKLib/HAdapt.c	/^static AdaptKind mllrMeanAdaptKind = BASE;$/;"	v	file:
mllrMeanBaseClass	HTKLib/HAdapt.c	/^static char *mllrMeanBaseClass = NULL;$/;"	v	file:
mllrMeanBlockSize	HTKLib/HAdapt.c	/^static IntVec mllrMeanBlockSize = NULL;$/;"	v	file:
mllrMeanRegTree	HTKLib/HAdapt.c	/^static char *mllrMeanRegTree = NULL;$/;"	v	file:
mllrMeanSplitThresh	HTKLib/HAdapt.c	/^static float mllrMeanSplitThresh = 1000.0;$/;"	v	file:
mlv	HLMTools/Cluster.c	/^static double     *mlv;                     \/* ML values involving class [N] *\/$/;"	v	file:
mmApiBuf	HTKLib/HAudio.c	/^} mmApiBuf;$/;"	t	typeref:struct:mmapibuf	file:
mmError	HTKLib/HAudio.c	/^   MMRESULT mmError;$/;"	m	struct:_AudioIn	file:
mmError	HTKLib/HAudio.c	/^   MMRESULT mmError;$/;"	m	struct:_AudioOut	file:
mmWPos	HTKTools/HSLab.c	/^static int mmWPos;$/;"	v	file:
mmapibuf	HTKLib/HAudio.c	/^typedef struct mmapibuf{$/;"	s	file:
mmeAllocBuffer	HTKLib/HAudio.c	/^void *mmeAllocBuffer(size_t size)$/;"	f
mmeAllocMem	HTKLib/HAudio.c	/^void *mmeAllocMem(size_t size)$/;"	f
mmeCheckForCallbacks	HTKLib/HAudio.c	/^Boolean mmeCheckForCallbacks(void)$/;"	f
mmeFreeBuffer	HTKLib/HAudio.c	/^Boolean mmeFreeBuffer(void *ptr)$/;"	f
mmeFreeMem	HTKLib/HAudio.c	/^Boolean mmeFreeMem(void *ptr)$/;"	f
mmeProcessCallbacks	HTKLib/HAudio.c	/^void mmeProcessCallbacks(void)$/;"	f
mmeWaitForCallbacks	HTKLib/HAudio.c	/^void mmeWaitForCallbacks(void)$/;"	f
mmfFn	HTKTools/HERest.c	/^static char * mmfFn  = NULL;     \/* output MMF file, if any *\/$/;"	v	file:
mmfFn	HTKTools/HHEd.c	/^static char * mmfFn  = NULL;     \/* output MMF file, if any *\/$/;"	v	file:
mmfFn	HTKTools/HMMIRest.c	/^static char * mmfFn  = NULL;     \/* output MMF file, if any *\/$/;"	v	file:
mmfIdMask	HTKLib/HModel.h	/^  char* mmfIdMask;     \/* mask of model sets that appropriate for *\/$/;"	m	struct:__anon129
mmfIdMask	HTKLib/HModel.h	/^  char* mmfIdMask;     \/* mask of model sets that appropriate for *\/$/;"	m	struct:__anon134
mmfIdMask	HTKTools/HHEd.c	/^static char mmfIdMask[MAXSTRLEN] = "*"; \/* MMF Id Mask for baseclass *\/$/;"	v	file:
mmfNames	HTKLib/HModel.h	/^   MILink mmfNames;        \/* List of external file names *\/$/;"	m	struct:_HMMSet
modAlign	HTKLVRec/HLVRec.h	/^   Boolean modAlign;$/;"	m	struct:_DecoderInst
modelHeap	HTKLVRec/HDecode.c	/^static MemHeap modelHeap;$/;"	v	file:
modelHeap	HTKLVRec/HDecode.mod.c	/^static MemHeap modelHeap;$/;"	v	file:
modelHeap	HTKTools/HVite.c	/^static MemHeap modelHeap;$/;"	v	file:
modelName	HTKTools/HParse.c	/^   LabId modelName;  \/* name of node *\/$/;"	m	struct:_Node	file:
model_	HTKLVRec/kenlm/lm/left.hh	/^    const M &model_;$/;"	m	class:lm::ngram::RuleScore
model_type	HTKLVRec/kenlm/lm/binary_format.hh	/^  ModelType model_type;$/;"	m	struct:lm::ngram::FixedWidthParameters
models	HTKLib/HRec.c	/^   Boolean models;          \/* Keep track of model history *\/$/;"	m	struct:precinfo	file:
models	HTKTools/HVite.c	/^static Boolean models = FALSE;    \/* Keep track of model alignment *\/$/;"	v	file:
models_	HTKLVRec/kenlm/lm/value_build.hh	/^    std::vector<const Model*> models_;$/;"	m	class:lm::ngram::LowerRestBuild
modendHypHeap	HTKLVRec/HLVRec.h	/^   MemHeap modendHypHeap;       \/* MHEAP for word end hyps *\/$/;"	m	struct:_DecoderInst
modify_	HTKLVRec/kenlm/lm/search_hashed.cc	/^    Middle &modify_;$/;"	m	class:lm::ngram::__anon57::ActivateLowerMiddle	file:
modify_	HTKLVRec/kenlm/lm/search_hashed.cc	/^    Weights *modify_;$/;"	m	class:lm::ngram::__anon57::ActivateUnigram	file:
modpath	HTKLVRec/HLVRec.h	/^   ModendHyp *modpath;          \/* model level traceback *\/$/;"	m	struct:_AltWordendHyp
modpath	HTKLVRec/HLVRec.h	/^   ModendHyp *modpath;          \/* model level traceback *\/$/;"	m	struct:_RelToken
modpath	HTKLVRec/HLVRec.h	/^   ModendHyp *modpath;          \/* model level traceback *\/$/;"	m	struct:_WordendHyp
modules	HLMLib/Makefile	/^modules = LModel.o LPMerge.o LPCalc.o LUtil.o LWMap.o LCMap.o LGBase.o$/;"	m
monoId	HTKLVRec/HLVNet.c	/^      LabId monoId;$/;"	m	union:_STLexNode::__anon37	file:
monoPhone	HTKLVRec/HLVRec.h	/^   LabId monoPhone[100];           \/* #### hard limit -- fix this *\/$/;"	m	struct:_DecoderInst
monophones	HTKTools/HSmooth.c	/^static LabId *monophones;    \/* array[1..nPhones]of LabId *\/$/;"	v	file:
mp	HTKLib/HFBLat.c	/^   MixPDF *mp;$/;"	m	struct:__anon101	file:
mp	HTKLib/HUtil.h	/^   MixPDF *mp;       \/* ->current mixPDF *\/$/;"	m	struct:__anon169
mp	HTKTools/HHEd.c	/^   MixPDF *mp;               \/* actual component *\/$/;"	m	struct:_CoList	file:
mpdf	HTKLib/HModel.h	/^   MixPDF *mpdf;        \/* -> mixture pdf *\/$/;"	m	struct:__anon121
mpe	HTKLib/HArc.h	/^  MPEStruct *mpe; \/*if doing mpe. *\/$/;"	m	struct:_Arc
mpe_occscale	HTKLib/HArc.h	/^  float mpe_occscale; \/* scale on the occupancy [for MPE code], equals$/;"	m	struct:_Acoustic
mtab	HTKLib/HModel.h	/^   MLink * mtab;           \/* Array[0..MACHASHSIZE-1]OF MLink *\/$/;"	m	struct:_HMMSet
mts_copy	HTKLVRec/HLVRec-propagate.c	/^static int mts_copy = 0;$/;"	v	file:
mts_fast	HTKLVRec/HLVRec-propagate.c	/^static int mts_fast = 0;$/;"	v	file:
mts_newid	HTKLVRec/HLVRec-propagate.c	/^static int mts_newid = 0;$/;"	v	file:
mts_newidNTOK	HTKLVRec/HLVRec-propagate.c	/^static int mts_newidNTOK = 0;$/;"	v	file:
mts_slow	HTKLVRec/HLVRec-propagate.c	/^static int mts_slow = 0;$/;"	v	file:
mu	HTKLib/HTrain.h	/^   Vector mu;        \/* mean vector counts *\/$/;"	m	struct:__anon165
muC	HTKLib/HTrain.c	/^static int muC,vaC,trC,wtC,prC;$/;"	v	file:
multiLat	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon187	file:
mutex_	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    boost::mutex mutex_;$/;"	m	class:util::stream::MultiProgress
myArc	HTKLib/HArc.h	/^  HArc *myArc; $/;"	m	struct:_Acoustic
n	HLMTools/LGPrep.c	/^   int n;                     \/* number of fields in list *\/$/;"	m	struct:__anon30	file:
n	HTKLVRec/HLVNet.h	/^   int n;$/;"	m	struct:_CompLMlaNode
n	HTKLVRec/HLVRec.h	/^   unsigned short n;$/;"	m	struct:_TokenSet
n	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^      uint64_t n[5];$/;"	m	struct:lm::builder::__anon42::StatCollector::OrderStat	file:
n	HTKLib/HAudio.c	/^   int n;                 \/* Number of valid samples in buffer *\/$/;"	m	struct:mmapibuf	file:
n	HTKLib/HNet.c	/^   int n;$/;"	m	struct:pinstinfo	file:
n	HTKLib/HNet.h	/^   int n;              \/* Arc identity *\/$/;"	m	struct:larc_e
n	HTKLib/HNet.h	/^   int n;              \/* Sorted order *\/$/;"	m	struct:lnode
n	HTKLib/HRec.c	/^   short n;                  \/* Number of rtok valid (0==1-best, 1>==N-best) *\/$/;"	m	struct:tokenset	file:
n1Cmds	HTKTools/HLEd.c	/^static int  n1Cmds = 17;$/;"	v	file:
n2lId	HLMLib/LPMerge.c	/^   int     **n2lId;          \/* array of NameId -> LabId lookup tables *\/$/;"	m	struct:__anon17	file:
nActivate	HTKLVRec/HLVRec.h	/^   unsigned long nActivate;$/;"	m	struct:_Stats
nActive	HTKLVRec/HLVRec.h	/^   unsigned long nActive;$/;"	m	struct:_Stats
nAlign	HTKLib/HNet.h	/^   short nAlign;       \/* Number of alignment records in word *\/$/;"	m	struct:larc
nArcs	HTKLib/HArc.h	/^  int nArcs; \/* normally 1, but e.g.  if quinphone or perhaps MWE, can be more. *\/$/;"	m	struct:_CorrN
nArcs	HTKLib/HArc.h	/^  int nArcs;$/;"	m	struct:ArcInfoStruct
nArgs	HTKTools/HDMan.c	/^   short nArgs;$/;"	m	struct:__anon192	file:
nArgs	HTKTools/HLEd.c	/^   short nArgs;$/;"	m	struct:__anon201	file:
nAvail	HTKLib/HWave.c	/^   long nAvail;         \/* Num samples allocated for data *\/$/;"	m	struct:_Wave	file:
nBeam	HTKLib/HRec.h	/^   LogFloat nBeam;          \/* Beam width for non-best tokens *\/$/;"	m	struct:vrecinfo
nBeam	HTKTools/HVite.c	/^static LogDouble nBeam = 0.0;     \/* nBeam threshold *\/$/;"	v	file:
nBlk	HTKTools/HSmooth.c	/^static int nBlk = 0;       \/* number of data blocks *\/$/;"	v	file:
nBlocks	HTKLVRec/HLVModel.h	/^   unsigned long nBlocks;$/;"	m	struct:_StateInfo_lv
nClass	HLMLib/LWMap.h	/^   int     nClass;       \/* number of class ids in map *\/$/;"	m	struct:__anon23
nCmds	HTKTools/HDMan.c	/^static int  nCmds = 21;$/;"	v	file:
nCmds	HTKTools/HHEd.c	/^static int  nCmds = 40;$/;"	v	file:
nCmds	HTKTools/HLEd.c	/^static int  nCmds = LASTCMD-1;$/;"	v	file:
nCols	HTKLib/HParm.c	/^   int nCols;         \/* num columns in each row of the parameter block *\/$/;"	m	struct:__anon141	file:
nCompNodes	HTKLVRec/HLVNet.h	/^   int nCompNodes;              \/* number of complex nodes in LM LA tree *\/$/;"	m	struct:_LMlaTree
nComponents	HTKTools/HHEd.c	/^   int  nComponents;         \/* number of components in this cluster *\/$/;"	m	struct:__anon198	file:
nCvrt	HTKLib/HParm.c	/^   int nCvrt;         \/* num columns produced from coding *\/$/;"	m	struct:__anon141	file:
nDeActivate	HTKLVRec/HLVRec.h	/^   unsigned long nDeActivate;$/;"	m	struct:_Stats
nDefPhones	HTKTools/HDMan.c	/^static int nDefPhones = 0;               \/* num predefined phones *\/$/;"	v	file:
nDefs	HTKTools/HLEd.c	/^   short nDefs;$/;"	m	struct:_Context	file:
nDenLats	HTKTools/HMMIRest.c	/^int nDenLats = 0;$/;"	v
nDim	HTKLVRec/HLVModel.h	/^   unsigned long nDim;         \/* real number of dimensions, e.g. 39 *\/$/;"	m	struct:_StateInfo_lv
nEntries	HTKLVRec/HLVRec.h	/^   int nEntries;$/;"	m	struct:_LMNodeCache
nEntry	HLMLib/LModel.h	/^   int nEntry;              \/* number of entries in model *\/$/;"	m	struct:__anon13
nFiles	HLMLib/LGBase.h	/^   int nFiles;             \/* num files in input set *\/$/;"	m	struct:__anon4
nFloorVar	HTKLib/HMap.c	/^static int nFloorVar = 0;     \/* # of floored variance comps *\/$/;"	v	file:
nFloorVar	HTKTools/HERest.c	/^static int nFloorVar = 0;     \/* # of floored variance comps *\/$/;"	v	file:
nFloorVar	HTKTools/HMMIRest.c	/^static int nFloorVar = 0;     \/* # of floored variance comps *\/$/;"	v	file:
nFloorVarMix	HTKLib/HMap.c	/^static int nFloorVarMix = 0;  \/* # of mix comps with floored vars *\/$/;"	v	file:
nFloorVarMix	HTKTools/HERest.c	/^static int nFloorVarMix = 0;  \/* # of mix comps with floored vars *\/$/;"	v	file:
nFloorVarMix	HTKTools/HMMIRest.c	/^static int nFloorVarMix = 0;  \/* # of mix comps with floored vars *\/$/;"	v	file:
nFloorWeight	HTKTools/HMMIRest.c	/^static int nFloorWeight = 0;  \/* # of floored weights. *\/$/;"	v	file:
nFrames	HTKLVRec/HLVRec.h	/^   unsigned long nFrames;$/;"	m	struct:_Stats
nFree	HTKLib/HTrain.h	/^   int nFree;        \/* number of items slots in total *\/$/;"	m	struct:__anon160
nGaussPDE1	HTKLib/HModel.c	/^static int nGaussPDE1 = 0;$/;"	v	file:
nGaussPDE2	HTKLib/HModel.c	/^static int nGaussPDE2 = 0;$/;"	v	file:
nGaussTot	HTKLib/HModel.c	/^static int nGaussTot = 0;$/;"	v	file:
nGramName	HLMLib/LModel.c	/^static char *nGramName[LM_NSIZE] = {$/;"	v	file:
nInBuffer	HTKLib/HAudio.c	/^   int nInBuffer;            \/* Number of valid samples in buffer *\/$/;"	m	struct:_AudioIn	file:
nInc	HTKTools/HSmooth.c	/^   long nInc;        \/* num times this acc incremented *\/$/;"	m	struct:_ChWtAcc	file:
nInputs	HTKTools/HDMan.c	/^static int nInputs = 0;              \/* number of input dictionaries *\/$/;"	v	file:
nInst	HTKLVRec/HLVRec-misc.c	/^   int nInst;$/;"	m	struct:_LayerStats	file:
nItem	HLMTools/LGPrep.c	/^   int nItem;                 \/* num words in set *\/$/;"	m	struct:__anon29	file:
nItems	HLMLib/LGBase.h	/^   int nItems;              \/* number of n-grams in file *\/$/;"	m	struct:__anon3
nItems	HTKLib/HTrain.c	/^static int nItems;      \/* num items in pool *\/$/;"	v	file:
nItems	HTKLib/HTrain.h	/^   int nItems;       \/* number of items stored *\/$/;"	m	struct:__anon160
nItems	HTKTools/HList.c	/^static int nItems  = 10;         \/* num items per line *\/$/;"	v	file:
nJoins	HTKTools/HHEd.c	/^static int nJoins;                     \/* current num mixs in joinSet *\/$/;"	v	file:
nLMlaCacheHit	HTKLVRec/HLVRec.h	/^   unsigned long nLMlaCacheHit;$/;"	m	struct:_Stats
nLMlaCacheMiss	HTKLVRec/HLVRec.h	/^   unsigned long nLMlaCacheMiss;$/;"	m	struct:_Stats
nLModel	HLMLib/LPMerge.c	/^   int     nLModel;          \/* number of LMs to merge *\/$/;"	m	struct:__anon17	file:
nLModel	HLMTools/LAdapt.c	/^static int     nLModel;                     \/* number of loaded LMs *\/$/;"	v	file:
nLModel	HLMTools/LMerge.c	/^static int       nLModel;                \/* number of loaded LMs *\/$/;"	v	file:
nLModel	HLMTools/LPlex.c	/^static int     nLModel;             \/* number of loaded LMs *\/$/;"	v	file:
nLabs	HTKTools/HResults.c	/^static int nLabs;$/;"	v	file:
nLats	HTKLib/HArc.h	/^  int nLats;$/;"	m	struct:ArcInfoStruct
nLayers	HTKLVRec/HLVNet.h	/^   int nLayers;                 \/* nuber of node layers *\/$/;"	m	struct:_LexNet
nLayers	HTKLVRec/HLVRec.h	/^   int nLayers;                 \/* nuber of node layers *\/$/;"	m	struct:_DecoderInst
nLogHmms	HTKTools/HSmooth.c	/^static int nLogHmms;       \/* number of logical HMM's *\/$/;"	v	file:
nMembers	HTKLib/HUtil.h	/^   int nMembers;		\/* cardinality of set *\/$/;"	m	struct:__anon170
nMix	HTKLVRec/HLVRec.h	/^   int nMix;$/;"	m	struct:_OutPCache
nMix	HTKLib/HModel.h	/^   int nMix;            \/* num mixtures in this stream *\/$/;"	m	struct:__anon125
nMix	HTKLib/HModel.h	/^   short nMix;           \/* num mixtures M in set *\/$/;"	m	struct:__anon124
nMix	HTKTools/HMMIRest.c	/^static int nMix = 0;  \/*  total # of gaussians. *\/$/;"	v	file:
nNewPhones	HTKTools/HDMan.c	/^static int nNewPhones = 0;               \/* num new phones encountered *\/$/;"	v	file:
nNode	HTKLVRec/HLVRec.h	/^   int nNode;$/;"	m	struct:_LMCache
nNodeA	HTKLVRec/HLVNet.h	/^   int nNodeA;         \/* hastable of A LexNodes *\/$/;"	m	struct:_TLexNet
nNodeBY	HTKLVRec/HLVNet.h	/^   int nNodeBY;         \/* linked list of nodes in main prefix tree B -- Y *\/$/;"	m	struct:_TLexNet
nNodeSIL	HTKLVRec/HLVNet.h	/^   int nNodeSIL;         \/* linked list of silencs (sil\/sp) nodes between ZS and SA *\/$/;"	m	struct:_TLexNet
nNodeZ	HTKLVRec/HLVNet.h	/^   int nNodeZ;         \/* hastable of Z LexNodes *\/$/;"	m	struct:_TLexNet
nNodes	HTKLVRec/HLVNet.h	/^   int nNodes;                  \/* number of nodes in LM LA tree *\/$/;"	m	struct:_LMlaTree
nNodes	HTKLVRec/HLVNet.h	/^   int nNodes;$/;"	m	struct:_LexNet
nNodesLayer	HTKLVRec/HLVNet.h	/^   int nNodesLayer[NLAYERS]; \/* number of nodes in each layer *\/$/;"	m	struct:_TLexNet
nNumLats	HTKTools/HMMIRest.c	/^int nNumLats = 0;$/;"	v
nOOV	HLMTools/LPlex.c	/^   int nOOV;                \/* number of OOVs *\/$/;"	m	struct:__anon34	file:
nObs	HTKLVRec/HLVRec.h	/^   int nObs;                    \/* num of valid obs in bock *\/$/;"	m	struct:_DecoderInst
nObs	HTKLib/HParm.h	/^   int nObs;                  \/* Number of table observations *\/$/;"	m	struct:__anon149
nOpen	HLMLib/LGBase.h	/^   int nOpen;              \/* num open files *\/$/;"	m	struct:__anon4
nPDFs	HTKLib/HFBLat.c	/^static int nPDFs[SMAX];  \/*rely on it being initialised to zeros.*\/$/;"	v	file:
nParm	HLMLib/LCMap.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLMLib/LGBase.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLMLib/LModel.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLMLib/LPCalc.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMLib/LPMerge.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMLib/LUtil.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLMLib/LWMap.c	/^static int nParm = 0;$/;"	v	file:
nParm	HLMTools/Cluster.c	/^static int          nParm = 0;              \/* total num params *\/$/;"	v	file:
nParm	HLMTools/HLMCopy.c	/^static int nParm = 0;                  \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LAdapt.c	/^static int nParm = 0;   \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LBuild.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LFoF.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LGCopy.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LGList.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LGPrep.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LLink.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LMerge.c	/^static int nParm = 0;                  \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LNewMap.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LNorm.c	/^static int nParm = 0;                  \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LPlex.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HLMTools/LSubset.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKLVRec/HDecode.c	/^static int nParm = 0;		\/* total num params *\/$/;"	v	file:
nParm	HTKLVRec/HDecode.mod.c	/^static int nParm = 0;		\/* total num params *\/$/;"	v	file:
nParm	HTKLVRec/HLVLM.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLVRec/HLVModel.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLVRec/HLVNet.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLVRec/HLVRec.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HAdapt.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HArc.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HDict.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HExactMPE.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HFB.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HFBLat.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HGraf.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HGraf.null.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HGraf_WIN32.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HLM.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HLat.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HMap.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HModel.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HNet.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HParm.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HRec.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HShell.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HTrain.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKLib/HUtil.c	/^static int nParm = 0;$/;"	v	file:
nParm	HTKTools/HBuild.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HCompV.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HCopy.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HDMan.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HERest.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HHEd.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HInit.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HLEd.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HLRescore.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HLStats.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HList.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HMMIRest.c	/^static int nParm = 0;                \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HParse.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HQuant.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HRest.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HResults.c	/^static int nParm = 0;               \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HSGen.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HSLab.c	/^static int nParm = 0;                \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HSmooth.c	/^static int nParm = 0;        \/* total num params *\/$/;"	v	file:
nParm	HTKTools/HVite.c	/^static int nParm = 0;            \/* total num params *\/$/;"	v	file:
nPaths	HTKLib/HLat.c	/^   LogDouble nPaths;     \/* number of paths from start node *\/$/;"	m	struct:_StatsInfo	file:
nPhone	HTKLVRec/HLVRec.h	/^   int nPhone;$/;"	m	struct:_DecoderInst
nPhone	HTKTools/HDMan.c	/^   short nPhone;$/;"	m	struct:__anon193	file:
nPhones	HTKTools/HSmooth.c	/^static int nPhones;          \/* number of monophones *\/$/;"	v	file:
nPhyHmms	HTKTools/HSmooth.c	/^static int nPhyHmms;       \/* number of physical HMM's *\/$/;"	v	file:
nPron	HTKTools/HDMan.c	/^   short nPron;$/;"	m	struct:__anon194	file:
nPronIds	HTKLVRec/HLVNet.h	/^   int nPronIds;        \/* number of wordend Ids assigned, should be = voc->nprons *\/$/;"	m	struct:_TLexNet
nRef	HTKTools/HResults.c	/^static int nRef,nTest;$/;"	v	file:
nRows	HTKLib/HParm.c	/^   int nRows;        \/* number of rows used in this block *\/$/;"	m	struct:pblock	file:
nRules	HLMTools/LGPrep.c	/^   int nRules;                \/* number of rules *\/$/;"	m	struct:__anon31	file:
nSamples	HTKLib/HParm.c	/^   long nSamples;     \/* num samples in original (WAVEFORM only) *\/$/;"	m	struct:__anon141	file:
nSamples	HTKLib/HParm.h	/^   long nSamples;             \/* Number of source samples *\/$/;"	m	struct:__anon149
nSamples	HTKLib/HWave.c	/^   int32  nSamples;$/;"	m	struct:__anon173	file:
nSamples	HTKLib/HWave.c	/^   int32  nSamples;$/;"	m	struct:__anon174	file:
nSamples	HTKLib/HWave.c	/^   int32 nSamples;$/;"	m	struct:__anon180	file:
nSamples	HTKLib/HWave.c	/^   long nSamples;       \/* No of samples in data *\/$/;"	m	struct:_Wave	file:
nSamples	HTKLib/HWave.c	/^   unsigned int nSamples;$/;"	m	struct:__anon179	file:
nSamples	HTKTools/HList.c	/^   long nSamples;$/;"	m	struct:__anon202	file:
nSamples	HTKTools/HSLab.c	/^static long nSamples;        \/* number of samples *\/$/;"	v	file:
nSeg	HTKTools/HRest.c	/^static int nSeg;           \/* num training segments *\/$/;"	v	file:
nSets	HLMTools/LGPrep.c	/^   int nSets;                 \/* number of word sets actually defined *\/$/;"	m	struct:__anon31	file:
nSize	HLMLib/LModel.h	/^   int nSize;                \/* model order 1=unigram, 2=bigram, etc *\/$/;"	m	struct:__anon15
nSize	HLMLib/LPCalc.h	/^   int          nSize;                \/* model order *\/$/;"	m	struct:__anon16
nSize	HLMTools/HLMCopy.c	/^static int       nSize = 0;              \/* output n-gram size *\/$/;"	v	file:
nSize	HLMTools/LAdapt.c	/^static int nSize     = 3;           \/* ngram size *\/$/;"	v	file:
nSize	HLMTools/LFoF.c	/^static int        nSize = 0;        \/* ngram size N *\/$/;"	v	file:
nSize	HLMTools/LGCopy.c	/^static int nSize     = 0;           \/* ngram size *\/$/;"	v	file:
nSize	HLMTools/LGPrep.c	/^static int nSize     = 3;           \/* ngram size *\/$/;"	v	file:
nSize	HLMTools/LMerge.c	/^static int       nSize = 0;              \/* output ngram size *\/$/;"	v	file:
nSize	HLMTools/LNorm.c	/^static int       nSize = 0;              \/* output n-gram size *\/$/;"	v	file:
nSnt	HTKTools/HMMIRest.c	/^static int nSnt      = 0;        \/* num sentences from current speaker *\/$/;"	v	file:
nStates	HTKLVRec/HLVRec.h	/^   int nStates;$/;"	m	struct:_OutPCache
nStates	HTKTools/HInit.c	/^static int nStates;              \/* number of states in hmm *\/$/;"	v	file:
nStates	HTKTools/HRest.c	/^static int nStates;        \/* numStates of hmm *\/$/;"	v	file:
nStreams	HTKTools/HInit.c	/^static int nStreams;             \/* number of streams in hmm *\/$/;"	v	file:
nStreams	HTKTools/HRest.c	/^static int nStreams;       \/* numStreams of hmm *\/$/;"	v	file:
nStreams	HTKTools/HSmooth.c	/^static int nStreams;             \/* number of data streams *\/$/;"	v	file:
nTS	HTKLVRec/HLVRec-misc.c	/^   int nTS;$/;"	m	struct:_LayerStats	file:
nTest	HTKTools/HResults.c	/^static int nRef,nTest;$/;"	v	file:
nThresh	HTKLib/HRec.c	/^   LogFloat nThresh;        \/* Cutoff for non-best tokens *\/$/;"	m	struct:precinfo	file:
nToPlay	HTKLib/HAudio.c	/^   int nToPlay;$/;"	m	struct:_AudioOut	file:
nTok	HLMTools/LPlex.c	/^   int nTok;                \/* total number of tokens *\/$/;"	m	struct:__anon34	file:
nTok	HTKLVRec/HDecode.c	/^static int nTok = 32;           \/* number of different LMStates per HMM state *\/$/;"	v	file:
nTok	HTKLVRec/HDecode.mod.c	/^static int nTok = 32;           \/* number of different LMStates per HMM state *\/$/;"	v	file:
nTok	HTKLVRec/HLVRec-misc.c	/^   int nTok;$/;"	m	struct:_LayerStats	file:
nTok	HTKLVRec/HLVRec.h	/^   int nTok;                    \/* max number of tokens per state *\/$/;"	m	struct:_DecoderInst
nTokSet	HTKLVRec/HLVRec.h	/^   unsigned long nTokSet;$/;"	m	struct:_Stats
nTokUsed	HTKTools/HRest.c	/^static int nTokUsed;       \/* actual number of tokens used *\/$/;"	v	file:
nToks	HTKLib/HRec.c	/^   int nToks;               \/* Maximum tokens to propagate (0==1) *\/$/;"	m	struct:precinfo	file:
nToks	HTKTools/HVite.c	/^static int nToks = 0;             \/* Number of tokens for N best *\/$/;"	v	file:
nTrans	HTKTools/HVite.c	/^static int nTrans = 1;            \/* Number of transcriptions for N best *\/$/;"	v	file:
nType	HTKTools/HParse.c	/^   NodeType nType;   \/* the type of this node *\/$/;"	m	struct:_NodeInfo	file:
nUse	HTKLib/HModel.h	/^   int nUse;               \/* num logical hmm's sharing this def *\/$/;"	m	struct:__anon128
nUse	HTKLib/HModel.h	/^   int nUse;            \/* usage counter *\/$/;"	m	struct:__anon120
nUse	HTKLib/HModel.h	/^   int nUse;            \/* usage counter *\/$/;"	m	struct:__anon126
nUse	HTKLib/HModel.h	/^  int nUse;                         \/* usage counter *\/$/;"	m	struct:_AdaptXForm
nUse	HTKLib/HModel.h	/^  int nUse;            \/* usage counter *\/$/;"	m	struct:__anon129
nUse	HTKLib/HModel.h	/^  int nUse;            \/* usage counter *\/$/;"	m	struct:__anon132
nUse	HTKLib/HModel.h	/^  int nUse;            \/* usage counter *\/$/;"	m	struct:__anon133
nUse	HTKLib/HModel.h	/^  int nUse;            \/* usage counter *\/$/;"	m	struct:__anon134
nUse	HTKTools/HParse.c	/^   int nUse;         \/* num sharing this LinkSet *\/$/;"	m	struct:__anon203	file:
nUsed	HTKLib/HParm.c	/^   int nUsed;         \/* num columns used in each row of the parm block *\/$/;"	m	struct:__anon141	file:
nUtt	HLMTools/LPlex.c	/^   int nUtt;                \/* number of utterances *\/$/;"	m	struct:__anon34	file:
nVB	HTKTools/HLEd.c	/^static int nVB = 0;                 \/* number of non-interword boundaries *\/$/;"	v	file:
nVar	HTKTools/HMMIRest.c	/^static long int nVar = 0;     \/* # total of vars *\/$/;"	v	file:
nVec	HTKLVRec/HLVModel.h	/^   unsigned long nVec;         \/* number of vecotrs (e.g. 10 = RoundAlign (nDim,  HLVMODEL_VEC_PAD) *\/$/;"	m	struct:_StateInfo_lv
nWB	HTKTools/HLEd.c	/^static int nWB = 0;                 \/* number of interword boundaries *\/$/;"	v	file:
nWeight	HTKTools/HMMIRest.c	/^static int nWeight = 0;  \/*  total # of weights. *\/$/;"	v	file:
nWords	HLMTools/LPlex.c	/^static int     nWords;              \/* number of words in list *\/$/;"	v	file:
nWords	HTKTools/HDMan.c	/^static int nWords = 0;               \/* number of words in word list *\/$/;"	v	file:
nWrd	HLMTools/LPlex.c	/^   int nWrd;                \/* number of words predicted *\/$/;"	m	struct:__anon34	file:
n_hmm	HTKLib/HNet.h	/^   n_hmm=2,             \/* Node Instance represents HMM *\/$/;"	e	enum:__anon137
n_lcontext	HTKLib/HNet.h	/^   n_lcontext=16,       \/* Multiplication factor for context id *\/$/;"	e	enum:__anon137
n_nocontext	HTKLib/HNet.h	/^   n_nocontext=15,      \/* binary and with this to remove context ids *\/$/;"	e	enum:__anon137
n_rcontext	HTKLib/HNet.h	/^   n_rcontext=16384     \/* Multiplication factor for context id *\/$/;"	e	enum:__anon137
n_tr0	HTKLib/HNet.h	/^   n_tr0=4,             \/* Entry token reaches exit in t=0 *\/$/;"	e	enum:__anon137
n_unused	HTKLib/HNet.h	/^   n_unused,            \/* Node Instance not yet assigned *\/$/;"	e	enum:__anon137
n_wd0	HTKLib/HNet.h	/^   n_wd0=1,             \/* Exit token reaches word node in t=0 *\/$/;"	e	enum:__anon137
n_wdstart	HTKLib/HNet.h	/^   n_wdstart=8,         \/* Temporary wdstart node *\/$/;"	e	enum:__anon137
n_word	HTKLib/HNet.h	/^   n_word=4,            \/* Node Instance represents word end (or null) *\/$/;"	e	enum:__anon137
na	HTKLib/HNet.h	/^   int na;                      \/* Number of arcs *\/$/;"	m	struct:lattice
nact	HTKLib/HRec.c	/^   int nact;                \/* Number of active instances *\/$/;"	m	struct:precinfo	file:
nact	HTKLib/HRec.h	/^   int nact;                \/* Number of active models *\/$/;"	m	struct:vrecinfo
nae	HTKTools/HLStats.c	/^static int nae=0;                \/* Number of accumulators created *\/$/;"	v	file:
nalign	HTKLib/HRec.c	/^   int nalign;              \/* Current number of align records *\/$/;"	m	struct:precinfo	file:
name	HLMLib/LCMap.h	/^   char *name;     	     	\/* name of class map *\/$/;"	m	struct:__anon1
name	HLMLib/LModel.h	/^   char  *name;              \/* textual description and header *\/$/;"	m	struct:__anon15
name	HLMLib/LUtil.c	/^   char * name;$/;"	m	struct:hdrField	file:
name	HLMLib/LUtil.h	/^   char *name;                 \/* Label Name *\/$/;"	m	struct:_NameHolder
name	HLMLib/LWMap.h	/^   char    *name;        \/* name of map *\/$/;"	m	struct:__anon23
name	HTKLVRec/HLVLM.h	/^   char *name;$/;"	m	struct:_FSLM
name	HTKLib/HLM.h	/^   char *name;                  \/* Name used for identifying lm *\/$/;"	m	struct:lmodel
name	HTKLib/HLabel.c	/^   LabId name;$/;"	m	struct:__anon107	file:
name	HTKLib/HLabel.h	/^   char * name;             \/* Label Name *\/$/;"	m	struct:_NameCell
name	HTKLib/HLat.c	/^   char name[MAXFNAMELEN];$/;"	m	struct:_LLFInfo	file:
name	HTKLib/HMem.h	/^   char *name;          \/*            name of this memory heap            *\/$/;"	m	struct:__anon116
name	HTKLib/HModel.c	/^   char *name;$/;"	m	struct:__anon118	file:
name	HTKLib/HShell.h	/^   char *name;          \/* name of param - upper case always *\/$/;"	m	struct:__anon157
name	HTKLib/HShell.h	/^   char name[256];      \/* file name for error messages *\/$/;"	m	struct:__anon154
name	HTKLib/esignal.h	/^    char        *name;          \/* identifying character string *\/$/;"	m	struct:FieldSpec
name	HTKTools/HDMan.c	/^   char *name;                  \/* full path of dictionary file *\/$/;"	m	struct:__anon195	file:
name	HTKTools/HLStats.c	/^   LabId name;                   \/* Name *\/$/;"	m	struct:cntr	file:
name	HTKTools/HLStats.c	/^   LabId name;                   \/* Name *\/$/;"	m	struct:wordinfo	file:
name	HTKTools/HList.c	/^   char *name;$/;"	m	struct:__anon202	file:
name	HTKTools/HResults.c	/^   char *name;$/;"	m	struct:_Spkr	file:
nameTab	HLMLib/LUtil.h	/^  NameHolder **nameTab;        \/* the actual table *\/$/;"	m	struct:__anon20
name_guess_	HTKLVRec/kenlm/util/file.hh	/^    std::string name_guess_;$/;"	m	class:util::FDException
namecellHeap	HTKLib/HLabel.c	/^static MemHeap namecellHeap;         \/* heap for name cells *\/$/;"	v	file:
names	HTKTools/HResults.c	/^static LabId *names;$/;"	v	file:
nan_symbol_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const char* const nan_symbol_;$/;"	m	class:double_conversion::DoubleToStringConverter
nan_symbol_	HTKLVRec/kenlm/util/double-conversion/double-conversion.h	/^  const char* const nan_symbol_;$/;"	m	class:double_conversion::StringToDoubleConverter
natReadOrder	HLMLib/LGBase.c	/^static Boolean natReadOrder = FALSE;    \/* Preserve natural read byte order *\/$/;"	v	file:
natReadOrder	HLMLib/LModel.c	/^static Boolean natReadOrder = FALSE;    \/* Preserve natural read byte order *\/$/;"	v	file:
natReadOrder	HTKLib/HShell.c	/^static Boolean natReadOrder = FALSE;     \/* Preserve natural mach read order*\/$/;"	v	file:
natReadOrder	HTKLib/HWave.c	/^static Boolean natReadOrder = (Boolean)FALSE;    \/* Preserve natural read byte order*\/$/;"	v	file:
natWriteOrder	HLMLib/LGBase.c	/^static Boolean natWriteOrder = FALSE;   \/* Preserve natural write byte order *\/$/;"	v	file:
natWriteOrder	HLMLib/LModel.c	/^static Boolean natWriteOrder = FALSE;   \/* Preserve natural write byte order *\/$/;"	v	file:
natWriteOrder	HTKLib/HParm.c	/^static Boolean natWriteOrder = (Boolean)FALSE; \/* Preserve natural write byte order*\/$/;"	v	file:
natWriteOrder	HTKLib/HShell.c	/^static Boolean natWriteOrder = FALSE;    \/* Preserve natural mach write order*\/$/;"	v	file:
natWriteOrder	HTKLib/HWave.c	/^static Boolean natWriteOrder = (Boolean)FALSE;   \/* Preserve natural write byte order*\/$/;"	v	file:
nbestentry	HTKLib/HRec.c	/^struct nbestentry {$/;"	s	file:
nboff	HLMLib/LModel.c	/^   int nboff;           \/* times computed using the back-off weight *\/$/;"	m	struct:_AccessInfo	file:
nc	HTKLib/HNet.h	/^   int nc;         \/* Number of contexts *\/$/;"	m	struct:hmmsetcxtinfo
ncells	HTKLib/HGraf.c	/^static unsigned int  ncells, dispWIDE, dispHIGH, dispDEEP;$/;"	v	file:
ncf	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
ncf	HTKLib/HNet.h	/^   int ncf;        \/* Number of context free models *\/$/;"	m	struct:hmmsetcxtinfo
nci	HTKLib/HNet.h	/^   int nci;        \/* Number of context independent models *\/$/;"	m	struct:hmmsetcxtinfo
ncn	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nconv	HTKTools/HHEd.c	/^static int nconv;$/;"	v	file:
ndx	HLMLib/LCMap.h	/^   int ndx;                \/* index of class *\/$/;"	m	struct:clEntry
ndx	HLMLib/LModel.h	/^   LM_Id   ndx;             \/* word index *\/$/;"	m	struct:_SMEntry
ndx	HLMLib/LModel.h	/^   LM_Id ndx;               \/* word index *\/$/;"	m	struct:_FLEntry
ndx	HLMLib/LWMap.h	/^   int ndx;                \/* index of word in map *\/$/;"	m	struct:MAPENTRY
ndx	HLMTools/LGList.c	/^   int  ndx;$/;"	m	struct:fitem	file:
nebo	HTKLVRec/HLVLM.h	/^   struct nentry *nebo;                \/* NEntry for back-off *\/$/;"	m	struct:nentry	typeref:struct:nentry::nentry
negBuf	HLMTools/LGPrep.c	/^static ShiftReg negBuf;             \/* N-grams from matched source text *\/$/;"	v	file:
nend	HTKLib/HNet.c	/^   int nend;        \/* Number of models in ends chain *\/$/;"	m	struct:pronholder	file:
nentry	HTKLVRec/HLVLM.h	/^typedef struct nentry {         \/* HLM NGram history *\/$/;"	s
nentry	HTKLib/HLM.h	/^typedef struct nentry {         \/* HLM NGram history *\/$/;"	s
nep_cmp	HLMLib/LModel.c	/^static int nep_cmp(const void *v1,const void *v2)$/;"	f	file:
nep_cmp	HTKLib/HLM.c	/^static int nep_cmp(const void *v1,const void *v2)$/;"	f	file:
net	HTKLVRec/HDecode.c	/^static LexNet *net;             \/* Lexicon network of all required words\/prons *\/$/;"	v	file:
net	HTKLVRec/HDecode.mod.c	/^static LexNet *net;             \/* Lexicon network of all required words\/prons *\/$/;"	v	file:
net	HTKLVRec/HLVRec.h	/^   LexNet *net;                 \/* network, contains pointers to Vocab and HMMSet *\/$/;"	m	struct:_DecoderInst
net	HTKLib/HNet.h	/^   char *net;			\/* Network file name (NULL==unknown) *\/$/;"	m	struct:lattice
net	HTKLib/HRec.c	/^   Network *net;            \/* Recognition network *\/$/;"	m	struct:precinfo	file:
netHeap	HTKLVRec/HDecode.c	/^static MemHeap netHeap;$/;"	v	file:
netHeap	HTKLVRec/HDecode.mod.c	/^static MemHeap netHeap;$/;"	v	file:
netHeap	HTKTools/HVite.c	/^static MemHeap netHeap;$/;"	v	file:
netName	HTKTools/HParse.c	/^   LabId netName;    \/* variable name (LHS of rule) *\/$/;"	m	struct:_SubNetDef	file:
network	HTKTools/HParse.c	/^   HPNetwork network;  \/* sub-network (RHS of rule) *\/ $/;"	m	struct:_SubNetDef	file:
neural	HTKLVRec/kenlm/lm/neural/wordvecs.cc	/^namespace lm { namespace neural {$/;"	n	namespace:lm	file:
neural	HTKLVRec/kenlm/lm/neural/wordvecs.hh	/^namespace neural {$/;"	n	namespace:lm
newData	HTKTools/HSLab.c	/^static Boolean newData=FALSE;$/;"	v	file:
newDir	HTKTools/HERest.c	/^static char * newDir = NULL;     \/* directory to store new hmm def files *\/$/;"	v	file:
newDir	HTKTools/HHEd.c	/^static char * newDir = NULL;     \/* directory to store new hmm def files *\/$/;"	v	file:
newDir	HTKTools/HLEd.c	/^static char * newDir    = NULL;     \/* dest label file directory *\/$/;"	v	file:
newDir	HTKTools/HMMIRest.c	/^static char * newDir = NULL;     \/* directory to store new hmm def files *\/$/;"	v	file:
newDir	HTKTools/HSmooth.c	/^static char * newDir = NULL;     \/* directory to store new hmm def files *\/$/;"	v	file:
newExt	HTKTools/HERest.c	/^static char * newExt = NULL;     \/* extension of new reestimated hmm files *\/$/;"	v	file:
newExt	HTKTools/HHEd.c	/^static char * newExt = NULL;     \/* extension of new edited hmm files *\/$/;"	v	file:
newExt	HTKTools/HLEd.c	/^static char * newExt    = "lab";    \/* dest label file extension *\/$/;"	v	file:
newExt	HTKTools/HMMIRest.c	/^static char * newExt = NULL;     \/* extension of new reestimated hmm files *\/$/;"	v	file:
newExt	HTKTools/HSmooth.c	/^static char * newExt = NULL;     \/* extension of new reestimated hmm files *\/$/;"	v	file:
newLM	HLMTools/LAdapt.c	/^static BackOffLM *newLM;            \/* the generated LM *\/$/;"	v	file:
newLabFile	HTKTools/HSLab.c	/^static Boolean newLabFile   = FALSE;   \/* forcing the creation of a new (empty) label file *\/$/;"	v	file:
newLabs	HTKTools/HLEd.c	/^static FILE *newLabs = NULL;        \/* list of newly created labels *\/$/;"	v	file:
newList	HTKTools/HDMan.c	/^static LabId newList[MAXPVOC];       \/* list of new phones encountered *\/$/;"	v	file:
newModel	HTKTools/HInit.c	/^static Boolean  newModel = TRUE;    \/* enable initial uniform segmentation *\/$/;"	v	file:
newPhones	HTKTools/HDMan.c	/^static FILE *newPhones = NULL;       \/* file of newly created phones *\/$/;"	v	file:
newWords	HLMTools/LAdapt.c	/^static int newWords  =  100000;     \/* max new words to accommodate *\/$/;"	v	file:
newWords	HLMTools/LGPrep.c	/^static int newWords  =  100000;     \/* max new words to accommodate *\/$/;"	v	file:
newWords	HLMTools/LSubset.c	/^static int      newWords = 1000; \/* new words from class map *\/$/;"	v	file:
new_word_	HTKLVRec/kenlm/lm/vocab.hh	/^    NewWordAction new_word_;$/;"	m	class:lm::ngram::GrowableVocab
newed_end_	HTKLVRec/kenlm/util/fixed_array.hh	/^    T *newed_end_;$/;"	m	class:util::FixedArray
newln	HTKLib/HLat.c	/^      LNode *newln;$/;"	m	union:_SubLNode::__anon111	file:
next	HLMLib/LCMap.h	/^   struct clEntry *next;   \/* next class in list *\/$/;"	m	struct:clEntry	typeref:struct:clEntry::clEntry
next	HLMLib/LGBase.h	/^   GFLink next;            \/* next file to open + ... *\/$/;"	m	struct:gramfile
next	HLMLib/LGBase.h	/^   UInt *next;             \/* next free slot in pool *\/$/;"	m	struct:__anon5
next	HLMLib/LUtil.c	/^   struct hdrField * next;$/;"	m	struct:hdrField	typeref:struct:hdrField::hdrField	file:
next	HLMLib/LUtil.h	/^   struct _NameHolder *next;   \/* Chain *\/$/;"	m	struct:_NameHolder	typeref:struct:_NameHolder::_NameHolder
next	HLMTools/HLMCopy.c	/^   struct dictlist *next;$/;"	m	struct:dictlist	typeref:struct:dictlist::dictlist	file:
next	HLMTools/LGList.c	/^   struct fitem * next;$/;"	m	struct:fitem	typeref:struct:fitem::fitem	file:
next	HLMTools/LGPrep.c	/^   struct ruledef *next;$/;"	m	struct:ruledef	typeref:struct:ruledef::ruledef	file:
next	HLMTools/LPlex.c	/^   Equiv *next;$/;"	m	struct:_Equiv	file:
next	HTKLVRec/HDecode.c	/^   BestInfo *next;$/;"	m	struct:_BestInfo	file:
next	HTKLVRec/HDecode.mod.c	/^   BestInfo *next;$/;"	m	struct:_BestInfo	file:
next	HTKLVRec/HLVNet.c	/^   STLexLink *next[2];$/;"	m	struct:_STLexLink	file:
next	HTKLVRec/HLVNet.h	/^   TLexLink *next;              \/* next link from this start node *\/$/;"	m	struct:_TLexLink
next	HTKLVRec/HLVNet.h	/^   TLexNode *next;               \/* next node in hash table for some net part (A, B..Y or Z) *\/$/;"	m	struct:_TLexNode
next	HTKLVRec/HLVRec.h	/^   AltWordendHyp *next;$/;"	m	struct:_AltWordendHyp
next	HTKLVRec/HLVRec.h	/^   LexNodeInst *next;           \/* next instance in linked linst for this layer *\/$/;"	m	struct:_LexNodeInst
next	HTKLVRec/HLVRec.h	/^   struct _LMLACacheEntry *next;$/;"	m	struct:_LMLACacheEntry	typeref:struct:_LMLACacheEntry::_LMLACacheEntry
next	HTKLVRec/kenlm/lm/trie.hh	/^  uint64_t next;$/;"	m	struct:lm::ngram::trie::UnigramValue
next	HTKLVRec/kenlm/lm/value.hh	/^    uint64_t next;$/;"	m	struct:lm::ngram::BackoffValue::TrieUnigramValue
next	HTKLVRec/kenlm/lm/value.hh	/^    uint64_t next;$/;"	m	struct:lm::ngram::RestValue::TrieUnigramValue
next	HTKLib/HAdapt.c	/^   struct _AInfo *next;            \/* next external file name in list *\/$/;"	m	struct:_AInfo	typeref:struct:_AInfo::_AInfo	file:
next	HTKLib/HAdapt.c	/^   struct _AccCache *next;$/;"	m	struct:_AccCache	typeref:struct:_AccCache::_AccCache	file:
next	HTKLib/HAdapt.c	/^   struct _ObsCache *next;$/;"	m	struct:_ObsCache	typeref:struct:_ObsCache::_ObsCache	file:
next	HTKLib/HArc.h	/^  CorrN *next;$/;"	m	struct:_CorrN
next	HTKLib/HAudio.c	/^   struct mmapibuf *next;$/;"	m	struct:mmapibuf	typeref:struct:mmapibuf::mmapibuf	file:
next	HTKLib/HDict.h	/^   Pron next;      \/* Next pronunciation of word *\/$/;"	m	struct:_WordPron
next	HTKLib/HDict.h	/^   Word next;       \/* next word in hash table chain *\/$/;"	m	struct:_DictEntry
next	HTKLib/HGraf.h	/^   BtnLink next;$/;"	m	struct:_HButton
next	HTKLib/HLabel.h	/^   struct _LabList *next;   \/* Next label list *\/$/;"	m	struct:_LabList	typeref:struct:_LabList::_LabList
next	HTKLib/HLabel.h	/^   struct _MLFEntry *next;    \/* next in chain *\/$/;"	m	struct:_MLFEntry	typeref:struct:_MLFEntry::_MLFEntry
next	HTKLib/HLabel.h	/^   struct _NameCell *next;  \/* Chain *\/$/;"	m	struct:_NameCell	typeref:struct:_NameCell::_NameCell
next	HTKLib/HLat.c	/^   LLFInfo *next;$/;"	m	struct:_LLFInfo	file:
next	HTKLib/HLat.c	/^   SubLArc *next;$/;"	m	struct:_SubLArc	file:
next	HTKLib/HLat.c	/^   SubLNode *next;$/;"	m	struct:_SubLNode	file:
next	HTKLib/HMem.c	/^   struct _MemHeapRec *next;$/;"	m	struct:_MemHeapRec	typeref:struct:_MemHeapRec::_MemHeapRec	file:
next	HTKLib/HMem.h	/^   BlockP next;         \/*           next block in chain                  *\/$/;"	m	struct:_Block
next	HTKLib/HModel.c	/^  XFDirLink next;          \/* next directory name in list *\/$/;"	m	struct:_XFDirInfo	file:
next	HTKLib/HModel.h	/^   ILink next;$/;"	m	struct:_ItemRec
next	HTKLib/HModel.h	/^   MILink next;            \/* next external file name in list *\/$/;"	m	struct:_MMFInfo
next	HTKLib/HModel.h	/^   MLink next;             \/* next cell in hash table *\/$/;"	m	struct:_MacroDef
next	HTKLib/HModel.h	/^   struct _PtrMap *next;   \/* next cell in hash table *\/$/;"	m	struct:_PtrMap	typeref:struct:_PtrMap::_PtrMap
next	HTKLib/HNet.c	/^   struct pronholder *next;$/;"	m	struct:pronholder	typeref:struct:pronholder::pronholder	file:
next	HTKLib/HNet.h	/^   struct sublatdef *next;  \/* Next sublat at this level *\/$/;"	m	struct:sublatdef	typeref:struct:sublatdef::sublatdef
next	HTKLib/HParm.c	/^   struct channelinfo *next;  \/* Next channel record *\/$/;"	m	struct:channelinfo	typeref:struct:channelinfo::channelinfo	file:
next	HTKLib/HParm.c	/^   struct pblock *next; \/* Next block *\/$/;"	m	struct:pblock	typeref:struct:pblock::pblock	file:
next	HTKLib/HShell.c	/^   struct _ConfigEntry *next;$/;"	m	struct:_ConfigEntry	typeref:struct:_ConfigEntry::_ConfigEntry	file:
next	HTKLib/HShell.c	/^   struct _VersionEntry *next;$/;"	m	struct:_VersionEntry	typeref:struct:_VersionEntry::_VersionEntry	file:
next	HTKLib/HTrain.h	/^   IBLink next;      \/* next block in chain *\/$/;"	m	struct:_ItemBlock
next	HTKLib/HVQ.h	/^   VQTable next;        \/* used internally for housekeeping *\/$/;"	m	struct:_VQTabRec
next	HTKTools/HBuild.c	/^   struct _GramEntry *next;$/;"	m	struct:_GramEntry	typeref:struct:_GramEntry::_GramEntry	file:
next	HTKTools/HBuild.c	/^   struct _WordFllr *next;$/;"	m	struct:_WordFllr	typeref:struct:_WordFllr::_WordFllr	file:
next	HTKTools/HCopy.c	/^   TrPtr next;                  \/* pointer to next in list *\/$/;"	m	struct:_TrList	file:
next	HTKTools/HDMan.c	/^   struct _ScriptItem *next;$/;"	m	struct:_ScriptItem	typeref:struct:_ScriptItem::_ScriptItem	file:
next	HTKTools/HHEd.c	/^   CLink next;                  \/* next item in group *\/$/;"	m	struct:_CRec	file:
next	HTKTools/HHEd.c	/^   QLink next;$/;"	m	struct:_QEnt	file:
next	HTKTools/HHEd.c	/^   struct _CoList *next;     \/* next component in the linked list *\/$/;"	m	struct:_CoList	typeref:struct:_CoList::_CoList	file:
next	HTKTools/HHEd.c	/^   struct _IPat *next;$/;"	m	struct:_IPat	typeref:struct:_IPat::_IPat	file:
next	HTKTools/HHEd.c	/^   struct _Node *next;          \/* doubly linked chain of *\/$/;"	m	struct:_Node	typeref:struct:_Node::_Node	file:
next	HTKTools/HHEd.c	/^   struct _Tree *next;          \/* next tree in list *\/$/;"	m	struct:_Tree	typeref:struct:_Tree::_Tree	file:
next	HTKTools/HLEd.c	/^   struct _Context *next;$/;"	m	struct:_Context	typeref:struct:_Context::_Context	file:
next	HTKTools/HLEd.c	/^   struct _FindAcc *next;$/;"	m	struct:_FindAcc	typeref:struct:_FindAcc::_FindAcc	file:
next	HTKTools/HLEd.c	/^   struct _ScriptItem *next;$/;"	m	struct:_ScriptItem	typeref:struct:_ScriptItem::_ScriptItem	file:
next	HTKTools/HParse.c	/^   struct _SubNetDef *next;$/;"	m	struct:_SubNetDef	typeref:struct:_SubNetDef::_SubNetDef	file:
next	HTKTools/HResults.c	/^   Equiv *next;$/;"	m	struct:_Equiv	file:
next	HTKTools/HResults.c	/^   struct _Spkr *next;$/;"	m	struct:_Spkr	typeref:struct:_Spkr::_Spkr	file:
next	HTKTools/HResults.c	/^   struct _SpotRec *next;$/;"	m	struct:_SpotRec	typeref:struct:_SpotRec::_SpotRec	file:
next	HTKTools/HSmooth.c	/^   WALink next;      \/* chain for wt accs *\/$/;"	m	struct:_ChWtAcc	file:
nextFree	HTKLVRec/HLVRec.h	/^   int nextFree;$/;"	m	struct:_LMNodeCache
nextGram	HLMLib/LGBase.h	/^   UInt nextGram[MAXNG];   \/* next gram to read from inset *\/  $/;"	m	struct:__anon4
nextOutSym	HTKTools/HDMan.c	/^   LabId nextOutSym;            \/* next input output sym - for lookahead *\/$/;"	m	struct:__anon195	file:
nextSpkr	HTKTools/HCompV.c	/^   struct SpkrAccListItem *nextSpkr;     \/* next pointer *\/$/;"	m	struct:SpkrAccListItem	typeref:struct:SpkrAccListItem::SpkrAccListItem	file:
nextValid	HLMLib/LGBase.h	/^   Boolean nextValid;      \/* true if nextGram is valid *\/$/;"	m	struct:__anon4
nextWord	HTKTools/HDMan.c	/^   LabId nextWord;              \/* next input word - for lookahead *\/$/;"	m	struct:__anon195	file:
nextWt	HLMLib/LGBase.h	/^   float nextWt;           \/* weight of next gram *\/$/;"	m	struct:__anon4
next_	HTKLVRec/kenlm/lm/bhiksha.hh	/^    util::BitsMask next_;$/;"	m	class:lm::ngram::trie::DontBhiksha
next_	HTKLVRec/kenlm/util/ersatz_progress.hh	/^    uint64_t current_, next_, complete_;$/;"	m	class:util::ErsatzProgress
next_	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    uint64_t current_, next_;$/;"	m	class:util::stream::WorkerProgress
next_inline_	HTKLVRec/kenlm/lm/bhiksha.hh	/^    const util::BitsMask next_inline_;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
next_source_	HTKLVRec/kenlm/lm/trie.hh	/^    const BitPacked *next_source_;$/;"	m	class:lm::ngram::trie::BitPackedMiddle
next_use	HTKLVRec/kenlm/lm/partial.hh	/^  unsigned char next_use;$/;"	m	struct:lm::ngram::ExtendReturn
nextarg	HTKLib/HShell.c	/^static int nextarg=1;         \/* next arg to return in GetxxxArg *\/$/;"	v	file:
nfe	HLMLib/LModel.h	/^   LM_Id nfe;               \/* number of FLEntry *\/$/;"	m	struct:_FLEntry
nfi	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nfllrs	HTKTools/HBuild.c	/^   int nfllrs;$/;"	m	struct:__anon188	file:
nfoll	HTKLVRec/HLVLM.h	/^   int nfoll;$/;"	m	struct:_FSLM_LatNode
nfoll	HTKLVRec/HLVNet.h	/^   short nfoll;$/;"	m	struct:_LexNode
nfree	HLMLib/LCMap.h	/^   int nfree;		     	\/* num records in free list *\/$/;"	m	struct:__anon1
ng	HLMTools/LAdapt.c	/^   UInt ng[MAXNG+1];    \/* ng[0] is oldest word *\/$/;"	m	struct:__anon26	file:
ng	HLMTools/LGPrep.c	/^   UInt ng[MAXNG+1];          \/* ng[0] is oldest word *\/$/;"	m	struct:__anon32	file:
ng_full	HLMLib/LGBase.h	/^   int ng_full;            \/* byte size of expanded N-gram ie N+1 ints *\/$/;"	m	struct:__anon2
ng_size	HLMLib/LGBase.h	/^   int ng_size;            \/* byte size of squashed N-gram records *\/$/;"	m	struct:__anon2
ngb	HLMTools/LAdapt.c	/^   NGBuffer *ngb;       \/* output ngram buffer *\/$/;"	m	struct:__anon26	file:
ngb	HLMTools/LGCopy.c	/^static NGBuffer   *ngb;             \/* output ngram buffer *\/$/;"	v	file:
ngb	HLMTools/LGPrep.c	/^   NGBuffer *ngb;             \/* output ngram buffer *\/$/;"	m	struct:__anon32	file:
ngbHeap	HLMTools/LGCopy.c	/^static MemHeap    ngbHeap;          \/* memory for NGBuffers *\/$/;"	v	file:
ngbHeap	HLMTools/LGPrep.c	/^static MemHeap ngbHeap;             \/* memory for NGBuffers *\/$/;"	v	file:
ngbSize	HLMTools/LAdapt.c	/^static int ngbSize   = 2000000;     \/* ngram buffer size *\/$/;"	v	file:
ngbSize	HLMTools/LGCopy.c	/^static int ngbSize   = 2000000;     \/* ngram buffer size *\/$/;"	v	file:
ngbSize	HLMTools/LGPrep.c	/^static int ngbSize   = 2000000;     \/* ngram buffer size *\/$/;"	v	file:
ngen	HTKTools/HSGen.c	/^static int ngen = 100;              \/* num sents to gen *\/$/;"	v	file:
nglm	HTKLVRec/HLVLM.h	/^      FSLM_ngram *nglm;$/;"	m	union:_FSLM::__anon36
ngram	HTKLVRec/kenlm/lm/bhiksha.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/bhiksha.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/binary_format.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/binary_format.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/blank.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/config.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/config.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/filter/format.hh	/^      StringPiece ngram;$/;"	m	struct:lm::InputBuffer::Line
ngram	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/left.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/model.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/model.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/model_type.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/ngram_query.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/partial.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/quantize.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/quantize.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/search_hashed.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/search_hashed.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/search_trie.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/search_trie.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/sizes.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/sizes.hh	/^namespace lm { namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/state.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/trie.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/trie.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/trie_sort.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/trie_sort.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/value.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/value_build.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/value_build.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLVRec/kenlm/lm/vocab.cc	/^namespace ngram {$/;"	n	namespace:lm	file:
ngram	HTKLVRec/kenlm/lm/vocab.hh	/^namespace ngram {$/;"	n	namespace:lm
ngram	HTKLib/HLM.h	/^      NGramLM *ngram;$/;"	m	union:lmodel::__anon106
ngram_length	HTKLVRec/kenlm/lm/return.hh	/^  unsigned char ngram_length;$/;"	m	struct:lm::FullScoreReturn
ngramlm	HTKLib/HLM.h	/^typedef struct ngramlm {$/;"	s
ngs	HLMLib/LGBase.h	/^   NGSource ngs[MAXINF];   \/* currently open sources *\/$/;"	m	struct:__anon4
nhits	HLMLib/LModel.c	/^   int nhits;           \/* times available *\/$/;"	m	struct:_AccessInfo	file:
nid	HTKLib/HVQ.h	/^   short nid,lid,rid;   \/* used for mapping between mem and ext def *\/$/;"	m	struct:_VQNodeRec
nil	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nin	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nistAlign	HTKTools/HResults.c	/^static Boolean nistAlign = FALSE;     \/* use NIST alignment & penalties *\/$/;"	v	file:
nistFormat	HTKTools/HResults.c	/^static Boolean nistFormat = FALSE;    \/* use NIST formatting *\/$/;"	v	file:
nlexA	HTKLVRec/HLVNet.h	/^   int nlexA;           \/* array of initial phones *\/$/;"	m	struct:_TLexNet
nlexAB	HTKLVRec/HLVNet.h	/^   int nlexAB;          \/* hastable of A-B contexts *\/$/;"	m	struct:_TLexNet
nlexP	HTKLVRec/HLVNet.h	/^   int nlexP;           \/* array of phones in single phone words*\/$/;"	m	struct:_TLexNet
nlexSA	HTKLVRec/HLVNet.h	/^   int nlexSA;         \/* hastable of (Z+'sil') - A contexts *\/$/;"	m	struct:_TLexNet
nlexYZ	HTKLVRec/HLVNet.h	/^   int nlexYZ;         \/* hastable of Y-Z contexts *\/$/;"	m	struct:_TLexNet
nlexZ	HTKLVRec/HLVNet.h	/^   int nlexZ;           \/* array of final phones *\/$/;"	m	struct:_TLexNet
nlexZS	HTKLVRec/HLVNet.h	/^   int nlexZS;         \/* hastable of Z - (A+'sil') contexts *\/$/;"	m	struct:_TLexNet
nlinks	HTKLVRec/HLVNet.h	/^   int nlinks;$/;"	m	struct:_TLexNode
nlinks	HTKLib/HNet.h	/^   int nlinks;          \/* Number of nodes connected to this one *\/$/;"	m	struct:_NetNode
nll	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nmiss	HLMLib/LModel.c	/^   int nmiss;           \/* times not available *\/$/;"	m	struct:_AccessInfo	file:
nmp	HTKLib/HRec.c	/^   int nmp;$/;"	m	struct:psetinfo	file:
nn	HTKLib/HNet.h	/^   int nn;                      \/* Number of nodes *\/$/;"	m	struct:lattice
nnl	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nnodes	HTKLVRec/HLVLM.h	/^   int nnodes;$/;"	m	struct:_FSLM_latlm
no	HTKTools/HHEd.c	/^   struct _Node *no;            \/* no subtree *\/$/;"	m	struct:_Node	typeref:struct:_Node::_Node	file:
no	HTKTools/HHEd.c	/^static AccSum yes,no;           \/* global accs for yes - no branches *\/$/;"	v	file:
noAlias	HTKTools/HHEd.c	/^static Boolean noAlias = FALSE;  \/* set to zap all aliases in hmmlist *\/$/;"	v	file:
noBounds	HTKTools/HLEd.c	/^static Boolean noBounds = FALSE;    \/* suppress boundary times if TRUE *\/$/;"	v	file:
noNumEscapes	HTKLib/HShell.c	/^static Boolean noNumEscapes = FALSE;     \/* Prevent writing in \\012 format *\/$/;"	v	file:
noTable	HTKLib/HParm.c	/^   Boolean noTable;    \/* no need for table access *\/$/;"	m	struct:_ParmBuf	file:
noTokenSurvived	HTKLib/HRec.h	/^   Boolean noTokenSurvived; \/* Set when no valid final token produced *\/$/;"	m	struct:vrecinfo
node	HTKLVRec/HLVNet.c	/^   STLexNode *node[2];  \/* numbered left to right *\/$/;"	m	struct:_STLexLink	file:
node	HTKLVRec/HLVNet.h	/^   LMlaNode *node;              \/* [0..nNodes-1] arry of entries *\/$/;"	m	struct:_LMlaTree
node	HTKLVRec/HLVNet.h	/^   LexNode *node;               \/* pointer to array of LexNodes *\/$/;"	m	struct:_LexNet
node	HTKLVRec/HLVRec.h	/^   LMNodeCache **node;$/;"	m	struct:_LMCache
node	HTKLVRec/HLVRec.h	/^   LexNode *node;$/;"	m	struct:_LexNodeInst
node	HTKLib/HNet.h	/^   NetNode *node;       \/* Node in network *\/$/;"	m	struct:_NetLink
node	HTKLib/HRec.c	/^   NetNode *node;       \/* Node for which alignment information present *\/$/;"	m	struct:align	file:
node	HTKLib/HRec.c	/^   NetNode *node;       \/* Position of instance within network *\/$/;"	m	struct:_NetInst	file:
node	HTKLib/HRec.h	/^   NetNode *node;       \/* Word level traceback info *\/$/;"	m	struct:path
nodeAhash	HTKLVRec/HLVNet.h	/^   TLexNode *nodeAhash[LEX_MOD_HASH_SIZE];$/;"	m	struct:_TLexNet
nodeBY	HTKLVRec/HLVNet.h	/^   TLexNode *nodeBY;$/;"	m	struct:_TLexNet
nodeHeap	HTKLVRec/HLVRec.h	/^   MemHeap nodeHeap;            \/* MHEAP for LMNodeCache entries *\/$/;"	m	struct:_LMCache
nodeHeap	HTKLib/HNet.h	/^   MemHeap nodeHeap;  \/* a heap for allocating nodes *\/$/;"	m	struct:__anon139
nodeHeap	HTKTools/HParse.c	/^static MemHeap nodeHeap;$/;"	v	file:
nodeIndex	HTKLib/HModel.h	/^  int nodeIndex;            \/* index number of node *\/$/;"	m	struct:_RegNode
nodeIndex	HTKTools/HHEd.c	/^   short  nodeIndex;         \/* node index number *\/$/;"	m	struct:__anon198	file:
nodeInfoHeap	HTKTools/HParse.c	/^static MemHeap nodeInfoHeap;$/;"	v	file:
nodeInstanceHeap	HTKLVRec/HLVRec.h	/^   MemHeap nodeInstanceHeap;    \/* MHEAP for LexNodeInsts *\/$/;"	m	struct:_DecoderInst
nodeNum	HTKTools/HParse.c	/^   int  nodeNum;     \/* store node numbers *\/$/;"	m	struct:_NodeInfo	file:
nodeOcc	HTKLib/HModel.h	/^  float nodeOcc;            \/* occupancy for this node *\/$/;"	m	struct:_RegNode
nodeSIL	HTKLVRec/HLVNet.h	/^   TLexNode *nodeSIL;$/;"	m	struct:_TLexNet
nodeZhash	HTKLVRec/HLVNet.h	/^   TLexNode *nodeZhash[LEX_MOD_HASH_SIZE];$/;"	m	struct:_TLexNet
node_hmm	HTKLib/HRec.c	53;"	d	file:
node_tr0	HTKLib/HRec.c	55;"	d	file:
node_wd0	HTKLib/HRec.c	56;"	d	file:
node_word	HTKLib/HRec.c	54;"	d	file:
nonFlooredConst	HTKTools/HMMIRest.c	/^static int totalConst=0,nonFlooredConst=0; \/*TODO: print.*\/$/;"	v	file:
nonKeys	HTKTools/HResults.c	/^static int nonKeys=0;         \/* count of nonKeyWords encountered *\/$/;"	v	file:
not_found_	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    WordIndex begin_sentence_, end_sentence_, not_found_;$/;"	m	class:lm::base::Vocabulary
np	HTKLVRec/kenlm/lm/wrappers/nplm.cc	/^namespace np {$/;"	n	namespace:lm	file:
np	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^namespace np {$/;"	n	namespace:lm
nphones	HTKLib/HDict.h	/^   short nphones;  \/* Number of phones in pronuciation *\/$/;"	m	struct:_WordPron
nphones	HTKLib/HNet.c	/^   short nphones;   \/* Number of phones for this instance *\/$/;"	m	struct:pronholder	file:
nphr	HTKTools/HResults.c	/^   int nsyms,nphr,phrcor;$/;"	m	struct:_Spkr	file:
nphr	HTKTools/HResults.c	/^static long nphr  = 0;     \/* Total phrases *\/$/;"	v	file:
nplm	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^namespace nplm {$/;"	n
npos	HTKLVRec/kenlm/util/string_piece.cc	/^const size_type StringPiece::npos = size_type(-1);$/;"	m	class:StringPiece	file:
npos	HTKLVRec/kenlm/util/string_piece.hh	/^  static const size_type npos;$/;"	m	class:StringPiece
nprons	HTKLib/HDict.h	/^   int nprons;          \/* total number of prons *\/$/;"	m	struct:__anon94
nprons	HTKLib/HDict.h	/^   int nprons;      \/* number of prons for this word *\/$/;"	m	struct:_DictEntry
npth	HTKLib/HRec.c	/^   int npth;                \/* Current number of path records *\/$/;"	m	struct:precinfo	file:
nse	HLMLib/LModel.h	/^   LM_Id nse;               \/* number of SMEntry *\/$/;"	m	struct:_FLEntry
nse	HTKLVRec/HLVLM.h	/^   LMId nse;                    \/* Number of ngrams for this entry *\/$/;"	m	struct:nentry
nse	HTKLib/HLM.h	/^   lmCnt nse;                   \/* Number of ngrams for this entry *\/$/;"	m	struct:nentry
nsize	HTKLVRec/HLVLM.h	/^   int nsize;                   \/* Unigram==1, Bigram==2, Trigram==3 *\/$/;"	m	struct:_FSLM_ngram
nsize	HTKLib/HLM.h	/^   int nsize;                   \/* Unigram==1, Bigram==2, Trigram==3 *\/$/;"	m	struct:ngramlm
nsp	HTKLib/HRec.c	/^   int nsp;$/;"	m	struct:psetinfo	file:
nstart	HTKLib/HNet.c	/^   int nstart;      \/* Number of models in starts chain *\/$/;"	m	struct:pronholder	file:
nsyms	HTKTools/HResults.c	/^   int nsyms,nphr,phrcor;$/;"	m	struct:_Spkr	file:
nsyms	HTKTools/HResults.c	/^static long nsyms = 0;     \/* Total symbols *\/$/;"	v	file:
ntr	HTKLib/HRec.c	/^   int ntr;$/;"	m	struct:psetinfo	file:
nulClass	HLMTools/LPlex.c	/^static LabId  nulClass;             \/* Id of NULCLASS phone label *\/$/;"	v	file:
nulClass	HTKTools/HResults.c	/^static LabId nulClass;                \/* Id of NULCLASS phone label *\/$/;"	v	file:
nulName	HLMTools/LPlex.c	/^static char   *nulName = "???";     \/* name of null class *\/$/;"	v	file:
nulName	HTKTools/HResults.c	/^static char * nulName = "???";        \/* name of null class *\/$/;"	v	file:
nullId	HTKTools/HLStats.c	/^static LabId nullId;                \/* id of !NULL label in ngram *\/$/;"	v	file:
nullLab	HTKTools/HLRescore.c	/^static LabId nullLab;           \/* !NULL LabId *\/$/;"	v	file:
nullNode	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon205	file:
nullOutput	HTKTools/HDMan.c	/^static Boolean nullOutput = FALSE;   \/* suppress generation of output dict *\/$/;"	v	file:
nullWord	HTKLib/HDict.h	/^   Word nullWord;       \/* dummy null word\/node *\/$/;"	m	struct:__anon94
nullWord	HTKLib/HLat.c	/^static LabId nullWord;          \/* null word in Lattices (!NULL) *\/$/;"	v	file:
nullWord	HTKLib/HNet.h	/^   Word nullWord;     \/* Word for output when word==NULL *\/$/;"	m	struct:__anon139
null_context_	HTKLVRec/kenlm/lm/facade.hh	/^    State begin_sentence_, null_context_;$/;"	m	class:lm::base::ModelFacade
null_context_memory_	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    const void *begin_sentence_memory_, *null_context_memory_;$/;"	m	class:lm::base::Model
null_token	HTKLib/HRec.c	/^const Token null_token={LZERO,0.0,NULL,NULL};$/;"	v
null_word_	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^    const lm::WordIndex null_word_;$/;"	m	class:lm::np::Vocabulary
null_word_	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^    lm::WordIndex null_word_;$/;"	m	class:lm::np::Model
numAccesses	HLMLib/LUtil.h	/^  long numAccesses;            \/* access statistics *\/$/;"	m	struct:__anon20
numAccesses	HTKLib/HLabel.c	/^static long numAccesses = 0;$/;"	v	file:
numActive	HTKTools/HDMan.c	/^static int numActive;                \/* num active input dictionaries *\/$/;"	v	file:
numCepCoef	HTKLib/HParm.c	/^   int numCepCoef;            \/* Number of cepstral coef *\/$/;"	m	struct:__anon141	file:
numChan	HTKLib/HWave.c	/^   int32 numChan;        \/* number of channels *\/$/;"	m	struct:__anon176	file:
numChannels	HTKLib/HWave.c	/^   short numChannels;$/;"	m	struct:__anon173	file:
numChannels	HTKLib/HWave.c	/^   short numChannels;$/;"	m	struct:__anon174	file:
numChannels	HTKLib/HWave.c	/^   short numChannels;$/;"	m	struct:__anon178	file:
numChans	HTKLib/HParm.c	/^   int numChans;              \/* Number of filter bank channels *\/$/;"	m	struct:__anon141	file:
numChans	HTKLib/HSigP.h	/^   int numChans;        \/* number of channels *\/$/;"	m	struct:__anon159
numChild	HTKLib/HModel.h	/^  int numChild;             \/* number of children - 0 if terminal *\/$/;"	m	struct:_RegNode
numClasses	HTKLib/HModel.h	/^  int numClasses;      \/* number of baseclasses *\/$/;"	m	struct:__anon129
numClust	HTKLib/HTrain.h	/^   int numClust;   \/* num cluster nodes *\/$/;"	m	struct:__anon162
numComps	HTKTools/HList.c	/^   int numComps;$/;"	m	struct:__anon202	file:
numConfigParms	HTKLib/HShell.c	/^static int numConfigParms = 0;$/;"	v	file:
numCons	HTKTools/HDMan.c	/^   int numCons;                 \/* number of context defs *\/$/;"	m	struct:__anon195	file:
numElem	HTKLib/HMem.h	/^   size_t numElem;      \/* #elems in blk             #bytes in blk        *\/$/;"	m	struct:_Block
numFields	HLMLib/LUtil.c	/^   int numFields;$/;"	m	struct:lmFileHdrRec	file:
numFiles	HTKLib/HModel.h	/^   int numFiles;           \/* total number of ext files *\/$/;"	m	struct:_HMMSet
numFllrs	HTKTools/HBuild.c	/^   int numFllrs;$/;"	m	struct:_GramEntry	file:
numFree	HTKLib/HMem.h	/^   size_t numFree;      \/* #free elements            #free bytes          *\/$/;"	m	struct:_Block
numLLFs	HTKLib/HLat.c	/^static int numLLFs = 0; $/;"	v	file:
numLat	HTKLib/HFBLat.h	/^  Lattice *numLat; \/* for MPE. *\/$/;"	m	struct:__anon102
numLatDir	HTKTools/HMMIRest.c	/^static char *numLatDir [MAXLATS];  \/*Numerator-alignment lattices.*\/$/;"	v	file:
numLatIncluded	HTKLib/HArc.h	/^  Boolean numLatIncluded; \/*if TRUE and this is a denominator lat, means the num lat$/;"	m	struct:ArcInfoStruct
numLatSubDirPat	HTKTools/HMMIRest.c	/^static char numLatSubDirPat[MAXSTRLEN] = "\\0";  \/* path mask of numerator lattices *\/$/;"	v	file:
numLatsLoaded	HTKLib/HLat.c	/^static int numLatsLoaded = 0;$/;"	v	file:
numLink	HTKLib/HNet.h	/^   int numLink;$/;"	m	struct:__anon139
numLinkSets	HTKTools/HParse.c	/^static long numLinkSets = 0;     \/* usage counters *\/$/;"	v	file:
numLinks	HTKTools/HParse.c	/^   short numLinks;   \/* number of links in set *\/$/;"	m	struct:__anon203	file:
numLinks	HTKTools/HParse.c	/^static long numLinks = 0;$/;"	v	file:
numLists	HTKLib/HLabel.h	/^   int numLists;           \/* num label lists (default=1) *\/$/;"	m	struct:__anon108
numLogHMM	HTKLib/HModel.h	/^   int numLogHMM;          \/* Num of logical HMM's *\/$/;"	m	struct:_HMMSet
numMLFs	HTKLib/HLabel.c	/^static int      numMLFs = 0;     \/* number of MLF files opened *\/$/;"	v	file:
numMacros	HTKLib/HModel.h	/^   int numMacros;          \/* num macros used in this set *\/$/;"	m	struct:_HMMSet
numMissing	HTKTools/HDMan.c	/^static int numMissing = 0;           \/* num words not found *\/$/;"	v	file:
numMix	HTKLib/HModel.h	/^   int numMix;             \/* Number of mixture components in HMMSet *\/$/;"	m	struct:_HMMSet
numNode	HTKLib/HNet.h	/^   int numNode;$/;"	m	struct:__anon139
numNodes	HTKLib/HModel.h	/^  int numNodes;        \/* number of non-terminal nodes in tree *\/$/;"	m	struct:RegTree
numNodes	HTKLib/HVQ.h	/^   short numNodes;      \/* total num nodes in all sub trees *\/$/;"	m	struct:_VQTabRec
numNodes	HTKTools/HParse.c	/^static long numNodes = 0;$/;"	v	file:
numNuisanceDim	HTKLib/HAdapt.c	/^static int numNuisanceDim = 0;$/;"	v	file:
numOut	HTKTools/HDMan.c	/^static int numOut = 0;               \/* num words processed *\/$/;"	v	file:
numOutMLF	HTKLib/HLabel.c	/^static int numOutMLF = 0;                   \/* number of output MLFs *\/ $/;"	v	file:
numParm	HTKLib/HAudio.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HLabel.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HMath.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HMem.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HSigP.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HVQ.c	/^static int numParm = 0;$/;"	v	file:
numParm	HTKLib/HWave.c	/^static int numParm = 0;$/;"	v	file:
numPhyHMM	HTKLib/HModel.h	/^   int numPhyHMM;          \/* Num of distinct physical HMM's *\/$/;"	m	struct:_HMMSet
numS	HTKTools/HList.c	/^static int numS = 1;             \/* number of streams *\/$/;"	v	file:
numSamples	HTKLib/HAudio.c	/^   int numSamples;$/;"	m	struct:_AudioIn	file:
numSamples	HTKLib/HAudio.c	/^   int numSamples;$/;"	m	struct:_AudioOut	file:
numSet	HTKTools/HSLab.c	/^static int numSet;              \/* number of alternative transcriptions *\/$/;"	v	file:
numSharedMix	HTKLib/HModel.h	/^   int numSharedMix;       \/* Number of shared mixtures in HMMSet *\/$/;"	m	struct:_HMMSet
numSharedStates	HTKLib/HModel.h	/^   int numSharedStates;    \/* Number of shared states in HMMSet *\/$/;"	m	struct:_HMMSet
numSpkrs	HTKTools/HResults.c	/^static int  numSpkrs  = 0;$/;"	v	file:
numStates	HTKLib/HModel.h	/^   int numStates;          \/* Number of states in HMMSet *\/$/;"	m	struct:_HMMSet
numStates	HTKLib/HModel.h	/^   short numStates;        \/* includes entry and exit states *\/$/;"	m	struct:__anon128
numTNodes	HTKLib/HModel.h	/^  int numTNodes;       \/* number of terminal nodes in tree *\/$/;"	m	struct:RegTree
numTests	HLMLib/LUtil.h	/^  long numTests;               \/* more access statistics *\/$/;"	m	struct:__anon20
numTests	HLMTools/LPlex.c	/^static int     numTests;            \/* number of tests to perform *\/$/;"	v	file:
numTests	HTKLib/HLabel.c	/^static long numTests = 0;$/;"	v	file:
numTransP	HTKLib/HModel.h	/^   int numTransP;          \/* Number of distinct transition matrices *\/$/;"	m	struct:_HMMSet
numTreeClust	HTKTools/HHEd.c	/^static int numTreeClust;        \/* number of clusters in tree *\/$/;"	v	file:
numWdBegin	HTKTools/HParse.c	/^static int numWdBegin=0;              \/* number of WORD_BEGIN nodes *\/$/;"	v	file:
numWdEnd	HTKTools/HParse.c	/^static int numWdEnd=0;                \/* number of WORD_END nodes *\/$/;"	v	file:
numWords	HTKLib/HLM.h	/^   lmCnt numWords;              \/* Number of words for language model *\/$/;"	m	struct:matbilm
numWrites	HTKLib/HAudio.c	/^   int numWrites;$/;"	m	struct:_AudioOut	file:
numXForms	HTKLib/HModel.h	/^  int numXForms;       \/* number of transforms in this xformset *\/$/;"	m	struct:__anon133
num_index	HTKLib/HFBLat.h	/^  float num_index; \/*make sure set. *\/$/;"	m	struct:__anon102
nwe	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nwi	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nwords	HTKLib/HDict.h	/^   int nwords;          \/* total number of words *\/$/;"	m	struct:__anon94
nwords	HTKTools/HBuild.c	/^   int nwords;$/;"	m	struct:__anon188	file:
nxl	HTKLib/HNet.c	/^int nwi=0,nin=0,nfi=0,ncn=0,nll=0,ncf=0,nwe=0,nil=0,nxl=0,nnl=0;$/;"	v
nxt	HLMLib/LGBase.h	/^   UInt nxt[MAXNG];         \/* next expanded N-gram (no count) *\/$/;"	m	struct:__anon3
nxtInst	HTKLib/HRec.c	/^   NetInst *nxtInst;        \/* Inst used to select next in step sequence *\/$/;"	m	struct:precinfo	file:
nxtpath	HTKLib/HRec.c	/^struct nxtpath$/;"	s	file:
nz	HTKLib/HAudio.c	/^static int nz=0;$/;"	v	file:
o	HTKLib/HTrain.h	/^   Observation o;       \/* used as an 'i\/o channel' to segstore *\/$/;"	m	struct:_SegStoreRec
oCnt	HTKLib/HParm.c	/^   int oCnt;              \/* Number of observations processed in session *\/$/;"	m	struct:channelinfo	file:
oStack	HTKTools/HCopy.c	/^static MemHeap oStack;          \/* output stack *\/$/;"	v	file:
objects	HTKLib/Makefile	/^objects = HGraf.o esig_asc.o \\$/;"	m
obs	HTKLVRec/HDecode.c	/^static Observation *obs;        \/* array of Observations *\/$/;"	v	file:
obs	HTKLVRec/HDecode.mod.c	/^static Observation *obs;        \/* array of Observations *\/$/;"	v	file:
obs	HTKLVRec/HLVRec.h	/^   Observation *obs;            \/* Observation for current frame *\/$/;"	m	struct:_DecoderInst
obs	HTKLib/HAdapt.c	/^   Vector obs;$/;"	m	struct:_ObsCache	file:
obs	HTKLib/HRec.c	/^   Observation *obs;         \/* Current Observation *\/$/;"	m	struct:precinfo	file:
obs	HTKTools/HCompV.c	/^static Observation obs;             \/* storage for observations  *\/$/;"	v	file:
obs	HTKTools/HQuant.c	/^static Observation obs;             \/* storage for observations  *\/$/;"	v	file:
obs	HTKTools/HVite.c	/^static Observation obs;           \/* current observation *\/$/;"	v	file:
obsBlock	HTKLVRec/HLVRec.h	/^   Observation *obsBlock[MAXBLOCKOBS]; \/* block of current and future Observations *\/$/;"	m	struct:_DecoderInst
obsFmt	HTKTools/HList.c	/^static Boolean obsFmt  = FALSE;  \/* print observation format *\/$/;"	v	file:
obsVec	HTKLib/HAdapt.c	/^   Vector  obsVec;$/;"	m	struct:__anon87	file:
obyte_order	HTKLib/HAudio.c	/^   char *obyte_order;$/;"	m	struct:_AudioIn	file:
obyte_order	HTKLib/HAudio.c	/^   char *obyte_order;$/;"	m	struct:_AudioOut	file:
oc	HTKLib/HAdapt.c	/^   ObsCache *oc;         \/* observation cache for input transform *\/$/;"	m	struct:__anon88	file:
occ	HTKLib/HAdapt.c	/^   double occ;  $/;"	m	struct:__anon85	file:
occ	HTKLib/HAdapt.c	/^   float occ;$/;"	m	struct:__anon87	file:
occ	HTKLib/HFBLat.c	/^   float occ;$/;"	m	struct:__anon101	file:
occ	HTKLib/HTrain.h	/^   Vector occ;       \/* array[1..N] of state occupation *\/$/;"	m	struct:__anon163
occ	HTKLib/HTrain.h	/^   float occ;        \/* occ for states sharing this mpdf *\/$/;"	m	struct:__anon165
occ	HTKLib/HTrain.h	/^   float occ;        \/* occ for states sharing this mpdf *\/$/;"	m	struct:__anon166
occ	HTKLib/HTrain.h	/^   float occ;        \/* occ for states sharing this pdf *\/$/;"	m	struct:__anon164
occ	HTKTools/HHEd.c	/^   float  occ;$/;"	m	struct:_AccSum	file:
occ	HTKTools/HHEd.c	/^   float occ;                   \/* total occupation count *\/$/;"	m	struct:_Node	file:
occ	HTKTools/HSmooth.c	/^   float occ;        \/* occ for states sharing this pdf *\/$/;"	m	struct:_ChWtAcc	file:
occStatsLoaded	HTKTools/HHEd.c	/^static Boolean occStatsLoaded = FALSE; \/* set when RO\/LS has loaded occ stats *\/$/;"	v	file:
occa	HTKLib/HFB.h	/^  Vector *occa;       \/* array[1..Q][1..Nq] of occ probs (trace only) *\/$/;"	m	struct:__anon98
occr	HTKTools/HRest.c	/^static Vector occr;        \/* array[1..nStates-1] of occ count for cur time *\/$/;"	v	file:
occs	HTKTools/HHEd.c	/^static float occs[2];           \/* array[Boolean]of occupation counts *\/$/;"	v	file:
occt	HTKLib/HFB.h	/^  Vector occt;        \/* occ probs for current time t *\/$/;"	m	struct:__anon98
occurrence	HTKLib/esignal.h	/^    short       occurrence;     \/* REQUIRED, GLOBAL, OPTIONAL, etc. *\/$/;"	m	struct:FieldSpec
off	HTKTools/HCopy.c	/^static HTime off = 0.0;         \/* length of files appended so far *\/$/;"	v	file:
offset	HTKLVRec/kenlm/util/bit_packing.hh	/^  uint64_t offset;$/;"	m	struct:util::BitAddress
offset	HTKLVRec/kenlm/util/parallel_read.cc	/^      uint64_t offset;$/;"	m	struct:util::__anon78::Reader::Request	file:
offset	HTKLib/HLabel.h	/^   long offset;   \/* offset into MLF file *\/$/;"	m	struct:__anon109
offset	HTKLib/esignal.h	/^    double      scale, offset;  \/* scale factor and offset relating$/;"	m	struct:FieldSpec
offset_	HTKLVRec/kenlm/util/stream/sort.hh	/^        uint64_t remaining_, offset_;$/;"	m	class:util::stream::MergeQueue::Entry
offset_begin_	HTKLVRec/kenlm/lm/bhiksha.hh	/^    const uint64_t *const offset_begin_;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
offset_end_	HTKLVRec/kenlm/lm/bhiksha.hh	/^    const uint64_t *const offset_end_;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
offsets_	HTKLVRec/kenlm/util/stream/sort.hh	/^    Offsets *offsets_;$/;"	m	class:util::stream::BlockSorter
offsets_	HTKLVRec/kenlm/util/stream/sort.hh	/^    Offsets offsets_;$/;"	m	class:util::stream::OwningMergingReader
offsets_	HTKLVRec/kenlm/util/stream/sort.hh	/^    Offsets offsets_;$/;"	m	class:util::stream::Sort
offsets_file_	HTKLVRec/kenlm/util/stream/sort.hh	/^    scoped_fd offsets_file_;$/;"	m	class:util::stream::Sort
oflags	HTKTools/HCompV.c	/^static char oflags[MAXSTRLEN] = "m";     \/* export flags for CMV *\/  $/;"	v	file:
ofmt	HTKLVRec/HDecode.c	/^static FileFormat ofmt = UNDEFF;	\/* Label output file format *\/$/;"	v	file:
ofmt	HTKLVRec/HDecode.mod.c	/^static FileFormat ofmt = UNDEFF;	\/* Label output file format *\/$/;"	v	file:
ofmt	HTKTools/HLEd.c	/^static FileFormat ofmt=UNDEFF;      \/* Label output file format *\/$/;"	v	file:
ofmt	HTKTools/HLRescore.c	/^static FileFormat ofmt=UNDEFF;  \/* Label output file format *\/$/;"	v	file:
ofmt	HTKTools/HSLab.c	/^static FileFormat ofmt=UNDEFF;      \/* Label output file format *\/$/;"	v	file:
ofmt	HTKTools/HVite.c	/^static FileFormat ofmt=UNDEFF;    \/* Label output file format *\/$/;"	v	file:
oldincludedir	HLMLib/Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	HLMTools/Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	HTKLVRec/Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	HTKLib/Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	HTKTools/Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldincludedir	Makefile	/^oldincludedir = \/usr\/include$/;"	m
oldmap	HTKTools/HLEd.c	/^static char oldmap[] = " RCFMDXZBEISWVLGTY ";$/;"	v	file:
omap	HLMTools/LGCopy.c	/^static WordMap    *omap = NULL;     \/* output buffer map *\/$/;"	v	file:
omap	HLMTools/LSubset.c	/^static WordMap  *omap;           \/* the ouput word\/class map *\/$/;"	v	file:
omapFN	HLMTools/LAdapt.c	/^static char *omapFN  = "wmap";      \/* output word map file name *\/$/;"	v	file:
omapFN	HLMTools/LGCopy.c	/^static char *omapFN  = NULL;        \/* output map filename *\/$/;"	v	file:
omapFN	HLMTools/LGPrep.c	/^static char *omapFN  = NULL;        \/* output word map filename *\/$/;"	v	file:
omapFN	HLMTools/LSubset.c	/^static char     *omapFN;         \/* output map filename *\/$/;"	v	file:
one_f	HTKLVRec/kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon41::OldSanity	file:
one_f	HTKLVRec/kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon41::Sanity	file:
one_uint64	HTKLVRec/kenlm/lm/binary_format.cc	/^  uint64_t one_uint64;$/;"	m	struct:lm::ngram::__anon41::OldSanity	file:
one_uint64	HTKLVRec/kenlm/lm/binary_format.cc	/^  uint64_t one_uint64;$/;"	m	struct:lm::ngram::__anon41::Sanity	file:
one_word_index	HTKLVRec/kenlm/lm/binary_format.cc	/^  WordIndex one_word_index, max_word_index, padding_to_8;$/;"	m	struct:lm::ngram::__anon41::Sanity	file:
one_word_index	HTKLVRec/kenlm/lm/binary_format.cc	/^  WordIndex one_word_index, max_word_index;$/;"	m	struct:lm::ngram::__anon41::OldSanity	file:
ooo	HTKLib/HRec.c	/^   Boolean ooo;         \/* Instance potentially out of order *\/$/;"	m	struct:_NetInst	file:
oov	HLMTools/LPlex.c	/^   OOVEntry oov[MAX_OOV];   \/* array of OOVs *\/$/;"	m	struct:__anon34	file:
op	HTKTools/HDMan.c	/^   EdOp op;$/;"	m	struct:__anon192	file:
op	HTKTools/HLEd.c	/^   EdOp op;$/;"	m	struct:__anon201	file:
op	HTKTools/HSLab.c	/^   OpType op;           \/* the operation carried out *\/$/;"	m	struct:__anon211	file:
operator !	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    bool operator!() const { return !stream_; }$/;"	f	class:lm::builder::NGramStream
operator !	HTKLVRec/kenlm/util/stream/block.hh	/^    bool operator!() const { return mem_ == NULL; }$/;"	f	class:util::stream::Block
operator !	HTKLVRec/kenlm/util/stream/stream.hh	/^    bool operator!() const { return current_ == NULL; }$/;"	f	class:util::stream::Stream
operator !	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    bool operator!() const {$/;"	f	class:util::TokenIter
operator !=	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    bool operator!=(const S &other) const { return !(*this == other); }$/;"	f	class:util::ProxyIterator
operator !=	HTKLVRec/kenlm/util/string_piece.hh	/^inline bool operator!=(const StringPiece& x, const StringPiece& y) {$/;"	f
operator ()	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    bool operator()(const WordIndex *first, const WordIndex *second) const {$/;"	f	class:lm::builder::__anon43::DedupeEquals
operator ()	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    std::size_t operator()(const WordIndex *start) const {$/;"	f	class:lm::builder::__anon43::DedupeHash
operator ()	HTKLVRec/kenlm/lm/builder/sort.hh	/^    inline bool operator()(const void *lhs, const void *rhs) const {$/;"	f	class:lm::builder::Comparator
operator ()	HTKLVRec/kenlm/lm/builder/sort.hh	/^  bool operator()(void *first_void, const void *second_void, const SuffixOrder &compare) const {$/;"	f	struct:lm::builder::AddCombiner
operator ()	HTKLVRec/kenlm/lm/filter/phrase.cc	/^  bool operator()(const Arc *first, const Arc *second) const {$/;"	f	struct:lm::phrase::detail::ArcGreater
operator ()	HTKLVRec/kenlm/lm/filter/thread.hh	/^    void operator()(Request request) {$/;"	f	class:lm::FilterWorker
operator ()	HTKLVRec/kenlm/lm/filter/thread.hh	/^    void operator()(Request request) {$/;"	f	class:lm::OutputWorker
operator ()	HTKLVRec/kenlm/lm/filter/vocab.hh	/^        void operator()(unsigned int index) {$/;"	f	class:lm::vocab::Multiple::Callback
operator ()	HTKLVRec/kenlm/lm/search_hashed.cc	/^    void operator()(const WordIndex *vocab_ids, const unsigned int \/*n*\/) {$/;"	f	class:lm::ngram::__anon57::ActivateUnigram
operator ()	HTKLVRec/kenlm/lm/search_hashed.cc	/^    void operator()(const WordIndex *vocab_ids, const unsigned int n) {$/;"	f	class:lm::ngram::__anon57::ActivateLowerMiddle
operator ()	HTKLVRec/kenlm/lm/trie.cc	/^    Key operator()(uint64_t index) const {$/;"	f	class:lm::ngram::trie::__anon59::KeyAccessor
operator ()	HTKLVRec/kenlm/lm/trie_sort.cc	/^  void operator()(std::size_t entry_size, unsigned char \/*order*\/, const void *first, const void * \/*second*\/, FILE *out) const {$/;"	f	struct:lm::ngram::trie::__anon60::FirstCombine
operator ()	HTKLVRec/kenlm/lm/trie_sort.cc	/^  void operator()(std::size_t entry_size, unsigned char order, const void *first, const void *second, FILE * \/*out*\/) const {$/;"	f	struct:lm::ngram::trie::__anon60::ThrowCombine
operator ()	HTKLVRec/kenlm/lm/trie_sort.hh	/^    bool operator()(const void *first_void, const void *second_void) const {$/;"	f	class:lm::ngram::trie::EntryCompare
operator ()	HTKLVRec/kenlm/lm/vocab.hh	/^    void operator()(const StringPiece &word) {$/;"	f	class:lm::ngram::WriteUniqueWords
operator ()	HTKLVRec/kenlm/lm/vocab.hh	/^    void operator()(const StringPiece &word) {}$/;"	f	class:lm::ngram::NoOpUniqueWords
operator ()	HTKLVRec/kenlm/util/joint_sort.hh	/^    bool operator()(const Proxy &left, const Proxy &right) const {$/;"	f	class:util::detail::LessWrapper
operator ()	HTKLVRec/kenlm/util/joint_sort.hh	/^    bool operator()(const Proxy &left, const typename Proxy::value_type &right) const {$/;"	f	class:util::detail::LessWrapper
operator ()	HTKLVRec/kenlm/util/joint_sort.hh	/^    bool operator()(const typename Proxy::value_type &left, const Proxy &right) const {$/;"	f	class:util::detail::LessWrapper
operator ()	HTKLVRec/kenlm/util/joint_sort.hh	/^    bool operator()(const typename Proxy::value_type &left, const typename Proxy::value_type &right) const {$/;"	f	class:util::detail::LessWrapper
operator ()	HTKLVRec/kenlm/util/multi_intersection.hh	/^  bool operator()(const Range &left, const Range &right) const {$/;"	f	struct:util::detail::RangeLessBySize
operator ()	HTKLVRec/kenlm/util/parallel_read.cc	/^    void operator()(const Request &request) {$/;"	f	class:util::__anon78::Reader
operator ()	HTKLVRec/kenlm/util/probing_hash_table.hh	/^  template <class T> T operator()(T arg) const { return arg; }$/;"	f	struct:util::IdentityHash
operator ()	HTKLVRec/kenlm/util/sized_iterator.hh	/^    bool operator()(const Proxy &first, const Proxy &second) const {$/;"	f	class:util::SizedCompare
operator ()	HTKLVRec/kenlm/util/sized_iterator.hh	/^    bool operator()(const Proxy &first, const std::string &second) const {$/;"	f	class:util::SizedCompare
operator ()	HTKLVRec/kenlm/util/sized_iterator.hh	/^    bool operator()(const std::string &first, const Proxy &second) const {$/;"	f	class:util::SizedCompare
operator ()	HTKLVRec/kenlm/util/sized_iterator.hh	/^    bool operator()(const std::string &first, const std::string &second) const {$/;"	f	class:util::SizedCompare
operator ()	HTKLVRec/kenlm/util/sorted_uniform.hh	/^    T operator()(const T *in) const { return *in; }$/;"	f	class:util::IdentityAccessor
operator ()	HTKLVRec/kenlm/util/stream/chain.hh	/^    template <class Position, class Worker> void operator()(const Position &position, Worker &worker) {$/;"	f	class:util::stream::Thread
operator ()	HTKLVRec/kenlm/util/stream/sort.hh	/^        bool operator()(const Entry &first, const Entry &second) const {$/;"	f	class:util::stream::MergeQueue::Greater
operator ()	HTKLVRec/kenlm/util/stream/sort.hh	/^  template <class Compare> bool operator()(const void *, const void *, const Compare &) const { $/;"	f	struct:util::stream::NeverCombine
operator ()	HTKLVRec/kenlm/util/string_piece_hash.hh	/^  bool operator()(const StringPiece &first, const StringPiece &second) const {$/;"	f	struct:StringPieceCompatibleEquals
operator ()	HTKLVRec/kenlm/util/string_piece_hash.hh	/^  size_t operator()(const StringPiece &str) const {$/;"	f	struct:StringPieceCompatibleHash
operator ()	HTKLVRec/kenlm/util/thread_pool.hh	/^    void operator()() {$/;"	f	class:util::Worker
operator *	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    const NGram &operator*() const { return current_; }$/;"	f	class:lm::builder::__anon42::CollapseStream
operator *	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    NGram &operator*() { return current_; }$/;"	f	class:lm::builder::__anon45::PruneNGramStream
operator *	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    NGram &operator*() { return gram_; }$/;"	f	class:lm::builder::NGramStream
operator *	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    const NGram &operator*() const { return gram_; }$/;"	f	class:lm::builder::NGramStream
operator *	HTKLVRec/kenlm/util/file.hh	/^    int operator*() const { return fd_; }$/;"	f	class:util::scoped_fd
operator *	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    Proxy operator*() { return p_; }$/;"	f	class:util::ProxyIterator
operator *	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    const Proxy operator*() const { return p_; }$/;"	f	class:util::ProxyIterator
operator *	HTKLVRec/kenlm/util/scoped.hh	/^    T &operator*() { return *scoped_base<T, Closer>::p_; }$/;"	f	class:util::scoped
operator *	HTKLVRec/kenlm/util/scoped.hh	/^    const T&operator*() const { return *scoped_base<T, Closer>::p_; }$/;"	f	class:util::scoped
operator *	HTKLVRec/kenlm/util/stream/chain.hh	/^    Block &operator*() { return current_; }$/;"	f	class:util::stream::Link
operator *	HTKLVRec/kenlm/util/stream/chain.hh	/^    const Block &operator*() const { return current_; }$/;"	f	class:util::stream::Link
operator +	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    S operator+(std::ptrdiff_t amount) const { S ret(*this); ret += amount; return ret; }$/;"	f	class:util::ProxyIterator
operator +	HTKLVRec/kenlm/util/proxy_iterator.hh	/^template <class Proxy> ProxyIterator<Proxy> operator+(std::ptrdiff_t amount, const ProxyIterator<Proxy> &it) {$/;"	f	namespace:util
operator ++	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    CollapseStream &operator++() {$/;"	f	class:lm::builder::__anon42::CollapseStream
operator ++	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    PruneNGramStream &operator++() {$/;"	f	class:lm::builder::__anon45::PruneNGramStream
operator ++	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    NGramStream &operator++() {$/;"	f	class:lm::builder::NGramStream
operator ++	HTKLVRec/kenlm/lm/trie_sort.hh	/^    RecordReader &operator++() {$/;"	f	class:lm::ngram::trie::RecordReader
operator ++	HTKLVRec/kenlm/util/ersatz_progress.hh	/^    ErsatzProgress &operator++() {$/;"	f	class:util::ErsatzProgress
operator ++	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    S &operator++() { return *this += 1; }$/;"	f	class:util::ProxyIterator
operator ++	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    S operator++(int) { S ret(*this); ++*this; return ret; }$/;"	f	class:util::ProxyIterator
operator ++	HTKLVRec/kenlm/util/stream/chain.cc	/^Link &Link::operator++() {$/;"	f	class:util::stream::Link
operator ++	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    WorkerProgress &operator++() {$/;"	f	class:util::stream::WorkerProgress
operator ++	HTKLVRec/kenlm/util/stream/stream.hh	/^    Stream &operator++() {$/;"	f	class:util::stream::Stream
operator +=	HTKLVRec/kenlm/util/ersatz_progress.hh	/^    ErsatzProgress &operator+=(uint64_t amount) {$/;"	f	class:util::ErsatzProgress
operator +=	HTKLVRec/kenlm/util/joint_sort.hh	/^    JointIter<KeyIter, ValueIter> &operator+=(std::ptrdiff_t amount) {$/;"	f	class:util::detail::JointIter
operator +=	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    S &operator+=(std::ptrdiff_t amount) { I() += amount; return *this; }$/;"	f	class:util::ProxyIterator
operator +=	HTKLVRec/kenlm/util/sized_iterator.hh	/^    SizedInnerIterator &operator+=(std::ptrdiff_t amount) {$/;"	f	class:util::SizedInnerIterator
operator +=	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    WorkerProgress &operator+=(uint64_t amount) {$/;"	f	class:util::stream::WorkerProgress
operator -	HTKLVRec/kenlm/util/joint_sort.hh	/^    std::ptrdiff_t operator-(const JointIter<KeyIter, ValueIter> &other) const { return key_ - other.key_; }$/;"	f	class:util::detail::JointIter
operator -	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    S operator-(std::ptrdiff_t amount) const { S ret(*this); ret -= amount; return ret; }$/;"	f	class:util::ProxyIterator
operator -	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    std::ptrdiff_t operator-(const S &other) const { return I() - other.I(); }$/;"	f	class:util::ProxyIterator
operator -	HTKLVRec/kenlm/util/sized_iterator.hh	/^    std::ptrdiff_t operator-(const SizedInnerIterator &other) const {$/;"	f	class:util::SizedInnerIterator
operator --	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    S &operator--() { return *this -= 1; }$/;"	f	class:util::ProxyIterator
operator --	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    S operator--(int) { S ret(*this); --*this; return ret; }$/;"	f	class:util::ProxyIterator
operator -=	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    S &operator-=(std::ptrdiff_t amount) { I() += (-amount); return *this; }$/;"	f	class:util::ProxyIterator
operator ->	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    const NGram *operator->() const { return &current_; }$/;"	f	class:lm::builder::__anon42::CollapseStream
operator ->	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    NGram *operator->() { return &current_; }$/;"	f	class:lm::builder::__anon45::PruneNGramStream
operator ->	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    NGram *operator->() { return &gram_; }$/;"	f	class:lm::builder::NGramStream
operator ->	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    const NGram *operator->() const { return &gram_; }$/;"	f	class:lm::builder::NGramStream
operator ->	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    Proxy *operator->() { return &p_; }$/;"	f	class:util::ProxyIterator
operator ->	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    const Proxy *operator->() const { return &p_; }$/;"	f	class:util::ProxyIterator
operator ->	HTKLVRec/kenlm/util/scoped.hh	/^    T *operator->() { return p_; }$/;"	f	class:util::scoped_base
operator ->	HTKLVRec/kenlm/util/scoped.hh	/^    const T *operator->() const { return p_; }$/;"	f	class:util::scoped_base
operator ->	HTKLVRec/kenlm/util/stream/chain.hh	/^    Block *operator->() { return &current_; }$/;"	f	class:util::stream::Link
operator ->	HTKLVRec/kenlm/util/stream/chain.hh	/^    const Block *operator->() const { return &current_; }$/;"	f	class:util::stream::Link
operator <	HTKLVRec/kenlm/lm/search_trie.cc	/^  bool operator<(const Gram &other) const {$/;"	f	struct:lm::ngram::trie::__anon58::Gram
operator <	HTKLVRec/kenlm/lm/state.hh	/^    bool operator<(const State &other) const {$/;"	f	class:lm::ngram::State
operator <	HTKLVRec/kenlm/lm/state.hh	/^  bool operator<(const ChartState &other) const {$/;"	f	struct:lm::ngram::ChartState
operator <	HTKLVRec/kenlm/lm/state.hh	/^  bool operator<(const Left &other) const {$/;"	f	struct:lm::ngram::Left
operator <	HTKLVRec/kenlm/util/joint_sort.hh	/^    bool operator<(const JointIter<KeyIter, ValueIter> &other) const { return (key_ < other.key_); }$/;"	f	class:util::detail::JointIter
operator <	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    bool operator<(const S &other) const { return I() < other.I(); }$/;"	f	class:util::ProxyIterator
operator <	HTKLVRec/kenlm/util/sized_iterator.hh	/^    bool operator<(const SizedInnerIterator &other) const {$/;"	f	class:util::SizedInnerIterator
operator <	HTKLVRec/kenlm/util/string_piece.hh	/^inline bool operator<(const StringPiece& x, const StringPiece& y) {$/;"	f
operator <<	HTKLVRec/kenlm/util/exception.hh	/^template <class Except, class Data> typename Except::template ExceptionTag<Except&>::Identity operator<<(Except &e, const Data &data) {$/;"	f	namespace:util
operator <<	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    FakeOFStream &operator<<(StringPiece str) {$/;"	f	class:util::FakeOFStream
operator <<	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    FakeOFStream &operator<<(char c) {$/;"	f	class:util::FakeOFStream
operator <<	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    FakeOFStream &operator<<(double value) {$/;"	f	class:util::FakeOFStream
operator <<	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    FakeOFStream &operator<<(float value) {$/;"	f	class:util::FakeOFStream
operator <<	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    FakeOFStream &operator<<(unsigned value) {$/;"	f	class:util::FakeOFStream
operator <<	HTKLVRec/kenlm/util/string_piece.hh	/^inline std::ostream& operator<<(std::ostream& o, const StringPiece& piece) {$/;"	f
operator <=	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    bool operator<=(const S &other) const { return !(*this > other); }$/;"	f	class:util::ProxyIterator
operator <=	HTKLVRec/kenlm/util/string_piece.hh	/^inline bool operator<=(const StringPiece& x, const StringPiece& y) {$/;"	f
operator =	HTKLVRec/kenlm/lm/trie_sort.cc	/^    PartialViewProxy &operator=(const PartialViewProxy &from) {$/;"	f	class:lm::ngram::trie::__anon60::PartialViewProxy
operator =	HTKLVRec/kenlm/lm/trie_sort.cc	/^    PartialViewProxy &operator=(const std::string &from) {$/;"	f	class:lm::ngram::trie::__anon60::PartialViewProxy
operator =	HTKLVRec/kenlm/util/exception.cc	/^Exception &Exception::operator=(const Exception &from) {$/;"	f	class:util::Exception
operator =	HTKLVRec/kenlm/util/joint_sort.hh	/^    JointProxy &operator=(const JointProxy &other) {$/;"	f	class:util::detail::JointProxy
operator =	HTKLVRec/kenlm/util/joint_sort.hh	/^    JointProxy &operator=(const value_type &other) {$/;"	f	class:util::detail::JointProxy
operator =	HTKLVRec/kenlm/util/mmap.cc	/^Rolling &Rolling::operator=(const Rolling &copy_from) {$/;"	f	class:util::Rolling
operator =	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    S &operator=(const S &other) {$/;"	f	class:util::ProxyIterator
operator =	HTKLVRec/kenlm/util/sized_iterator.hh	/^    SizedProxy &operator=(const SizedProxy &from) {$/;"	f	class:util::SizedProxy
operator =	HTKLVRec/kenlm/util/sized_iterator.hh	/^    SizedProxy &operator=(const std::string &from) {$/;"	f	class:util::SizedProxy
operator ==	HTKLVRec/kenlm/lm/state.hh	/^    bool operator==(const State &other) const {$/;"	f	class:lm::ngram::State
operator ==	HTKLVRec/kenlm/lm/state.hh	/^  bool operator==(const ChartState &other) const {$/;"	f	struct:lm::ngram::ChartState
operator ==	HTKLVRec/kenlm/lm/state.hh	/^  bool operator==(const Left &other) const {$/;"	f	struct:lm::ngram::Left
operator ==	HTKLVRec/kenlm/util/joint_sort.hh	/^    bool operator==(const JointIter<KeyIter, ValueIter> &other) const { return key_ == other.key_; }$/;"	f	class:util::detail::JointIter
operator ==	HTKLVRec/kenlm/util/parallel_read.cc	/^      bool operator==(const Request &other) const {$/;"	f	struct:util::__anon78::Reader::Request
operator ==	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    bool operator==(const S &other) const { return I() == other.I(); }$/;"	f	class:util::ProxyIterator
operator ==	HTKLVRec/kenlm/util/sized_iterator.hh	/^    bool operator==(const SizedInnerIterator &other) const {$/;"	f	class:util::SizedInnerIterator
operator ==	HTKLVRec/kenlm/util/string_piece.hh	/^inline bool operator==(const StringPiece& x, const StringPiece& y) {$/;"	f
operator >	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    bool operator>(const S &other) const { return other < *this; }$/;"	f	class:util::ProxyIterator
operator >	HTKLVRec/kenlm/util/string_piece.hh	/^inline bool operator>(const StringPiece& x, const StringPiece& y) {$/;"	f
operator >=	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    bool operator>=(const S &other) const { return !(*this < other); }$/;"	f	class:util::ProxyIterator
operator >=	HTKLVRec/kenlm/util/string_piece.hh	/^inline bool operator>=(const StringPiece& x, const StringPiece& y) {$/;"	f
operator >>	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^inline util::stream::Chain &operator>>(util::stream::Chain &chain, NGramStream &str) {$/;"	f	namespace:lm::builder
operator >>	HTKLVRec/kenlm/lm/builder/pipeline.cc	/^    template <class T> Master &operator>>(const T &worker) {$/;"	f	class:lm::builder::__anon47::Master
operator >>	HTKLVRec/kenlm/util/stream/chain.cc	/^Chain &Chain::operator>>(const PWriteAndRecycle &writer) {$/;"	f	class:util::stream::Chain
operator >>	HTKLVRec/kenlm/util/stream/chain.cc	/^Chain &Chain::operator>>(const WriteAndRecycle &writer) {$/;"	f	class:util::stream::Chain
operator >>	HTKLVRec/kenlm/util/stream/chain.hh	/^    Chain &operator>>(const Recycler &) {$/;"	f	class:util::stream::Chain
operator >>	HTKLVRec/kenlm/util/stream/chain.hh	/^    template <class Worker> typename CheckForRun<Worker>::type &operator>>(const Worker &worker) {$/;"	f	class:util::stream::Chain
operator >>	HTKLVRec/kenlm/util/stream/chain.hh	/^    template <class Worker> typename CheckForRun<Worker>::type &operator>>(const boost::reference_wrapper<Worker> &worker) {$/;"	f	class:util::stream::Chain
operator >>	HTKLVRec/kenlm/util/stream/chain.hh	/^inline Chain &operator>>(Chain &chain, Link &link) {$/;"	f	namespace:util::stream
operator >>	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    Chains &operator>>(const util::stream::Recycler &recycler) {$/;"	f	class:util::stream::Chains
operator >>	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    template <class Worker> typename CheckForRun<Worker>::type &operator>>(const Worker &worker) {$/;"	f	class:util::stream::Chains
operator >>	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    template <class Worker> typename CheckForRun<Worker>::type &operator>>(const boost::reference_wrapper<Worker> &worker) {$/;"	f	class:util::stream::Chains
operator >>	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^inline Chains &operator>>(Chains &chains, ChainPositions &positions) {$/;"	f	namespace:util::stream
operator >>	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^template <class T> inline Chains &operator>>(Chains &chains, GenericStreams<T> &streams) {$/;"	f	namespace:util::stream
operator >>	HTKLVRec/kenlm/util/stream/stream.hh	/^inline Chain &operator>>(Chain &chain, Stream &stream) {$/;"	f	namespace:util::stream
operator []	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  T& operator[](int index) const {$/;"	f	class:double_conversion::Vector
operator []	HTKLVRec/kenlm/util/fixed_array.hh	/^    T &operator[](std::size_t i) { return begin()[i]; }$/;"	f	class:util::FixedArray
operator []	HTKLVRec/kenlm/util/fixed_array.hh	/^    const T &operator[](std::size_t i) const { return begin()[i]; }$/;"	f	class:util::FixedArray
operator []	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    Proxy operator[](std::ptrdiff_t amount) const { return *(*this + amount); }$/;"	f	class:util::ProxyIterator
operator []	HTKLVRec/kenlm/util/scoped.hh	/^    T &operator[](std::size_t idx) { return scoped<T, scoped_delete_array_forward>::p_[idx]; }$/;"	f	class:util::scoped_array
operator []	HTKLVRec/kenlm/util/scoped.hh	/^    const T &operator[](std::size_t idx) const { return scoped<T, scoped_delete_array_forward>::p_[idx]; }$/;"	f	class:util::scoped_array
operator []	HTKLVRec/kenlm/util/string_piece.hh	/^  char operator[](size_type i) const { return ptr_[i]; }$/;"	f	class:StringPiece
operator bool	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    operator bool() const { return block_; }$/;"	f	class:lm::builder::__anon42::CollapseStream
operator bool	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    operator bool() const {$/;"	f	class:lm::builder::__anon45::PruneNGramStream
operator bool	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    operator bool() const { return stream_; }$/;"	f	class:lm::builder::NGramStream
operator bool	HTKLVRec/kenlm/lm/trie_sort.hh	/^    operator bool() const { return remains_; }$/;"	f	class:lm::ngram::trie::RecordReader
operator bool	HTKLVRec/kenlm/util/stream/block.hh	/^    operator bool() const { return mem_ != NULL; }$/;"	f	class:util::stream::Block
operator bool	HTKLVRec/kenlm/util/stream/chain.hh	/^    operator bool() const { return current_; }$/;"	f	class:util::stream::Link
operator bool	HTKLVRec/kenlm/util/stream/stream.hh	/^    operator bool() const { return current_ != NULL; }$/;"	f	class:util::stream::Stream
operator bool	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    operator bool() const {$/;"	f	class:util::TokenIter
operator std::string	HTKLVRec/kenlm/lm/trie_sort.cc	/^    operator std::string() const {$/;"	f	class:lm::ngram::trie::__anon60::PartialViewProxy
operator std::string	HTKLVRec/kenlm/util/sized_iterator.hh	/^    operator std::string() const {$/;"	f	class:util::SizedProxy
operator value_type	HTKLVRec/kenlm/util/joint_sort.hh	/^    operator value_type() const {$/;"	f	class:util::detail::JointProxy
optSet	HTKLib/HModel.h	/^   Boolean optSet;         \/* true if global options have been set *\/$/;"	m	struct:_HMMSet
optarg	HTKLVRec/kenlm/util/getopt.c	/^char	*optarg;$/;"	v
opterr	HTKLVRec/kenlm/util/getopt.c	/^int	opterr = 1;$/;"	v
optind	HTKLVRec/kenlm/util/getopt.c	/^int	optind = 1;$/;"	v
optopt	HTKLVRec/kenlm/util/getopt.c	/^int	optopt;$/;"	v
order	HTKLVRec/kenlm/lm/binary_format.hh	/^  unsigned char order;$/;"	m	struct:lm::ngram::FixedWidthParameters
order	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  std::size_t order;$/;"	m	struct:lm::builder::PipelineConfig
order_	HTKLVRec/kenlm/lm/builder/sort.hh	/^    std::size_t order_;$/;"	m	class:lm::builder::Comparator
order_	HTKLVRec/kenlm/lm/search_trie.cc	/^    const unsigned char order_;$/;"	m	class:lm::ngram::trie::__anon58::WriteEntries	file:
order_	HTKLVRec/kenlm/lm/trie_sort.hh	/^    unsigned char order_;$/;"	m	class:lm::ngram::trie::EntryCompare
order_	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    unsigned char order_;$/;"	m	class:lm::base::Model
ordering_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    std::deque<Request> ordering_;$/;"	m	class:lm::OutputWorker
orders_	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    std::vector<OrderStat> orders_;$/;"	m	class:lm::builder::__anon42::StatCollector	file:
original_base_	HTKLVRec/kenlm/lm/bhiksha.hh	/^    void *original_base_;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
orphanMacFile	HTKLib/HModel.c	/^static char orphanMacFile[100];         \/* last resort file for new macros *\/$/;"	v	file:
osamples	HTKLib/HAudio.c	/^   long osamples;            \/* Sample rate *\/$/;"	m	struct:_AudioIn	file:
osamples	HTKLib/HAudio.c	/^   long osamples;            \/* Sample rate *\/$/;"	m	struct:_AudioOut	file:
ospfn	HTKTools/HSLab.c	/^static char *ospfn = "noname.wav";         \/* the speech file name on the command line *\/$/;"	v	file:
ot	HTKLib/HFB.h	/^  Observation ot;      \/* Observation at time t ... *\/$/;"	m	struct:__anon96
ot2	HTKLib/HFB.h	/^  Observation ot2;     \/* Cepstral Mean Normalised obervation, used in$/;"	m	struct:__anon96
otprob	HTKLib/HArc.h	/^  float ****otprob; \/* [myArc->t_start..myArc->t_end][0..(S>1?S:0)][2..Nq-1][0..(M>1)?M:0] *\/$/;"	m	struct:_Acoustic
otprob	HTKLib/HFB.h	/^  float *****otprob;  \/* array[1..T][1..Q][2..Nq-1][0..S][0..M] of prob *\/$/;"	m	struct:__anon98
outBufPos	HTKLib/HAudio.c	/^   int outBufPos;            \/* Position to read out of buffer *\/$/;"	m	struct:_AudioIn	file:
outCMapRaw	HLMLib/LCMap.c	/^static Boolean outCMapRaw = FALSE;       \/* Output file in raw mode *\/$/;"	v	file:
outCMapRaw	HLMTools/Cluster.c	/^static Boolean     outCMapRaw = FALSE;      \/* Output classes in raw mode *\/$/;"	v	file:
outCMapRawTrap	HLMTools/Cluster.c	/^static Boolean     outCMapRawTrap = FALSE;  \/* Has this been changed by config file? *\/$/;"	v	file:
outConn	HTKLib/HAudio.c	/^   char outConn[30];   $/;"	m	struct:_AudioOut	file:
outDictFn	HLMTools/HLMCopy.c	/^static char      *outDictFn = NULL;      \/* dictionary to write *\/$/;"	v	file:
outDir	HTKTools/HCompV.c	/^static char *outDir=NULL;           \/* HMM output directory *\/$/;"	v	file:
outDir	HTKTools/HInit.c	/^static char *outDir=NULL;           \/* HMM output directory *\/$/;"	v	file:
outDir	HTKTools/HRest.c	/^static char * outDir = NULL;     \/* output macro file directory, if any *\/$/;"	v	file:
outFN	HLMTools/LAdapt.c	/^static char *outFN   = NULL;        \/* output LM filename *\/$/;"	v	file:
outLabDir	HTKTools/HCopy.c	/^static char *outLabDir = NULL;  \/* output label dir *\/$/;"	v	file:
outMLF	HTKLib/HLabel.c	/^static FILE *outMLF = NULL;                 \/* output MLF file, if any *\/ $/;"	v	file:
outMLFSet	HTKLib/HLabel.c	/^static OutMLFEntry outMLFSet[MAXMLFS];      \/* array of output MLFs *\/$/;"	v	file:
outMapped	HLMTools/LGCopy.c	/^static Boolean outMapped = FALSE;   \/* output mapped IDs only *\/$/;"	v	file:
outPCache	HTKLVRec/HLVRec.h	/^   OutPCache *outPCache;        \/* cache of outP values for block of observations *\/$/;"	m	struct:_DecoderInst
outPStats	HTKTools/HResults.c	/^static Boolean outPStats  = FALSE;    \/* enable phoneme statistics *\/$/;"	v	file:
outRow	HTKLib/HParm.c	/^   int outRow;         \/*   of next row to return (may be in any block) *\/$/;"	m	struct:_ParmBuf	file:
outSilWarn	HTKLib/HParm.c	/^   Boolean outSilWarn;        \/* Give Warning when SilMeas *\/$/;"	m	struct:__anon141	file:
outSpkrPat	HTKLib/HAdapt.h	/^  char *outSpkrPat;$/;"	m	struct:__anon89
outStream	HLMTools/LPlex.c	/^FILE *outStream;$/;"	v
outStreamFN	HLMTools/LPlex.c	/^static char *outStreamFN = NULL;$/;"	v	file:
outSym	HTKLib/HDict.h	/^   LabId outSym;   \/* Output symbol generated when pronunciation recognised *\/$/;"	m	struct:_WordPron
outTrans	HTKTools/HResults.c	/^static Boolean outTrans   = FALSE;    \/* enable transcription output *\/$/;"	v	file:
outWMapRaw	HLMLib/LWMap.c	/^static Boolean outWMapRaw = FALSE;   \/* Output file in raw mode *\/$/;"	v	file:
outXForm	HTKLib/HAdapt.c	/^static AdaptXForm* outXForm = NULL;$/;"	v	file:
outXForm	HTKLib/HAdapt.h	/^  AdaptXForm *outXForm;$/;"	m	struct:__anon89
outXFormDir	HTKLib/HAdapt.h	/^  char *outXFormDir;$/;"	m	struct:__anon89
outXFormExt	HTKLib/HAdapt.h	/^  char *outXFormExt;$/;"	m	struct:__anon89
out_	HTKLVRec/kenlm/lm/filter/vocab.hh	/^        Output &out_;$/;"	m	class:lm::vocab::Multiple::Callback
out_	HTKLVRec/kenlm/lm/left.hh	/^    ChartState *out_;$/;"	m	class:lm::ngram::RuleScore
out_	HTKLVRec/kenlm/util/ersatz_progress.hh	/^    std::ostream *out_;$/;"	m	class:util::ErsatzProgress
out_	HTKLVRec/kenlm/util/stream/chain.hh	/^    PCQueue<Block> *in_, *out_;$/;"	m	class:util::stream::ChainPosition
out_	HTKLVRec/kenlm/util/stream/chain.hh	/^    PCQueue<Block> *in_, *out_;$/;"	m	class:util::stream::Link
out_fd_	HTKLVRec/kenlm/lm/builder/print.hh	/^    util::scoped_fd out_fd_;$/;"	m	class:lm::builder::PrintARPA
out_offsets_	HTKLVRec/kenlm/util/stream/sort.hh	/^    Offsets *out_offsets_;$/;"	m	class:util::stream::MergingReader
outbuf	HTKTools/HDMan.c	/^static DBuffer outbuf;               \/* the output buffer with its global script *\/$/;"	v	file:
outfile	HTKTools/HDMan.c	/^static FILE *outfile = NULL;         \/* The output file *\/$/;"	v	file:
outfn	HTKTools/HCompV.c	/^static char *outfn=NULL;            \/* output HMM file name (name only) *\/$/;"	v	file:
outfn	HTKTools/HInit.c	/^static char *outfn=NULL;            \/* output HMM file name (name only) *\/$/;"	v	file:
outfn	HTKTools/HRest.c	/^static char *outfn=NULL;         \/* output definition file name *\/$/;"	v	file:
outlierThresh	HTKTools/HHEd.c	/^static float outlierThresh = -1.0;     \/* outlier threshold set by RO cmd *\/$/;"	v	file:
outp	HTKLib/HRec.c	/^   LogFloat outp;           \/* State\/mixture output likelihood *\/$/;"	m	struct:precomp	file:
outpBlocksize	HTKLVRec/HDecode.c	/^static int outpBlocksize = 1;   \/* number of frames for which outP is calculated in one go *\/$/;"	v	file:
outpBlocksize	HTKLVRec/HDecode.mod.c	/^static int outpBlocksize = 1;   \/* number of frames for which outP is calculated in one go *\/$/;"	v	file:
outprob	HTKTools/HRest.c	/^static Matrix outprob;     \/* array[2..nStates-1][1..maxT] of output prob *\/$/;"	v	file:
output_	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    Output output_;$/;"	m	class:lm::builder::__anon46::Callback	file:
output_	HTKLVRec/kenlm/lm/filter/format.hh	/^    Output &output_;$/;"	m	class:lm::DispatchInput
output_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    Output &output_;$/;"	m	class:lm::OutputWorker
output_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    OutputBuffer output_;$/;"	m	class:lm::ThreadBatch
output_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    util::ThreadPool<OutputWorker<Batch, RealOutput> > output_;$/;"	m	class:lm::Controller
output_q	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  bool output_q;$/;"	m	struct:lm::builder::PipelineConfig
output_q_	HTKLVRec/kenlm/lm/builder/interpolate.hh	/^    bool output_q_;$/;"	m	class:lm::builder::Interpolate
output_sum_	HTKLVRec/kenlm/util/stream/sort.hh	/^    uint64_t output_sum_;$/;"	m	class:util::stream::Offsets
outputs_	HTKLVRec/kenlm/lm/builder/output.hh	/^    boost::ptr_vector<OutputHook> outputs_[NUMBER_OF_HOOKS];$/;"	m	class:lm::builder::Output
outsym	HTKTools/HDMan.c	/^   LabId outsym;                \/* name of output symbol if any *\/$/;"	m	struct:__anon194	file:
outx	HTKLib/HAudio.c	/^   int inx,outx;         \/* in\/out indices - wrap modulo size *\/$/;"	m	struct:__anon92	file:
overwrite	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^  std::vector<Discount> overwrite;$/;"	m	struct:lm::builder::DiscountConfig
own_	HTKLVRec/kenlm/util/stream/io.hh	/^    bool own_;$/;"	m	class:util::stream::PRead
owner	HTKLib/HModel.h	/^   HLink owner;      \/* HMM owning this item *\/$/;"	m	struct:_ItemRec
owner	HTKLib/HModel.h	/^   struct _HMMSet *owner;  \/* owner of this model *\/$/;"	m	struct:__anon128	typeref:struct:__anon128::_HMMSet
pCntr	HTKTools/HLStats.c	/^   Cntr *pCntr;                  \/* Physical counter *\/$/;"	m	struct:wordinfo	file:
pCollThresh	HTKLib/HRec.h	/^   int pCollThresh;         \/* Max path records created before collection *\/$/;"	m	struct:vrecinfo
pCountLimit	HTKTools/HLStats.c	/^static int pCountLimit  = -1;       \/* max occurrences to list for pCount *\/$/;"	v	file:
pHead	HTKLib/HAudio.c	/^   mmApiBuf *pHead;         \/* Head of buffer list *\/$/;"	m	struct:_AudioOut	file:
pInfo	HTKLib/HFB.h	/^  PruneInfo *pInfo;   \/* pruning information *\/$/;"	m	struct:__anon98
pLab	HLMTools/LPlex.c	/^static LabId pLab[LBUF_SIZE];       \/* label array *\/$/;"	v	file:
pListFN	HTKTools/HDMan.c	/^static char *pListFN = NULL;         \/* name of phone list file *\/$/;"	v	file:
pNoRef	HTKLib/HRec.c	/^   Path pNoRef;             \/* Head of PathNoRef linked list *\/$/;"	m	struct:precinfo	file:
pNoTail	HTKLib/HRec.c	/^   Path pNoTail;            \/* Tail of PathNoRef linked list *\/$/;"	m	struct:precinfo	file:
pSize	HTKTools/HLStats.c	/^static int pSize;                \/* Number of physical labels *\/$/;"	v	file:
pTab	HTKTools/HLStats.c	/^static Cntr *pTab;               \/* Table of physical counts *\/$/;"	v	file:
pTail	HTKLib/HAudio.c	/^   mmApiBuf *pTail;         \/* Tail of buffer list *\/$/;"	m	struct:_AudioOut	file:
pYesRef	HTKLib/HRec.c	/^   Path pYesRef;            \/* Head of PathYesRef linked list *\/$/;"	m	struct:precinfo	file:
pYesTail	HTKLib/HRec.c	/^   Path pYesTail;           \/* Tail of PathYesRef linked list *\/$/;"	m	struct:precinfo	file:
p_	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    Proxy p_;$/;"	m	class:util::ProxyIterator
p_	HTKLVRec/kenlm/util/scoped.hh	/^    T *p_;$/;"	m	class:util::scoped_base
paInfo	HTKLib/HAdapt.c	/^   AInfo *paInfo;        \/* parent transform information *\/$/;"	m	struct:__anon88	file:
paSpkrPat	HTKLib/HAdapt.h	/^  char *paSpkrPat;$/;"	m	struct:__anon89
paXForm	HTKLib/HAdapt.h	/^  AdaptXForm *paXForm;$/;"	m	struct:__anon89
paXForm	HTKLib/HFB.h	/^  AdaptXForm *paXForm;\/* current parent transform (if any) *\/$/;"	m	struct:__anon99
paXForm	HTKLib/HFBLat.h	/^  AdaptXForm *paXForm;\/* current parent transform (if any) *\/$/;"	m	struct:__anon102
paXFormDir	HTKLib/HAdapt.h	/^  char *paXFormDir;$/;"	m	struct:__anon89
paXFormExt	HTKLib/HAdapt.h	/^  char *paXFormExt;$/;"	m	struct:__anon89
paac	HTKLib/HAdapt.c	/^   AccCache *paac;       \/* accummulator cache for parent transform *\/$/;"	m	struct:__anon88	file:
pact	HLMTools/LGPrep.c	/^   float pact;                \/* % applic factor *\/$/;"	m	struct:ruledef	file:
padding_to_8	HTKLVRec/kenlm/lm/binary_format.cc	/^  WordIndex one_word_index, max_word_index, padding_to_8;$/;"	m	struct:lm::ngram::__anon41::Sanity	file:
page_	HTKLVRec/kenlm/util/file_piece.hh	/^    const uint64_t page_;$/;"	m	class:util::FilePiece
paoc	HTKLib/HAdapt.c	/^   ObsCache *paoc;       \/* observation cache for parent transform *\/$/;"	m	struct:__anon88	file:
parMode	HTKTools/HERest.c	/^static int parMode   = -1;       \/* enable one of the \/\/ modes *\/$/;"	v	file:
parMode	HTKTools/HMMIRest.c	/^static int parMode   = -1;       \/* enable one of the parallel modes *\/$/;"	v	file:
param	HTKLib/HShell.c	/^   ConfParam param;$/;"	m	struct:_ConfigEntry	file:
params	HTKLib/HAudio.c	/^   long params[2];           \/* parameter array *\/$/;"	m	struct:_AudioIn	file:
params	HTKLib/HAudio.c	/^   long params[6];           \/* parameter array *\/$/;"	m	struct:_AudioOut	file:
parc	HTKLib/HNet.h	/^   ArcId parc;         \/* Next arc preceding end node *\/$/;"	m	struct:larc
parc	HTKLib/HNet.h	/^   ArcId parc;$/;"	m	struct:larc_s
parc	HTKLib/HNet.h	/^   EArcId parc;        \/* Next arc preceding end node *\/$/;"	m	struct:larc_e
parent	HLMLib/LModel.h	/^   struct _FLEntry *parent; \/* parent FLEntry - used when reconstructing context *\/$/;"	m	struct:_FLEntry	typeref:struct:_FLEntry::_FLEntry
parent	HTKTools/HHEd.c	/^   struct _Node *parent;        \/* parent of this node *\/$/;"	m	struct:_Node	typeref:struct:_Node::_Node	file:
parentLarc	HTKLib/HArc.h	/^  LArc *parentLarc; \/*the word arc in the Lattice from which this was derived.*\/$/;"	m	struct:_Arc
parentXForm	HTKLib/HModel.h	/^   AdaptXForm *parentXForm;$/;"	m	struct:_HMMSet
parentXForm	HTKLib/HModel.h	/^  struct _AdaptXForm *parentXForm;  \/* parent transform, NULL if no parent parenttransform *\/$/;"	m	struct:_AdaptXForm	typeref:struct:_AdaptXForm::_AdaptXForm
parent_	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    MultiProgress *parent_;$/;"	m	class:util::stream::WorkerProgress
parmHeap	HTKLib/HParm.c	/^static MemHeap parmHeap;                \/* HParm no longer uses gstack *\/$/;"	v	file:
parms	HTKLib/HAudio.c	/^   SSPlayParams parms;$/;"	m	struct:_AudioOut	file:
parms	HTKLib/HAudio.c	/^   SSRecordParams parms;$/;"	m	struct:_AudioIn	file:
parsePhysicalHMM	HTKLib/HUtil.c	/^static Boolean parsePhysicalHMM = FALSE;$/;"	v	file:
pat	HTKTools/HHEd.c	/^   char *pat;$/;"	m	struct:_IPat	file:
patHash	HTKLib/HLabel.h	/^   unsigned patHash;    \/* hash of pattern if not general *\/$/;"	m	struct:_MLFEntry
patList	HTKTools/HHEd.c	/^   IPat *patList;               $/;"	m	struct:_QEnt	file:
patType	HTKLib/HLabel.h	/^   MLFPatType patType;  \/* type of pattern *\/$/;"	m	struct:_MLFEntry
path	HTKLVRec/HLVRec.h	/^   WordendHyp *path;            \/* word level path for traceback *\/$/;"	m	struct:_RelToken
path	HTKLVRec/HLVRec.h	/^   WordendHyp *path;            \/* word level path for traceback *\/$/;"	m	struct:_Token
path	HTKLib/HRec.c	/^   Path *path;          \/* Route (word level) through network *\/$/;"	m	struct:reltoken	file:
path	HTKLib/HRec.h	/^   Path *path;		\/* Route (word level) through network *\/$/;"	m	struct:token
path	HTKLib/HRec.h	/^struct path$/;"	s
pathHeap	HTKLib/HRec.c	/^   MemHeap pathHeap;        \/* Path heap *\/$/;"	m	struct:precinfo	file:
pathPattern	HTKTools/HCompV.c	/^static char pathPattern[MAXSTRLEN];      \/* path mask *\/$/;"	v	file:
pattern	HTKLib/HLabel.h	/^   char *pattern;       \/* pattern to match for this definition *\/$/;"	m	struct:_MLFEntry
pattern	HTKLib/HUtil.c	/^static char pattern[PAT_LEN];  \/* A copy of the last pattern parsed *\/$/;"	v	file:
pattern	HTKTools/HLEd.c	/^   LabId *pattern;      \/* pattern to find *\/$/;"	m	struct:_FindAcc	file:
pb	HTKTools/HCopy.c	/^static ParmBuf pb;              \/* main parmBuf; cat input, xform wv to this *\/$/;"	v	file:
pbStatMap	HTKLib/HParm.c	/^static char * pbStatMap[] = { $/;"	v	file:
pbValid	HTKLib/HShell.h	/^   Boolean pbValid;     \/* true if putback holds char *\/$/;"	m	struct:__anon154
pblock	HTKLib/HParm.c	/^typedef struct pblock {$/;"	s	file:
pbuf	HTKLib/HFB.h	/^  ParmBuf pbuf;       \/* parameter buffer *\/$/;"	m	struct:__anon96
pbuf	HTKTools/HDMan.c	/^   Pronunciation pbuf;          \/* and its pronunciation - for lookahead *\/$/;"	m	struct:__anon195	file:
pbuf	HTKTools/HInit.c	/^static ParmBuf pbuf;             \/* Currently input parm buffer *\/$/;"	v	file:
pbuf	HTKTools/HRest.c	/^static ParmBuf pbuf;             \/* Currently input parm buffer *\/$/;"	v	file:
pbuf2	HTKLib/HFB.h	/^  ParmBuf pbuf2;      \/* a second parameter buffer (if required) *\/$/;"	m	struct:__anon96
pclose	HTKLib/HShell.c	921;"	d	file:
pcra	HTKLib/HNet.h	/^   EArcId pcra;        \/*  to easy deletetion *\/$/;"	m	struct:larc_e
pde	HTKLVRec/HLVRec.c	/^static Boolean pde = FALSE;      \/* partial distance elimination *\/$/;"	v	file:
pde	HTKLib/HFB.c	/^static Boolean pde = FALSE;  \/* partial distance elimination *\/$/;"	v	file:
pde1BlockEnd	HTKLib/HModel.c	/^static int pde1BlockEnd = 13;          \/* size of PDE blocks *\/$/;"	v	file:
pde2BlockEnd	HTKLib/HModel.c	/^static int pde2BlockEnd = 26;          \/* size of PDE blocks *\/$/;"	v	file:
pdeTh1	HTKLib/HModel.c	/^static LogFloat pdeTh1 = -5.0;         \/* threshold for 1\/3 PDE *\/$/;"	v	file:
pdeTh2	HTKLib/HModel.c	/^static LogFloat pdeTh2 = 0.0;          \/* threshold for 2\/3 PDE *\/$/;"	v	file:
pdf	HTKLib/HModel.h	/^   StreamElem *pdf;     \/* array[1..numStreams] of StreamElem *\/$/;"	m	struct:__anon126
pen	HTKLib/HLM.h	/^   LogFloat pen;                \/* Word insertion penalty *\/$/;"	m	struct:lmodel
period	HTKTools/HList.c	/^   HTime period;$/;"	m	struct:__anon202	file:
permHeap	HLMTools/LPlex.c	/^MemHeap permHeap;                   \/* Stores global stats *\/$/;"	v
permHeap	HTKTools/HLEd.c	/^static MemHeap permHeap;            \/* Permanent storage *\/$/;"	v	file:
permHeap	HTKTools/HResults.c	/^MemHeap permHeap;                     \/* Stores global stats *\/$/;"	v
phnInsPen	HTKLib/HExactMPE.c	/^static float phnInsPen = 0.0;    \/* repeat of config also used in HFBLat.c *\/$/;"	v	file:
phnInsPen	HTKLib/HFBLat.c	/^static float phnInsPen = 0.0;                 \/* Insertion penalty for each phone, not subject to lm scaling.  Normally zero, but setting it to e.g.$/;"	v	file:
phone	HTKLib/HArc.h	/^  LabId phone;         \/* phone-in-context. *\/$/;"	m	struct:_Arc
phone	HTKTools/HDMan.c	/^   LabId phone[MAXPHONES];$/;"	m	struct:__anon193	file:
phoneFreq	HTKLVRec/HLVRec.h	/^   int *phoneFreq;$/;"	m	struct:_DecoderInst
phonePost	HTKLVRec/HLVRec.h	/^   LogDouble *phonePost;$/;"	m	struct:_DecoderInst
phoneStr	HTKTools/HResults.c	/^static char * phoneStr  = "WORD";     \/* label for phone level stats *\/$/;"	v	file:
phonebuf	HTKTools/HParse.c	/^static LabId phonebuf[MAXPHONES];   \/* space to store the current pronunciation *\/$/;"	v	file:
phones	HTKLib/HDict.h	/^   LabId *phones;  \/* Array[0..nphones-1] of phones *\/$/;"	m	struct:_WordPron
phones	HTKLib/HNet.c	/^   LabId *phones;   \/* Phone sequence for the instance *\/$/;"	m	struct:pronholder	file:
phones	HTKLib/HNet.c	/^   LabId *phones;$/;"	m	struct:pinstinfo	file:
phonesHeap	HTKLib/HDict.h	/^   MemHeap phonesHeap;  \/* for arrays of phones   *\/$/;"	m	struct:__anon94
phonesOut	HTKLib/HAudio.c	/^static Boolean phonesOut = TRUE;$/;"	v	file:
phrase	HTKLVRec/kenlm/lm/filter/phrase.cc	/^namespace phrase {$/;"	n	namespace:lm	file:
phrase	HTKLVRec/kenlm/lm/filter/phrase.hh	/^      std::vector<unsigned int> substring, left, right, phrase;$/;"	m	struct:lm::phrase::Substrings::SentenceRelation
phrase	HTKLVRec/kenlm/lm/filter/phrase.hh	/^namespace phrase {$/;"	n	namespace:lm
phraseStr	HTKTools/HResults.c	/^static char * phraseStr = "SENT";     \/* label for phrase level stats *\/$/;"	v	file:
phrcor	HTKTools/HResults.c	/^   int nsyms,nphr,phrcor;$/;"	m	struct:_Spkr	file:
phrcor	HTKTools/HResults.c	/^static long phrcor= 0;     \/* Phrase correct *\/$/;"	v	file:
pinstinfo	HTKLib/HNet.c	/^typedef struct pinstinfo {$/;"	s	file:
pipe_logfile	HLMTools/Cluster.c	/^static Boolean      pipe_logfile;           \/* HShell file handling - using pipe? *\/$/;"	v	file:
pk	HTKLib/HParm.c	/^   ParmKind pk;       \/* Type of source - split into parmKind and *\/$/;"	m	struct:hparmsrcdef	file:
pk	HTKLib/HParm.h	/^   ParmKind pk;          \/* parm kind of this obs (bk or DISCRETE) *\/$/;"	m	struct:__anon147
pkgdatadir	Makefile	/^pkgdatadir = $(datadir)\/@PACKAGE@$/;"	m
pkgincludedir	Makefile	/^pkgincludedir = $(includedir)\/@PACKAGE@$/;"	m
pkglibdir	Makefile	/^pkglibdir = $(libdir)\/@PACKAGE@$/;"	m
pkind	HTKLib/HModel.c	/^   ParmKind pkind;      \/* samp kind when sym==PARMKIND *\/$/;"	m	struct:__anon119	file:
pkind	HTKLib/HModel.h	/^   ParmKind pkind;         \/* kind of obs vector components *\/$/;"	m	struct:_HMMSet
pkind	HTKLib/HModel.h	/^  ParmKind pkind;      \/* parameter kind for xform to be applied to *\/$/;"	m	struct:__anon134
playPort	HTKLib/HAudio.c	/^   ALport playPort;          \/* SGI audio port *\/$/;"	m	struct:_AudioOut	file:
playVol	HTKTools/HSLab.c	/^static short playVol = 0;    \/* the volume for playing samples *\/$/;"	v	file:
plotBuf	HTKTools/HSLab.c	/^static int *plotBuf;         \/* buffer to store waveform samples to plot *\/$/;"	v	file:
pmap	HTKLib/HModel.h	/^   PtrMap ** pmap;         \/* Array[0..PTRHASHSIZE-1]OF PtrMap* *\/$/;"	m	struct:_HMMSet
pmkmap	HTKLib/HParm.c	/^static char *pmkmap[] = {"WAVEFORM", "LPC", "LPREFC", "LPCEPSTRA", $/;"	v	file:
pnlen	HTKLib/HRec.c	/^   int pnlen;               \/* Number of PathNoRef list *\/$/;"	m	struct:precinfo	file:
pnum	HTKLib/HDict.h	/^   short pnum;     \/* Pronunciation number 1..nprons *\/$/;"	m	struct:_WordPron
pobcaStack	HTKLib/HAdapt.c	/^static MemHeap pobcaStack; \/* parent obscache *\/$/;"	v	file:
pointer	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    typedef ProxyIterator<Proxy> * pointer;$/;"	t	class:util::ProxyIterator
pointer	HTKLVRec/kenlm/util/string_piece.hh	/^  typedef const char* pointer;$/;"	t	class:StringPiece
pointer_bhiksha_bits	HTKLVRec/kenlm/lm/config.hh	/^  uint8_t pointer_bhiksha_bits;$/;"	m	struct:lm::ngram::Config
pointers	HTKLVRec/kenlm/lm/state.hh	/^  uint64_t pointers[KENLM_MAX_ORDER - 1];$/;"	m	struct:lm::ngram::Left
poison_	HTKLVRec/kenlm/util/thread_pool.hh	/^    Request poison_;$/;"	m	class:util::ThreadPool
poison_	HTKLVRec/kenlm/util/thread_pool.hh	/^    const Request poison_;$/;"	m	class:util::Worker
poisoned_	HTKLVRec/kenlm/util/stream/chain.hh	/^    bool poisoned_;$/;"	m	class:util::stream::Link
pool	HLMLib/LGBase.h	/^   UInt *pool;             \/* array[0..used-1] of ngrams *\/$/;"	m	struct:__anon5
poolsize	HLMLib/LGBase.h	/^   int poolsize;           \/* number of N-gram slots in pool *\/$/;"	m	struct:__anon5
popen	HTKLib/HShell.c	920;"	d	file:
pos	HTKLib/HArc.h	/^  int pos;       \/*the position of this phone in the word arc.*\/$/;"	m	struct:_Arc
posBuf	HLMTools/LGPrep.c	/^static ShiftReg posBuf;             \/* N-grams from edited text *\/$/;"	v	file:
position	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  int position() const {$/;"	f	class:double_conversion::StringBuilder
position	HTKLib/HUtil.c	/^static char *position;         \/*  and the current position in copy *\/$/;"	v	file:
position	HTKLib/esignal.h	/^    int     position;$/;"	m	struct:Annot
position_	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  int position_;$/;"	m	class:double_conversion::StringBuilder
position_	HTKLVRec/kenlm/util/file_piece.hh	/^    const char *position_, *last_space_, *position_end_;$/;"	m	class:util::FilePiece
position_end_	HTKLVRec/kenlm/util/file_piece.hh	/^    const char *position_, *last_space_, *position_end_;$/;"	m	class:util::FilePiece
positive_log_probability	HTKLVRec/kenlm/lm/config.hh	/^  WarningAction positive_log_probability;$/;"	m	struct:lm::ngram::Config
post	HTKLVRec/kenlm/util/pcqueue.hh	/^    void post() {$/;"	f	class:util::Semaphore
postFrames	HTKLib/HParm.c	/^   int postFrames;$/;"	m	struct:__anon141	file:
pr	HTKLib/HFB.h	/^  LogDouble pr;        \/* log prob of current utterance *\/$/;"	m	struct:__anon96
pr	HTKLib/HFB.h	/^  LogDouble pr;       \/* log prob of current utterance *\/$/;"	m	struct:__anon98
pr	HTKLib/HFBLat.h	/^  LogDouble pr;$/;"	m	struct:__anon102
prC	HTKLib/HTrain.c	/^static int muC,vaC,trC,wtC,prC;$/;"	v	file:
prData	HTKTools/HList.c	/^static Boolean prData  = TRUE;   \/* print data *\/$/;"	v	file:
prScale	HTKTools/HLRescore.c	/^static double prScale = 1.0;    \/* pronunciation scale factor *\/$/;"	v	file:
prScale	HTKTools/HVite.c	/^static double prScale = 1.0;      \/* pronunciation scale factor *\/$/;"	v	file:
preEmph	HTKLib/HParm.c	/^   float preEmph;             \/* PreEmphasis Coef *\/$/;"	m	struct:__anon141	file:
preFrames	HTKLib/HParm.c	/^   int preFrames;$/;"	m	struct:__anon141	file:
preQual	HTKLib/HModel.h	/^  Boolean preQual;     \/* is this applied prior to qualifiers? *\/$/;"	m	struct:__anon134
preQual	HTKLib/HParm.c	/^   Boolean preQual;$/;"	m	struct:__anon141	file:
prec	HTKLib/HArc.h	/^  HArc *prec;$/;"	m	struct:_Arc
precTrans	HTKLib/HArc.h	/^  ArcTrans *precTrans;$/;"	m	struct:_Arc
precTrans	HTKLib/HArc.h	/^  CorrA *precTrans;$/;"	m	struct:_CorrN
precinfo	HTKLib/HRec.c	/^struct precinfo {$/;"	s	file:
precomp	HTKLib/HRec.c	/^typedef struct precomp$/;"	s	file:
pred	HTKLib/HLabel.h	/^   LLink pred;              \/* Preceding label *\/$/;"	m	struct:_Label
pred	HTKLib/HNet.h	/^   ArcId pred;         \/* Linked list of arcs preceding node *\/$/;"	m	struct:lnode
pred	HTKTools/HParse.c	/^   LinkSet *pred;    \/* predecessors to this node *\/$/;"	m	struct:_Node	file:
prefix	HLMLib/Makefile	/^prefix = \/home\/siyujing\/openSource\/htk_linux\/htk\/$/;"	m
prefix	HLMTools/Makefile	/^prefix = \/home\/siyujing\/openSource\/htk_linux\/htk\/$/;"	m
prefix	HTKLVRec/Makefile	/^prefix = \/home\/siyujing\/openSource\/htk_linux\/htk\/$/;"	m
prefix	HTKLib/Makefile	/^prefix = \/home\/siyujing\/openSource\/htk_linux\/htk\/$/;"	m
prefix	HTKTools/Makefile	/^prefix = \/home\/siyujing\/openSource\/htk_linux\/htk\/$/;"	m
prefix	Makefile	/^prefix = \/home\/siyujing\/openSource\/htk_linux\/htk\/$/;"	m
present	HTKLib/esignal.h	/^    Bool	present;	\/* is OPTIONAL field present in record? *\/$/;"	m	struct:FieldSpec
prev	HTKLVRec/HLVRec.h	/^   ModendHyp *prev;             \/* previous model info *\/$/;"	m	struct:_ModendHyp
prev	HTKLVRec/HLVRec.h	/^   WordendHyp *prev;            \/* previous word info *\/$/;"	m	struct:_AltWordendHyp
prev	HTKLVRec/HLVRec.h	/^   WordendHyp *prev;            \/* previous word info *\/$/;"	m	struct:_WordendHyp
prev	HTKLib/HArc.h	/^  CorrN *prev;$/;"	m	struct:_CorrN
prev	HTKLib/HAudio.c	/^   struct mmapibuf *prev;$/;"	m	struct:mmapibuf	typeref:struct:mmapibuf::mmapibuf	file:
prev	HTKLib/HRec.c	/^   Align *prev;         \/* Previous align record *\/$/;"	m	struct:align	file:
prev	HTKLib/HRec.c	/^   NBestEntry *prev;$/;"	m	struct:nbestentry	file:
prev	HTKLib/HRec.c	/^   Path *prev;          \/* Previous word record *\/$/;"	m	struct:nxtpath	file:
prev	HTKLib/HRec.h	/^   Path *prev;		\/* Previous word record *\/$/;"	m	struct:path
prev	HTKTools/HHEd.c	/^   struct _Node *prev;          \/* leaf nodes *\/$/;"	m	struct:_Node	typeref:struct:_Node::_Node	file:
pri	HTKLib/HRec.c	/^static PRecInfo *pri;$/;"	v	file:
pri	HTKLib/HRec.h	/^   PRecInfo *pri;           \/* Private recognition information *\/$/;"	m	struct:vrecinfo
prid	HTKLib/HRec.c	/^   int prid;                \/* Unique pri identifier *\/$/;"	m	struct:precinfo	file:
printOOV	HLMTools/LPlex.c	/^static Boolean printOOV = FALSE;    \/* print uniqe OOV's and their frequencies *\/$/;"	v	file:
printVersionInfo	HTKLib/HShell.c	/^static Boolean printVersionInfo = FALSE; \/* request version info *\/$/;"	v	file:
prlike	HTKLib/HNet.h	/^   LogFloat prlike;    \/* Pronunciation likelihood of arc *\/$/;"	m	struct:larc
prob	HLMLib/LModel.c	/^   double prob;         \/* sum of prob   returned *\/$/;"	m	struct:_AccessInfo	file:
prob	HLMLib/LModel.h	/^   LM_Prob prob;            \/* probability *\/$/;"	m	struct:_SMEntry
prob	HLMLib/LModel.h	/^  float  prob;               \/* log probability of word: word|class *\/$/;"	m	struct:__anon14
prob	HTKLVRec/HLVLM.h	/^   NGLM_Prob prob;              \/* probability *\/$/;"	m	struct:sentry
prob	HTKLVRec/HLVLM.h	/^   float prob;                  \/* probability *\/$/;"	m	struct:_FSLM_LatArc
prob	HTKLVRec/HLVRec.h	/^   LMTokScore prob;$/;"	m	struct:_LMCacheLA
prob	HTKLVRec/HLVRec.h	/^   LMTokScore prob;$/;"	m	struct:_LMLACacheEntry
prob	HTKLVRec/kenlm/lm/builder/ngram.hh	/^  float prob;  \/\/ Uninterpolated probability.$/;"	m	struct:lm::builder::Uninterpolated
prob	HTKLVRec/kenlm/lm/return.hh	/^  float prob;$/;"	m	struct:lm::FullScoreReturn
prob	HTKLVRec/kenlm/lm/weights.hh	/^  float prob;$/;"	m	struct:lm::Prob
prob	HTKLVRec/kenlm/lm/weights.hh	/^  float prob;$/;"	m	struct:lm::ProbBackoff
prob	HTKLVRec/kenlm/lm/weights.hh	/^  float prob;$/;"	m	struct:lm::RestWeights
prob	HTKLib/HDict.h	/^   LogFloat prob;  \/* Log probability of pronunciation *\/$/;"	m	struct:_WordPron
prob	HTKLib/HLM.h	/^   float prob;                  \/* probability *\/$/;"	m	struct:sentry
prob	HTKLib/HModel.h	/^   float prob;           \/* mixture prob scaled by maxP *\/$/;"	m	struct:__anon123
prob	HTKLib/HTrain.h	/^   LogFloat prob;    \/* PreComputed Mixture Log Prob *\/$/;"	m	struct:__anon167
prob	HTKLib/HTrain.h	/^   float *prob;      \/* PreComputed mixture Log Probs *\/$/;"	m	struct:__anon164
prob	HTKTools/HDMan.c	/^   float prob;$/;"	m	struct:__anon193	file:
prob2	HLMLib/LModel.c	/^   double prob2;        \/* sum of prob^2 returned *\/$/;"	m	struct:_AccessInfo	file:
probScale	HTKLib/HFBLat.c	/^static float probScale = 1.0;                 \/* Scales the state-output and lm probabilities.  Leave this alone for normal usage. *\/$/;"	v	file:
probType	HLMLib/LModel.h	/^   LMProbType probType;      \/* probability type *\/$/;"	m	struct:__anon15
prob_	HTKLVRec/kenlm/lm/left.hh	/^    float prob_;$/;"	m	class:lm::ngram::RuleScore
prob_bits	HTKLVRec/kenlm/lm/config.hh	/^  uint8_t prob_bits, backoff_bits;$/;"	m	struct:lm::ngram::Config
prob_bits_	HTKLVRec/kenlm/lm/quantize.hh	/^    uint8_t prob_bits_, backoff_bits_;$/;"	m	class:lm::ngram::SeparatelyQuantize
probing_multiplier	HTKLVRec/kenlm/lm/binary_format.hh	/^  float probing_multiplier;$/;"	m	struct:lm::ngram::FixedWidthParameters
probing_multiplier	HTKLVRec/kenlm/lm/config.hh	/^  float probing_multiplier;$/;"	m	struct:lm::ngram::Config
probs	HTKLib/HModel.h	/^   TMProb *probs;        \/* array[1..M] of TMProb *\/$/;"	m	struct:__anon124
probs_	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    std::vector<float> probs_;$/;"	m	class:lm::builder::__anon46::Callback	file:
processText	HLMTools/LAdapt.c	/^static Boolean processText = TRUE;    \/* generate model from raw text data *\/$/;"	v	file:
produce_at_	HTKLVRec/kenlm/util/pcqueue.hh	/^  T *produce_at_;$/;"	m	class:util::PCQueue
produce_at_mutex_	HTKLVRec/kenlm/util/pcqueue.hh	/^  boost::mutex produce_at_mutex_;$/;"	m	class:util::PCQueue
prog_vc_id	HLMTools/HLMCopy.c	/^char *prog_vc_id = "$Id: HLMCopy.c,v 1.1.1.1 2006\/10\/11 09:54:44 jal58 Exp $";$/;"	v
prog_version	HLMTools/HLMCopy.c	/^char *prog_version = "!HVER!HLMCopy:   3.4.1 [CUED 12\/03\/09]";$/;"	v
progress	HLMLib/LPMerge.c	/^   int     progress;         \/* progress tracking *\/$/;"	m	struct:__anon17	file:
progress_	HTKLVRec/kenlm/util/file_piece.hh	/^    ErsatzProgress progress_;$/;"	m	class:util::FilePiece
progress_	HTKLVRec/kenlm/util/stream/chain.hh	/^    MultiProgress progress_;$/;"	m	class:util::stream::Chain
progress_	HTKLVRec/kenlm/util/stream/chain.hh	/^    WorkerProgress progress_;$/;"	m	class:util::stream::ChainPosition
progress_	HTKLVRec/kenlm/util/stream/chain.hh	/^    WorkerProgress progress_;$/;"	m	class:util::stream::Link
projSize	HTKLib/HModel.h	/^   short projSize;         \/* dimension of vector to update *\/$/;"	m	struct:_HMMSet
pron	HTKLVRec/HLVNet.c	/^      Pron pron;$/;"	m	union:_STLexNode::__anon37	file:
pron	HTKLVRec/HLVNet.h	/^      PronId pron;$/;"	m	union:_LexNode::__anon38
pron	HTKLVRec/HLVNet.h	/^   Pron pron;$/;"	m	struct:_TLexNode
pron	HTKLVRec/HLVRec.h	/^   PronId pron;                 \/* pronunciation chosen *\/$/;"	m	struct:_WordendHyp
pron	HTKLib/HDict.h	/^   Pron pron;       \/* first pronunciation *\/$/;"	m	struct:_DictEntry
pron	HTKLib/HNet.c	/^   Pron pron;       \/* Actual pronunciation *\/$/;"	m	struct:pronholder	file:
pron	HTKLib/HNet.c	/^   Pron pron;$/;"	m	struct:pinstinfo	file:
pron	HTKLib/HNet.h	/^      Pron   pron;      \/* Word represented (may == null) *\/$/;"	m	union:_NetNode::__anon138
pron	HTKTools/HDMan.c	/^   Pronunciation pron[MAXPRONS];$/;"	m	struct:__anon194	file:
pronHeap	HTKLib/HDict.h	/^   MemHeap pronHeap;    \/* for WordPron structs   *\/$/;"	m	struct:__anon94
pronId2LMId	HTKLVRec/HLVLM.h	/^   LMId *pronId2LMId;           \/* PronId -> LMId mapping array [1..voc->nprons] $/;"	m	struct:_FSLM_ngram
pronScale	HTKLVRec/HDecode.c	/^static float pronScale = 1.0;   \/* pronunciation scaling factor *\/$/;"	v	file:
pronScale	HTKLVRec/HDecode.mod.c	/^static float pronScale = 1.0;   \/* pronunciation scaling factor *\/$/;"	v	file:
pronScale	HTKLVRec/HLVRec.h	/^   float pronScale;             \/* pronunciation scaling factor *\/$/;"	m	struct:_DecoderInst
pronholder	HTKLib/HNet.c	/^typedef struct pronholder$/;"	s	file:
pronlist	HTKLVRec/HLVNet.h	/^   Pron *pronlist;              \/* array [1..voc->nprons]  of Prons for given PronId *\/$/;"	m	struct:_LexNet
pronsUsed	HTKTools/HDMan.c	/^   int pronsUsed;               \/* num prons actually used *\/$/;"	m	struct:__anon195	file:
protectStaks	HTKLib/HMem.c	/^static Boolean protectStaks = FALSE;    \/* enable stack protection *\/$/;"	v	file:
protectStk	HTKLib/HMem.h	/^   Boolean protectStk;  \/*  MSTAK only, prevents disposal below Stack Top *\/$/;"	m	struct:__anon116
prscale	HTKLib/HNet.h	/^   float prscale;		\/* Pronunciation scale factor *\/$/;"	m	struct:lattice
pruneInArcsPerSec	HTKTools/HLRescore.c	/^static LogDouble pruneInArcsPerSec = 0.0;  \/* arcs per second threshold (-t) *\/$/;"	v	file:
pruneInLat	HTKTools/HLRescore.c	/^static Boolean pruneInLat = FALSE;  \/* -t *\/$/;"	v	file:
pruneInThresh	HTKTools/HLRescore.c	/^static LogDouble pruneInThresh = - LZERO;  \/* beam for pruning (-t) *\/$/;"	v	file:
pruneInc	HTKLib/HFB.c	/^   LogDouble pruneInc;       \/* pruning threshold increment *\/$/;"	m	struct:__anon95	file:
pruneInc	HTKTools/HERest.c	/^static LogDouble pruneInc = 0.0;         \/* pruning threshold increment *\/$/;"	v	file:
pruneInit	HTKLib/HFB.c	/^   LogDouble pruneInit;      \/* pruning threshold initially *\/$/;"	m	struct:__anon95	file:
pruneInit	HTKTools/HERest.c	/^static LogDouble pruneInit = NOPRUNE;    \/* pruning threshold initially *\/$/;"	v	file:
pruneLim	HTKLib/HFB.c	/^   LogDouble pruneLim;       \/* pruning threshold limit *\/$/;"	m	struct:__anon95	file:
pruneLim	HTKTools/HERest.c	/^static LogDouble pruneLim = NOPRUNE;     \/* pruning threshold limit *\/$/;"	v	file:
pruneOutArcsPerSec	HTKTools/HLRescore.c	/^static LogDouble pruneOutArcsPerSec = 0.0; \/* arcs per second threshold (-u) *\/$/;"	v	file:
pruneOutLat	HTKTools/HLRescore.c	/^static Boolean pruneOutLat = FALSE; \/* -u *\/$/;"	v	file:
pruneOutThresh	HTKTools/HLRescore.c	/^static LogDouble pruneOutThresh = - LZERO; \/* beam for pruning (-u) *\/$/;"	v	file:
pruneSetting	HTKLib/HFB.c	/^} pruneSetting = { NOPRUNE, 0.0, NOPRUNE, 10.0 };$/;"	v	typeref:struct:__anon95	file:
pruneThresh	HTKLib/HFB.h	/^  LogDouble pruneThresh;    \/* pruning threshold currently *\/$/;"	m	struct:__anon97
pruneWords	HLMTools/LAdapt.c	/^static Boolean pruneWords = FALSE;    \/* prune input text according to word list *\/$/;"	v	file:
prune_threshold_	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    uint64_t prune_threshold_;$/;"	m	class:lm::builder::__anon42::CollapseStream	file:
prune_thresholds	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  std::vector<uint64_t> prune_thresholds; \/\/mjd$/;"	m	struct:lm::builder::PipelineConfig
prune_thresholds_	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^    const std::vector<uint64_t> &prune_thresholds_; $/;"	m	class:lm::builder::AdjustCounts
prune_thresholds_	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    const std::vector<uint64_t>& prune_thresholds_;$/;"	m	class:lm::builder::__anon46::Callback	file:
prune_thresholds_	HTKLVRec/kenlm/lm/builder/interpolate.hh	/^    const std::vector<uint64_t> prune_thresholds_;$/;"	m	class:lm::builder::Interpolate
prune_vocab	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  bool prune_vocab;$/;"	m	struct:lm::builder::PipelineConfig
prune_vocab_	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    bool prune_vocab_;$/;"	m	class:lm::builder::__anon46::Callback	file:
prune_vocab_	HTKLVRec/kenlm/lm/builder/interpolate.hh	/^    bool prune_vocab_;$/;"	m	class:lm::builder::Interpolate
prune_vocab_file	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  std::string prune_vocab_file;$/;"	m	struct:lm::builder::PipelineConfig
prune_vocab_filename_	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^    const std::string& prune_vocab_filename_; $/;"	m	class:lm::builder::CorpusCount
prune_words_	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    const std::vector<bool>& prune_words_;$/;"	m	class:lm::builder::__anon42::CollapseStream	file:
prune_words_	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^    const std::vector<bool> &prune_words_;$/;"	m	class:lm::builder::AdjustCounts
prune_words_	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^    std::vector<bool>& prune_words_;$/;"	m	class:lm::builder::CorpusCount
pruning_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^      bool pruning_;$/;"	m	class:lm::builder::__anon45::OnlyGamma	file:
pruning_	HTKLVRec/kenlm/lm/builder/initial_probabilities.cc	/^    bool pruning_;$/;"	m	class:lm::builder::__anon45::AddRight	file:
psSum	HTKTools/HSGen.c	/^static double psSum;    \/* total log prob of all sentences *\/$/;"	v	file:
pscale	HTKLib/HRec.c	/^   float pscale;            \/* Pronunciation probs scale factor *\/$/;"	m	struct:precinfo	file:
psetinfo	HTKLib/HRec.c	/^struct psetinfo$/;"	s	file:
psi	HTKLib/HRec.c	/^   PSetInfo *psi;           \/* HMMSet information *\/$/;"	m	struct:precinfo	file:
psi	HTKTools/HVite.c	/^static PSetInfo *psi;             \/* Private data used by HRec *\/$/;"	v	file:
psum	HLMTools/LGPrep.c	/^   float psum;                \/* accumulator *\/$/;"	m	struct:ruledef	file:
ptr	HLMLib/LUtil.h	/^   void *ptr;                  \/* General-purpose ptr *\/$/;"	m	struct:_NameHolder
ptr	HTKLib/HModel.h	/^   Ptr ptr;                \/* the structure *\/$/;"	m	struct:_PtrMap
ptr	HTKTools/HSLab.c	/^   LLink ptr;           \/* pointer to the label last modified (if any) *\/$/;"	m	struct:__anon211	file:
ptr_	HTKLVRec/kenlm/util/mmap.hh	/^    void *ptr_;$/;"	m	class:util::Rolling
ptr_	HTKLVRec/kenlm/util/sized_iterator.hh	/^    uint8_t *ptr_;$/;"	m	class:util::SizedInnerIterator
ptr_	HTKLVRec/kenlm/util/string_piece.hh	/^  const char*   ptr_;$/;"	m	class:StringPiece
ptype	HLMLib/LPCalc.h	/^   LMProbType   ptype;                \/* probability type *\/$/;"	m	struct:__anon16
push_back	HTKLVRec/kenlm/lm/builder/sort.hh	/^    void push_back(util::stream::Chain &chain, const util::stream::SortConfig &config, const Compare &compare) {$/;"	f	class:lm::builder::Sorts
push_back	HTKLVRec/kenlm/util/fixed_array.hh	/^    template <class C> void push_back(const C &c) {$/;"	f	class:util::FixedArray
putWtActive	HTKLib/HModel.c	/^static Boolean putWtActive;   \/* false until a weight is output *\/$/;"	v	file:
putback	HTKLib/HShell.h	/^   int putback;         \/* put back character *\/$/;"	m	struct:__anon154
pxd	HTKLib/HRec.c	/^   Boolean pxd;         \/* External propagation done this frame *\/$/;"	m	struct:_NetInst	file:
pylen	HTKLib/HRec.c	/^   int pylen;               \/* Number of PathYesRef list *\/$/;"	m	struct:precinfo	file:
qDms	HTKLib/HFB.h	/^  short *qDms;        \/* array[1..Q] of minimum model duration *\/$/;"	m	struct:__anon98
qHead	HTKLib/HAudio.c	/^   mmApiBuf *qHead;         \/* Head of buffer waiting to be filled list *\/$/;"	m	struct:_AudioIn	file:
qHead	HTKTools/HHEd.c	/^static QLink qHead = NULL;      \/* Head of question list *\/$/;"	v	file:
qHi	HTKLib/HArc.h	/^  int *qHi;     \/* [t], highest q active at time t *\/$/;"	m	struct:ArcInfoStruct
qHi	HTKLib/HFB.h	/^  short *qHi;               \/* array[1..T] of top of pruning beam *\/$/;"	m	struct:__anon97
qIds	HTKLib/HFB.h	/^  LabId  *qIds;       \/* array[1..Q] of logical HMM names (in qList) *\/$/;"	m	struct:__anon98
qLo	HTKLib/HArc.h	/^  int *qLo;     \/* [t], lowest q active at time t *\/$/;"	m	struct:ArcInfoStruct
qLo	HTKLib/HFB.h	/^  short *qLo;               \/* array[1..T] of bottom of pruning beam *\/$/;"	m	struct:__anon97
qName	HTKTools/HHEd.c	/^   LabId qName;                 \/* an expanded list of model names *\/$/;"	m	struct:_QEnt	file:
qTail	HTKLib/HAudio.c	/^   mmApiBuf *qTail;         \/* Tail of buffer waiting to be filled list *\/$/;"	m	struct:_AudioIn	file:
qTail	HTKTools/HHEd.c	/^static QLink qTail = NULL;      \/* Tail of question list *\/$/;"	v	file:
q_delta_	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    std::vector<float> q_delta_;$/;"	m	class:lm::builder::__anon46::OutputQ	file:
qcksrtM	HTKLib/HRec.c	/^static void qcksrtM(float *array,int l,int r,int M)$/;"	f	file:
qen	HTKLib/HParm.c	/^   int qen;            \/* final row in main block qualified (last valid row) *\/$/;"	m	struct:_ParmBuf	file:
qs_CmpGFile	HLMLib/LGBase.c	/^static int qs_CmpGFile(const void *p1, const void *p2)$/;"	f	file:
qs_CmpNGram	HLMLib/LGBase.c	/^static int qs_CmpNGram(const void *p1, const void *p2)$/;"	f	file:
qs_cmpSize	HLMLib/LGBase.c	/^static int        qs_cmpSize;   \/* must set before using this routine *\/$/;"	v	file:
qs_cneBuf	HLMLib/LModel.c	/^static CNEntry *qs_cneBuf;      \/* global table of read CNEntry *\/$/;"	v	file:
qs_inset	HLMLib/LGBase.c	/^static NGInputSet *qs_inset;    \/* input set *\/$/;"	v	file:
qs_wmap	HLMLib/LGBase.c	/^static WordMap    *qs_wmap;     \/* word list to access mapentries *\/$/;"	v	file:
qsa	HTKLib/HRec.c	/^   LogFloat *qsa;           \/* Array form performing qsort *\/$/;"	m	struct:precinfo	file:
qsn	HTKLib/HRec.c	/^   int qsn;                 \/* Sizeof qsa *\/$/;"	m	struct:precinfo	file:
qst	HTKLib/HParm.c	/^   int qst;            \/* next row in main block to qualify (qst>qwin) *\/$/;"	m	struct:_ParmBuf	file:
quant_	HTKLVRec/kenlm/lm/search_trie.cc	/^    const Quant &quant_;$/;"	m	class:lm::ngram::trie::__anon58::WriteEntries	file:
quant_	HTKLVRec/kenlm/lm/search_trie.hh	/^    Quant quant_;$/;"	m	class:lm::ngram::trie::TrieSearch
quant_bits_	HTKLVRec/kenlm/lm/trie.hh	/^    uint8_t quant_bits_;$/;"	m	class:lm::ngram::trie::BitPackedMiddle
quest	HTKTools/HHEd.c	/^   QLink quest;                 \/* question used to do split *\/$/;"	m	struct:_Node	file:
questHeap	HTKTools/HHEd.c	/^static MemHeap questHeap;   \/* Heap holds all questions *\/$/;"	v	file:
queue_	HTKLVRec/kenlm/util/stream/sort.hh	/^    Queue queue_;$/;"	m	class:util::stream::MergeQueue
queue_size_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    const size_t queue_size_;$/;"	m	class:lm::Controller
queues_	HTKLVRec/kenlm/util/stream/chain.hh	/^    boost::ptr_vector<PCQueue<Block> > queues_;$/;"	m	class:util::stream::Chain
quiet	HTKTools/HSGen.c	/^static Boolean quiet = FALSE;       \/* suppress sentence output *\/$/;"	v	file:
qwin	HTKLib/HParm.c	/^   int qwin;           \/* Width of qualify window (needed on each side) *\/$/;"	m	struct:_ParmBuf	file:
r	HTKLib/HParm.c	/^   ShortVec r;        \/* raw speech vector *\/$/;"	m	struct:__anon141	file:
r	HTKTools/HParse.c	/^   LabId r;$/;"	m	struct:__anon206	file:
rOK	HTKLib/HAudio.c	77;"	d	file:
rOR	HTKLib/HAudio.c	79;"	d	file:
rPthHeap	HTKLib/HRec.c	/^   MemHeap rPthHeap;        \/* NxtPath heap *\/$/;"	m	struct:precinfo	file:
rTokHeap	HTKLib/HRec.c	/^   MemHeap rTokHeap;        \/* RelToken heap *\/$/;"	m	struct:precinfo	file:
rUR	HTKLib/HAudio.c	78;"	d	file:
rank	HTKLib/esignal.h	/^    short       rank;           \/* number of dimensions *\/$/;"	m	struct:Array
rank	HTKLib/esignal.h	/^    short       rank;           \/* number of dimensions *\/$/;"	m	struct:FieldSpec
rawBuffer	HTKLib/HParm.c	/^   char *rawBuffer;   \/* buffer for external data *\/$/;"	m	struct:__anon141	file:
rawEnergy	HTKLib/HParm.c	/^   Boolean rawEnergy;         \/* Use raw energy before preEmp and ham *\/$/;"	m	struct:__anon141	file:
rawMITFormat	HTKLVRec/HLVLM.c	/^static Boolean rawMITFormat = FALSE;    \/* by default do not use HTK quoting *\/$/;"	v	file:
rawMITFormat	HTKLib/HLM.c	/^static Boolean rawMITFormat = FALSE;    \/* Don't use HTK quoting and escapes *\/$/;"	v	file:
rawMode	HTKTools/HDMan.c	/^   Boolean rawMode;             \/* Raw input mode *\/$/;"	m	struct:__anon195	file:
rawOut	HTKTools/HList.c	/^static Boolean rawOut = FALSE;   \/* raw output i.e no numbering *\/$/;"	v	file:
raw_amount_	HTKLVRec/kenlm/util/read_compressed.hh	/^    uint64_t raw_amount_;$/;"	m	class:util::ReadCompressed
rbegin	HTKLVRec/kenlm/util/string_piece.hh	/^  const_reverse_iterator rbegin() const {$/;"	f	class:StringPiece
rbuf	HTKLib/HAudio.c	/^   ReplayBuf rbuf;           \/* replay buffer (if needed) *\/$/;"	m	struct:_AudioIn	file:
rc	HTKLVRec/HLVNet.h	/^   LabId rc;            \/* right context phone *\/$/;"	m	struct:_TLexNode
rc	HTKLib/HAudio.c	/^   UMSAudioDevice_ReturnCode rc;$/;"	m	struct:_AudioIn	file:
rc	HTKLib/HAudio.c	/^   UMSAudioDevice_ReturnCode rc;$/;"	m	struct:_AudioOut	file:
rc	HTKLib/HNet.c	/^   NetNode **rc;    \/* Right contexts - linked to word end nodes *\/$/;"	m	struct:pronholder	file:
read_backoffs	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  util::stream::ChainConfig read_backoffs;$/;"	m	struct:lm::builder::PipelineConfig
read_bound_	HTKLVRec/kenlm/util/mmap.hh	/^    std::size_t read_bound_;$/;"	m	class:util::Rolling
real	HTKLib/esignal.h	/^typedef struct {Schar	real, imag;}	ScharComplex;$/;"	m	struct:__anon186
real	HTKLib/esignal.h	/^typedef struct {double	real, imag;}	DoubleComplex;$/;"	m	struct:__anon182
real	HTKLib/esignal.h	/^typedef struct {float	real, imag;}	FloatComplex;$/;"	m	struct:__anon183
real	HTKLib/esignal.h	/^typedef struct {long	real, imag;}	LongComplex;$/;"	m	struct:__anon184
real	HTKLib/esignal.h	/^typedef struct {short	real, imag;}	ShortComplex;$/;"	m	struct:__anon185
recCHeap	HTKLVRec/HLVRec.c	/^MemHeap recCHeap;                       \/* CHEAP for small general allocation *\/$/;"	v
recPort	HTKLib/HAudio.c	/^   ALport recPort;           \/* SGI audio port *\/$/;"	m	struct:_AudioIn	file:
rec_freq	HLMTools/Cluster.c	/^static int          rec_freq = 1000;        \/* Frequency we write recovery files (0 = off) *\/$/;"	v	file:
recfn	HTKTools/HResults.c	/^static char *recfn;                   \/* rec file name (test) *\/$/;"	v	file:
recid	HTKTools/HResults.c	/^static char recid[5][255];            \/* upto 5 identifiers for *\/$/;"	v	file:
recidUsed	HTKTools/HResults.c	/^static int recidUsed = 0;             \/* number of test identifiers set *\/$/;"	v	file:
recnum	HTKLib/esignal.h	/^    long    recnum;$/;"	m	struct:Annot
ref	HTKTools/HResults.c	/^static LabList *ref,*test;            \/* the labels being compared *\/$/;"	v	file:
refList	HTKLib/HNet.h	/^   SubLatDef *refList;          \/* List of all SubLats referring to this lat *\/$/;"	m	struct:lattice
reference	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    typedef Proxy reference;$/;"	t	class:util::ProxyIterator
reference	HTKLVRec/kenlm/util/string_piece.hh	/^  typedef const char& reference;$/;"	t	class:StringPiece
refid	HTKTools/HResults.c	/^static char * refid=NULL;             \/* identifiers for reference material *\/$/;"	v	file:
reftex	HTKBook/Makefile	/^reftex =     HTKRef\/Cluster.tex  HTKRef\/HInit.tex    HTKRef\/HResults.tex    \\$/;"	m
regA	HTKTools/HSLab.c	/^   int   regA, regB;       \/* marked regions on the screen (if any) *\/$/;"	m	struct:__anon209	file:
regAcc	HTKLib/HAdapt.c	/^   RegAcc *regAcc;       \/* accumulate information for generating transform *\/$/;"	m	struct:__anon88	file:
regB	HTKTools/HSLab.c	/^   int   regA, regB;       \/* marked regions on the screen (if any) *\/$/;"	m	struct:__anon209	file:
regHeap	HTKLVRec/HDecode.c	/^static MemHeap regHeap;$/;"	v	file:
regHeap	HTKLVRec/HDecode.mod.c	/^static MemHeap regHeap;$/;"	v	file:
regHeap	HTKTools/HVite.c	/^static MemHeap regHeap;$/;"	v	file:
regTree	HTKLib/HModel.h	/^  RegTree regTree;     \/* the regression tree used for transform *\/$/;"	m	struct:__anon130
regnMarked	HTKTools/HSLab.c	/^static Boolean regnMarked = FALSE;     \/* region marked *\/$/;"	v	file:
relBeamWidth	HTKLVRec/HDecode.c	/^static LogFloat relBeamWidth = - LZERO;  \/* pruning relative beam width *\/$/;"	v	file:
relBeamWidth	HTKLVRec/HDecode.mod.c	/^static LogFloat relBeamWidth = - LZERO;  \/* pruning relative beam width *\/$/;"	v	file:
relBeamWidth	HTKLVRec/HLVRec.h	/^   RelTokScore relBeamWidth;    \/* beamWidth of relative tokenset  beam *\/$/;"	m	struct:_DecoderInst
relTok	HTKLVRec/HLVRec.h	/^   RelToken *relTok;            \/*# sorted by LMState? *\/$/;"	m	struct:_TokenSet
relTokHeap	HTKLVRec/HLVRec.h	/^   MemHeap relTokHeap;          \/* MHEAP for RelToken arrays (dec->nTok-1 elements) *\/$/;"	m	struct:_DecoderInst
release	HTKLVRec/kenlm/util/file.hh	/^    int release() {$/;"	f	class:util::scoped_fd
release	HTKLVRec/kenlm/util/scoped.hh	/^    T *release() {$/;"	f	class:util::scoped_base
reltoken	HTKLib/HRec.c	/^typedef struct reltoken$/;"	s	file:
remDup	HLMTools/HLMCopy.c	/^static Boolean   remDup = TRUE;          \/* Don't add duplicate prons *\/$/;"	v	file:
remDupPron	HTKLib/HNet.c	/^Boolean remDupPron=TRUE;$/;"	v
remain_	HTKLVRec/kenlm/util/read_compressed.cc	/^    uint8_t *remain_;$/;"	m	class:util::__anon79::UncompressedWithHeader	file:
remaining_	HTKLVRec/kenlm/util/stream/sort.hh	/^        uint64_t remaining_, offset_;$/;"	m	class:util::stream::MergeQueue::Entry
remains_	HTKLVRec/kenlm/lm/trie_sort.hh	/^    bool remains_;$/;"	m	class:lm::ngram::trie::RecordReader
remove_prefix	HTKLVRec/kenlm/util/string_piece.hh	/^  void remove_prefix(size_type n) {$/;"	f	class:StringPiece
remove_suffix	HTKLVRec/kenlm/util/string_piece.hh	/^  void remove_suffix(size_type n) {$/;"	f	class:StringPiece
rend	HTKLVRec/kenlm/util/string_piece.hh	/^  const_reverse_iterator rend() const {$/;"	f	class:StringPiece
reorderComps	HTKLib/HModel.c	/^static Boolean reorderComps=FALSE;      \/* re-order mixture components (PDE) *\/$/;"	v	file:
repHeap	HTKTools/HVite.c	/^static MemHeap repHeap;$/;"	v	file:
replay	HTKTools/HList.c	/^static Boolean replay = FALSE;   \/* replay audio *\/$/;"	v	file:
replay	HTKTools/HVite.c	/^static Boolean replay = FALSE;    \/* enable audio replay *\/$/;"	v	file:
report	HTKLib/HGraf.c	/^static XEvent        report;$/;"	v	file:
required	HTKTools/HDMan.c	/^static LabId required;               \/* current required word *\/$/;"	v	file:
reset	HTKLVRec/kenlm/util/file.hh	/^    void reset(int to = -1) {$/;"	f	class:util::scoped_fd
reset	HTKLVRec/kenlm/util/mmap.cc	/^void scoped_memory::reset(void *data, std::size_t size, Alloc source) {$/;"	f	class:util::scoped_memory
reset	HTKLVRec/kenlm/util/mmap.hh	/^    void reset() { reset(NULL, 0, NONE_ALLOCATED); }$/;"	f	class:util::scoped_memory
reset	HTKLVRec/kenlm/util/mmap.hh	/^    void reset() {$/;"	f	class:util::scoped_mmap
reset	HTKLVRec/kenlm/util/mmap.hh	/^    void reset(void *data, std::size_t size) {$/;"	f	class:util::scoped_mmap
reset	HTKLVRec/kenlm/util/scoped.hh	/^    void reset(T *p = NULL) {$/;"	f	class:util::scoped_base
rest	HTKLVRec/kenlm/lm/return.hh	/^  float rest;$/;"	m	struct:lm::FullScoreReturn
rest	HTKLVRec/kenlm/lm/weights.hh	/^  float rest;$/;"	m	struct:lm::RestWeights
rest_function	HTKLVRec/kenlm/lm/config.hh	/^  RestFunction rest_function;$/;"	m	struct:lm::ngram::Config
rest_lower_files	HTKLVRec/kenlm/lm/config.hh	/^  std::vector<std::string> rest_lower_files;$/;"	m	struct:lm::ngram::Config
reverse_iterator	HTKLVRec/kenlm/util/string_piece.hh	/^  typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:StringPiece
rff	HTKTools/HResults.c	/^static FileFormat rff   = UNDEFF;     \/* ff of reference transcription files *\/$/;"	v	file:
rfind	HTKLVRec/kenlm/util/string_piece.cc	/^size_type StringPiece::rfind(char c, size_type pos) const {$/;"	f	class:StringPiece
rfind	HTKLVRec/kenlm/util/string_piece.cc	/^size_type StringPiece::rfind(const StringPiece& s, size_type pos) const {$/;"	f	class:StringPiece
rgain	HTKLib/HAudio.c	/^   long rgain;$/;"	m	struct:_AudioIn	file:
rgain	HTKLib/HAudio.c	/^   long rgain;$/;"	m	struct:_AudioOut	file:
rid	HTKLib/HVQ.h	/^   short nid,lid,rid;   \/* used for mapping between mem and ext def *\/$/;"	m	struct:_VQNodeRec
right	HTKLVRec/kenlm/lm/filter/phrase.hh	/^      std::vector<unsigned int> substring, left, right, phrase;$/;"	m	struct:lm::phrase::Substrings::SentenceRelation
right	HTKLVRec/kenlm/lm/state.hh	/^  State right;$/;"	m	struct:lm::ngram::ChartState
right	HTKLib/HVQ.h	/^   VQNode left,right;   \/* offspring, only right is used in linTree *\/$/;"	m	struct:_VQNodeRec
right	HTKTools/HHEd.c	/^   HLink left,right;            \/* physical names of constituent biphones *\/$/;"	m	struct:__anon197	file:
rlev	HTKTools/HResults.c	/^static int rlev=0;                    \/* Label level to be used as ref *\/$/;"	v	file:
rmax	HTKLib/HRec.c	/^static const RelToken rmax={0.0,0.0,NULL$/;"	v	file:
rnull	HTKLib/HRec.c	/^static const RelToken rnull={LZERO,0.0,NULL$/;"	v	file:
roCounter	HTKTools/HVite.c	/^static int roCounter = 0;         \/* Counter for audio output name *\/$/;"	v	file:
roPrefix	HTKTools/HVite.c	/^static char * roPrefix=NULL;      \/* Prefix for direct audio output name *\/$/;"	v	file:
roSuffix	HTKTools/HVite.c	/^static char * roSuffix=NULL;      \/* Suffix for direct audio output name *\/$/;"	v	file:
root	HLMLib/LModel.h	/^   FLEntry root;             \/* the actual LM tree *\/$/;"	m	struct:__anon15
root	HTKLVRec/HLVNet.h	/^   TLexNode *root;	\/* global chain of all nodes *\/$/;"	m	struct:_TLexNet
root	HTKLib/HModel.h	/^  RegNode *root;       \/* pointer to the root node of the tree *\/$/;"	m	struct:RegTree
root	HTKTools/HHEd.c	/^   Node *root;                  \/* root of tree *\/$/;"	m	struct:_Tree	file:
rootFN	HLMTools/LAdapt.c	/^static char *rootFN  = "gram";      \/* gbase root file name *\/$/;"	v	file:
rootFN	HLMTools/LGCopy.c	/^static char *rootFN  = "data";      \/* gbase root file name *\/$/;"	v	file:
rootFN	HLMTools/LGPrep.c	/^static char *rootFN  = "gram";      \/* gbase root filename *\/$/;"	v	file:
rootW	HTKLib/HGraf.c	/^static Window        rootW, theWindow;                   $/;"	v	file:
rset	HLMTools/LGPrep.c	/^static RuleSet rset;                \/* rule set if any *\/$/;"	v	file:
rtree	HTKLib/HModel.h	/^  RegTree *rtree;                   \/* regression tree to be used for adaptation *\/$/;"	m	struct:_AdaptXForm
ruleFN	HLMTools/LGPrep.c	/^static char *ruleFN  = NULL;        \/* file containing edit rules *\/$/;"	v	file:
ruledef	HLMTools/LGPrep.c	/^typedef struct ruledef{    \/* rule definition *\/$/;"	s	file:
run	HTKLVRec/kenlm/util/stream/sort.hh	/^      uint64_t run;$/;"	m	struct:util::stream::Offsets::Entry
s	HTKLib/HParm.c	/^   Vector s;          \/* speech vector *\/$/;"	m	struct:__anon141	file:
s	HTKLib/HShell.h	/^   char *s;$/;"	m	union:__anon156
s	HTKLib/HUtil.h	/^   int s;            \/* current stream index 1..S *\/$/;"	m	struct:__anon169
sAudioIn	HTKLib/HAudio.c	/^static AudioIn sAudioIn=NULL;$/;"	v	file:
sAudioOut	HTKLib/HAudio.c	/^static AudioOut sAudioOut=NULL;$/;"	v	file:
sBuf	HTKLib/HRec.c	/^   TokenSet *sBuf;          \/* Buffer Array[2..N-1] of tokset for StepHMM1_N *\/$/;"	m	struct:psetinfo	file:
sCnt	HTKLib/HParm.c	/^   int sCnt;              \/* Number of files processed in current session *\/$/;"	m	struct:channelinfo	file:
sEnd	HTKTools/HSLab.c	/^static long sStart, sEnd;                  \/* the start and end sample currently visible on the screen *\/$/;"	v	file:
sIdx	HTKLib/HModel.h	/^   int sIdx;            \/* State index *\/$/;"	m	struct:__anon126
sLeft	HTKLib/HNet.h	/^   Boolean sLeft;  \/* Seen left context dependency *\/$/;"	m	struct:hmmsetcxtinfo
sMagic	HTKLib/HAudio.c	/^static DWORD sMagic=-1;$/;"	v	file:
sPre	HTKLib/HRec.c	/^   PreComp *sPre;           \/* Array[1..nsp] State PreComps *\/$/;"	m	struct:psetinfo	file:
sProb	HTKTools/HHEd.c	/^   float sProb;                 \/* likelihood of split cluster *\/$/;"	m	struct:_Node	file:
sRight	HTKLib/HNet.h	/^   Boolean sRight; \/* Seen right context dependency *\/$/;"	m	struct:hmmsetcxtinfo
sSet	HTKTools/HSmooth.c	/^static StreamElem **sSet;    \/* array[1..aSize]of stream *\/$/;"	v	file:
sSetStack	HTKTools/HSmooth.c	/^static MemHeap sSetStack;$/;"	v	file:
sStart	HTKTools/HSLab.c	/^static long sStart, sEnd;                  \/* the start and end sample currently visible on the screen *\/$/;"	v	file:
sa	HTKTools/HCompV.c	/^   SpkrAcc *sa;                          \/* speaker accumulate *\/$/;"	m	struct:SpkrAccListItem	file:
salist	HTKTools/HCompV.c	/^static SpkrAccListItem *salist = NULL;   \/* global speaker accumulate list *\/$/;"	v	file:
sampFreqs	HTKLib/HAudio.c	/^static float sampFreqs[NUM_SAMP_FREQS] = {$/;"	v	file:
sampKind	HTKLib/HWave.c	/^   short sampKind;$/;"	m	struct:__anon180	file:
sampPeriod	HTKLib/HAudio.c	/^   HTime sampPeriod;         \/* sampling period in 100ns units *\/$/;"	m	struct:_AudioIn	file:
sampPeriod	HTKLib/HParm.c	/^   HTime sampPeriod;  \/* Either 0.0 or the fixed sample rate of source *\/$/;"	m	struct:hparmsrcdef	file:
sampPeriod	HTKLib/HSigP.h	/^   long sampPeriod;     \/* sample period *\/$/;"	m	struct:__anon159
sampPeriod	HTKLib/HWave.c	/^   HTime sampPeriod;    \/* Sample period in 100ns units *\/$/;"	m	struct:_Wave	file:
sampPeriod	HTKLib/HWave.c	/^   int32 sampPeriod;  \/* sample period in usecs *\/$/;"	m	struct:__anon175	file:
sampPeriod	HTKLib/HWave.c	/^   int32 sampPeriod;$/;"	m	struct:__anon180	file:
sampPeriod	HTKTools/HList.c	/^static HTime sampPeriod;         \/* raw audio input only *\/$/;"	v	file:
sampPeriod	HTKTools/HSLab.c	/^static HTime sampPeriod;     \/* the sample period *\/$/;"	v	file:
sampRate	HTKLib/HWave.c	/^   int32 sampRate;       \/* sample rate code *\/$/;"	m	struct:__anon176	file:
sampRate	HTKLib/HWave.c	/^   int32 sampRate;    \/* sample rate in Hertz *\/$/;"	m	struct:__anon175	file:
sampRate	HTKLib/HWave.c	/^   short sampRate;$/;"	m	struct:__anon173	file:
sampRate	HTKLib/HWave.c	/^   short sampRate;$/;"	m	struct:__anon174	file:
sampSize	HTKLib/HWave.c	/^   short sampSize;   \/* sample size in bits (16) *\/$/;"	m	struct:__anon175	file:
sampSize	HTKLib/HWave.c	/^   short sampSize;$/;"	m	struct:__anon179	file:
sampSize	HTKLib/HWave.c	/^   short sampSize;$/;"	m	struct:__anon180	file:
sampSize	HTKTools/HList.c	/^   int sampSize;$/;"	m	struct:__anon202	file:
samplesPt	HTKTools/HSLab.c	/^static float samplesPt;      \/* samples per point of the graphics screen *\/$/;"	v	file:
saveAsVQ	HTKTools/HCopy.c	/^Boolean saveAsVQ = FALSE;$/;"	v
saveAudioOut	HTKTools/HVite.c	/^static Boolean saveAudioOut=FALSE;\/* Save rec output from direct audio *\/$/;"	v	file:
saveBaseClass	HTKLib/HModel.c	/^static Boolean saveBaseClass = FALSE;   \/* save base classes *\/ $/;"	v	file:
saveBinary	HTKLib/HAdapt.h	/^  Boolean saveBinary;$/;"	m	struct:__anon89
saveBinary	HTKLib/HModel.c	/^static Boolean saveBinary = FALSE;      \/* save HMM defs in binary *\/$/;"	v	file:
saveBinary	HTKTools/HCompV.c	/^static Boolean saveBinary = FALSE;  \/* save output in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HERest.c	/^static Boolean saveBinary = FALSE;  \/* save output in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HInit.c	/^static Boolean saveBinary = FALSE;  \/* save output in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HMMIRest.c	/^static Boolean saveBinary = FALSE;  \/* save output HMMs in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HRest.c	/^static Boolean saveBinary = FALSE;  \/* save output in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HSmooth.c	/^static Boolean saveBinary = FALSE;  \/* save output in binary  *\/$/;"	v	file:
saveBinary	HTKTools/HVite.c	/^static Boolean saveBinary=FALSE;  \/* Save tmf in binary format *\/$/;"	v	file:
saveCompressed	HTKLib/HParm.c	/^   Boolean saveCompressed;    \/* If LPREFC save as IREFC else _C *\/$/;"	m	struct:__anon141	file:
saveCompressed	HTKLib/HParm.h	/^   Boolean saveCompressed;    \/* Save in compressed format *\/$/;"	m	struct:__anon149
saveFiles	HLMTools/LAdapt.c	/^static Boolean saveFiles = TRUE;      \/* save intermediate files *\/ $/;"	v	file:
saveFmt	HLMLib/LPCalc.h	/^   LMFileFmt    saveFmt;              \/* output LM file format *\/$/;"	m	struct:__anon16
saveFmt	HLMTools/HLMCopy.c	/^static LMFileFmt saveFmt = LMF_BINARY;   \/* LM file format *\/$/;"	v	file:
saveFmt	HLMTools/LMerge.c	/^static LMFileFmt saveFmt = DEF_SAVEFMT;  \/* LM file format *\/$/;"	v	file:
saveFmt	HLMTools/LNorm.c	/^static LMFileFmt saveFmt = LMF_BINARY;   \/* LM file format *\/$/;"	v	file:
saveGlobOpts	HTKLib/HModel.c	/^static Boolean saveGlobOpts = TRUE;     \/* save ~o with HMM defs *\/$/;"	v	file:
saveHMMSet	HTKTools/HHEd.c	/^static Boolean saveHMMSet   = TRUE;    \/* Save the HMMSet *\/$/;"	v	file:
saveInputXForm	HTKLib/HModel.c	/^static Boolean saveInputXForm = TRUE;   \/* save input xforms with models set *\/$/;"	v	file:
saveLatBin	HTKTools/HParse.c	/^static Boolean saveLatBin=FALSE;      \/* save lattice in binary *\/ $/;"	v	file:
saveLatLM	HTKTools/HParse.c	/^static Boolean saveLatLM=FALSE;       \/* output lattice probabilities *\/$/;"	v	file:
saveRegTree	HTKLib/HModel.c	/^static Boolean saveRegTree = FALSE;     \/* save regression classes and tree *\/ $/;"	v	file:
saveSemiTiedBinary	HTKLib/HAdapt.c	/^static Boolean saveSemiTiedBinary = FALSE;$/;"	v	file:
saveSpkrModels	HTKLib/HAdapt.c	/^static Boolean saveSpkrModels = FALSE;$/;"	v	file:
saveWithCRC	HTKLib/HParm.c	/^   Boolean saveWithCRC;       \/* Append check sum on save *\/$/;"	m	struct:__anon141	file:
saveWithCRC	HTKLib/HParm.h	/^   Boolean saveWithCRC;       \/* Save with CRC check added *\/$/;"	m	struct:__anon149
savedCommandLine	HTKLib/HShell.c	/^static char *savedCommandLine;$/;"	v	file:
saw_unk_	HTKLVRec/kenlm/lm/vocab.hh	/^    bool saw_unk_;$/;"	m	class:lm::ngram::ProbingVocabulary
saw_unk_	HTKLVRec/kenlm/lm/vocab.hh	/^    bool saw_unk_;$/;"	m	class:lm::ngram::SortedVocabulary
sbindir	HLMLib/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	HLMTools/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	HTKLVRec/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	HTKLib/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	HTKTools/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbindir	Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
scIndex	HTKTools/HSLab.c	/^static short scIndex = 0;    \/* initial scaling index == 1.0*\/$/;"	v	file:
scString	HTKTools/HSLab.c	/^static char *scString[NUM_OF_SCALES] = {"x1", "x2", "x4", "x8", "x16", "x32"};$/;"	v	file:
scValues	HTKTools/HSLab.c	/^static float scValues[NUM_OF_SCALES] = {1.0, 2.0, 4.0, 8.0, 16.0, 32.0};$/;"	v	file:
sc_lmlike	HTKLib/HArc.h	/^  LogFloat sc_lmlike;$/;"	m	struct:_CorrA
scale	HTKLib/HLM.h	/^   float scale;                 \/* Language model scale *\/$/;"	m	struct:lmodel
scale	HTKLib/HRec.c	/^   float scale;             \/* LM (Net probs) scale factor *\/$/;"	m	struct:precinfo	file:
scale	HTKLib/esignal.h	/^    double      scale, offset;  \/* scale factor and offset relating$/;"	m	struct:FieldSpec
scale_btn	HTKTools/HSLab.c	/^static HButton *scale_btn;   \/* pointer to the amplitude scale button *\/$/;"	v	file:
scaledOcc	HTKLib/HFBLat.c	/^   float scaledOcc; \/*for MEE.*\/$/;"	m	struct:__anon101	file:
scaled_aclike	HTKLib/HArc.h	/^  float scaled_aclike; \/* scaled. *\/$/;"	m	struct:_CorrN
sccs	HTKLib/HShell.c	/^   char *sccs;$/;"	m	struct:_VersionEntry	file:
scoped	HTKLVRec/kenlm/util/scoped.hh	/^    explicit scoped(T *p = NULL) : scoped_base<T, Closer>(p) {}$/;"	f	class:util::scoped
scoped	HTKLVRec/kenlm/util/scoped.hh	/^    explicit scoped(void *p = NULL) : scoped_base<void, Closer>(p) {}$/;"	f	class:util::scoped
scoped	HTKLVRec/kenlm/util/scoped.hh	/^template <class Closer> class scoped<void, Closer> : public scoped_base<void, Closer> {$/;"	c	namespace:util
scoped	HTKLVRec/kenlm/util/scoped.hh	/^template <class T, class Closer> class scoped : public scoped_base<T, Closer> {$/;"	c	namespace:util
scoped_FILE	HTKLVRec/kenlm/util/file.hh	/^typedef scoped<std::FILE, scoped_FILE_closer> scoped_FILE;$/;"	t	namespace:util
scoped_FILE_closer	HTKLVRec/kenlm/util/file.hh	/^struct scoped_FILE_closer {$/;"	s	namespace:util
scoped_array	HTKLVRec/kenlm/util/scoped.hh	/^    explicit scoped_array(T *p = NULL) : scoped<T, scoped_delete_array_forward>(p) {}$/;"	f	class:util::scoped_array
scoped_array	HTKLVRec/kenlm/util/scoped.hh	/^template <class T> class scoped_array : public scoped<T, scoped_delete_array_forward> {$/;"	c	namespace:util
scoped_base	HTKLVRec/kenlm/util/scoped.hh	/^    explicit scoped_base(T *p = NULL) : p_(p) {}$/;"	f	class:util::scoped_base
scoped_base	HTKLVRec/kenlm/util/scoped.hh	/^template <class T, class Closer> class scoped_base {$/;"	c	namespace:util
scoped_c	HTKLVRec/kenlm/util/scoped.hh	/^    explicit scoped_c(T *p = NULL) : scoped<T, scoped_c_forward<T, clean> >(p) {}$/;"	f	class:util::scoped_c
scoped_c	HTKLVRec/kenlm/util/scoped.hh	/^template <class T, void (*clean)(T*)> class scoped_c : public scoped<T, scoped_c_forward<T, clean> > {$/;"	c	namespace:util
scoped_c_forward	HTKLVRec/kenlm/util/scoped.hh	/^template <class T, void (*clean)(T*)> struct scoped_c_forward {$/;"	s	namespace:util
scoped_delete_array_forward	HTKLVRec/kenlm/util/scoped.hh	/^struct scoped_delete_array_forward {$/;"	s	namespace:util
scoped_delete_forward	HTKLVRec/kenlm/util/scoped.hh	/^struct scoped_delete_forward {$/;"	s	namespace:util
scoped_fd	HTKLVRec/kenlm/util/file.hh	/^    explicit scoped_fd(int fd) : fd_(fd) {}$/;"	f	class:util::scoped_fd
scoped_fd	HTKLVRec/kenlm/util/file.hh	/^    scoped_fd() : fd_(-1) {}$/;"	f	class:util::scoped_fd
scoped_fd	HTKLVRec/kenlm/util/file.hh	/^class scoped_fd {$/;"	c	namespace:util
scoped_malloc	HTKLVRec/kenlm/util/scoped.hh	/^    explicit scoped_malloc(void *p = NULL) : scoped_c<void, std::free>(p) {}$/;"	f	class:util::scoped_malloc
scoped_malloc	HTKLVRec/kenlm/util/scoped.hh	/^class scoped_malloc : public scoped_c<void, std::free> {$/;"	c	namespace:util
scoped_memory	HTKLVRec/kenlm/util/mmap.hh	/^    scoped_memory() : data_(NULL), size_(0), source_(NONE_ALLOCATED) {}$/;"	f	class:util::scoped_memory
scoped_memory	HTKLVRec/kenlm/util/mmap.hh	/^    scoped_memory(void *data, std::size_t size, Alloc source) $/;"	f	class:util::scoped_memory
scoped_memory	HTKLVRec/kenlm/util/mmap.hh	/^class scoped_memory {$/;"	c	namespace:util
scoped_mmap	HTKLVRec/kenlm/util/mmap.hh	/^    scoped_mmap() : data_((void*)-1), size_(0) {}$/;"	f	class:util::scoped_mmap
scoped_mmap	HTKLVRec/kenlm/util/mmap.hh	/^    scoped_mmap(void *data, std::size_t size) : data_(data), size_(size) {}$/;"	f	class:util::scoped_mmap
scoped_mmap	HTKLVRec/kenlm/util/mmap.hh	/^class scoped_mmap {$/;"	c	namespace:util
scoped_ptr	HTKLVRec/kenlm/util/scoped.hh	/^    explicit scoped_ptr(T *p = NULL) : scoped<T, scoped_delete_forward>(p) {}$/;"	f	class:util::scoped_ptr
scoped_ptr	HTKLVRec/kenlm/util/scoped.hh	/^template <class T> class scoped_ptr : public scoped<T, scoped_delete_forward> {$/;"	c	namespace:util
score	HTKLVRec/HLVRec.h	/^   TokScore  score;             \/* current likelihood of token, $/;"	m	struct:_Token
score	HTKLVRec/HLVRec.h	/^   TokScore score;              \/* total likelihood at end of word (time t) *\/$/;"	m	struct:_AltWordendHyp
score	HTKLVRec/HLVRec.h	/^   TokScore score;              \/* total likelihood at end of word (time t) *\/$/;"	m	struct:_WordendHyp
score	HTKLVRec/HLVRec.h	/^   TokScore score;$/;"	m	struct:_TokenSet
score	HTKLib/HLabel.h	/^   float score;             \/* primary score eg. logP *\/$/;"	m	struct:_Label
score	HTKLib/HNet.h	/^   double score;       \/* Field used for pruning *\/$/;"	m	struct:lnode
score	HTKLib/HNet.h	/^   float score;        \/* Field used for pruning\/sorting *\/$/;"	m	struct:larc
score	HTKLib/HRec.c	/^   double score;$/;"	m	struct:nbestentry	file:
score	HTKTools/HResults.c	/^   float score;                 \/* score for this hit *\/$/;"	m	struct:_SpotRec	file:
score	HTKTools/HResults.c	/^   int score;$/;"	m	struct:_Cell	file:
scribeMap	HTKLib/HLabel.c	/^static char *scribeMap[] = {"LBB:", "LBA:", "UTS:"};$/;"	v	file:
script	HTKLib/HShell.c	/^static FILE *script = NULL;   \/* script file if any *\/$/;"	v	file:
script	HTKTools/HDMan.c	/^   ScriptItem *script;          \/* edit script for this input dictionary *\/$/;"	m	struct:__anon195	file:
script	HTKTools/HLEd.c	/^static ScriptItem *script;          \/* linked list of edit commands *\/$/;"	v	file:
scriptBuf	HTKLib/HShell.c	/^static char scriptBuf[256];   \/* buffer for current script arg *\/$/;"	v	file:
scriptBufLoaded	HTKLib/HShell.c	/^static Boolean scriptBufLoaded = FALSE;$/;"	v	file:
scriptDir	HTKTools/HDMan.c	/^static char *scriptDir = NULL;       \/* directory to look for scripts *\/$/;"	v	file:
scriptcount	HTKLib/HShell.c	/^static int scriptcount = 0;   \/* num words in script *\/$/;"	v	file:
se	HTKLVRec/HLVLM.h	/^   SEntry *se;                  \/* Array[0..nse-1] of ngram probabilities *\/$/;"	m	struct:nentry
se	HTKLib/HLM.h	/^   SEntry *se;                  \/* Array[0..nse-1] of ngram probabilities *\/$/;"	m	struct:nentry
se	HTKLib/HUtil.h	/^   StateElem *se;    \/* ->current stateElem *\/$/;"	m	struct:__anon169
seIndexes	HTKLib/HRec.c	/^   short ***seIndexes;      \/* Array[1..ntr] of seIndexes *\/$/;"	m	struct:psetinfo	file:
se_buff	HLMLib/LModel.h	/^   SMEntry *se_buff;         \/* temp buffer *\/ \/* NB variable size! *\/$/;"	m	struct:__anon15
se_cmp	HTKLVRec/HLVLM.c	/^static int se_cmp(const void *v1,const void *v2)$/;"	f	file:
se_cmp	HTKLib/HLM.c	/^static int se_cmp(const void *v1,const void *v2)$/;"	f	file:
se_cmp	HTKTools/HLStats.c	/^int se_cmp(const void *v1,const void *v2)$/;"	f
sea	HLMLib/LModel.h	/^   struct _SMEntry *sea;    \/* sorted array [0..nse-1] of SMEntry *\/$/;"	m	struct:_FLEntry	typeref:struct:_FLEntry::_SMEntry
search_	HTKLVRec/kenlm/lm/model.hh	/^    Search search_;$/;"	m	class:lm::ngram::detail::GenericModel
search_version	HTKLVRec/kenlm/lm/binary_format.hh	/^  unsigned int search_version;$/;"	m	struct:lm::ngram::FixedWidthParameters
seen	HTKLib/HShell.h	/^   Boolean seen;        \/* set true when read by any module *\/$/;"	m	struct:__anon157
seen	HTKTools/HParse.c	/^   Boolean seen;     \/* flag used when scanning network *\/$/;"	m	struct:_NodeInfo	file:
segId	HTKTools/HCompV.c	/^static LabId  segId  = NULL;        \/* and its id *\/$/;"	v	file:
segId	HTKTools/HInit.c	/^static LabId  segId  = NULL;        \/* and its id *\/$/;"	v	file:
segId	HTKTools/HQuant.c	/^static LabId segId  = NULL;         \/* and its id *\/$/;"	v	file:
segId	HTKTools/HRest.c	/^static LabId  segId  = NULL;     \/* and its index *\/$/;"	v	file:
segLab	HTKTools/HCompV.c	/^static char *segLab = NULL;         \/* segment label if any *\/$/;"	v	file:
segLab	HTKTools/HInit.c	/^static char * segLab = NULL;        \/* segment label if any *\/$/;"	v	file:
segLab	HTKTools/HQuant.c	/^static char *segLab = NULL;         \/* segment label, if any *\/$/;"	v	file:
segLab	HTKTools/HRest.c	/^static char * segLab = NULL;     \/* segment label if any *\/$/;"	v	file:
segLen	HTKLib/HTrain.h	/^   int segLen;          \/* blkSize for each segment *\/$/;"	m	struct:_SegStoreRec
segReject	HTKTools/HRest.c	/^static Boolean segReject = TRUE; \/* Enable short train segment rejection *\/$/;"	v	file:
segStore	HTKTools/HInit.c	/^static SegStore segStore;        \/* Storage for data segments *\/$/;"	v	file:
segStore	HTKTools/HRest.c	/^static SegStore segStore;        \/* Storage for data segments *\/$/;"	v	file:
segmentStack	HTKTools/HInit.c	/^static MemHeap segmentStack;     \/* Used by segStore *\/$/;"	v	file:
segmentStack	HTKTools/HRest.c	/^static MemHeap segmentStack;     \/* Used by segStore *\/$/;"	v	file:
selfCalSilDet	HTKLib/HParm.c	/^   int selfCalSilDet;         \/* Self calibrating silence detection *\/$/;"	m	struct:__anon141	file:
semiTied	HTKLib/HModel.h	/^   AdaptXForm *semiTied;   \/* SemiTied transform associated with model set *\/$/;"	m	struct:_HMMSet
semiTied2InputXForm	HTKLib/HAdapt.c	/^static Boolean semiTied2InputXForm = FALSE;$/;"	v	file:
semiTiedFloorScale	HTKLib/HAdapt.c	/^static float semiTiedFloorScale = 0.1;$/;"	v	file:
semiTiedMacro	HTKLib/HAdapt.c	/^static char *semiTiedMacro = NULL;$/;"	v	file:
semiTiedMacro	HTKLib/HModel.h	/^   char *semiTiedMacro;  \/* macroname of semi-tied transform *\/$/;"	m	struct:_HMMSet
semiTiedVFloor	HTKLib/HAdapt.c	/^static Boolean semiTiedVFloor = TRUE;$/;"	v	file:
senId	HLMTools/LPlex.c	/^static LabId senId = NULL;          \/* sentence end marker *\/$/;"	v	file:
sent	HLMTools/LPlex.c	/^static PStats  sent;                \/* per utterance accumulators *\/$/;"	v	file:
sentMarker	HTKTools/HLEd.c	/^static LabId sentMarker=NULL;       \/* sentence bndary marker set by SB cmd *\/$/;"	v	file:
sent_end	HLMTools/Cluster.c	/^static char         sent_end[256];          \/* sentence end word *\/$/;"	v	file:
sent_start	HLMTools/Cluster.c	/^static char         sent_start[256];        \/* sentence start word *\/$/;"	v	file:
sentence_marker_missing	HTKLVRec/kenlm/lm/config.hh	/^  WarningAction sentence_marker_missing;$/;"	m	struct:lm::ngram::Config
sentry	HTKLVRec/HLVLM.h	/^typedef struct sentry {         \/* HLM NGram probability *\/$/;"	s
sentry	HTKLib/HLM.h	/^typedef struct sentry {         \/* HLM NGram probability *\/$/;"	s
seqno	HLMLib/LWMap.h	/^   int     seqno;        \/* sequence number *\/$/;"	m	struct:__anon23
sequenceStack	HTKTools/HInit.c	/^static MemHeap sequenceStack;    \/* For storage of sequences *\/$/;"	v	file:
sequence_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    uint64_t sequence_;$/;"	m	class:lm::Controller
sequence_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    uint64_t sequence_;$/;"	m	class:lm::ThreadBatch
set	HTKLVRec/kenlm/util/string_piece.hh	/^  void set(const char* data, size_type len) { ptr_ = data; length_ = len; }$/;"	f	class:StringPiece
set	HTKLVRec/kenlm/util/string_piece.hh	/^  void set(const char* str) {$/;"	f	class:StringPiece
set	HTKLVRec/kenlm/util/string_piece.hh	/^  void set(const void* data, size_type len) {$/;"	f	class:StringPiece
set	HTKLib/HRec.c	/^   RelToken *set;            \/* Likelihood sorted array[0..nToks] of rtoks *\/$/;"	m	struct:tokenset	file:
set	HTKLib/HUtil.h	/^   Boolean *set;		\/* array[1..nMembers] of Boolean *\/$/;"	m	struct:__anon170
setHeap	HTKLib/HUtil.c	/^static MemHeap setHeap;$/;"	v	file:
set_e	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  void set_e(int new_value) { e_ = new_value; }$/;"	f	class:double_conversion::DiyFp
set_f	HTKLVRec/kenlm/util/double-conversion/diy-fp.h	/^  void set_f(uint64_t new_value) { f_ = new_value; }$/;"	f	class:double_conversion::DiyFp
set_ids	HLMTools/Cluster.c	/^void set_ids(int start, int end, int unk)$/;"	f
set_output_prefix	HLMTools/Cluster.c	/^void set_output_prefix(char *name)$/;"	f
setid	HLMTools/LGPrep.c	/^   int   setid;               \/* set index *\/$/;"	m	union:__anon28	file:
setlist	HLMTools/LGPrep.c	/^   SetDef **setlist;          \/* array[0..MAX_SETS-1] of -> SetDef *\/$/;"	m	struct:__anon31	file:
sets_	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    std::vector<boost::iterator_range<const unsigned int*> > sets_;$/;"	m	class:lm::vocab::Multiple
sets_	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    std::vector<boost::iterator_range<const unsigned int*> > sets_;$/;"	m	class:lm::vocab::Union
setup_all_counts	HLMTools/Cluster.c	/^void setup_all_counts(void)$/;"	f
sgn	HTKLib/HMath.c	684;"	d	file:
sharedMix	HTKLib/HFB.c	/^static Boolean sharedMix = FALSE; \/* true if shared mixtures *\/$/;"	v	file:
sharedstatedir	HLMLib/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	HLMTools/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	HTKLVRec/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	HTKLib/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	HTKTools/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
sharedstatedir	Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
showConfig	HTKLib/HShell.c	/^static Boolean showConfig = FALSE;       \/* show configuration params *\/$/;"	v	file:
show_MLV	HLMTools/Cluster.c	/^static Boolean     show_MLV=FALSE;          \/* Show MLV after each change *\/$/;"	v	file:
show_progress	HTKLVRec/kenlm/lm/config.hh	/^  bool show_progress;$/;"	m	struct:lm::ngram::Config
si	HTKLVRec/HLVModel.h	/^   StateInfo **si;              \/* pointers to HModel:StateInfos  for USEHMODEL=T *\/$/;"	m	struct:_StateInfo_lv
si	HTKLVRec/HLVRec.h	/^   StateInfo_lv *si;$/;"	m	struct:_DecoderInst
si	HTKLib/HUtil.h	/^   StateInfo *si;    \/* ->current stateInfo *\/$/;"	m	struct:__anon169
sideXForm	HTKLib/HParm.c	/^   AdaptXForm *sideXForm;$/;"	m	struct:__anon141	file:
sideXFormExt	HTKLib/HParm.c	/^   char* sideXFormExt;       \/* side XForm mask *\/$/;"	m	struct:__anon141	file:
sideXFormMask	HTKLib/HParm.c	/^   char* sideXFormMask;       \/* side XForm mask *\/$/;"	m	struct:__anon141	file:
sig	HTKLib/HAudio.c	/^   int sig;                  \/* signal if any *\/$/;"	m	struct:_AudioIn	file:
sigAudio	HTKLib/HAudio.c	/^static AudioIn sigAudio;  \/* Globals used for signalling *\/$/;"	v	file:
sigNum	HTKLib/HAudio.c	/^static int sigNum=NULLSIG;$/;"	v	file:
sign	HLMLib/LUtil.c	/^static int sign(int r)$/;"	f	file:
significand	HTKLVRec/kenlm/util/double-conversion/cached-powers.cc	/^  uint64_t significand;$/;"	m	struct:double_conversion::CachedPower	file:
sigpHeap	HTKLib/HSigP.c	/^static MemHeap sigpHeap;$/;"	v	file:
silDetCnt	HTKLib/HParm.c	/^   int silDetCnt;      \/* Number of silence frames in window *\/$/;"	m	struct:_ParmBuf	file:
silDict	HTKLVRec/HDecode.c	/^static Boolean silDict = FALSE; \/* does dict contain -\/sp\/sil variants with probs *\/$/;"	v	file:
silDict	HTKLVRec/HDecode.mod.c	/^static Boolean silDict = FALSE; \/* does dict contain -\/sp\/sil variants with probs *\/$/;"	v	file:
silDict	HTKLVRec/HLVNet.h	/^   Boolean silDict;             \/* does dict contain -\/sp\/sil variants and pronprobs? *\/$/;"	m	struct:_LexNet
silDict	HTKLVRec/HLVNet.h	/^   Boolean silDict;     \/* does dict contain -\/sp\/sil variants and pronprobs? *\/$/;"	m	struct:_TLexNet
silDiscard	HTKLib/HParm.c	/^   float silDiscard;          \/* Calibrate discard level *\/$/;"	m	struct:__anon141	file:
silFloor	HTKLib/HParm.c	/^   float silFloor;            \/* Silence floor in dBs *\/$/;"	m	struct:__anon141	file:
silGlchCount	HTKLib/HParm.c	/^   int silGlchCount;          \/*   of sil in spc acceptable as glitches *\/$/;"	m	struct:__anon141	file:
silId	HTKLib/HNet.c	/^   int silId;$/;"	m	struct:pinstinfo	file:
silLab	HTKLVRec/HDecode.c	/^static LabId silLab;            \/*   corresponding LabId *\/$/;"	v	file:
silLab	HTKLVRec/HDecode.mod.c	/^static LabId silLab;            \/*   corresponding LabId *\/$/;"	v	file:
silMean	HTKLib/HParm.c	/^   float silMean;             \/* Mean silence energy (in dB) *\/$/;"	m	struct:__anon141	file:
silModel	HTKLVRec/HDecode.c	/^static char *silModel = "sil";  \/* model used as word end Silence *\/$/;"	v	file:
silModel	HTKLVRec/HDecode.mod.c	/^static char *silModel = "sil";  \/* model used as word end Silence *\/$/;"	v	file:
silSeqCount	HTKLib/HParm.c	/^   int silSeqCount;           \/*   of silence before stopping *\/$/;"	m	struct:__anon141	file:
simpleDiffs	HTKLib/HParm.c	/^   Boolean simpleDiffs;       \/* Use simple differences for delta calcs *\/$/;"	m	struct:__anon141	file:
size	HLMLib/LCMap.h	/^   int size;               \/* size of class *\/$/;"	m	struct:clEntry
size	HLMLib/LGBase.h	/^   int size;               \/* size of fof table *\/$/;"	m	struct:__anon6
size	HLMLib/LWMap.h	/^   int     size;         \/* size of array *\/$/;"	m	struct:__anon23
size	HLMLib/LWMap.h	/^   int size;             \/* size of lookup array *\/$/;"	m	struct:__anon22
size	HLMTools/Cluster.c	/^   int       size; \/* Number of bigrams with this word in *\/$/;"	m	struct:__anon25	file:
size	HTKLVRec/HLVRec.h	/^   int size;$/;"	m	struct:_LMNodeCache
size	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  int size() const { return buffer_.length(); }$/;"	f	class:double_conversion::StringBuilder
size	HTKLVRec/kenlm/util/fixed_array.hh	/^    std::size_t size() const { return end() - begin(); }$/;"	f	class:util::FixedArray
size	HTKLVRec/kenlm/util/mmap.hh	/^    std::size_t size() const { return size_; }$/;"	f	class:util::scoped_memory
size	HTKLVRec/kenlm/util/mmap.hh	/^    std::size_t size() const { return size_; }$/;"	f	class:util::scoped_mmap
size	HTKLVRec/kenlm/util/parallel_read.cc	/^      std::size_t size;$/;"	m	struct:util::__anon78::Reader::Request	file:
size	HTKLVRec/kenlm/util/string_piece.hh	/^  size_type size() const { return length_; }$/;"	f	class:StringPiece
size	HTKLib/HAudio.c	/^   int size;              \/* Size of buffer *\/$/;"	m	struct:mmapibuf	file:
size	HTKLib/HAudio.c	/^   int used,size;        \/* used in data, size of data *\/$/;"	m	struct:__anon92	file:
size	HTKLib/HParm.c	/^   int size;          \/* Sample size fields *\/$/;"	m	struct:hparmsrcdef	file:
size	HTKLib/HWave.c	/^   int32 size;        \/* size of rest of chunk *\/$/;"	m	struct:__anon177	file:
size	HTKLib/HWave.c	/^   int32 size;$/;"	m	struct:__anon178	file:
size	HTKTools/HHEd.c	/^   int size;                    \/* number of non terminal nodes *\/$/;"	m	struct:_Tree	file:
size_	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    const std::size_t size_;$/;"	m	class:lm::builder::__anon43::DedupeEquals	file:
size_	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    const std::size_t size_;$/;"	m	class:lm::builder::__anon43::DedupeHash	file:
size_	HTKLVRec/kenlm/util/mmap.hh	/^    std::size_t size_;$/;"	m	class:util::scoped_memory
size_	HTKLVRec/kenlm/util/mmap.hh	/^    std::size_t size_;$/;"	m	class:util::scoped_mmap
size_	HTKLVRec/kenlm/util/sized_iterator.hh	/^    std::size_t size_;$/;"	m	class:util::SizedInnerIterator
size_type	HTKLVRec/kenlm/util/string_piece.cc	/^typedef StringPiece::size_type size_type;$/;"	t	file:
size_type	HTKLVRec/kenlm/util/string_piece.hh	/^  typedef size_t size_type;$/;"	t	class:StringPiece
skipOOV	HLMTools/LPlex.c	/^static Boolean skipOOV  = TRUE;     \/* discard OOV in computation *\/$/;"	v	file:
skipend	HTKLib/HFB.h	/^  int skipend;$/;"	m	struct:__anon99
skipendInit	HTKLib/HFB.c	/^static int skipendInit   = -1;$/;"	v	file:
skipstart	HTKLib/HFB.h	/^  int skipstart;      \/* Skipover region - debugging only *\/$/;"	m	struct:__anon99
skipstartInit	HTKLib/HFB.c	/^static int skipstartInit = -1;$/;"	v	file:
slaHeap	HTKLib/HLat.c	/^static MemHeap slaHeap, slnHeap;\/* MHEAPs for use in LatExpand() *\/$/;"	v	file:
slat	HTKLib/HNet.c	/^static Lattice *slat;   \/* Used by qsort cmp routines *\/$/;"	v	file:
slnHeap	HTKLib/HLat.c	/^static MemHeap slaHeap, slnHeap;\/* MHEAPs for use in LatExpand() *\/$/;"	v	file:
snum	HTKTools/HHEd.c	/^   short snum;$/;"	m	struct:_Node	file:
socket	HTKLib/HAudio.c	/^   int socket;$/;"	m	struct:_AudioIn	file:
socket	HTKLib/HAudio.c	/^   int socket;$/;"	m	struct:_AudioOut	file:
sort	HLMLib/LWMap.h	/^   int sort;               \/* for sorting (gives lexical ordering) *\/$/;"	m	struct:MAPENTRY
sort	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  util::stream::SortConfig sort;$/;"	m	struct:lm::builder::PipelineConfig
sortFirst	HTKTools/HLEd.c	/^static Boolean sortFirst = FALSE;   \/* Sort on loading *\/$/;"	v	file:
sortLattice	HTKTools/HLRescore.c	/^static Boolean sortLattice = TRUE;         \/* sort lattice nodes by time & posterior *\/$/;"	v	file:
sortTab	HLMLib/LWMap.c	/^static LabId *sortTab;               \/* global temp used by qsort *\/$/;"	v	file:
sort_order	HLMTools/Cluster.c	/^static int          sort_order = SORT_WMAP; \/* Order words are considered in *\/$/;"	v	file:
sort_uni	HLMTools/Cluster.c	/^static int         *sort_uni;               \/* Sort unigrams by count *\/$/;"	v	file:
source	HLMLib/LWMap.h	/^   char    *source;      \/* description of sources *\/$/;"	m	struct:__anon23
source	HTKLVRec/kenlm/util/mmap.hh	/^    Alloc source() const { return source_; }$/;"	f	class:util::scoped_memory
source	HTKLib/HLM.c	/^static Source source;           \/* input file *\/$/;"	v	file:
source	HTKLib/HLat.c	/^   Source source;$/;"	m	struct:_LLFInfo	file:
source	HTKLib/HUtil.c	/^static Source *source;         \/* Current source for item list *\/$/;"	v	file:
source	HTKTools/HDMan.c	/^   LabId source;                \/* name of source dict *\/$/;"	m	struct:__anon193	file:
source	HTKTools/HDMan.c	/^   LabId source;                \/* name of source dict *\/$/;"	m	struct:__anon195	file:
source	HTKTools/HHEd.c	/^static Source source;      \/* the current input file *\/$/;"	v	file:
source_	HTKLVRec/kenlm/util/mmap.hh	/^    Alloc source_;$/;"	m	class:util::scoped_memory
spDetCnt	HTKLib/HParm.c	/^   int spDetCnt;       \/* Number of speech frames in window *\/$/;"	m	struct:_ParmBuf	file:
spDetCur	HTKLib/HParm.c	/^   int spDetCur;       \/* Current speech detector frame *\/$/;"	m	struct:_ParmBuf	file:
spDetEn	HTKLib/HParm.c	/^   int spDetEn;        \/* row after last to return (MAX_INT == waiting) *\/$/;"	m	struct:_ParmBuf	file:
spDetEn	HTKLib/HParm.h	/^   int spDetEn;               \/* Frame number of last frame of buffer *\/$/;"	m	struct:__anon149
spDetFin	HTKLib/HParm.c	/^   int spDetFin;       \/* final row allowed to return (normally qen) *\/$/;"	m	struct:_ParmBuf	file:
spDetLst	HTKLib/HParm.c	/^   int spDetLst;       \/* Last frame of speech seen *\/$/;"	m	struct:_ParmBuf	file:
spDetParmsSet	HTKLib/HParm.c	/^   Boolean spDetParmsSet; \/* Speech detector parameters set *\/$/;"	m	struct:channelinfo	file:
spDetParmsSet	HTKLib/HParm.h	/^   Boolean spDetParmsSet;     \/* Parameters set for sp\/sil detector *\/$/;"	m	struct:__anon149
spDetSNR	HTKLib/HParm.c	/^   float spDetSNR;        \/* Measured\/set silence\/speech ratio (dB) *\/$/;"	m	struct:channelinfo	file:
spDetSNR	HTKLib/HParm.h	/^   float spDetSNR;            \/* Speech\/noise ratio for channel *\/$/;"	m	struct:__anon149
spDetSil	HTKLib/HParm.c	/^   float spDetSil;        \/* Measured\/set silence level for channel (dB) *\/$/;"	m	struct:channelinfo	file:
spDetSil	HTKLib/HParm.h	/^   float spDetSil;            \/* Silence level for channel *\/$/;"	m	struct:__anon149
spDetSp	HTKLib/HParm.c	/^   float spDetSp;         \/* Measured\/set speech level for channel (dB) *\/$/;"	m	struct:channelinfo	file:
spDetSp	HTKLib/HParm.h	/^   float spDetSp;             \/* Speech level for channel *\/$/;"	m	struct:__anon149
spDetSt	HTKLib/HParm.c	/^   int spDetSt;        \/* first row to return (MAX_INT == waiting) *\/$/;"	m	struct:_ParmBuf	file:
spDetSt	HTKLib/HParm.h	/^   int spDetSt;               \/* Frame number of first frame of buffer *\/$/;"	m	struct:__anon149
spDetThresh	HTKLib/HParm.c	/^   float spDetThresh;     \/* Measured\/set speech\/silence threshold (dB) *\/$/;"	m	struct:channelinfo	file:
spDetThresh	HTKLib/HParm.h	/^   float spDetThresh;         \/* Silence\/speech level threshold *\/$/;"	m	struct:__anon149
spLab	HTKLVRec/HDecode.c	/^static LabId spLab;             \/*   corresponding LabId *\/$/;"	v	file:
spLab	HTKLVRec/HDecode.mod.c	/^static LabId spLab;             \/*   corresponding LabId *\/$/;"	v	file:
spModel	HTKLVRec/HDecode.c	/^static char *spModel = "sp";    \/* model used as word end Short Pause *\/$/;"	v	file:
spModel	HTKLVRec/HDecode.mod.c	/^static char *spModel = "sp";    \/* model used as word end Short Pause *\/$/;"	v	file:
spPattern	HTKTools/HCompV.c	/^static char spPattern[MAXSTRLEN];        \/* speaker mask *\/$/;"	v	file:
spSkipLayer	HTKLVRec/HLVNet.h	/^   int spSkipLayer;             \/* id of layer where tokens get pronprob added and bypass sp *\/$/;"	m	struct:_LexNet
spSum	HTKLib/HAdapt.c	/^   Vector spSum;$/;"	m	struct:__anon87	file:
spSumSq	HTKLib/HAdapt.c	/^   Vector spSumSq;$/;"	m	struct:__anon87	file:
spThresh	HTKLib/HParm.c	/^   float spThresh;            \/* Speech Threshold (in dB above sil level) *\/$/;"	m	struct:__anon141	file:
spVal	HTKLib/HParm.c	/^   float *spVal;       \/* Array of speech\/silence levels *\/$/;"	m	struct:_ParmBuf	file:
spcGlchCount	HTKLib/HParm.c	/^   int spcGlchCount;          \/*   of spc in sil acceptable as glitches *\/$/;"	m	struct:__anon141	file:
spcSeqCount	HTKLib/HParm.c	/^   int spcSeqCount;           \/* Number of frames for speech window *\/$/;"	m	struct:__anon141	file:
spcl_btn	HTKTools/HSLab.c	/^static HButton *spcl_btn;                 \/* pointer to special button *\/$/;"	v	file:
spcl_str	HTKTools/HSLab.c	/^static char spcl_str[SLEN] = "Command";   \/* special button string *\/$/;"	v	file:
spdf	HTKLib/HModel.h	/^   MixtureVector spdf;  \/* Mixture Vector *\/$/;"	m	struct:__anon125
speakerOut	HTKLib/HAudio.c	/^static Boolean speakerOut = FALSE;$/;"	v	file:
specialNull	HTKLib/HNet.c	/^static DictEntry specialNull;$/;"	v	file:
spfn	HTKTools/HSLab.c	/^static char spfn[SLEN] = "noname.wav";     \/* the speech (waveform) file name *\/$/;"	v	file:
spkrFails	HTKTools/HResults.c	/^static int  spkrFails = 0;     \/* num time spkr pattern fails to match *\/$/;"	v	file:
spkrHead	HTKTools/HResults.c	/^static Spkr *spkrHead = NULL;$/;"	v	file:
spkrMask	HTKTools/HResults.c	/^static char * spkrMask = NULL;        \/* non-null report on per spkr basis *\/$/;"	v	file:
splitNameHeap	HTKTools/HParse.c	/^MemHeap  splitNameHeap;$/;"	v
spotWidth	HTKTools/HResults.c	/^static int spotWidth = 66;$/;"	v	file:
spots	HTKTools/HResults.c	/^static SpotRec **spots;$/;"	v	file:
sqOffset	HLMLib/LGBase.c	/^static int sqOffset;                    \/* squash offset, this depends on byte *\/$/;"	v	file:
sqr	HTKTools/HHEd.c	/^   Vector sqr;                  \/* count statistics             *\/$/;"	m	struct:_AccSum	file:
squareSum	HTKTools/HCompV.c	/^   Covariance   squareSum;          \/* acc for sum of squares *\/$/;"	m	struct:__anon189	file:
squareSum	HTKTools/HCompV.c	/^   Vector squareSum;                     \/* variance structure for speaker *\/$/;"	m	struct:__anon190	file:
src	HLMLib/LGBase.h	/^   Source src;              \/* the input stream *\/$/;"	m	struct:__anon3
src	HLMTools/LGPrep.c	/^   FieldVec src;              \/* match part of rule *\/$/;"	m	struct:ruledef	file:
src	HTKLVRec/HLVRec.h	/^   LMState *src;$/;"	m	struct:_LMCacheLA
src	HTKLVRec/HLVRec.h	/^   LMState src;$/;"	m	struct:_LMLACacheEntry
src	HTKLib/HParm.c	/^   Source src;        \/* Source to read HParm file from *\/$/;"	m	struct:__anon141	file:
src	HTKTools/HDMan.c	/^   Source src;                  \/* input file source *\/$/;"	m	struct:__anon195	file:
srcFF	HTKLib/HParm.c	/^   FileFormat srcFF;          \/* Source File format *\/ $/;"	m	struct:__anon141	file:
srcFF	HTKLib/HParm.h	/^   FileFormat srcFF;          \/* Source File format *\/ $/;"	m	struct:__anon149
srcFF	HTKTools/HCopy.c	/^FileFormat srcFF     = UNDEFF;   \/* I\/O configuration options *\/$/;"	v
srcFN	HLMTools/HLMCopy.c	/^static char      *srcFN = NULL;          \/* source file name *\/$/;"	v	file:
srcFN	HLMTools/LBuild.c	/^static char *srcFN   = NULL;        \/* input LM filename *\/$/;"	v	file:
srcFN	HLMTools/LNorm.c	/^static char      *srcFN = NULL;          \/* source file name *\/$/;"	v	file:
srcHdr	HTKTools/HList.c	/^static Boolean srcHdr  = FALSE;  \/* print source header info *\/$/;"	v	file:
srcLM	HLMTools/LBuild.c	/^static BackOffLM *srcLM = NULL;     \/* the source model if any *\/$/;"	v	file:
srcLabFF	HTKTools/HCopy.c	/^FileFormat srcLabFF  = UNDEFF;$/;"	v
srcPK	HTKLib/HParm.c	/^   ParmKind srcPK;            \/* Source ParmKind *\/ $/;"	m	struct:__anon141	file:
srcPK	HTKLib/HParm.h	/^   ParmKind srcPK;            \/* Source ParmKind *\/ $/;"	m	struct:__anon149
srcPK	HTKTools/HCopy.c	/^ParmKind srcPK       = ANON;$/;"	v
srcSampRate	HTKLib/HParm.c	/^   HTime srcSampRate;         \/* Source Sample Rate *\/ $/;"	m	struct:__anon141	file:
srcSampRate	HTKLib/HParm.h	/^   HTime srcSampRate;         \/* Source Sample Rate *\/ $/;"	m	struct:__anon149
srcSampRate	HTKTools/HCopy.c	/^HTime srcSampRate    = 0.0;$/;"	v
srcUsed	HTKLib/HParm.c	/^   int srcUsed;       \/* num columns which was used in source *\/$/;"	m	struct:__anon141	file:
srcVecSize	HTKLib/HParm.h	/^   int srcVecSize;            \/* Size of source vector *\/$/;"	m	struct:__anon149
src_kenlm	HTKLVRec/HLVRec.h	/^   lm::ngram::State src_kenlm;$/;"	m	struct:_LMCacheLA
srcdir	HLMLib/Makefile	/^srcdir = .$/;"	m
srcdir	HLMTools/Makefile	/^srcdir = .$/;"	m
srcdir	HTKLVRec/Makefile	/^srcdir = .$/;"	m
srcdir	HTKLib/Makefile	/^srcdir = .$/;"	m
srcdir	HTKTools/Makefile	/^srcdir = .$/;"	m
srcdir	Makefile	/^srcdir = .$/;"	m
sri_	HTKLVRec/kenlm/lm/search_trie.cc	/^    SRISucks &sri_;$/;"	m	class:lm::ngram::trie::__anon58::FindBlanks	file:
sri_	HTKLVRec/kenlm/lm/search_trie.cc	/^    SRISucks &sri_;$/;"	m	class:lm::ngram::trie::__anon58::WriteEntries	file:
sstId	HLMLib/LPCalc.c	/^static LabId  sstId;                          \/* sentence start marker *\/$/;"	v	file:
sstId	HLMTools/LGPrep.c	/^static LabId sstId = NULL;          \/* sentence start id *\/$/;"	v	file:
sstId	HLMTools/LPlex.c	/^static LabId sstId = NULL;          \/* sentence start marker *\/$/;"	v	file:
sstStr	HLMLib/LPCalc.c	/^static char   sstStr[256] = DEF_STARTWORD;    \/* sentence start marker *\/$/;"	v	file:
st	HTKTools/HCopy.c	/^static HTime st=0.0;            \/* start of samples to copy *\/$/;"	v	file:
st	HTKTools/HSLab.c	/^   long st, en;            \/* start and end sample of the previous zoom level *\/$/;"	m	struct:__anon209	file:
stHeap	HTKLib/HRec.c	/^   MemHeap *stHeap;         \/* Array[0..stHeapNum-1] of heaps for states *\/$/;"	m	struct:precinfo	file:
stHeapIdx	HTKLib/HRec.c	/^   short *stHeapIdx;        \/* Array[1..max] of state to heap index *\/$/;"	m	struct:psetinfo	file:
stHeapNum	HTKLib/HRec.c	/^   short stHeapNum;         \/* Number of separate state heaps *\/$/;"	m	struct:psetinfo	file:
stRow	HTKLib/HParm.c	/^   int stRow;        \/* absolute number of first row in this block *\/$/;"	m	struct:pblock	file:
start	HTKLVRec/HDecode.c	/^   int start;           \/* frame numbers *\/$/;"	m	struct:_BestInfo	file:
start	HTKLVRec/HDecode.mod.c	/^   int start;           \/* frame numbers *\/$/;"	m	struct:_BestInfo	file:
start	HTKLVRec/HLVNet.h	/^   LexNode *start;              \/* single start node *\/$/;"	m	struct:_LexNet
start	HTKLVRec/HLVNet.h	/^   TLexNode *start;     \/* start node of network *\/$/;"	m	struct:_TLexNet
start	HTKLVRec/HLVNet.h	/^   TLexNode *start;$/;"	m	struct:_TLexLink
start	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  T* start() const { return start_; }$/;"	f	class:double_conversion::Vector
start	HTKLib/HArc.h	/^  CorrN *start;$/;"	m	struct:_CorrA
start	HTKLib/HArc.h	/^  HArc *start; \/*The beginning and end of a dll of arcs.*\/$/;"	m	struct:ArcInfoStruct
start	HTKLib/HArc.h	/^  HArc *start;$/;"	m	struct:_ArcTrans
start	HTKLib/HFBLat.c	/^   int start;$/;"	m	struct:__anon100	file:
start	HTKLib/HLabel.h	/^   HTime start,end;         \/* Start and end times in 100ns units *\/$/;"	m	struct:_Label
start	HTKLib/HNet.h	/^   NodeId start;       \/* Node at start of word *\/$/;"	m	struct:larc
start	HTKLib/HNet.h	/^   NodeId start;       \/* Node at start of word *\/$/;"	m	struct:larc_e
start	HTKLib/HNet.h	/^   NodeId start;$/;"	m	struct:larc_s
startId	HTKLVRec/HLVNet.h	/^   LabId startId;       \/* id of STARTWORD (from config) *\/$/;"	m	struct:_TLexNet
startLMWord	HTKLib/HLat.c	/^static LabId startLMWord;       \/* word at start in LM (<s>) *\/$/;"	v	file:
startLMWord	HTKTools/HLRescore.c	/^static char *startLMWord;       \/* word at start in LM (<s>) *\/$/;"	v	file:
startLab	HTKLVRec/HDecode.c	/^static LabId startLab;          \/*   corresponding LabId *\/$/;"	v	file:
startLab	HTKLVRec/HDecode.mod.c	/^static LabId startLab;          \/*   corresponding LabId *\/$/;"	v	file:
startLab	HTKTools/HLRescore.c	/^static LabId startLab;          \/* corresponding LabId *\/$/;"	v	file:
startPron	HTKLVRec/HLVNet.h	/^   PronId startPron;            \/* pron of <s> *\/$/;"	m	struct:_LexNet
startPronId	HTKLVRec/HLVLM.h	/^   PronId startPronId;$/;"	m	struct:_FSLM
startTok	HTKLVRec/HLVRec.c	/^RelToken startTok = {NULL, NULL, 0.0, 0.0, NULL};$/;"	v
startWord	HTKLVRec/HDecode.c	/^static char *startWord = "<s>"; \/* word used at start of network *\/$/;"	v	file:
startWord	HTKLVRec/HDecode.mod.c	/^static char *startWord = "<s>"; \/* word used at start of network *\/$/;"	v	file:
startWord	HTKLib/HLat.c	/^static LabId startWord;         \/* word at start of Lattice (!SENT_START) *\/$/;"	v	file:
startWord	HTKTools/HLRescore.c	/^static char *startWord;         \/* word at start of Lattice (!SENT_START) *\/$/;"	v	file:
start_	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  T* start_;$/;"	m	class:double_conversion::Vector
start_class	HLMTools/Cluster.c	/^static int         start_class = 2;         \/* Which is the first 'real' class? *\/$/;"	v	file:
start_foll	HTKLib/HArc.h	/^  ArcTrans *start_foll; \/*The transition is in a dll w.r.t both the arcs it follows and the ones it precedes.*\/$/;"	m	struct:_ArcTrans
start_foll	HTKLib/HArc.h	/^  CorrA *start_foll;$/;"	m	struct:_CorrA
start_id	HLMTools/Cluster.c	/^static int         start_id=-1, end_id=-1;  \/* Start and end word ids *\/$/;"	v	file:
start_inst	HTKLib/HRec.c	/^   NetInst *start_inst;     \/* Inst that started a move *\/$/;"	m	struct:precinfo	file:
start_prec	HTKLib/HArc.h	/^  ArcTrans *start_prec; \/*the start_{foll,prec} dll is the list of the transitions attached to the same start node; *\/$/;"	m	struct:_ArcTrans
started_	HTKLVRec/kenlm/util/usage.cc	/^    Wall started_;$/;"	m	class:util::__anon83::RecordStart	file:
starti	HTKLib/HArc.h	/^  int starti;  \/* start & end of search beam. *\/$/;"	m	struct:_CorrN
starts	HTKLib/HNet.c	/^   NetNode *starts; \/* Chain of initial models *\/$/;"	m	struct:pronholder	file:
starts_with	HTKLVRec/kenlm/util/string_piece.hh	/^  bool starts_with(const StringPiece& x) const {$/;"	f	class:StringPiece
starts_with	HTKLVRec/kenlm/util/string_piece.hh	/^inline bool starts_with(const StringPiece& longer, const StringPiece& prefix) {$/;"	f
statFN	HTKTools/HERest.c	/^static char * statFN;            \/* stats file, if any *\/$/;"	v	file:
statFN	HTKTools/HMMIRest.c	/^static char * statFN=0;            \/* stats file, if any *\/$/;"	v	file:
statFN	HTKTools/HSmooth.c	/^static char * statFN;            \/* stats file, if any *\/$/;"	v	file:
statHeap	HTKTools/HLStats.c	/^static MemHeap statHeap;            \/* Permenant stats storage *\/$/;"	v	file:
state	HTKLib/HNet.h	/^   int state;         \/* State number (-1==model_end) *\/$/;"	m	struct:lalign
state	HTKLib/HRec.c	/^   TokenSet *state;     \/* TokenSet[0..N-2] in state [1..N-1] for hmm *\/$/;"	m	struct:_NetInst	file:
state	HTKLib/HRec.c	/^   short state;         \/* State level traceback info *\/$/;"	m	struct:align	file:
state	HTKTools/HHEd.c	/^   int    state;             \/* state containing this component *\/$/;"	m	struct:_CoList	file:
state	HTKTools/HHEd.c	/^   int state;                   \/* state (or 0 if hmm tree) *\/$/;"	m	struct:_Tree	file:
state	HTKTools/HHEd.c	/^   short state;                 \/* state of clink *\/$/;"	m	struct:_CRec	file:
stateCounter	HTKLib/HModel.h	/^   int stateCounter;    \/* # of state occurrences *\/$/;"	m	struct:__anon126
stateOutP	HTKLVRec/HLVRec.h	/^   LogFloat *stateOutP;$/;"	m	struct:_OutPCache
stateT	HTKLVRec/HLVRec.h	/^   int *stateT;$/;"	m	struct:_OutPCache
state_size_	HTKLVRec/kenlm/lm/virtual_interface.hh	/^    const size_t state_size_;$/;"	m	class:lm::base::Model
states	HTKLib/HRec.c	/^   Boolean states;          \/* Keep track of state history *\/$/;"	m	struct:precinfo	file:
states	HTKTools/HVite.c	/^static Boolean states = FALSE;    \/* Keep track of state alignment *\/$/;"	v	file:
staticSemiTied	HTKLib/HAdapt.c	/^static Boolean staticSemiTied = FALSE;$/;"	v	file:
stats	HTKLVRec/HLVRec.h	/^   Stats stats;                 \/* statistics about pruning etc. *\/$/;"	m	struct:_DecoderInst
stats	HTKTools/HERest.c	/^static Boolean stats = FALSE;    \/* enable statistics reports *\/$/;"	v	file:
stats	HTKTools/HMMIRest.c	/^static Boolean stats = FALSE;    \/* enable statistics reports *\/$/;"	v	file:
stats	HTKTools/HSGen.c	/^static Boolean stats = FALSE;       \/* enable grammar stats estimation *\/$/;"	v	file:
stats	HTKTools/HSmooth.c	/^static Boolean stats = FALSE;    \/* enable statistics reports *\/$/;"	v	file:
status	HTKLib/HAudio.c	/^   AudioInStatus status;     \/* current status of this audio stream *\/$/;"	m	struct:_AudioIn	file:
status	HTKLib/HParm.c	/^   PBStatus status;    \/* status of this buffer *\/$/;"	m	struct:_ParmBuf	file:
stdBuf	HLMTools/LAdapt.c	/^static ShiftReg  stdBuf;            \/* used for normal N-gram processing *\/$/;"	v	file:
stdBuf	HLMTools/LGPrep.c	/^static ShiftReg stdBuf;             \/* used for normal N-gram processing *\/$/;"	v	file:
stdGC	HTKTools/HHEd.c	/^static float meanGC,stdGC;             \/* mean and stdev of GConst *\/$/;"	v	file:
ste	HTKLib/HUtil.h	/^   StreamElem *ste;  \/* ->current streamElem *\/$/;"	m	struct:__anon169
stenSet	HTKTools/HCopy.c	/^static Boolean stenSet=FALSE;   \/* set if either st or en set *\/$/;"	v	file:
step	HTKTools/HSLab.c	/^   float step;$/;"	m	struct:__anon213	file:
stindex	HTKLib/HShell.c	/^   long stindex;                        \/* start sample to extract *\/$/;"	m	struct:__anon150	file:
stlLinkN	HTKLVRec/HLVNet.c	/^int stlLinkN = 0;$/;"	v
stlNodeN	HTKLVRec/HLVNet.c	/^int stlNodeN = 0;$/;"	v
stone_	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^    unsigned char stone_;$/;"	m	class:util::stream::WorkerProgress
stones_written_	HTKLVRec/kenlm/util/ersatz_progress.hh	/^    unsigned char stones_written_;$/;"	m	class:util::ErsatzProgress
stopSignalled	HTKLib/HAudio.c	/^static volatile Boolean stopSignalled;$/;"	v	file:
storage_	HTKLVRec/kenlm/util/pcqueue.hh	/^  boost::scoped_array<T> storage_;$/;"	m	class:util::PCQueue
store	HLMTools/Cluster.c	/^static bi_count    *store;                  \/* Store of current word w (w,*) pairs *\/$/;"	v	file:
storeMInfo	HTKLib/HAdapt.c	/^static Boolean storeMInfo = TRUE;      \/* whether original model information  is to be stored *\/$/;"	v	file:
store_idx	HLMTools/Cluster.c	/^static int          store_idx;              \/* Next index of second word in bigram *\/$/;"	v	file:
str	HTKLib/HGraf.h	/^   char *str;                 \/* string in button *\/$/;"	m	struct:_HButton
str	HTKTools/HCopy.c	/^   char *str;                   \/* output string *\/$/;"	m	struct:_TrList	file:
stream	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^namespace util { namespace stream { class ChainPositions; } }$/;"	n	namespace:util
stream	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^namespace stream {$/;"	n	namespace:util
stream	HTKLVRec/kenlm/lm/builder/initial_probabilities.hh	/^namespace util { namespace stream { class Chains; } }$/;"	n	namespace:util
stream	HTKLVRec/kenlm/lm/builder/output.hh	/^namespace util { namespace stream { class Chains; class ChainPositions; } }$/;"	n	namespace:util
stream	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^namespace util { namespace stream { class ChainPositions; } }$/;"	n	namespace:util
stream	HTKLVRec/kenlm/util/stream/block.hh	/^namespace stream {$/;"	n	namespace:util
stream	HTKLVRec/kenlm/util/stream/chain.cc	/^namespace stream {$/;"	n	namespace:util	file:
stream	HTKLVRec/kenlm/util/stream/chain.hh	/^namespace stream {$/;"	n	namespace:util
stream	HTKLVRec/kenlm/util/stream/config.hh	/^namespace util { namespace stream {$/;"	n	namespace:util
stream	HTKLVRec/kenlm/util/stream/io.cc	/^namespace stream {$/;"	n	namespace:util	file:
stream	HTKLVRec/kenlm/util/stream/io.hh	/^namespace stream {$/;"	n	namespace:util
stream	HTKLVRec/kenlm/util/stream/line_input.cc	/^namespace util { namespace stream {$/;"	n	namespace:util	file:
stream	HTKLVRec/kenlm/util/stream/line_input.hh	/^namespace util {namespace stream {$/;"	n	namespace:util
stream	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^namespace util { namespace stream {$/;"	n	namespace:util	file:
stream	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^namespace util { namespace stream {$/;"	n	namespace:util
stream	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^namespace util { namespace stream {$/;"	n	namespace:util
stream	HTKLVRec/kenlm/util/stream/sort.hh	/^namespace stream {$/;"	n	namespace:util
stream	HTKLVRec/kenlm/util/stream/stream.hh	/^namespace stream {$/;"	n	namespace:util
stream	HTKLib/HAudio.c	/^   SStream stream;$/;"	m	struct:_AudioIn	file:
stream	HTKLib/HAudio.c	/^   SStream stream;$/;"	m	struct:_AudioOut	file:
stream	HTKLib/HModel.h	/^   int stream;          \/* enables multi-stream semi-tied transforms *\/$/;"	m	struct:__anon120
stream	HTKTools/HHEd.c	/^   int    stream;            \/* stream for this component *\/$/;"	m	struct:_CoList	file:
streamMode	HLMTools/LPlex.c	/^static Boolean streamMode = FALSE;  \/* stream mode *\/$/;"	v	file:
stream_	HTKLVRec/kenlm/lm/builder/ngram_stream.hh	/^    util::stream::Stream stream_;$/;"	m	class:lm::builder::NGramStream
stream_	HTKLVRec/kenlm/util/exception.hh	/^    std::stringstream stream_;$/;"	m	class:util::Exception
stream_	HTKLVRec/kenlm/util/read_compressed.cc	/^    bz_stream stream_;$/;"	m	class:util::__anon79::BZip	file:
stream_	HTKLVRec/kenlm/util/read_compressed.cc	/^    lzma_stream stream_;$/;"	m	class:util::__anon79::XZip	file:
stream_	HTKLVRec/kenlm/util/read_compressed.cc	/^    std::istream &stream_;$/;"	m	class:util::__anon79::IStreamReader	file:
stream_	HTKLVRec/kenlm/util/read_compressed.cc	/^    z_stream stream_;$/;"	m	class:util::__anon79::GZip	file:
string_backing_	HTKLVRec/kenlm/lm/vocab.hh	/^    util::Pool string_backing_;$/;"	m	class:lm::ngram::SortedVocabulary
strings_to_enumerate_	HTKLVRec/kenlm/lm/vocab.hh	/^    std::vector<StringPiece> strings_to_enumerate_;$/;"	m	class:lm::ngram::SortedVocabulary
stripContexts	HTKTools/HResults.c	/^static Boolean stripContexts = FALSE; \/* strip triphone contexts *\/$/;"	v	file:
stripTriPhones	HTKLib/HLabel.c	/^static Boolean stripTriPhones = FALSE;   \/* Enable triPhone stripping *\/$/;"	v	file:
strlen_LEVELSEP	HTKLib/HLabel.c	581;"	d	file:
strmProj	HTKLib/HTrain.c	/^Boolean strmProj = FALSE; $/;"	v
stroutp	HTKTools/HRest.c	/^static Vector **stroutp;   \/* array[1..maxT][2..nStates-1][1..nStreams] ...*\/$/;"	v	file:
structure	HTKLib/HModel.h	/^   Ptr structure;          \/* -> shared structure or HMM Def *\/$/;"	m	struct:_MacroDef
style	HTKLib/HParm.c	/^   CodeStyle style;   \/* style encoding *\/$/;"	m	struct:__anon141	file:
sub	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Cell	file:
sub	HTKTools/HResults.c	/^   int ins,del,sub,hit;$/;"	m	struct:_Spkr	file:
sub	HTKTools/HResults.c	/^static long sub   = 0;     \/* Total substitutions *\/$/;"	v	file:
subLatEnd	HTKLib/HNet.c	/^char *subLatEnd="!)_SUBLAT",subLatEndBuf[MAXSTRLEN];$/;"	v
subLatEndBuf	HTKLib/HNet.c	/^char *subLatEnd="!)_SUBLAT",subLatEndBuf[MAXSTRLEN];$/;"	v
subLatId	HTKLib/HNet.h	/^   LabId subLatId;              \/* Lattice Identifier (for SubLats only) *\/$/;"	m	struct:lattice
subLatStart	HTKLib/HNet.c	/^char *subLatStart="!SUBLAT_(",subLatStartBuf[MAXSTRLEN];$/;"	v
subLatStartBuf	HTKLib/HNet.c	/^char *subLatStart="!SUBLAT_(",subLatStartBuf[MAXSTRLEN];$/;"	v
subLatWord	HTKLib/HDict.h	/^   Word subLatWord;     \/* special word for HNet subLats *\/$/;"	m	struct:__anon94
subList	HTKLib/HNet.h	/^   SubLatDef *subList;          \/* List of sublats in this lattice level *\/$/;"	m	struct:lattice
subNetHeap	HTKTools/HParse.c	/^static MemHeap subNetHeap;$/;"	v	file:
subNetId	HTKTools/HParse.c	/^static LabId  subNetId;$/;"	v	file:
subNetStoreHeap	HTKTools/HParse.c	/^MemHeap  subNetStoreHeap;$/;"	v
subPen	HTKTools/HResults.c	/^static const int subPen = 10;     \/* error penalties *\/$/;"	v	file:
subPenNIST	HTKTools/HResults.c	/^static const int subPenNIST = 4;  \/* NIST error penalties *\/$/;"	v	file:
subdir	HTKLib/HLabel.h	/^   char *subdir;     \/* Sub-directory to search for MLF_SIMPLE & MLF_FULL *\/$/;"	m	union:__anon110
subfields	HTKLib/esignal.h	/^    FieldList   subfields;      \/* field specs of subfields *\/$/;"	m	struct:FieldSpec
sublat	HTKLib/HNet.h	/^   SubLatDef *sublat;  \/* SubLat for node (if word==lat->voc->subLatWord) *\/$/;"	m	struct:lnode
sublatdef	HTKLib/HNet.h	/^typedef struct sublatdef {$/;"	s
sublatmarkers	HTKLib/HNet.c	/^Boolean sublatmarkers=FALSE;$/;"	v
substr	HTKLVRec/kenlm/util/string_piece.cc	/^StringPiece StringPiece::substr(size_type pos, size_type n) const {$/;"	f	class:StringPiece
substring	HTKLVRec/kenlm/lm/filter/phrase.hh	/^      std::vector<unsigned int> substring, left, right, phrase;$/;"	m	struct:lm::phrase::Substrings::SentenceRelation
substrings_	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    const Substrings &substrings_;$/;"	m	class:lm::phrase::detail::ConditionCommon
succ	HTKLib/HLabel.h	/^   LLink succ;              \/* Successor label *\/$/;"	m	struct:_Label
succ	HTKTools/HParse.c	/^   LinkSet *succ;    \/* successors to this node *\/$/;"	m	struct:_Node	file:
sum	HTKTools/HHEd.c	/^   Vector sum;                  \/* the sum, sqr and occupation  *\/$/;"	m	struct:_AccSum	file:
sumDur	HTKTools/HLStats.c	/^   float sumDur;                 \/* Total duration *\/$/;"	m	struct:wordinfo	file:
sumTokPerTS	HTKLVRec/HLVRec.h	/^   unsigned long sumTokPerTS;$/;"	m	struct:_Stats
sum_of_all_bigram_counts	HLMTools/Cluster.c	/^static int         sum_of_all_bigram_counts;\/* Sum of all bigram counts *\/$/;"	v	file:
sum_of_all_uni_counts	HLMTools/Cluster.c	/^static int         sum_of_all_uni_counts;   \/* Sum of all unigram counts *\/$/;"	v	file:
svec	HTKLib/HModel.h	/^   StateElem *svec;        \/* array[2..numStates-1] of StateElem *\/  $/;"	m	struct:__anon128
sw	HTKLib/HAudio.c	/^   long sw;$/;"	m	struct:_AudioIn	file:
sw	HTKLib/HAudio.c	/^   long sw;$/;"	m	struct:_AudioOut	file:
swap	HTKLVRec/kenlm/lm/trie_sort.cc	/^    friend void swap(PartialViewProxy first, PartialViewProxy second) {$/;"	f	class:lm::ngram::trie::__anon60::PartialViewProxy
swap	HTKLVRec/kenlm/util/joint_sort.hh	/^    friend void swap(JointIter &first, JointIter &second) {$/;"	f	class:util::detail::JointIter
swap	HTKLVRec/kenlm/util/joint_sort.hh	/^    friend void swap(JointProxy<KeyIter, ValueIter> first, JointProxy<KeyIter, ValueIter> second) {$/;"	f	class:util::detail::JointProxy
swap	HTKLVRec/kenlm/util/sized_iterator.hh	/^    friend void swap(SizedInnerIterator &first, SizedInnerIterator &second) {$/;"	f	class:util::SizedInnerIterator
swap	HTKLVRec/kenlm/util/sized_iterator.hh	/^    friend void swap(SizedProxy first, SizedProxy second) {$/;"	f	class:util::SizedProxy
swapXForm	HTKLib/HModel.h	/^  struct _AdaptXForm  *swapXForm;    \/* has this transform been swapped with parent *\/$/;"	m	struct:_AdaptXForm	typeref:struct:_AdaptXForm::_AdaptXForm
swapXForms	HTKLib/HAdapt.c	/^static Boolean swapXForms = FALSE;     \/* swap the transforms around after generating transform *\/$/;"	v	file:
swidth	HTKLib/HModel.h	/^   short swidth[SMAX];     \/* [0]=num streams,[i]=width of stream i *\/$/;"	m	struct:_HMMSet
swidth	HTKLib/HModel.h	/^  IntVec swidth;       \/* stream width size *\/$/;"	m	struct:__anon129
swidth	HTKLib/HParm.h	/^   short swidth[SMAX];   \/* [0]=num streams,[i]=width of stream i *\/$/;"	m	struct:__anon147
swidth	HTKLib/HVQ.h	/^   short swidth[SMAX];  \/* sw[0]=num streams, sw[i]=width of stream i *\/$/;"	m	struct:_VQTabRec
swidth	HTKTools/HQuant.c	/^static short swidth[SMAX];          \/* stream widths *\/$/;"	v	file:
swidth0	HTKTools/HCopy.c	/^int swidth0 = 1;$/;"	v
sym	HTKLib/HModel.c	/^   Symbol sym;          \/* the current input symbol *\/$/;"	m	struct:__anon119	file:
sym	HTKLib/HModel.c	/^   Symbol sym; } symMap[] = $/;"	m	struct:__anon118	file:
symMap	HTKLib/HModel.c	/^   Symbol sym; } symMap[] = $/;"	v	typeref:struct:__anon118	file:
symNames	HTKLib/HModel.c	/^static char *symNames[NULLSYM+1];$/;"	v	file:
symbol	HTKTools/HParse.c	/^static enum _Symbol symbol;         \/* Current symbol *\/$/;"	v	typeref:enum:_Symbol	file:
sysconfdir	HLMLib/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	HLMTools/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	HTKLVRec/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	HTKLib/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	HTKTools/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
sysconfdir	Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
systems	HTKLVRec/kenlm/lm/filter/format.hh	/^      std::vector<size_t> systems;$/;"	m	struct:lm::MultipleOutputBuffer::Annotated
t	HTKLVRec/HLVRec.h	/^   int t;$/;"	m	struct:_LMNodeCache
t	HTKLib/HArc.c	/^   struct _ArcList *t;$/;"	m	struct:_ArcList	typeref:struct:_ArcList::_ArcList	file:
t	HTKLib/HFBLat.c	/^   struct _CorrectArcList *t;$/;"	m	struct:_CorrectArcList	typeref:struct:_CorrectArcList::_CorrectArcList	file:
t	HTKLib/HNet.c	/^   int t;$/;"	m	struct:pinstinfo	file:
tBuf	HTKLib/HRec.c	/^   Token *tBuf;             \/* Buffer Array[2..N-1] of tok for StepHMM1 *\/$/;"	m	struct:psetinfo	file:
tIdx	HTKLib/HModel.h	/^   int tIdx;               \/* Transition matrix index *\/$/;"	m	struct:__anon128
tMPruneThresh	HTKTools/HRest.c	/^static float tMPruneThresh = 10.0;    \/* tied mix prune threshold *\/$/;"	v	file:
tProb	HTKTools/HHEd.c	/^   float tProb;                 \/* likelihood of total cluster *\/$/;"	m	struct:_Node	file:
tStack	HTKTools/HCopy.c	/^static MemHeap tStack;          \/* trace list  stack *\/$/;"	v	file:
tType	HTKTools/HQuant.c	/^static TreeType tType = linTree;    \/* codebook structure *\/$/;"	v	file:
t_end	HTKLib/HArc.h	/^  int t_end;$/;"	m	struct:_Arc
t_end	HTKLib/HArc.h	/^  int t_start, t_end;$/;"	m	struct:_Acoustic
t_start	HTKLib/HArc.h	/^  int t_start, t_end;$/;"	m	struct:_Acoustic
t_start	HTKLib/HArc.h	/^  int t_start;$/;"	m	struct:_Arc
tabFN	HTKLib/HVQ.h	/^   char * tabFN;        \/* name of this VQ table *\/$/;"	m	struct:_VQTabRec
table_	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    Table table_;$/;"	m	class:lm::phrase::Substrings
table_	HTKLVRec/kenlm/lm/quantize.hh	/^        const Bins *table_;$/;"	m	class:lm::ngram::SeparatelyQuantize::LongestPointer
tables_	HTKLVRec/kenlm/lm/quantize.hh	/^    Bins tables_[KENLM_MAX_ORDER - 1][2];$/;"	m	class:lm::ngram::SeparatelyQuantize
tact	HTKLib/HRec.c	/^   int tact;                \/* Cummulative number of active instances *\/$/;"	m	struct:precinfo	file:
tag	HTKLib/HNet.h	/^   char    *tag;        \/* Semantic tagging information *\/$/;"	m	struct:_NetNode
tag	HTKLib/HNet.h	/^   char *tag;          \/* Semantic tag for this node *\/$/;"	m	struct:lnode
tagSentStart	HLMTools/LGPrep.c	/^static Boolean tagSentStart = FALSE;\/* tag senetence start words with _ *\/$/;"	v	file:
tagSources	HTKTools/HDMan.c	/^static Boolean tagSources = FALSE;   \/* tag output words with name of source dict *\/$/;"	v	file:
tail	HLMTools/LGPrep.c	/^   RuleDef * tail;            \/* tail of list of rules *\/$/;"	m	struct:__anon31	file:
tail	HTKLib/HLabel.h	/^   LLink tail;              \/* Pointer to tail of List *\/$/;"	m	struct:_LabList
tail	HTKLib/HLabel.h	/^   LabList *tail;          \/* Pointer to tail of Label List *\/$/;"	m	struct:__anon108
tail	HTKLib/HRec.c	/^   NetInst tail;            \/* Tail (newest) of Inst linked list *\/$/;"	m	struct:precinfo	file:
takeLogs	HTKLib/HSigP.h	/^   Boolean takeLogs;    \/* log filterbank channels *\/$/;"	m	struct:__anon159
target	HLMLib/Makefile	/^target  = HLMLib.a$/;"	m
target	HTKLib/Makefile	/^target = HTKLib.a$/;"	m
task_	HTKLVRec/kenlm/util/pcqueue.hh	/^    task_t task_;$/;"	m	class:util::Semaphore
tee	HTKLib/HNet.c	/^   Boolean tee;     \/* TRUE if word consists solely of tee models *\/$/;"	m	struct:pronholder	file:
teeWords	HTKLib/HNet.h	/^   Boolean teeWords;  \/* True if any tee words are present *\/$/;"	m	struct:__anon139
tempArcStack	HTKLib/HArc.c	/^static MemHeap tempArcStack;                  \/* for temporary structures. *\/$/;"	v	file:
tempHeap	HLMTools/LPlex.c	/^MemHeap tempHeap;                   \/* Stores data valid only for file *\/$/;"	v
tempHeap	HTKTools/HLEd.c	/^static MemHeap tempHeap;            \/* Storage for current file *\/$/;"	v	file:
tempHeap	HTKTools/HResults.c	/^MemHeap tempHeap;                     \/* Stores data valid only for file *\/$/;"	v
tempStack	HTKLib/HFBLat.h	/^  MemHeap tempStack;$/;"	m	struct:__anon102
tempTS	HTKLVRec/HLVRec.h	/^   TokenSet **tempTS;           \/* temp tokset arrays for PropagateInternal() *\/$/;"	m	struct:_DecoderInst
temp_prefix	HTKLVRec/kenlm/util/stream/config.hh	/^  std::string temp_prefix;$/;"	m	struct:util::stream::SortConfig
temporary_directory_prefix	HTKLVRec/kenlm/lm/config.hh	/^  std::string temporary_directory_prefix;$/;"	m	struct:lm::ngram::Config
test	HTKTools/HResults.c	/^static LabList *ref,*test;            \/* the labels being compared *\/$/;"	v	file:
testInfo	HLMTools/LPlex.c	/^static int     testInfo[MAX_TEST];  \/* the array of test records *\/$/;"	v	file:
text_	HTKLVRec/kenlm/util/exception.hh	/^    mutable std::string text_;$/;"	m	class:util::Exception
texttt AT i j prob itemList t	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection{\\texttt{AT i j prob itemList(t)}}$/;"	b
tff	HTKTools/HResults.c	/^static FileFormat tff   = UNDEFF;     \/* ff of test transcription files *\/$/;"	v	file:
tgInfo	HLMLib/LModel.h	/^   TuringGoodInfo tgInfo;   \/* Turing-Good discounting *\/$/;"	m	union:__anon11
tgt	HLMTools/LGPrep.c	/^   FieldVec tgt;              \/* replacement part of rule *\/$/;"	m	struct:ruledef	file:
tgtFF	HTKLib/HParm.c	/^   FileFormat tgtFF;          \/* Target File format *\/ $/;"	m	struct:__anon141	file:
tgtFF	HTKLib/HParm.h	/^   FileFormat tgtFF;          \/* Target File format *\/ $/;"	m	struct:__anon149
tgtFF	HTKTools/HCopy.c	/^FileFormat tgtFF     = UNDEFF;$/;"	v
tgtFN	HLMTools/HLMCopy.c	/^static char      *tgtFN = NULL;          \/* target file name *\/$/;"	v	file:
tgtFN	HLMTools/LBuild.c	/^static char *tgtFN   = NULL;        \/* output LM filename *\/$/;"	v	file:
tgtFN	HLMTools/LMerge.c	/^static char      *tgtFN;                 \/* output model name *\/$/;"	v	file:
tgtFN	HLMTools/LNorm.c	/^static char      *tgtFN = NULL;          \/* target file name *\/$/;"	v	file:
tgtHdr	HTKTools/HList.c	/^static Boolean tgtHdr  = FALSE;  \/* print target header info *\/$/;"	v	file:
tgtLM	HLMTools/LBuild.c	/^static BackOffLM *tgtLM = NULL;     \/* the generated LM *\/$/;"	v	file:
tgtLM	HLMTools/LMerge.c	/^static BackOffLM *tgtLM;                 \/* target lm *\/$/;"	v	file:
tgtLabFF	HTKTools/HCopy.c	/^FileFormat tgtLabFF  = UNDEFF;$/;"	v
tgtPK	HTKLib/HParm.c	/^   ParmKind tgtPK;            \/* Target ParmKind *\/ $/;"	m	struct:__anon141	file:
tgtPK	HTKLib/HParm.h	/^   ParmKind tgtPK;            \/* Target ParmKind *\/ $/;"	m	struct:__anon149
tgtPK	HTKTools/HCopy.c	/^ParmKind tgtPK       = ANON;$/;"	v
tgtSampRate	HTKLib/HParm.c	/^   HTime tgtSampRate;         \/* Target Sample Rate *\/ $/;"	m	struct:__anon141	file:
tgtSampRate	HTKLib/HParm.h	/^   HTime tgtSampRate;         \/* Target Sample Rate *\/ $/;"	m	struct:__anon149
tgtSampRate	HTKTools/HCopy.c	/^HTime tgtSampRate    = 0.0;$/;"	v
tgtUsed	HTKLib/HParm.c	/^   int tgtUsed;       \/* num columns which will be used once converted *\/$/;"	m	struct:__anon141	file:
tgtVecSize	HTKLib/HParm.h	/^   int tgtVecSize;            \/* Size of target vector *\/$/;"	m	struct:__anon149
tgtVoc	HLMTools/LAdapt.c	/^static WordMap   *tgtVoc = NULL;    \/* target vocabulary *\/          $/;"	v	file:
theBitmap	HTKLib/HGraf_WIN32.c	/^static HBITMAP  theBitmap;        \/* Internal representation of window contents *\/$/;"	v	file:
theBrush	HTKLib/HGraf_WIN32.c	/^static HBRUSH theBrush = NULL;      \/* Used to fill solid areas *\/$/;"	v	file:
theCmap	HTKLib/HGraf.c	/^static Colormap      theCmap;$/;"	v	file:
theDisp	HTKLib/HGraf.c	/^static Display       *theDisp;                           $/;"	v	file:
theFont	HTKLib/HGraf_WIN32.c	/^static HFONT theFont   = NULL;      \/* Current font for text output *\/$/;"	v	file:
theGC	HTKLib/HGraf.c	/^static GC            theGC;$/;"	v	file:
thePen	HTKLib/HGraf_WIN32.c	/^static HPEN thePen     = NULL;      \/* Used to draw lines *\/$/;"	v	file:
theScreen	HTKLib/HGraf.c	/^static int           theScreen;                          $/;"	v	file:
theVisual	HTKLib/HGraf.c	/^static Visual        *theVisual;$/;"	v	file:
theWindow	HTKLib/HGraf.c	/^static Window        rootW, theWindow;                   $/;"	v	file:
theWindow	HTKLib/HGraf_WIN32.c	/^static HWND theWindow = NULL;     \/* A handle to the graphics window *\/$/;"	v	file:
thinPen	HTKLib/HGraf_WIN32.c	/^static HPEN thinPen    = NULL;      \/* Always has width 1, needed for outlining filled shapes *\/$/;"	v	file:
thirdWin	HTKLib/HParm.c	/^   int thirdWin;              \/* Accel window halfsize *\/$/;"	m	struct:__anon141	file:
thisCommand	HTKTools/HHEd.c	/^static int thisCommand;                \/* index of current command *\/$/;"	v	file:
thisP	HTKTools/HInit.c	/^static Vector   thisP,lastP;     \/* Columns of log probabilities *\/$/;"	v	file:
thisWpos	HTKTools/HSLab.c	/^static int thisWpos, lastWpos;      \/* the positions of the waveform pointer *\/$/;"	v	file:
thread_	HTKLVRec/kenlm/util/stream/chain.hh	/^    boost::thread thread_;$/;"	m	class:util::stream::Thread
thread_	HTKLVRec/kenlm/util/thread_pool.hh	/^    boost::thread thread_;$/;"	m	class:util::Worker
threads_	HTKLVRec/kenlm/util/stream/chain.hh	/^    boost::ptr_vector<Thread> threads_;$/;"	m	class:util::stream::Chain
threads_	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^    boost::ptr_vector<util::stream::Thread> threads_;$/;"	m	class:util::stream::Chains
thresh	HTKLib/HModel.h	/^  float thresh;        \/* split threshold to determine stopping in tree *\/$/;"	m	struct:RegTree
threshold_	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    std::size_t threshold_;$/;"	m	class:util::AutoProbing
tid	HTKLib/HAudio.c	/^   ATransID tid;$/;"	m	struct:_AudioIn	file:
tid	HTKLib/HAudio.c	/^   ATransID tid;$/;"	m	struct:_AudioOut	file:
tiedMixName	HTKTools/HHEd.c	/^static char tiedMixName[MAXSTRLEN] = "TM"; \/* Tied mixture base name *\/$/;"	v	file:
time	HTKLib/HAdapt.c	/^   int time;$/;"	m	struct:_ObsCache	file:
time	HTKLib/HNet.h	/^   HTime time;         \/* Time of word boundary at node *\/$/;"	m	struct:lnode
time	HTKLib/HTrain.h	/^   int   time;       \/* time for which prob is valid *\/$/;"	m	struct:__anon164
time	HTKLib/HTrain.h	/^   int   time;       \/* time for which prob is valid *\/$/;"	m	struct:__anon167
timerDone	HTKLib/HGraf.c	/^static Boolean timerDone;$/;"	v	file:
tl	HTKLib/HTrain.h	/^   IBLink tl;        \/* tail of list of item blocks *\/$/;"	m	struct:__anon160
tlb	HLMLib/LWMap.h	/^   int *tlb;             \/* the actual lookup array *\/$/;"	m	struct:__anon22
tlev	HTKTools/HResults.c	/^static int tlev=0;                    \/* Label level to be scored *\/$/;"	v	file:
tmBeam	HTKLib/HRec.h	/^   LogFloat tmBeam;         \/* Beam width for tied mixtures *\/$/;"	m	struct:vrecinfo
tmBeam	HTKTools/HVite.c	/^static LogFloat tmBeam = 10.0;    \/* tied mix prune threshold *\/$/;"	v	file:
tmRecs	HTKLib/HModel.h	/^   TMixRec tmRecs[SMAX];   \/* array[1..S]of tied mixture record *\/$/;"	m	struct:_HMMSet
tmp	HLMTools/Cluster.c	/^static char        tmp[256];                \/* Scrap array *\/$/;"	v	file:
tmpCHeap	HTKTools/HSLab.c	/^static MemHeap tmpCHeap;     \/* storage allocated once *\/$/;"	v	file:
tmpHeap	HTKTools/HHEd.c	/^static MemHeap tmpHeap;     \/* Temporary (duration of command or less) heap *\/$/;"	v	file:
tmpHeap	HTKTools/HLStats.c	/^static MemHeap tmpHeap;             \/* Temporary storage *\/$/;"	v	file:
tmpStack	HTKTools/HSLab.c	/^static MemHeap tmpStack;     \/* temporary storage with reset *\/$/;"	v	file:
tmp_c1	HLMTools/Cluster.c	/^static int        *tmp_c1=NULL;             \/* Temporary set of bigrams (1) *\/$/;"	v	file:
tmp_c2	HLMTools/Cluster.c	/^static int        *tmp_c2=NULL;             \/* Temporary set of bigrams (2) *\/$/;"	v	file:
tmp_c3	HLMTools/Cluster.c	/^static int        *tmp_c3=NULL;             \/* Temporary set of bigrams (3) *\/$/;"	v	file:
tmp_c4	HLMTools/Cluster.c	/^static int        *tmp_c4=NULL;             \/* Temporary set of bigrams (4) *\/$/;"	v	file:
tmp_sum1	HLMTools/Cluster.c	/^static int        *tmp_sum1=NULL;           \/* Temporary word-class counts (1) *\/$/;"	v	file:
tmp_sum2	HLMTools/Cluster.c	/^static int        *tmp_sum2=NULL;           \/* Temporary word-class counts (2) *\/$/;"	v	file:
tnetHeap	HTKLVRec/HLVNet.c	/^static MemHeap tnetHeap;                \/* used for temporary data in net creation *\/$/;"	v	file:
to	HTKLVRec/kenlm/util/parallel_read.cc	/^      void *to;$/;"	m	struct:util::__anon78::Reader::Request	file:
to_	HTKLVRec/kenlm/lm/builder/print.hh	/^    int to_;$/;"	m	class:lm::builder::Print
to_	HTKLVRec/kenlm/lm/search_hashed.hh	/^    const float *to_;$/;"	m	class:lm::ngram::detail::LongestPointer
to_	HTKLVRec/kenlm/lm/trie.hh	/^    const ProbBackoff *to_;$/;"	m	class:lm::ngram::trie::UnigramPointer
to_	HTKLVRec/kenlm/lm/value.hh	/^    const Weights *to_;$/;"	m	class:lm::ngram::GenericProbingProxy
to_	HTKLVRec/kenlm/lm/value.hh	/^    const Weights *to_;$/;"	m	class:lm::ngram::GenericTrieUnigramProxy
to_read_	HTKLVRec/kenlm/lm/filter/thread.hh	/^    util::PCQueue<Batch*> to_read_;$/;"	m	class:lm::Controller
toggle	HTKLib/HGraf.h	/^   Boolean toggle;            \/* if true, clicking toggles state *\/$/;"	m	struct:_HButton
tok	HTKLib/HRec.c	/^   Token tok;                \/* Most likely Token in state *\/$/;"	m	struct:tokenset	file:
tokSetHeap	HTKLVRec/HLVRec.h	/^   MemHeap *tokSetHeap;         \/* MHEAPs for N TokenSet arrays *\/$/;"	m	struct:_DecoderInst
tokSetIdCount	HTKLVRec/HLVRec.h	/^   unsigned int tokSetIdCount;\/* max id used so far for token sets *\/$/;"	m	struct:_DecoderInst
token	HTKLib/HRec.h	/^typedef struct token$/;"	s
token_count	HTKLVRec/kenlm/lm/builder/header_info.hh	/^  uint64_t token_count;$/;"	m	struct:HeaderInfo
token_count_	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^    uint64_t &token_count_;$/;"	m	class:lm::builder::CorpusCount
tokenset	HTKLib/HRec.c	/^typedef struct tokenset$/;"	s	file:
top	HTKTools/HLEd.c	/^static int top=1;    \/* virtual top level of current label list *\/$/;"	v	file:
topM	HTKLib/HModel.h	/^   short topM;           \/* num TMProbs actually used *\/$/;"	m	struct:__anon124
top_builddir	Makefile	/^top_builddir = .$/;"	m
top_srcdir	HLMLib/Makefile	/^top_srcdir = ..$/;"	m
top_srcdir	HLMTools/Makefile	/^top_srcdir = ..$/;"	m
top_srcdir	HTKLVRec/Makefile	/^top_srcdir = ..$/;"	m
top_srcdir	HTKLib/Makefile	/^top_srcdir = ..$/;"	m
top_srcdir	HTKTools/Makefile	/^top_srcdir = ..$/;"	m
top_srcdir	Makefile	/^top_srcdir = .$/;"	m
totAlloc	HTKLib/HMem.h	/^   size_t totAlloc;     \/*  total #elems alloc'ed    total #bytes alloc'd *\/$/;"	m	struct:__anon116
totUsed	HTKLib/HMem.h	/^   size_t totUsed;      \/*  total #elems used        total #bytes used    *\/$/;"	m	struct:__anon116
total	HTKLib/HAudio.c	/^   int total;               \/* Total number of samples queued *\/$/;"	m	struct:_AudioIn	file:
total	HTKLib/HAudio.c	/^   int total;               \/* Total number of samples queued *\/$/;"	m	struct:_AudioOut	file:
totalConst	HTKTools/HMMIRest.c	/^static int totalConst=0,nonFlooredConst=0; \/*TODO: print.*\/$/;"	v	file:
totalCount	HTKTools/HCompV.c	/^static long totalCount=0;           \/* total number of vector samples*\/$/;"	v	file:
totalDur	HTKTools/HResults.c	/^static HTime totalDur = 0.0;          \/* total duration of test input *\/$/;"	v	file:
totalPr	HTKTools/HERest.c	/^static LogDouble totalPr=0;   \/* total log prob upto current utterance *\/$/;"	v	file:
totalPr	HTKTools/HSmooth.c	/^static LogDouble totalPr;    \/* total log prob of all training utterances *\/$/;"	v	file:
totalPr1	HTKTools/HMMIRest.c	/^static LogDouble totalPr1=0,totalPr2=0,totalPr3=0;              \/* total log prob upto current utterance, totalPr3 for MMI den in MPE with MMI Prior*\/$/;"	v	file:
totalPr2	HTKTools/HMMIRest.c	/^static LogDouble totalPr1=0,totalPr2=0,totalPr3=0;              \/* total log prob upto current utterance, totalPr3 for MMI den in MPE with MMI Prior*\/$/;"	v	file:
totalPr3	HTKTools/HMMIRest.c	/^static LogDouble totalPr1=0,totalPr2=0,totalPr3=0;              \/* total log prob upto current utterance, totalPr3 for MMI den in MPE with MMI Prior*\/$/;"	v	file:
totalProns	HTKTools/HDMan.c	/^   int totalProns;              \/* total prons in this source *\/$/;"	m	struct:__anon195	file:
totalT	HTKTools/HERest.c	/^static int totalT=0;       \/* total number of frames in training data *\/$/;"	v	file:
totalT	HTKTools/HMMIRest.c	/^static int totalT=0;                             \/* total number of frames in training data *\/$/;"	v	file:
totalT	HTKTools/HSmooth.c	/^static int totalT=0;         \/* total number of frames in training data *\/$/;"	v	file:
totalWords	HTKTools/HDMan.c	/^   int totalWords;              \/* total words in this source *\/$/;"	m	struct:__anon195	file:
total_bits_	HTKLVRec/kenlm/lm/trie.cc	/^    const uint8_t key_bits_, total_bits_;$/;"	m	class:lm::ngram::trie::__anon59::KeyAccessor	file:
total_bits_	HTKLVRec/kenlm/lm/trie.hh	/^    uint8_t total_bits_;$/;"	m	class:lm::ngram::trie::BitPacked
total_memory	HTKLVRec/kenlm/util/stream/config.hh	/^  std::size_t total_memory;$/;"	m	struct:util::stream::ChainConfig
total_memory	HTKLVRec/kenlm/util/stream/config.hh	/^  std::size_t total_memory;$/;"	m	struct:util::stream::SortConfig
total_memory_	HTKLVRec/kenlm/util/stream/sort.hh	/^    std::size_t total_memory_;$/;"	m	class:util::stream::MergingReader
total_order_	HTKLVRec/kenlm/lm/search_trie.cc	/^    const unsigned char total_order_;$/;"	m	class:lm::ngram::trie::__anon58::BlankManager	file:
total_size_	HTKLVRec/kenlm/util/file_piece.hh	/^    const uint64_t total_size_;$/;"	m	class:util::FilePiece
totals	HLMLib/LModel.h	/^   int *totals;              \/* array of class counts (sum of word counts for each class) *\/$/;"	m	struct:__anon15
totl	HLMTools/LPlex.c	/^static PStats  totl;                \/* global accumulator *\/$/;"	v	file:
tpdf	HTKLib/HModel.h	/^   Vector tpdf;          \/* TIEDHS *\/$/;"	m	union:__anon122
tr	HTKLib/HFB.h	/^  Transcription *tr;  \/* current transcription *\/$/;"	m	struct:__anon96
tr	HTKTools/HCopy.c	/^static Transcription *tr;       \/* current transcription *\/$/;"	v	file:
trC	HTKLib/HTrain.c	/^static int muC,vaC,trC,wtC,prC;$/;"	v	file:
trList	HTKTools/HCopy.c	/^static TrL trList;              \/* 1st element in trace linked list *\/$/;"	v	file:
trNum	HTKLib/HLabel.c	/^static double trNum;$/;"	v	file:
trStr	HTKLib/HLabel.c	/^static char trStr[256];$/;"	v	file:
trStr	HTKTools/HCopy.c	/^static TrPtr trStr = &trList;   \/* ptr to it *\/$/;"	v	file:
trSym	HTKLib/HLabel.c	/^static TrSymbol trSym = TRNULL;$/;"	v	file:
trace	HLMLib/LCMap.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LGBase.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LModel.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LPCalc.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LPMerge.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LUtil.c	/^static int trace = 0;$/;"	v	file:
trace	HLMLib/LWMap.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/Cluster.c	/^static int          trace = 0;              \/* trace setting *\/$/;"	v	file:
trace	HLMTools/HLMCopy.c	/^static int       trace = 0;              \/* trace level *\/$/;"	v	file:
trace	HLMTools/LAdapt.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LBuild.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LFoF.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LGCopy.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LGList.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LGPrep.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LLink.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LMerge.c	/^static int trace = 0;                    \/* trace level *\/$/;"	v	file:
trace	HLMTools/LNewMap.c	/^static int trace = 0;$/;"	v	file:
trace	HLMTools/LNorm.c	/^static int       trace = 0;              \/* trace level *\/$/;"	v	file:
trace	HLMTools/LPlex.c	/^static int trace = 0;               \/* trace level *\/$/;"	v	file:
trace	HLMTools/LSubset.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLVRec/HDecode.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLVRec/HDecode.mod.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLVRec/HLVLM.c	/^static int trace=0;$/;"	v	file:
trace	HTKLVRec/HLVModel.c	/^static int trace=0;$/;"	v	file:
trace	HTKLVRec/HLVNet.c	/^static int trace=0;$/;"	v	file:
trace	HTKLVRec/HLVRec.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HAdapt.c	/^static int trace = 0;                   \/* trace info *\/$/;"	v	file:
trace	HTKLib/HArc.c	/^static int trace=1;$/;"	v	file:
trace	HTKLib/HAudio.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HDict.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HFB.c	/^static int trace         =  0;$/;"	v	file:
trace	HTKLib/HFBLat.c	/^static int trace     =  1;            \/* Trace level *\/$/;"	v	file:
trace	HTKLib/HGraf.c	/^static int trace = 0;                   \/* Just for consistency *\/$/;"	v	file:
trace	HTKLib/HGraf.null.c	/^static int trace = 0;                   \/* Just for consistency *\/$/;"	v	file:
trace	HTKLib/HGraf_WIN32.c	/^static int trace = 0;                   \/* Just for consistency *\/$/;"	v	file:
trace	HTKLib/HLM.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HLabel.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HLat.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HMap.c	/^static int trace     = 0;        \/* Trace level *\/$/;"	v	file:
trace	HTKLib/HMath.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HMem.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HModel.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HNet.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HParm.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HRec.c	/^static int trace=0;$/;"	v	file:
trace	HTKLib/HShell.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HSigP.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HTrain.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HUtil.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HVQ.c	/^static int trace = 0;$/;"	v	file:
trace	HTKLib/HWave.c	/^static int trace = 0;$/;"	v	file:
trace	HTKTools/HBuild.c	/^static int trace     = 0;           \/* Trace flags *\/$/;"	v	file:
trace	HTKTools/HCompV.c	/^static int  trace    = 0;           \/* trace level *\/$/;"	v	file:
trace	HTKTools/HCopy.c	/^static int  trace  = 0;         \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HDMan.c	/^static int  trace    = 0;           \/* trace level *\/$/;"	v	file:
trace	HTKTools/HERest.c	/^static int trace     = 0;        \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HHEd.c	/^static int  trace    = 0;        \/* current trace level *\/$/;"	v	file:
trace	HTKTools/HInit.c	/^static int trace = 0;               \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HLEd.c	/^static int  trace    = 0;           \/* trace level *\/$/;"	v	file:
trace	HTKTools/HLRescore.c	/^static int trace = 0;$/;"	v	file:
trace	HTKTools/HLStats.c	/^static int trace = 0;               \/* trace level *\/$/;"	v	file:
trace	HTKTools/HList.c	/^static int trace = 0;$/;"	v	file:
trace	HTKTools/HMMIRest.c	/^static long int trace     = 1;        \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HParse.c	/^static int trace     = 0;         \/* Trace flags *\/$/;"	v	file:
trace	HTKTools/HQuant.c	/^static int trace = 0;               \/* trace level *\/$/;"	v	file:
trace	HTKTools/HRest.c	/^static int  trace    = 0;        \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HResults.c	/^static int trace = 0;               \/* trace level *\/$/;"	v	file:
trace	HTKTools/HSGen.c	/^static int trace = 0;$/;"	v	file:
trace	HTKTools/HSLab.c	/^static int trace = 0;                \/* trace level *\/$/;"	v	file:
trace	HTKTools/HSmooth.c	/^static int trace     = 0;        \/* Trace level *\/$/;"	v	file:
trace	HTKTools/HVite.c	/^static int trace = 0;$/;"	v	file:
traceBack	HTKTools/HInit.c	/^static short   **traceBack;      \/* array[1..segLen][2..numStates-1] *\/$/;"	v	file:
traceBackStack	HTKTools/HInit.c	/^static MemHeap traceBackStack;   \/* For storage of traceBack info *\/$/;"	v	file:
traceWidth	HTKTools/HCopy.c	/^static int traceWidth = 70;     \/* print this many chars before wrapping ln *\/$/;"	v	file:
tran	HTKLib/HTrain.h	/^   Matrix tran;      \/* array[1..N][1..N]of transition count *\/$/;"	m	struct:__anon163
trans	HTKTools/HCopy.c	/^static Transcription *trans=NULL;\/* main labels; cat all input to this *\/$/;"	v	file:
trans	HTKTools/HSLab.c	/^static Transcription *trans;    \/* the transcriptions *\/$/;"	v	file:
transAlt	HTKLib/HLabel.c	/^static int transAlt = 0;           \/* if >0 filter all but specified alt *\/$/;"	v	file:
transHeap	HTKLVRec/HDecode.c	/^static MemHeap transHeap;$/;"	v	file:
transHeap	HTKLVRec/HDecode.mod.c	/^static MemHeap transHeap;$/;"	v	file:
transHeap	HTKTools/HLRescore.c	/^static MemHeap transHeap;$/;"	v	file:
transHit	HTKLVRec/HLVRec.h	/^   int transHit;$/;"	m	struct:_LMCache
transLev	HTKLib/HLabel.c	/^static int transLev = 0;           \/* if >0 filter all but specified level *\/$/;"	v	file:
transMiss	HTKLVRec/HLVRec.h	/^   int transMiss;$/;"	m	struct:_LMCache
transP	HTKLib/HModel.h	/^   SMatrix transP;         \/* transition matrix (logs) *\/$/;"	m	struct:__anon128
transProb	HTKLVRec/HLVLM.h	/^   LogFloat (*transProb) (FSLM *lm, LMState src, PronId pronId, LMState *dest);$/;"	m	struct:_FSLM
transStack	HTKLib/HFB.h	/^  MemHeap transStack; \/* utterance transcript information heap *\/$/;"	m	struct:__anon96
transStack	HTKTools/HInit.c	/^static MemHeap transStack;       \/* For storage of transcription *\/$/;"	v	file:
transStack	HTKTools/HMMIRest.c	/^static MemHeap transStack;         \/* Transcriptions... comment in original HERest says transformations, but it's wrong.*\/$/;"	v	file:
transStack	HTKTools/HRest.c	/^static MemHeap transStack;       \/* For storage of transcription *\/$/;"	v	file:
transform	Makefile	/^transform = s,x,x,$/;"	m
translm	HTKLib/HExactMPE.c	83;"	d	file:
translm	HTKLib/HFBLat.c	145;"	d	file:
tree	HTKLib/HVQ.h	/^   VQNode tree[SMAX];   \/* 1 tree per stream *\/$/;"	m	struct:_VQTabRec
treeList	HTKTools/HHEd.c	/^static Tree *treeList = NULL;   \/* list of trees *\/$/;"	v	file:
treeMerge	HTKTools/HHEd.c	/^static Boolean treeMerge = TRUE; \/* After tree spltting merge leaves *\/$/;"	v	file:
treeName	HTKTools/HHEd.c	/^static char treeName[256] = "";$/;"	v	file:
triSize	HTKTools/HHEd.c	/^static int triSize;        \/* num items in triTab *\/$/;"	v	file:
triStrip	HTKTools/HLEd.c	/^static Boolean triStrip = FALSE;    \/* ignore triphone contexts in matching *\/$/;"	v	file:
triTab	HTKTools/HHEd.c	/^static TriRec *triTab;     \/* array[0..triSize-1] of TriRec; *\/$/;"	v	file:
trie	HTKLVRec/kenlm/lm/bhiksha.cc	/^namespace trie {$/;"	n	namespace:lm::ngram	file:
trie	HTKLVRec/kenlm/lm/bhiksha.hh	/^namespace trie {$/;"	n	namespace:lm::ngram
trie	HTKLVRec/kenlm/lm/search_trie.cc	/^namespace trie {$/;"	n	namespace:lm::ngram	file:
trie	HTKLVRec/kenlm/lm/search_trie.hh	/^namespace trie {$/;"	n	namespace:lm::ngram
trie	HTKLVRec/kenlm/lm/trie.cc	/^namespace trie {$/;"	n	namespace:lm::ngram	file:
trie	HTKLVRec/kenlm/lm/trie.hh	/^namespace trie {$/;"	n	namespace:lm::ngram
trie	HTKLVRec/kenlm/lm/trie_sort.cc	/^namespace trie {$/;"	n	namespace:lm::ngram	file:
trie	HTKLVRec/kenlm/lm/trie_sort.hh	/^namespace trie {$/;"	n	namespace:lm::ngram
ts	HTKLVRec/HLVRec.h	/^   TokenSet *ts;                \/* array of TokenSets; one per state (incl. entry and exit) *\/$/;"	m	struct:_LexNodeInst
tscale	HTKLib/HNet.h	/^   float tscale;                \/* time scale factor (default: 1, i.e. seconds) *\/$/;"	m	struct:lattice
tt AU hmmList	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt AU hmmList}$/;"	b
tt CL hmmList	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt CL hmmList}$/;"	b
tt CO newList	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt CO newList}$/;"	b
tt DP s n id	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt DP s n id ...}$/;"	b
tt FA varscale	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt FA varscale}$/;"	b
tt FC	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt FC}$/;"	b
tt FV file	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt FV file} $/;"	b
tt HK hsetkind	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt HK hsetkind}$/;"	b
tt JO size minw	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt JO size minw}$/;"	b
tt PR	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt PR }$/;"	b
tt PS nstates power numiters	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt PS nstates power [numiters]   }$/;"	b
tt QS name itemList h	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt QS name itemList(h)}$/;"	b
tt RC N identifier itemlist	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt RC N identifier [itemlist]}$/;"	b
tt TB f macro itemList s or h	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt TB f macro itemList(s or h)}$/;"	b
tt TC f macro itemList s	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt TC f macro itemList(s)}$/;"	b
tt TI macro itemList	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt TI macro itemList}$/;"	b
tt TR n	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt TR n}$/;"	b
tt UT itemList	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt UT itemList}$/;"	b
tt XF filename	HTKBook/HTKRef/HHEd.tex	/^\\subsubsection*{\\tt XF filename}$/;"	b
twoDataFiles	HTKLib/HFB.h	/^  Boolean twoDataFiles; \/* Using two data files *\/$/;"	m	struct:__anon96
twoDataFiles	HTKLib/HFBLat.h	/^  Boolean twoDataFiles;$/;"	m	struct:__anon102
twoDataFiles	HTKTools/HERest.c	/^static Boolean twoDataFiles = FALSE; \/* Enables creation of ot2 for FB$/;"	v	file:
twoDataFiles	HTKTools/HMMIRest.c	/^static Boolean twoDataFiles = FALSE; \/* For training using two data files, probably never needed & code not tested. *\/$/;"	v	file:
twoModels	HTKLib/HFB.h	/^  Boolean twoModels;  \/* Enable two model reestimation *\/$/;"	m	struct:__anon99
txtSrc	HLMTools/LAdapt.c	/^static char *txtSrc  = NULL;        \/* gram file text source descriptor *\/$/;"	v	file:
txtsrc	HLMLib/LGBase.h	/^   char txtsrc[MAXSTRLEN];  \/* text source description *\/$/;"	m	struct:__anon3
txtsrc	HLMTools/LGPrep.c	/^static char *txtsrc  = NULL;        \/* gram file text source descriptor *\/$/;"	v	file:
type	HTKLVRec/HLVLM.h	/^   FSLMType type;$/;"	m	struct:_FSLM
type	HTKLVRec/HLVNet.c	/^   STLexNodeType type;$/;"	m	struct:_STLexNode	file:
type	HTKLVRec/HLVNet.h	/^   LexNodeType type;$/;"	m	struct:_TLexNode
type	HTKLVRec/HLVNet.h	/^   unsigned char type;          \/* using char instead of enum can save 4 bytes! *\/$/;"	m	struct:_LexNode
type	HTKLVRec/kenlm/util/stream/chain.hh	/^      typedef Chain type;$/;"	t	struct:util::stream::Chain::CheckForRun
type	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^      typedef Chains type;$/;"	t	struct:util::stream::Chains::CheckForRun
type	HTKLib/HLM.h	/^   LMType type;                 \/* LM type *\/$/;"	m	struct:lmodel
type	HTKLib/HLabel.h	/^   MLFDefType type;     \/* type of this definition *\/$/;"	m	struct:_MLFEntry
type	HTKLib/HMem.h	/^   HeapType type;       \/*              type of this heap                 *\/$/;"	m	struct:__anon116
type	HTKLib/HModel.h	/^   char type;              \/* type of macro [hluvixdtmps*] *\/$/;"	m	struct:_MacroDef
type	HTKLib/HNet.h	/^   NetNodeType type;    \/* Type of this node (includes context) *\/$/;"	m	struct:_NetNode
type	HTKLib/HVQ.h	/^   TreeType type;       \/* linear or binary *\/$/;"	m	struct:_VQTabRec
type	HTKLib/esignal.h	/^    short       type;           \/* data type code *\/$/;"	m	struct:Array
type	HTKLib/esignal.h	/^    short       type;           \/* data type code *\/$/;"	m	struct:FieldSpec
type_	HTKLVRec/kenlm/lm/builder/output.hh	/^    const HookType type_;$/;"	m	class:lm::builder::OutputHook
type_count_	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^    WordIndex &type_count_;$/;"	m	class:lm::builder::CorpusCount
u4srt	HLMLib/LUtil.c	/^static void u4srt(int32 *data, int l, int r,$/;"	f	file:
uFlags	HTKLib/HFB.h	/^  UPDSet uFlags;      \/* parameter update flags *\/$/;"	m	struct:__anon99
uFlags	HTKLib/HFBLat.h	/^  UPDSet uFlags;$/;"	m	struct:__anon102
uFlags	HTKTools/HERest.c	/^static UPDSet uFlags = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES); \/* update flags *\/$/;"	v	file:
uFlags	HTKTools/HInit.c	/^static UPDSet uFlags = (UPDSet) (UPMEANS|UPVARS|UPMIXES|UPTRANS); \/* update flags *\/$/;"	v	file:
uFlags	HTKTools/HMMIRest.c	/^static UPDSet uFlags = UPMEANS|UPVARS|UPTRANS|UPMIXES;   \/* update flags *\/$/;"	v	file:
uFlags	HTKTools/HRest.c	/^static UPDSet uFlags = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES);     \/* update flags *\/$/;"	v	file:
uFlags	HTKTools/HSmooth.c	/^static UPDSet uFlags = (UPDSet) (UPMEANS|UPVARS|UPTRANS|UPMIXES);   \/* update flags *\/$/;"	v	file:
uFlagsAccs	HTKTools/HMMIRest.c	/^static UPDSet uFlagsAccs = UPMEANS|UPVARS|UPTRANS|UPMIXES;   \/* used in storing accs. *\/$/;"	v	file:
uFlagsMLE	HTKTools/HMMIRest.c	/^static UPDSet uFlagsMLE = 0; \/*which we only update with MLE, ignoring the MMI parameters.*\/$/;"	v	file:
uint16_t	HTKLVRec/kenlm/util/double-conversion/utils.h	/^typedef unsigned short uint16_t;  \/\/ NOLINT$/;"	t
uint32_t	HTKLVRec/kenlm/util/double-conversion/utils.h	/^typedef unsigned int uint32_t;$/;"	t
uint32_to_float	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^static float uint32_to_float(uint32_t d32) { return BitCast<float>(d32); }$/;"	f	namespace:double_conversion
uint64_t	HTKLVRec/kenlm/util/double-conversion/utils.h	/^typedef unsigned __int64 uint64_t;$/;"	t
uint64_to_double	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^static double uint64_to_double(uint64_t d64) { return BitCast<double>(d64); }$/;"	f	namespace:double_conversion
uint8_t	HTKLVRec/kenlm/util/double-conversion/utils.h	/^typedef unsigned char uint8_t;$/;"	t
ullAvailExtendedVirtual	HTKLVRec/kenlm/util/usage.cc	/^  DWORDLONG ullAvailExtendedVirtual;$/;"	m	struct:__anon82	file:
ullAvailPageFile	HTKLVRec/kenlm/util/usage.cc	/^  DWORDLONG ullAvailPageFile;$/;"	m	struct:__anon82	file:
ullAvailPhys	HTKLVRec/kenlm/util/usage.cc	/^  DWORDLONG ullAvailPhys;$/;"	m	struct:__anon82	file:
ullAvailVirtual	HTKLVRec/kenlm/util/usage.cc	/^  DWORDLONG ullAvailVirtual;$/;"	m	struct:__anon82	file:
ullTotalPageFile	HTKLVRec/kenlm/util/usage.cc	/^  DWORDLONG ullTotalPageFile;$/;"	m	struct:__anon82	file:
ullTotalPhys	HTKLVRec/kenlm/util/usage.cc	/^  DWORDLONG ullTotalPhys;$/;"	m	struct:__anon82	file:
ullTotalVirtual	HTKLVRec/kenlm/util/usage.cc	/^  DWORDLONG ullTotalVirtual;$/;"	m	struct:__anon82	file:
ultraKey	HLMLib/LModel.c	/^static short   ultraKey[KEY_LENGTH];    \/* Key used to identify ultra LMs *\/$/;"	v	file:
undo	HTKTools/HSLab.c	/^static UndoRecord undo;                \/* the undo record variable *\/$/;"	v	file:
undoEmpty	HTKTools/HSLab.c	/^static Boolean undoEmpty;              \/* shows the status of the record *\/$/;"	v	file:
uni	HLMTools/Cluster.c	/^static unigram     *uni;                    \/* Unigram store *\/$/;"	v	file:
uniFloor	HLMLib/LPCalc.c	/^static float  uniFloor = 1.0;                 \/* unigram floor *\/$/;"	v	file:
uniFloor	HLMLib/LPCalc.h	/^   float        uniFloor;             \/* unigram floor *\/$/;"	m	struct:__anon16
uniFloor	HTKTools/HLStats.c	/^static float uniFloor   = 1.0;      \/* min count for unigram probs *\/$/;"	v	file:
uniFn	HLMTools/HLMCopy.c	/^static char      *uniFn = NULL;          \/* unigram file name *\/$/;"	v	file:
uniform_prob_	HTKLVRec/kenlm/lm/builder/interpolate.hh	/^    float uniform_prob_;$/;"	m	class:lm::builder::Interpolate
unigram	HLMTools/Cluster.c	/^typedef UInt unigram;   \/* Occurrence count *\/$/;"	t	file:
unigram_	HTKLVRec/kenlm/lm/search_hashed.hh	/^        typename Value::Weights *unigram_;$/;"	m	class:lm::ngram::detail::HashedSearch::Unigram
unigram_	HTKLVRec/kenlm/lm/search_hashed.hh	/^    Unigram unigram_;$/;"	m	class:lm::ngram::detail::HashedSearch
unigram_	HTKLVRec/kenlm/lm/search_trie.hh	/^    Unigram unigram_;$/;"	m	class:lm::ngram::trie::TrieSearch
unigram_	HTKLVRec/kenlm/lm/trie.hh	/^    UnigramValue *unigram_;$/;"	m	class:lm::ngram::trie::Unigram
unigram_	HTKLVRec/kenlm/lm/trie_sort.hh	/^    util::scoped_fd unigram_;$/;"	m	class:lm::ngram::trie::SortedFiles
unigram_add	HLMTools/Cluster.c	/^void unigram_add(NGram ng, int count)$/;"	f
unigram_init	HLMTools/Cluster.c	/^void unigram_init(int words)$/;"	f
unigram_read	HLMTools/Cluster.c	/^UInt unigram_read(UInt id)$/;"	f
unigrams	HTKLVRec/HLVLM.h	/^   NGLM_Prob *unigrams;         \/* Unigram probabilities indexed by PronId! *\/$/;"	m	struct:_FSLM_ngram
unigrams	HTKLib/HLM.h	/^   Vector unigrams;             \/* Unigram probabilities *\/$/;"	m	struct:ngramlm
unigrams_	HTKLVRec/kenlm/lm/search_trie.cc	/^    UnigramValue *const unigrams_;$/;"	m	class:lm::ngram::trie::__anon58::WriteEntries	file:
unigrams_	HTKLVRec/kenlm/lm/search_trie.cc	/^    const ProbBackoff *unigrams_;$/;"	m	class:lm::ngram::trie::__anon58::FindBlanks	file:
unigrams_	HTKLVRec/kenlm/lm/value_build.hh	/^    std::vector<float> unigrams_;$/;"	m	class:lm::ngram::LowerRestBuild
uninterp	HTKLVRec/kenlm/lm/builder/ngram.hh	/^  Uninterpolated uninterp;$/;"	m	union:lm::builder::Payload
uniqOOV	HLMTools/LPlex.c	/^   int uniqOOV;             \/* number of unique oov's *\/$/;"	m	struct:__anon34	file:
units	HTKLib/esignal.h	/^    char        *units;         \/* string giving physical units *\/$/;"	m	struct:FieldSpec
unkEquiv	HLMTools/LPlex.c	/^static int    unkEquiv = 0;         \/* number of equivalent words outside the word list *\/$/;"	v	file:
unkId	HLMTools/LAdapt.c	/^static LabId unkId = NULL;                   \/* OOV marker *\/$/;"	v	file:
unkId	HLMTools/LPlex.c	/^static LabId unkId = NULL;          \/* sentence end marker *\/$/;"	v	file:
unkStr	HLMLib/LCMap.c	/^static char  unkStr[256] = DEF_UNKNOWNNAME;  \/* name of (hdrless) unk class *\/$/;"	v	file:
unkStr	HLMTools/LAdapt.c	/^static char  unkStr[256] = DEF_UNKNOWNNAME;  \/* OOV class string *\/$/;"	v	file:
unk_id	HLMTools/Cluster.c	/^static int         unk_id=-1;               \/* Unknown word token id *\/$/;"	v	file:
unk_sep	HLMTools/Cluster.c	/^static Boolean     unk_sep = FALSE;         \/* Keep unknown word in its own class? *\/$/;"	v	file:
unkid	HLMLib/LCMap.c	/^static LabId unkid  = NULL;	             \/* name of (hdrless) unk class *\/$/;"	v	file:
unkndx	HLMLib/LCMap.c	/^static int  unkndx  = DEF_UNKNOWNID;         \/* ndx of (hdrless) unk class *\/$/;"	v	file:
unknown	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon187	file:
unknown	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon205	file:
unknownId	HTKTools/HBuild.c	/^static LabId unknownId;             \/* id of unknown label in ngram *\/$/;"	v	file:
unknown_missing	HTKLVRec/kenlm/lm/config.hh	/^  WarningAction unknown_missing;$/;"	m	struct:lm::ngram::Config
unknown_missing_logprob	HTKLVRec/kenlm/lm/config.hh	/^  float unknown_missing_logprob;$/;"	m	struct:lm::ngram::Config
unknown_w	HLMTools/Cluster.c	/^static char         unknown_w[256];         \/* unknown word token *\/$/;"	v	file:
unqPK	HTKLib/HParm.c	/^   ParmKind unqPK;    \/* Used to track conversion from srcPK to tgtPK *\/$/;"	m	struct:__anon141	file:
up_dataStack	HTKLib/HFBLat.h	/^  MemHeap up_dataStack;$/;"	m	struct:__anon102
up_hmmMMF	HTKTools/HERest.c	/^static char up_hmmMMF[MAXFNAMELEN];  \/* alignment hmm list *\/$/;"	v	file:
up_hset	HTKLib/HFB.h	/^  HMMSet *up_hset;    \/* set of HMMs to be re-estimated *\/$/;"	m	struct:__anon99
up_info	HTKLib/HFBLat.h	/^  BufferInfo up_info;             \/* info from buffer on second data file *\/$/;"	m	struct:__anon102
up_ot	HTKLib/HFBLat.h	/^  Observation up_ot;$/;"	m	struct:__anon102
up_pbuf	HTKLib/HFBLat.h	/^  ParmBuf up_pbuf;$/;"	m	struct:__anon102
up_qList	HTKLib/HFB.h	/^  HLink *up_qList;    \/* array[1..Q] of active HMM defs *\/$/;"	m	struct:__anon98
update	HTKTools/HVite.c	/^static int update = 0;            \/* Perfom MLLR & update every n utts *\/$/;"	v	file:
updateMode	HTKTools/HERest.c	/^static int updateMode = UPMODE_UPDATE; \/* dump summed accs, update models or do both? *\/$/;"	v	file:
updateMode	HTKTools/HMMIRest.c	/^static int updateMode = UPMODE_UPDATE; \/* dump summed accs, update models or do both? *\/$/;"	v	file:
usage	HTKLib/HNet.h	/^   int usage;               \/* Number of references to this SubLat *\/$/;"	m	struct:sublatdef
usage	HTKLib/HRec.c	/^   int usage;           \/* Times struct ref'd (by align or path) *\/$/;"	m	struct:align	file:
usage	HTKLib/HRec.h	/^   int usage;           \/* Times struct ref'd (by next path) *\/$/;"	m	struct:path
useBias	HTKLib/HAdapt.c	/^static Boolean useBias = TRUE;         \/* whether a bias is to be estimated for the xform *\/$/;"	v	file:
useHModel	HTKLVRec/HDecode.c	/^static Boolean useHModel = FALSE; \/* use standard HModel OutP functions *\/$/;"	v	file:
useHModel	HTKLVRec/HDecode.mod.c	/^static Boolean useHModel = FALSE; \/* use standard HModel OutP functions *\/$/;"	v	file:
useHModel	HTKLVRec/HLVModel.h	/^   Boolean useHModel;$/;"	m	struct:_StateInfo_lv
useHModel	HTKLVRec/HLVRec.h	/^   Boolean useHModel;           \/* use normal HModel OutP() functions? *\/$/;"	m	struct:_DecoderInst
useHam	HTKLib/HParm.c	/^   Boolean useHam;            \/* Use Hamming Window *\/$/;"	m	struct:__anon141	file:
useInXForm	HTKLib/HAdapt.h	/^  Boolean useInXForm;$/;"	m	struct:__anon89
useLLF	HTKTools/HMMIRest.c	/^static Boolean useLLF = FALSE;          \/* use directory based LLF files instead of individual lattices *\/$/;"	v	file:
useLeafStats	HTKTools/HHEd.c	/^static Boolean useLeafStats = TRUE; \/* Use leaf stats to init macros *\/$/;"	v	file:
useMLF	HTKTools/HCopy.c	/^static Boolean useMLF=FALSE;    \/* set if we are saving to an mlf *\/$/;"	v	file:
useModelName	HTKTools/HHEd.c	/^static Boolean useModelName = TRUE;    \/* Use base-phone name as tree name *\/$/;"	v	file:
useOldPrune	HTKLVRec/HLVRec.c	/^static Boolean useOldPrune = FALSE;     \/* backward compatibility for max model and reltok pruning etc. *\/$/;"	v	file:
useOutXForm	HTKLib/HAdapt.h	/^  Boolean useOutXForm;$/;"	m	struct:__anon89
usePaXForm	HTKLib/HAdapt.h	/^  Boolean usePaXForm;$/;"	m	struct:__anon89
usePower	HTKLib/HParm.c	/^   Boolean usePower;          \/* Use power instead of Magnitude *\/$/;"	m	struct:__anon141	file:
usePower	HTKLib/HSigP.h	/^   Boolean usePower;    \/* use power rather than magnitude *\/$/;"	m	struct:__anon159
useSilDet	HTKLib/HParm.c	/^   Boolean useSilDet;         \/* Use Silence Detector *\/$/;"	m	struct:__anon141	file:
useSilDet	HTKLib/HParm.h	/^   Boolean useSilDet;         \/* Use Silence Detector *\/$/;"	m	struct:__anon149
used	HLMLib/LGBase.h	/^   int used;               \/* number used slots in pool *\/$/;"	m	struct:__anon5
used	HLMLib/LWMap.h	/^   int     used;         \/* total words and classes in map *\/$/;"	m	struct:__anon23
used	HLMTools/LAdapt.c	/^   int used;            \/* actual words in register *\/$/;"	m	struct:__anon26	file:
used	HLMTools/LGPrep.c	/^   int used;                  \/* actual words in register *\/$/;"	m	struct:__anon32	file:
used	HTKLib/HAudio.c	/^   int used,size;        \/* used in data, size of data *\/$/;"	m	struct:__anon92	file:
used	HTKLib/HMem.h	/^   ByteP used;          \/* alloc map, 1 bit\/elem         not used         *\/$/;"	m	struct:_Block
used	HTKLib/HRec.c	/^   Boolean used;        \/* Reference to struct by current inst *\/$/;"	m	struct:align	file:
used	HTKLib/HRec.h	/^   Boolean used;        \/* Reference to struct by current inst *\/$/;"	m	struct:path
used	HTKLib/HTrain.h	/^   int used;         \/* num items in this block *\/$/;"	m	struct:_ItemBlock
used_	HTKLVRec/kenlm/util/pcqueue.hh	/^  Semaphore used_;$/;"	m	class:util::PCQueue
used_digits_	HTKLVRec/kenlm/util/double-conversion/bignum.h	/^  int used_digits_;$/;"	m	class:double_conversion::Bignum
user	HTKLVRec/HLVRec.h	/^   int user;                  \/* general user info; #### get rid of this! *\/$/;"	m	struct:_WordendHyp
user	HTKLib/HLM.h	/^   void *user;                  \/* Accumulator or cache storage *\/$/;"	m	struct:nentry
user	HTKLib/HShell.h	/^   char *user;          \/* name of module\/tool to use this param *\/$/;"	m	struct:__anon157
user	HTKTools/HParse.c	/^   Ptr  user;       \/* for attaching user defined data *\/$/;"	m	struct:_Node	file:
user	HTKTools/HParse.c	/^   Ptr  user;       \/* for attaching user defined data *\/$/;"	m	struct:__anon203	file:
usort	HLMLib/LUtil.c	/^void usort(void *base, int n, size_t size,$/;"	f
usrt	HLMLib/LUtil.c	/^static void usrt(void *base, int l, int r, size_t size,$/;"	f	file:
util	HTKLVRec/kenlm/lm/builder/adjust_counts.hh	/^namespace util { namespace stream { class ChainPositions; } }$/;"	n
util	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/lm/builder/initial_probabilities.hh	/^namespace util { namespace stream { class Chains; } }$/;"	n
util	HTKLVRec/kenlm/lm/builder/output.hh	/^namespace util { namespace stream { class Chains; class ChainPositions; } }$/;"	n
util	HTKLVRec/kenlm/lm/filter/arpa_io.hh	/^namespace util { class FilePiece; }$/;"	n
util	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^namespace util { namespace stream { class ChainPositions; } }$/;"	n
util	HTKLVRec/kenlm/lm/model.hh	/^namespace util { class FilePiece; }$/;"	n
util	HTKLVRec/kenlm/lm/neural/wordvecs.hh	/^namespace util { class FilePiece; }$/;"	n
util	HTKLVRec/kenlm/lm/search_hashed.hh	/^namespace util { class FilePiece; }$/;"	n
util	HTKLVRec/kenlm/lm/trie_sort.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/bit_packing.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/bit_packing.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/ersatz_progress.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/ersatz_progress.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/exception.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/exception.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/fake_ofstream.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/file.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/file.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/file_piece.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/file_piece.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/fixed_array.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/joint_sort.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/mmap.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/mmap.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/multi_intersection.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/murmur_hash.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/murmur_hash.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/parallel_read.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/parallel_read.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/pcqueue.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/pool.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/pool.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/probing_hash_table.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/proxy_iterator.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/read_compressed.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/read_compressed.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/scoped.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/scoped.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/sized_iterator.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/sorted_uniform.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/stream/block.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/stream/chain.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/stream/chain.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/stream/config.hh	/^namespace util { namespace stream {$/;"	n
util	HTKLVRec/kenlm/util/stream/io.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/stream/io.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/stream/line_input.cc	/^namespace util { namespace stream {$/;"	n	file:
util	HTKLVRec/kenlm/util/stream/line_input.hh	/^namespace util {namespace stream {$/;"	n
util	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^namespace util { namespace stream {$/;"	n	file:
util	HTKLVRec/kenlm/util/stream/multi_progress.hh	/^namespace util { namespace stream {$/;"	n
util	HTKLVRec/kenlm/util/stream/multi_stream.hh	/^namespace util { namespace stream {$/;"	n
util	HTKLVRec/kenlm/util/stream/sort.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/stream/stream.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/thread_pool.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/tokenize_piece.hh	/^namespace util {$/;"	n
util	HTKLVRec/kenlm/util/usage.cc	/^namespace util {$/;"	n	file:
util	HTKLVRec/kenlm/util/usage.hh	/^namespace util {$/;"	n
utt	HTKTools/HVite.c	/^static UttInfo *utt;              \/* utterance info for state\/frame align *\/$/;"	v	file:
uttStack	HTKTools/HERest.c	/^static MemHeap uttStack;$/;"	v	file:
utterFN	HTKLVRec/HLVRec.h	/^   char *utterFN;               \/* name of current utterance *\/$/;"	m	struct:_DecoderInst
utterance	HTKLib/HNet.h	/^   char *utterance;		\/* Utterance file name (NULL==unknown) *\/$/;"	m	struct:lattice
v	HTKLib/HNet.h	/^   short v;            \/* Pronunciation variant number *\/$/;"	m	struct:lnode
v1Compat	HTKLib/HParm.c	/^   Boolean v1Compat;          \/* V1 compatibility mode *\/$/;"	m	struct:__anon141	file:
v1Compat	HTKTools/HParse.c	/^static Boolean v1Compat=FALSE;        \/* compatability mode? *\/$/;"	v	file:
vCtr	HTKLib/HTrain.h	/^   Vector vCtr;    \/* cluster centre vector *\/$/;"	m	struct:__anon161
vDefunct	HTKTools/HRest.c	/^static float vDefunct=0.0;       \/* variance below which mixture defunct *\/$/;"	v	file:
vFloor	HTKLib/HMap.c	/^static Vector vFloor[SMAX]; \/* variance floor - default is all zero *\/$/;"	v	file:
vFloor	HTKLib/HModel.h	/^   SVector vFloor;      \/* enables flooring for multiple semi-tied transforms *\/$/;"	m	struct:__anon120
vFloor	HTKLib/HModel.h	/^  SVector vFloor;      \/* used for SEMIT variance flooring *\/$/;"	m	struct:__anon132
vFloor	HTKTools/HERest.c	/^static Vector vFloor[SMAX]; \/* variance floor - default is all zero *\/$/;"	v	file:
vFloor	HTKTools/HInit.c	/^static Vector vFloor[SMAX];         \/* variance floor - default is all zero *\/$/;"	v	file:
vFloor	HTKTools/HMMIRest.c	/^static Vector vFloor[SMAX];          \/* variance floor - default is all zero *\/$/;"	v	file:
vFloor	HTKTools/HRest.c	/^static Vector vFloor[SMAX];      \/* variance floor - default is all zero *\/$/;"	v	file:
vFloor	HTKTools/HSmooth.c	/^static Vector vFloor[SMAX];  \/* variance floor - default is all zero *\/$/;"	v	file:
vFloorScale	HTKTools/HCompV.c	/^static float vFloorScale = 0.0;     \/* if >0.0 then vFloor scaling *\/$/;"	v	file:
vInfoHd	HTKLib/HShell.c	/^static VersionEntry *vInfoHd = NULL;  \/* head of version info list *\/$/;"	v	file:
vInfoTl	HTKLib/HShell.c	/^static VersionEntry *vInfoTl = NULL;  \/* tail of version info list *\/$/;"	v	file:
vSize	HTKLib/HTrain.c	/^static int vSize;       \/* size of vectors *\/$/;"	v	file:
vSize	HTKTools/HCompV.c	/^static int vSize = 0;                    \/* target observation vector size *\/$/;"	v	file:
vSize	HTKTools/HMMIRest.c	/^static int vSize;                \/* input vector size *\/$/;"	v	file:
vSize	HTKTools/HSmooth.c	/^static int vSize;                \/* input vector size *\/$/;"	v	file:
vTmp	HTKLib/HTrain.c	/^static Vector vTmp;     \/* temp vector *\/$/;"	v	file:
v_peak	HTKLib/HAudio.c	/^   v_peak=1,$/;"	e	enum:__anon90	file:
v_rms	HTKLib/HAudio.c	/^   v_rms$/;"	e	enum:__anon90	file:
vaC	HTKLib/HTrain.c	/^static int muC,vaC,trC,wtC,prC;$/;"	v	file:
val	HTKLib/HShell.h	/^   ConfVal val;         \/* value *\/$/;"	m	struct:__anon157
valid	HTKLib/HModel.h	/^  Boolean valid;       \/* is it valid to generate a transform at the root node *\/$/;"	m	struct:RegTree
valid_size_	HTKLVRec/kenlm/util/stream/block.hh	/^    std::size_t valid_size_;$/;"	m	class:util::stream::Block
value	HLMLib/LUtil.c	/^   char * value;$/;"	m	struct:hdrField	file:
value	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^  lm::WordIndex value;$/;"	m	struct:lm::builder::__anon43::VocabEntry	file:
value	HTKLVRec/kenlm/lm/search_hashed.hh	/^  Prob value;$/;"	m	struct:lm::ngram::detail::ProbEntry
value	HTKLVRec/kenlm/lm/value.hh	/^    ProbBackoff value;$/;"	m	struct:lm::ngram::BackoffValue::ProbingEntry
value	HTKLVRec/kenlm/lm/value.hh	/^    Value value;$/;"	m	struct:lm::ngram::RestValue::ProbingEntry
value	HTKLVRec/kenlm/lm/vocab.hh	/^  WordIndex value;$/;"	m	struct:lm::ngram::ProbingVocabularyEntry
value	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  double value() const { return uint64_to_double(d64_); }$/;"	f	class:double_conversion::Double
value	HTKLVRec/kenlm/util/double-conversion/ieee.h	/^  float value() const { return uint32_to_float(d32_); }$/;"	f	class:double_conversion::Single
value	HTKLVRec/kenlm/util/joint_sort.hh	/^      typename std::iterator_traits<ValueIter>::value_type value;$/;"	m	struct:util::detail::JointProxy::__anon74
value_	HTKLVRec/kenlm/util/joint_sort.hh	/^    ValueIter value_;$/;"	m	class:util::detail::JointIter
value_type	HTKLVRec/kenlm/lm/trie_sort.cc	/^    typedef std::string value_type;$/;"	t	class:lm::ngram::trie::__anon60::PartialViewProxy	file:
value_type	HTKLVRec/kenlm/util/joint_sort.hh	/^    } value_type;$/;"	t	class:util::detail::JointProxy	typeref:struct:util::detail::JointProxy::__anon74
value_type	HTKLVRec/kenlm/util/proxy_iterator.hh	/^    typedef typename Proxy::value_type value_type;$/;"	t	class:util::ProxyIterator
value_type	HTKLVRec/kenlm/util/sized_iterator.hh	/^    typedef std::string value_type;$/;"	t	class:util::SizedProxy
value_type	HTKLVRec/kenlm/util/string_piece.hh	/^  typedef char value_type;$/;"	t	class:StringPiece
values_	HTKLVRec/kenlm/lm/search_trie.cc	/^    std::vector<float> values_[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::trie::__anon58::SRISucks	file:
var	HTKLib/HMath.h	/^   SVector var;         \/* if DIAGC or INVDIAGC *\/$/;"	m	union:__anon114
varFloorPercent	HTKTools/HERest.c	/^static float varFloorPercent = 0;$/;"	v	file:
varFloorPercent	HTKTools/HMMIRest.c	/^static float varFloorPercent = 0;$/;"	v	file:
varScale	HTKLib/HParm.c	/^   Vector varScale;   \/* var scaling vector  *\/$/;"	m	struct:__anon141	file:
varScale	HTKLib/HParm.c	/^static float varScale[100];$/;"	v	file:
varScaleDN	HTKLib/HParm.c	/^   char* varScaleDN ;         \/* dir to find variance estimate files *\/$/;"	m	struct:__anon141	file:
varScaleDim	HTKLib/HParm.c	/^static int varScaleDim=0;$/;"	v	file:
varScaleFN	HTKLib/HParm.c	/^   char *varScaleFN;          \/* var scale file name *\/          $/;"	m	struct:__anon141	file:
varScaleFN	HTKLib/HParm.c	/^static char varScaleFN[MAXFNAMELEN] = "\\0";$/;"	v	file:
varScaleMask	HTKLib/HParm.c	/^   char* varScaleMask;        \/* variance estimate file selection mask *\/$/;"	m	struct:__anon141	file:
varScalePathMask	HTKLib/HParm.c	/^   char* varScalePathMask;    \/* variance estimate file path selection mask *\/$/;"	m	struct:__anon141	file:
varScaleVector	HTKLib/HParm.c	/^   Vector varScaleVector; \/* vector loaded from varscale dir *\/$/;"	m	struct:__anon141	file:
varSmooth	HTKTools/HMMIRest.c	/^static float varSmooth = 0;$/;"	v	file:
vaxOrder	HTKLib/HShell.c	/^Boolean vaxOrder = FALSE;$/;"	v
vbnd	HTKTools/HLEd.c	/^static LabId vbnd[MAXIV];           \/* non-interwd bndaries set via NB cmd *\/$/;"	v	file:
vecSize	HTKLib/HModel.h	/^   short vecSize;          \/* dimension of observation vectors *\/$/;"	m	struct:_HMMSet
vecSize	HTKLib/HModel.h	/^  int vecSize;         \/* must be matched to a stream width! *\/$/;"	m	struct:__anon132
vecs_	HTKLVRec/kenlm/lm/neural/wordvecs.hh	/^    Storage vecs_;$/;"	m	class:lm::neural::WordVecs
ver	HTKLib/HShell.c	/^   char *ver;$/;"	m	struct:_VersionEntry	file:
verbose	HLMTools/Cluster.c	/^static Boolean      verbose = FALSE;        \/* Verbose file logging *\/$/;"	v	file:
verbose_header_	HTKLVRec/kenlm/lm/builder/print.hh	/^    bool verbose_header_;$/;"	m	class:lm::builder::PrintARPA
version	HTKLVRec/kenlm/lm/vocab.cc	/^  unsigned int version;$/;"	m	struct:lm::ngram::detail::ProbingVocabularyHeader	file:
version	HTKLib/HWave.c	/^   short version;$/;"	m	struct:__anon173	file:
version	HTKLib/HWave.c	/^   short version;$/;"	m	struct:__anon174	file:
vertices_	HTKLVRec/kenlm/lm/filter/phrase.hh	/^    std::vector<detail::Vertex> vertices_;$/;"	m	class:lm::phrase::detail::ConditionCommon
voc	HLMTools/HLMCopy.c	/^static Vocab     *voc   = NULL;          \/* the defining word list *\/$/;"	v	file:
voc	HTKLVRec/HLVNet.h	/^   Vocab *voc;$/;"	m	struct:_LexNet
voc	HTKLVRec/HLVNet.h	/^   Vocab *voc;$/;"	m	struct:_TLexNet
voc	HTKLib/HNet.h	/^   Vocab *voc;                  \/* Dictionary lattice based on *\/$/;"	m	struct:lattice
voc	HTKTools/HSGen.c	/^static Vocab   voc;     \/* associated vocab *\/$/;"	v	file:
vocSize	HLMLib/LModel.h	/^   int vocSize;              \/* vocabulary size *\/$/;"	m	struct:__anon15
vocSize	HTKLVRec/HLVLM.h	/^   int vocSize;                 \/* Core LM size *\/$/;"	m	struct:_FSLM_ngram
vocSize	HTKLib/HLM.h	/^   int vocSize;                 \/* Core LM size *\/$/;"	m	struct:ngramlm
vocab	HLMTools/HLMCopy.c	/^static Vocab     vocab;                  \/* word list buffer *\/$/;"	v	file:
vocab	HTKLVRec/HDecode.c	/^static Vocab vocab;		\/* wordlist or dictionary *\/$/;"	v	file:
vocab	HTKLVRec/HDecode.mod.c	/^static Vocab vocab;		\/* wordlist or dictionary *\/$/;"	v	file:
vocab	HTKLVRec/HLVLM.h	/^   Vocab *vocab;                \/* Vocab used to find prons of words *\/$/;"	m	struct:_FSLM_ngram
vocab	HTKLVRec/kenlm/lm/filter/vocab.cc	/^namespace vocab {$/;"	n	namespace:lm	file:
vocab	HTKLVRec/kenlm/lm/filter/vocab.hh	/^namespace vocab {$/;"	n	namespace:lm
vocab	HTKLib/HNet.h	/^   Vocab *vocab;      \/* Dictionary from which words appear *\/$/;"	m	struct:__anon139
vocab	HTKLib/HNet.h	/^   char *vocab;			\/* Dictionary file name (NULL==unknown) *\/$/;"	m	struct:lattice
vocab	HTKTools/HLEd.c	/^static Vocab vocab;                 \/* And the associated vocab *\/$/;"	v	file:
vocab	HTKTools/HLRescore.c	/^static Vocab vocab;		\/* wordlist or dictionary *\/$/;"	v	file:
vocab	HTKTools/HMMIRest.c	/^Vocab vocab;$/;"	v
vocab	HTKTools/HVite.c	/^static Vocab vocab;               \/* the dictionary *\/$/;"	v	file:
vocabFN	HTKLVRec/HLVNet.h	/^   char *vocabFN;$/;"	m	struct:_LexNet
vocab_	HTKLVRec/kenlm/lm/builder/print.hh	/^    const VocabReconstitute &vocab_;$/;"	m	class:lm::builder::Print
vocab_	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    const Words &vocab_;$/;"	m	class:lm::vocab::Single
vocab_	HTKLVRec/kenlm/lm/interpolate/arpa_to_stream.hh	/^    ngram::GrowableVocab<ngram::WriteUniqueWords> &vocab_;$/;"	m	class:lm::interpolate::ARPAToStream
vocab_	HTKLVRec/kenlm/lm/model.hh	/^    VocabularyT vocab_;$/;"	m	class:lm::ngram::detail::GenericModel
vocab_	HTKLVRec/kenlm/lm/neural/wordvecs.hh	/^    ngram::ProbingVocabulary vocab_;$/;"	m	class:lm::neural::WordVecs
vocab_	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^    Vocabulary vocab_;$/;"	m	class:lm::np::Model
vocab_	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^    const nplm::vocabulary &vocab_;$/;"	m	class:lm::np::Vocabulary
vocab_backing_	HTKLVRec/kenlm/lm/neural/wordvecs.hh	/^    util::scoped_malloc vocab_backing_;$/;"	m	class:lm::neural::WordVecs
vocab_estimate	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  lm::WordIndex vocab_estimate;$/;"	m	struct:lm::builder::PipelineConfig
vocab_fd_	HTKLVRec/kenlm/lm/builder/output.hh	/^    int vocab_fd_;$/;"	m	class:lm::builder::Output
vocab_file	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  std::string vocab_file;$/;"	m	struct:lm::builder::PipelineConfig
vocab_htk	HTKLVRec/HLVRec.h	/^   Vocab vocab_htk;$/;"	m	struct:_DecoderInst
vocab_kenlm	HTKLVRec/HLVRec.h	/^   lm::base::Vocabulary vocab_kenlm;$/;"	m	struct:_DecoderInst
vocab_pad_	HTKLVRec/kenlm/lm/binary_format.hh	/^    std::size_t header_size_, vocab_size_, vocab_pad_;$/;"	m	class:lm::ngram::BinaryFormat
vocab_size_	HTKLVRec/kenlm/lm/binary_format.hh	/^    std::size_t header_size_, vocab_size_, vocab_pad_;$/;"	m	class:lm::ngram::BinaryFormat
vocab_size_for_unk	HTKLVRec/kenlm/lm/builder/pipeline.hh	/^  uint64_t vocab_size_for_unk;$/;"	m	struct:lm::builder::PipelineConfig
vocab_string_offset_	HTKLVRec/kenlm/lm/binary_format.hh	/^    uint64_t vocab_string_offset_;$/;"	m	class:lm::ngram::BinaryFormat
vocab_write_	HTKLVRec/kenlm/lm/builder/corpus_count.hh	/^    int vocab_write_;$/;"	m	class:lm::builder::CorpusCount
vocabs_	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    const Words &vocabs_;$/;"	m	class:lm::vocab::Multiple
vocabs_	HTKLVRec/kenlm/lm/filter/vocab.hh	/^    const Words &vocabs_;$/;"	m	class:lm::vocab::Union
vol	HTKLib/HAudio.c	/^   float vol;                \/* current volume *\/$/;"	m	struct:_AudioOut	file:
volStr	HTKTools/HSLab.c	/^static char volStr[10];      \/* the string displayed in the volume button *\/$/;"	v	file:
volType	HTKLib/HAudio.c	/^static VolType volType = v_peak;$/;"	v	file:
vol_btn	HTKTools/HSLab.c	/^static HButton *vol_btn;     \/* pointer to the volume button *\/$/;"	v	file:
vq	HTKLib/HParm.h	/^   short vq[SMAX];       \/* array[1..swidth[0]] of VQ index *\/$/;"	m	struct:__anon147
vqHeap	HTKLib/HVQ.c	/^static MemHeap vqHeap;     \/* MSTAK for allocating VQTables *\/$/;"	v	file:
vqList	HTKLib/HVQ.c	/^static VQTable vqList = NULL;$/;"	v	file:
vqSegs	HTKLib/HTrain.h	/^   Sequence vqSegs;     \/* each seg is a sequence of vq[SMAX] *\/$/;"	m	struct:_SegStoreRec
vqTab	HTKLib/HParm.c	/^   VQTable vqTab;             \/* VQ table *\/$/;"	m	struct:__anon141	file:
vqTabFN	HTKLib/HParm.c	/^   char *vqTabFN;             \/* Name of VQ Table Defn File *\/$/;"	m	struct:__anon141	file:
vqTabFN	HTKLib/HParm.h	/^   char *vqTabFN;             \/* Name of VQ Table Defn File *\/$/;"	m	struct:__anon149
vqfn	HTKTools/HQuant.c	/^static char *vqfn = NULL;           \/* filename for output VQ table *\/$/;"	v	file:
vqidx	HTKLib/HVQ.h	/^   short vqidx;         \/* vq index of this node *\/$/;"	m	struct:_VQNodeRec
vrecinfo	HTKLib/HRec.h	/^struct vrecinfo$/;"	s
vri	HTKTools/HVite.c	/^static VRecInfo *vri;             \/* Visible HRec Info *\/$/;"	v	file:
vsize	HTKLib/HModel.h	/^  int vsize;                \/* vector size associated with the baseclasses of this node *\/$/;"	m	struct:_RegNode
w	HTKLib/HGraf.h	/^   int x, y, w, h;            \/* size of button rectangle *\/$/;"	m	struct:_HButton
w	HTKLib/HParm.c	/^      Wave w;           \/* the waveform file *\/$/;"	m	union:_ParmBuf::__anon143	file:
w	HTKLib/HParm.h	/^   Wave w;                    \/* the wave input - if any *\/$/;"	m	struct:__anon149
w	HTKTools/HSLab.c	/^   int x, y, w, h, bw;    \/* x-pos, y-pos, width, height, fg and bg colours *\/$/;"	m	struct:__anon212	file:
wList	HLMLib/LPMerge.c	/^   WordMap *wList;           \/* the target word list *\/$/;"	m	struct:__anon17	file:
wList	HLMTools/LMerge.c	/^static WordMap   wList;                  \/* the word list *\/$/;"	v	file:
wList	HLMTools/LPlex.c	/^static WordMap wList;               \/* the word list *\/$/;"	v	file:
wList	HTKTools/HDMan.c	/^static LabId *wList = NULL;          \/* filter word list *\/$/;"	v	file:
wListFN	HTKTools/HDMan.c	/^static char *wListFN = NULL;         \/* name of word list file *\/$/;"	v	file:
wSpot	HTKTools/HResults.c	/^static Boolean wSpot      = FALSE;    \/* true if word spotting *\/$/;"	v	file:
wait	HTKLVRec/kenlm/util/pcqueue.hh	/^    void wait() {$/;"	f	class:util::Semaphore
waitForSigH	HTKLib/HAudio.c	/^static volatile Boolean waitForSigH;$/;"	v	file:
warpFreq	HTKLib/HParm.c	/^   float warpFreq;            \/* Warp freq axis for vocal tract normalisation *\/$/;"	m	struct:__anon141	file:
warpLowerCutOff	HTKLib/HParm.c	/^   float warpLowerCutOff;     \/* lower and upper threshold frequencies *\/$/;"	m	struct:__anon141	file:
warpUpperCutOff	HTKLib/HParm.c	/^   float warpUpperCutOff;     \/*   for linear frequency warping *\/  $/;"	m	struct:__anon141	file:
wasNewline	HTKLib/HShell.h	/^   Boolean wasNewline;  \/* true if SkipWhiteSpace went over newline *\/$/;"	m	struct:__anon154
wasQuoted	HTKLib/HShell.c	/^static Boolean wasQuoted;     \/* true if next arg was quoted *\/$/;"	v	file:
wasQuoted	HTKLib/HShell.h	/^   Boolean wasQuoted;   \/* true if ReadString returned quoted string *\/$/;"	m	struct:__anon154
wavStack	HTKTools/HSLab.c	/^static MemHeap wavStack;     \/* storage for waveforms *\/$/;"	v	file:
wave	HTKTools/HSLab.c	/^static Wave wave;            \/* the input waveform *\/$/;"	v	file:
waveData	HTKLib/HAudio.c	/^   LPSTR waveData;        \/* Data in buffer *\/$/;"	m	struct:mmapibuf	file:
waveFmt	HTKLib/HAudio.c	/^   LPPCMWAVEFORMAT waveFmt; \/* Pointer to PCMWAVEFORMAT *\/$/;"	m	struct:_AudioIn	file:
waveFmt	HTKLib/HAudio.c	/^   LPPCMWAVEFORMAT waveFmt; \/* Pointer to PCMWAVEFORMAT *\/$/;"	m	struct:_AudioOut	file:
waveHdr	HTKLib/HAudio.c	/^   LPWAVEHDR waveHdr;     \/* Pointer to WAVEHDR *\/$/;"	m	struct:mmapibuf	file:
waveIn	HTKLib/HAudio.c	/^   HWAVEIN waveIn;$/;"	m	struct:_AudioIn	file:
waveOut	HTKLib/HAudio.c	/^   HWAVEOUT waveOut;$/;"	m	struct:_AudioOut	file:
waveOutDev	HTKLib/HAudio.c	/^   UINT waveOutDev;         \/* Device being used for wave output *\/$/;"	m	struct:_AudioOut	file:
wavePos	HTKLib/HAudio.c	/^   LPMMTIME wavePos;        \/* Pointer to MMTIME *\/$/;"	m	struct:_AudioIn	file:
wavePos	HTKLib/HAudio.c	/^   LPMMTIME wavePos;        \/* Pointer to MMTIME *\/$/;"	m	struct:_AudioOut	file:
wavePtrOn	HTKTools/HSLab.c	/^static Boolean wavePtrOn = FALSE;   \/* keeps track of the state of the waveform pointer *\/$/;"	v	file:
waveWin	HTKTools/HSLab.c	/^static RectWin waveWin;      \/* the waveform window *\/$/;"	v	file:
wbar	HTKTools/HSmooth.c	/^static Vector *wbar;         \/* array[0..nBlk]of weight vector *\/$/;"	v	file:
wbnd	HTKTools/HLEd.c	/^static LabId wbnd[MAXIW];           \/* interword bndaries set via WB cmd *\/$/;"	v	file:
wbuf	HTKTools/HDMan.c	/^   WordBuf wbuf;                \/* current input word *\/$/;"	m	struct:__anon195	file:
wcd	HTKTools/HSmooth.c	/^static Vector *wcd;          \/* array[0..nBlk]of weight vector *\/$/;"	v	file:
wd	HTKTools/HBuild.c	/^   Word wd;$/;"	m	struct:_GramEntry	file:
wd	HTKTools/HBuild.c	/^   Word wd;$/;"	m	struct:_WordFllr	file:
wdBegin	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon205	file:
wdBeginId	HTKTools/HParse.c	/^static LabId wdBeginId;               \/* LabId of WD_BEGIN nodes  *\/$/;"	v	file:
wdBnd	HTKTools/HDMan.c	/^static LabId wdBnd;                  \/* LabId of word boundary symbol  *\/   $/;"	v	file:
wdBndSym	HTKTools/HDMan.c	/^static char wdBndSym[10] = "#";      \/* word boundary symbol *\/$/;"	v	file:
wdEnd	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon205	file:
wdEndId	HTKTools/HParse.c	/^static LabId wdEndId;                 \/* LabId of WD_END nodes  *\/$/;"	v	file:
wdExternal	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon205	file:
wdInternal	HTKTools/HParse.c	/^typedef enum {unknown, wdInternal, wdExternal, wdBegin, wdEnd, nullNode} NodeType;$/;"	e	enum:__anon205	file:
wdNet	HTKTools/HVite.c	/^static Lattice *wdNet;            \/* the word level recognition network *\/$/;"	v	file:
wdNetFn	HTKTools/HVite.c	/^static char *wdNetFn = NULL;      \/* Word level lattice *\/$/;"	v	file:
wdThresh	HLMLib/LModel.h	/^   float wdThresh;          \/* Threshold for wd pruning *\/$/;"	m	struct:__anon12
wdThresh	HLMLib/LPCalc.h	/^   int          wdThresh[LM_NSIZE+1]; \/* n-gram wd threshold array *\/$/;"	m	struct:__anon16
wdThresh	HLMTools/LNorm.c	/^static float wdThresh[LM_NSIZE+1];  \/* new wdThresh for COUNT-models *\/$/;"	v	file:
wdThresh	HLMTools/LPlex.c	/^static float wdThresh[LM_NSIZE+1];  \/* new wdThresh for COUNT-models *\/$/;"	v	file:
wd_cmp	HTKTools/HLStats.c	/^static int wd_cmp(const void *v1,const void *v2)$/;"	f	file:
wdid	HLMTools/LGPrep.c	/^   LabId wdid;                \/* word literal *\/$/;"	m	union:__anon28	file:
wdid	HLMTools/LPlex.c	/^   LabId wdid;$/;"	m	struct:__anon33	file:
wdlist	HTKLib/HLM.h	/^   LabId *wdlist;               \/* Lookup table for words from lmId *\/$/;"	m	struct:matbilm
wdlist	HTKLib/HLM.h	/^   LabId *wdlist;               \/* Lookup table for words from lmId *\/$/;"	m	struct:ngramlm
wdlk	HTKLib/HRec.c	/^   LogFloat wdlk;       \/* Max likelihood of t=0 path to word end node *\/$/;"	m	struct:_NetInst	file:
wdpenalty	HTKLib/HNet.h	/^   LogFloat wdpenalty;		\/* Word insertion penalty *\/$/;"	m	struct:lattice
we	HTKLVRec/HLVNet.c	/^   Pron we;$/;"	m	struct:_STLexLink	file:
weBeamWidth	HTKLVRec/HDecode.c	/^static LogFloat weBeamWidth = - LZERO;   \/* pruning wordend beam width *\/$/;"	v	file:
weBeamWidth	HTKLVRec/HDecode.mod.c	/^static LogFloat weBeamWidth = - LZERO;   \/* pruning wordend beam width *\/$/;"	v	file:
weBeamWidth	HTKLVRec/HLVRec.h	/^   TokScore weBeamWidth;        \/* wordend beam width (set by -v cmd line option) *\/$/;"	m	struct:_DecoderInst
weHypHeap	HTKLVRec/HLVRec.h	/^   MemHeap weHypHeap;           \/* MHEAP for word end hyps *\/$/;"	m	struct:_DecoderInst
we_tag	HTKLVRec/HLVRec.h	/^   void *we_tag;$/;"	m	struct:_RelToken
weight	HLMLib/LGBase.h	/^   float weight;           \/* weight for subsequent mixing *\/$/;"	m	struct:gramfile
weight	HLMLib/LPMerge.h	/^   float weight;            \/* interpolation weight *\/$/;"	m	struct:__anon18
weight	HTKLib/HModel.h	/^   float weight;        \/* mixture weight *\/$/;"	m	struct:__anon121
weights	HTKLVRec/kenlm/lm/trie.hh	/^  ProbBackoff weights;$/;"	m	struct:lm::ngram::trie::UnigramValue
weights	HTKLVRec/kenlm/lm/value.hh	/^    Weights weights;$/;"	m	struct:lm::ngram::BackoffValue::TrieUnigramValue
weights	HTKLVRec/kenlm/lm/value.hh	/^    Weights weights;$/;"	m	struct:lm::ngram::RestValue::TrieUnigramValue
weights	HTKLib/HModel.h	/^   SVector weights;     \/* vector of stream weights *\/$/;"	m	struct:__anon126
wfmt	HTKTools/HSLab.c	/^static FileFormat wfmt=UNDEFF;      \/* wave file format *\/$/;"	v	file:
wgt	HTKLib/HModel.h	/^   Matrix wgt;          \/* for interpolated transforms *\/$/;"	m	union:__anon131
what	HTKLVRec/kenlm/util/exception.cc	/^const char *Exception::what() const throw() {$/;"	f	class:util::Exception
what_is_word	HLMTools/Cluster.c	/^char *what_is_word(UInt id)$/;"	f
white	HTKLib/HGraf.c	/^static unsigned long black, white;$/;"	v	file:
wid	HLMTools/LGList.c	/^   LabId wid;$/;"	m	struct:fitem	file:
width	HTKLib/esignal.h	/^    int     width;$/;"	m	struct:Annot
widthSet	HTKTools/HQuant.c	/^Boolean widthSet = FALSE;          \/* true if width of any stream is set *\/$/;"	v
widx	HTKTools/HDMan.c	/^static int widx = 0;                 \/* next word to take from wordList *\/$/;"	v	file:
winCreated	HTKLib/HGraf.c	/^static Boolean       winCreated = FALSE;$/;"	v	file:
winCreated	HTKLib/HGraf_WIN32.c	/^static Boolean winCreated    = FALSE;               \/* prevent duplicate windows *\/$/;"	v	file:
winDur	HTKLib/HParm.c	/^   HTime winDur;              \/* Source window duration *\/$/;"	m	struct:__anon141	file:
winPoints	HTKLib/HGraf_WIN32.c	/^static POINT winPoints[MAX_POINT];$/;"	v	file:
winTok	HTKLVRec/HLVRec.h	/^   RelToken *winTok;            \/* RelTok array fro MergeTokSet() *\/$/;"	m	struct:_DecoderInst
winTok_cmp	HTKLVRec/HLVRec-propagate.c	/^static int winTok_cmp (const void *v1,const void *v2)$/;"	f	file:
wlist	HLMTools/HLMCopy.c	/^static WordMap   wlist;                  \/* word list *\/$/;"	v	file:
wlist	HLMTools/LAdapt.c	/^static WordMap   wlist;             \/* restricting the word list *\/$/;"	v	file:
wlist	HLMTools/LNorm.c	/^static WordMap   wlist;                  \/* word list *\/$/;"	v	file:
wlistFN	HLMTools/HLMCopy.c	/^static char      *wlistFN = NULL;        \/* word list file name *\/$/;"	v	file:
wlistFN	HLMTools/LAdapt.c	/^static char *wlistFN = NULL;        \/* file containing edit rules *\/$/;"	v	file:
wlistFN	HLMTools/LNorm.c	/^static char      *wlistFN = NULL;        \/* word list file name *\/$/;"	v	file:
wlistFN	HLMTools/LPlex.c	/^static char   *wlistFN = NULL;$/;"	v	file:
wlt	HLMLib/LWMap.h	/^   LookupTable *wlt;     \/* word lookup table *\/$/;"	m	struct:__anon23
wm	HLMLib/LGBase.h	/^   WordMap *wm;             \/* word map to be used with this source *\/$/;"	m	struct:__anon3
wm	HLMLib/LGBase.h	/^   WordMap *wm;            \/* covering word map *\/$/;"	m	struct:__anon4
wm	HLMLib/LGBase.h	/^   WordMap *wm;            \/* word map for ngrams *\/$/;"	m	struct:__anon5
wmap	HLMLib/LCMap.h	/^   WordMap *wmap;	     	\/* associated word map *\/$/;"	m	struct:__anon1
wmap	HLMLib/LPCalc.h	/^   WordMap      *wmap;                \/* word map *\/$/;"	m	struct:__anon16
wmap	HLMTools/Cluster.c	/^static WordMap      wmap;                   \/* HTK word map *\/$/;"	v	file:
wmap	HLMTools/LAdapt.c	/^static WordMap    wmap;              \/* word map for this corpus *\/$/;"	v	file:
wmap	HLMTools/LBuild.c	/^static WordMap    wmap;$/;"	v	file:
wmap	HLMTools/LFoF.c	/^static WordMap    wmap;             \/* word map for this corpus *\/$/;"	v	file:
wmap	HLMTools/LGCopy.c	/^static WordMap    wmap;             \/* word map for this corpus *\/$/;"	v	file:
wmap	HLMTools/LGList.c	/^static  WordMap wmap;            \/* and the word map *\/$/;"	v	file:
wmap	HLMTools/LGPrep.c	/^static WordMap wmap;                \/* word map for this corpus *\/$/;"	v	file:
wmap	HLMTools/LSubset.c	/^static WordMap  wmap;            \/* the word map *\/$/;"	v	file:
wmapFN	HLMTools/LBuild.c	/^static char *wmapFN  = "wmap";      \/* output word map file name *\/$/;"	v	file:
wnHashTab	HTKLib/HNet.c	/^static NetNode *wnHashTab[WNHASHSIZE];$/;"	v	file:
wop	HTKTools/HDMan.c	/^   EdOp wop;                    \/* Used to apply UCWORD\/LCWORD before sorting inputs *\/$/;"	m	struct:__anon195	file:
word	HLMLib/LModel.h	/^   int *word;                \/* array of word counts *\/$/;"	m	struct:__anon15
word	HTKLVRec/HLVLM.h	/^   LMId word[NSIZE-1];          \/* Word history representing this entry *\/$/;"	m	struct:nentry
word	HTKLVRec/HLVLM.h	/^   PronId word;                 \/* _Pron_ id !! *\/$/;"	m	struct:_FSLM_LatArc
word	HTKLVRec/HLVLM.h	/^   PronId word;                 \/* _Pron_ id !! *\/$/;"	m	struct:sentry
word	HTKLVRec/HLVLM.h	/^   Word word;$/;"	m	struct:_FSLM_LatNode
word	HTKLib/HArc.h	/^  LabId word; $/;"	m	struct:_Arc
word	HTKLib/HDict.h	/^   Word word;      \/* Word this is a pronuciation of *\/$/;"	m	struct:_WordPron
word	HTKLib/HLM.h	/^   lmId word;                   \/* word id *\/$/;"	m	struct:sentry
word	HTKLib/HLM.h	/^   lmId word[NSIZE-1];          \/* Word history representing this entry *\/$/;"	m	struct:nentry
word	HTKLib/HNet.h	/^   Word word;          \/* Word represented by arc (labels may be on nodes) *\/$/;"	m	struct:lnode
word	HTKTools/HDMan.c	/^   LabId word;                  \/* a word + its pronunciations *\/$/;"	m	struct:__anon194	file:
word	HTKTools/HLStats.c	/^   unsigned short word[ASIZE];   \/* Bigram id *\/$/;"	m	struct:aentry	file:
wordBeam	HTKLib/HRec.h	/^   LogFloat wordBeam;       \/* Separte word end beam width *\/$/;"	m	struct:vrecinfo
wordBeam	HTKTools/HVite.c	/^static LogDouble wordBeam = -LZERO;\/* word-end pruning threshold *\/$/;"	v	file:
wordEndLayerId	HTKLVRec/HLVNet.h	/^   int wordEndLayerId;          \/* id of layer where token's time and score are copied to weHyp *\/$/;"	m	struct:_LexNet
wordHeap	HTKLib/HDict.h	/^   MemHeap wordHeap;    \/* for DictEntry structs  *\/$/;"	m	struct:__anon94
wordLoop	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon187	file:
wordMaxNode	HTKLib/HRec.c	/^   NetNode *wordMaxNode;    \/* Most likely word end node in network *\/$/;"	m	struct:precinfo	file:
wordMaxNode	HTKLib/HRec.h	/^   NetNode *wordMaxNode;    \/* Most likely word end node in network *\/$/;"	m	struct:vrecinfo
wordMaxTok	HTKLib/HRec.c	/^   Token wordMaxTok;        \/* Most likely word end token *\/$/;"	m	struct:precinfo	file:
wordMaxTok	HTKLib/HRec.h	/^   Token wordMaxTok;        \/* Most likely word end token *\/$/;"	m	struct:vrecinfo
wordName	HTKLib/HDict.h	/^   LabId wordName;  \/* word identifier *\/$/;"	m	struct:_DictEntry
wordNum	HTKTools/HBuild.c	/^   int wordNum;$/;"	m	struct:_GramEntry	file:
wordPair	HTKTools/HBuild.c	/^typedef enum {unknown, wordLoop, boBiGram, matBiGram, multiLat, wordPair} BuildType;$/;"	e	enum:__anon187	file:
wordPen	HTKTools/HLRescore.c	/^static LogDouble wordPen = 0.0; \/* inter word log penalty *\/$/;"	v	file:
wordPen	HTKTools/HVite.c	/^static LogDouble wordPen = 0.0;   \/* inter model propagation log prob *\/$/;"	v	file:
wordThresh	HTKLib/HRec.c	/^   LogFloat wordThresh;     \/* Cutoff for word end propagation *\/$/;"	m	struct:precinfo	file:
word_bits_	HTKLVRec/kenlm/lm/trie.hh	/^    uint8_t word_bits_;$/;"	m	class:lm::ngram::trie::BitPacked
word_list_	HTKLVRec/kenlm/lm/vocab.hh	/^    util::FakeOFStream word_list_;$/;"	m	class:lm::ngram::WriteUniqueWords
word_mask_	HTKLVRec/kenlm/lm/trie.hh	/^    uint64_t word_mask_;$/;"	m	class:lm::ngram::trie::BitPacked
wordinfo	HTKTools/HLStats.c	/^typedef struct wordinfo{         \/* Label Occurrence Counters *\/$/;"	s	file:
wordlist	HTKLVRec/HLVLM.h	/^   Word *wordlist;              \/* Lookup table for Words from LMId *\/$/;"	m	struct:_FSLM_ngram
wordmemcmp	HTKLVRec/kenlm/util/string_piece.hh	/^  static int wordmemcmp(const char* p, const char* p2, size_type N) {$/;"	f	class:StringPiece
wordnum	HLMTools/LGPrep.c	/^static int wordnum = 0;$/;"	v	file:
wordpen	HTKLib/HRec.c	/^   LogFloat wordpen;        \/* Word insertion penalty *\/$/;"	m	struct:precinfo	file:
words	HTKLVRec/kenlm/lm/state.hh	/^    WordIndex words[KENLM_MAX_ORDER - 1];$/;"	m	class:lm::ngram::State
words	HTKLVRec/kenlm/lm/wrappers/nplm.hh	/^  WordIndex words[NPLM_MAX_ORDER - 1];$/;"	m	struct:lm::np::State
wordsUsed	HTKTools/HDMan.c	/^   int wordsUsed;               \/* num words actually used *\/$/;"	m	struct:__anon195	file:
workers_	HTKLVRec/kenlm/util/thread_pool.hh	/^    boost::ptr_vector<Worker<Handler> > workers_;$/;"	m	class:util::ThreadPool
worstScore	HTKLVRec/HLVRec-misc.c	/^   TokScore worstScore;$/;"	m	struct:_LayerStats	file:
wpNet	HTKTools/HLRescore.c	/^static Lattice *wpNet;          \/* the word level recognition network *\/$/;"	v	file:
wpNetFile	HTKTools/HLRescore.c	/^static char *wpNetFile = NULL;  \/* word pair LM network filename *\/$/;"	v	file:
wptr	HLMLib/LUtil.h	/^   struct _NameHolder *wptr;   \/* equivalence class *\/$/;"	m	struct:_NameHolder	typeref:struct:_NameHolder::_NameHolder
writeLat	HTKTools/HLRescore.c	/^static Boolean writeLat = FALSE;    \/* -w *\/$/;"	v	file:
write_logfile	HLMTools/Cluster.c	/^static Boolean      write_logfile = TRUE;   \/* Write a log file during execution *\/$/;"	v	file:
write_method	HTKLVRec/kenlm/lm/config.hh	/^  WriteMethod write_method;$/;"	m	struct:lm::ngram::Config
write_method_	HTKLVRec/kenlm/lm/binary_format.hh	/^    const Config::WriteMethod write_method_;$/;"	m	class:lm::ngram::BinaryFormat
write_mmap	HTKLVRec/kenlm/lm/config.hh	/^  const char *write_mmap;$/;"	m	struct:lm::ngram::Config
write_mmap_	HTKLVRec/kenlm/lm/binary_format.hh	/^    const char *write_mmap_;$/;"	m	class:lm::ngram::BinaryFormat
write_to_	HTKLVRec/kenlm/lm/bhiksha.hh	/^    uint64_t *write_to_;$/;"	m	class:lm::ngram::trie::ArrayBhiksha
write_word_counts	HLMTools/Cluster.c	/^void write_word_counts(char *filename)$/;"	f
write_word_probs	HLMTools/Cluster.c	/^void write_word_probs(char *filename)$/;"	f
wsStack	HTKTools/HSmooth.c	/^static MemHeap wsStack;$/;"	v	file:
wtAccStack	HTKTools/HSmooth.c	/^static MemHeap wtAccStack;$/;"	v	file:
wtC	HTKLib/HTrain.c	/^static int muC,vaC,trC,wtC,prC;$/;"	v	file:
wtStore	HTKTools/HSmooth.c	/^static WALink ***wtStore;  \/* array [1..nPhyHmms][2..nStates-1][1..nStreams]$/;"	v	file:
wtab	HTKLib/HDict.h	/^   Word *wtab;          \/* hash table for DictEntry's *\/$/;"	m	struct:__anon94
wv	HTKTools/HCopy.c	/^static Wave wv;                 \/* main waveform; cat all input to this *\/$/;"	v	file:
x	HTKLib/HGraf.h	/^   int x, y, w, h;            \/* size of button rectangle *\/$/;"	m	struct:_HButton
x	HTKLib/HGraf.h	/^   int x,y;          \/* position of mouse *\/$/;"	m	struct:__anon103
x	HTKLib/HGraf.h	/^  short x, y;$/;"	m	struct:__anon104
x	HTKLib/HSigP.h	/^   Vector x;            \/* array[1..fftN] of fftchans *\/$/;"	m	struct:__anon159
x	HTKLib/HTrain.h	/^   MemHeap *x;     \/* memheap holding this set *\/$/;"	m	struct:__anon162
x	HTKTools/HSLab.c	/^   int x, y, w, h, bw;    \/* x-pos, y-pos, width, height, fg and bg colours *\/$/;"	m	struct:__anon212	file:
x	HTKTools/HSLab.c	/^   int x, y;$/;"	m	struct:__anon213	file:
xInfo	HTKLib/HParm.c	/^   Ptr xInfo;         \/* Application data *\/$/;"	m	struct:hparmsrcdef	file:
xKind	HTKLib/HAdapt.c	/^static XFormKind xKind     = MLLRMEAN;  \/* Transform Kind to be created *\/$/;"	v	file:
xMargin	HTKTools/HCopy.c	/^static HTime xMargin=0.0;       \/* margin to include around extracted labs *\/$/;"	v	file:
xc	HTKLib/HNet.h	/^   int xc;         \/* Number of cross word contexts *\/$/;"	m	struct:hmmsetcxtinfo
xf	HTKLib/HModel.h	/^   InputXForm *xf;         \/* Input transform of HMMSet *\/$/;"	m	struct:_HMMSet
xfInfo	HTKLVRec/HDecode.c	/^static XFInfo xfInfo;$/;"	v	file:
xfInfo	HTKLVRec/HDecode.mod.c	/^static XFInfo xfInfo;$/;"	v	file:
xfInfo	HTKTools/HERest.c	/^static XFInfo xfInfo;$/;"	v	file:
xfInfo	HTKTools/HMMIRest.c	/^static XFInfo xfInfo;$/;"	v	file:
xfInfo	HTKTools/HVite.c	/^static XFInfo xfInfo;$/;"	v	file:
xform	HTKLib/HMath.h	/^   SMatrix xform;       \/* if XFORMC *\/$/;"	m	union:__anon114
xform	HTKLib/HModel.h	/^  LinXForm *xform;     \/* actual transform to be applied *\/$/;"	m	struct:__anon134
xform	HTKLib/HModel.h	/^  SMatrix* xform;      \/* 1..numBlocks matrix transforms *\/$/;"	m	struct:__anon132
xform	HTKLib/HParm.c	/^   InputXForm *xform;$/;"	m	struct:__anon141	file:
xform	HTKLib/HParm.h	/^   Ptr xform;                 \/* Used for input xform associated with this buffer *\/$/;"	m	struct:__anon149
xformAdaptKind	HTKLib/HAdapt.c	/^static AdaptKind xformAdaptKind = BASE;$/;"	v	file:
xformBaseClass	HTKLib/HAdapt.c	/^static char *xformBaseClass = NULL;$/;"	v	file:
xformBlockSize	HTKLib/HAdapt.c	/^static IntVec xformBlockSize = NULL;$/;"	v	file:
xformDirNames	HTKLib/HModel.c	/^static XFDirLink xformDirNames = NULL;  \/* linked list of input transform directories *\/$/;"	v	file:
xformName	HTKLib/HModel.h	/^  char* xformName;                  \/* name of the transform (macroname) *\/$/;"	m	struct:_AdaptXForm
xformName	HTKLib/HModel.h	/^  char* xformName;     \/* name of the transform (macroname) *\/$/;"	m	struct:__anon134
xformRegTree	HTKLib/HAdapt.c	/^static char *xformRegTree = NULL;$/;"	v	file:
xformSet	HTKLib/HModel.h	/^  XFormSet  *xformSet;              \/* set of linear transforms *\/$/;"	m	struct:_AdaptXForm
xformSplitThresh	HTKLib/HAdapt.c	/^static float xformSplitThresh = -1000.0;$/;"	v	file:
xformStack	HTKLib/HModel.c	/^static MemHeap xformStack;              \/* For Storage of xforms with no model sets ... *\/$/;"	v	file:
xformTMF	HTKLib/HAdapt.h	/^  char *xformTMF;$/;"	m	struct:__anon89
xformWgts	HTKLib/HModel.h	/^  AdaptWgt  xformWgts;              \/* set of weights for all the base classes *\/$/;"	m	struct:_AdaptXForm
xforms	HTKLib/HModel.h	/^  LinXForm **xforms;   \/* 1..numTrans linear transforms *\/$/;"	m	struct:__anon133
xkind	HTKLib/HAdapt.c	/^   XFormKind xkind;$/;"	m	struct:__anon85	file:
xkind	HTKLib/HModel.h	/^  XFormKind xkind;     \/* transform kind (MLLRMEAN, CMLLR etc *\/$/;"	m	struct:__anon133
xlist	HTKTools/HLEd.c	/^static Context *xlist = NULL;$/;"	v	file:
y	HTKLib/HGraf.h	/^   int x, y, w, h;            \/* size of button rectangle *\/$/;"	m	struct:_HButton
y	HTKLib/HGraf.h	/^   int x,y;          \/* position of mouse *\/$/;"	m	struct:__anon103
y	HTKLib/HGraf.h	/^  short x, y;$/;"	m	struct:__anon104
y	HTKTools/HSLab.c	/^   int x, y, w, h, bw;    \/* x-pos, y-pos, width, height, fg and bg colours *\/$/;"	m	struct:__anon212	file:
y	HTKTools/HSLab.c	/^   int x, y;$/;"	m	struct:__anon213	file:
yes	HTKTools/HHEd.c	/^   struct _Node *yes;           \/* yes subtree *\/$/;"	m	struct:_Node	typeref:struct:_Node::_Node	file:
yes	HTKTools/HHEd.c	/^static AccSum yes,no;           \/* global accs for yes - no branches *\/$/;"	v	file:
zMeanSrc	HTKLib/HParm.c	/^   Boolean zMeanSrc;          \/* Zero Mean the Source *\/$/;"	m	struct:__anon141	file:
zapUnknown	HTKTools/HBuild.c	/^static Boolean zapUnknown = FALSE;  \/* zap unknown symbols from bigram *\/$/;"	v	file:
zero_buf	HTKLib/HAudio.c	/^static short zero_buf[BUF_SIZE];$/;"	v	file:
zero_f	HTKLVRec/kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon41::OldSanity	file:
zero_f	HTKLVRec/kenlm/lm/binary_format.cc	/^  float zero_f, one_f, minus_half_f;$/;"	m	struct:lm::ngram::__anon41::Sanity	file:
zoomLev	HTKTools/HSLab.c	/^static int zoomLev;                    \/* the current zoom level - ptr in the zoom record *\/$/;"	v	file:
zoomRec	HTKTools/HSLab.c	/^static ZoomRecord zoomRec[MAX_ZOOM];   \/* the zoom record *\/$/;"	v	file:
zot	HTKTools/HRest.c	/^static Vector zot;         \/* temp storage for zero mean obs vector *\/$/;"	v	file:
zsBeamWidth	HTKLVRec/HDecode.c	/^static LogFloat zsBeamWidth = - LZERO;   \/* pruning z-s beam width *\/$/;"	v	file:
zsBeamWidth	HTKLVRec/HDecode.mod.c	/^static LogFloat zsBeamWidth = - LZERO;   \/* pruning z-s beam width *\/$/;"	v	file:
zsBeamWidth	HTKLVRec/HLVRec.h	/^   TokScore zsBeamWidth;        \/* Z-S beam width (set by -v cmd line option) *\/$/;"	m	struct:_DecoderInst
~ARPAInputException	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^ARPAInputException::~ARPAInputException() throw() {}$/;"	f	class:lm::ARPAInputException
~ARPAOutputException	HTKLVRec/kenlm/lm/filter/arpa_io.cc	/^ARPAOutputException::~ARPAOutputException() throw() {}$/;"	f	class:lm::ARPAOutputException
~BZException	HTKLVRec/kenlm/util/read_compressed.cc	/^BZException::~BZException() throw() {}$/;"	f	class:util::BZException
~BZip	HTKLVRec/kenlm/util/read_compressed.cc	/^    ~BZip() {$/;"	f	class:util::__anon79::BZip
~BadDiscountException	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^BadDiscountException::~BadDiscountException() throw() {}$/;"	f	class:lm::builder::BadDiscountException
~BadSortConfig	HTKLVRec/kenlm/util/stream/sort.hh	/^    ~BadSortConfig() throw() {}$/;"	f	class:util::stream::BadSortConfig
~Callback	HTKLVRec/kenlm/lm/builder/interpolate.cc	/^    ~Callback() {$/;"	f	class:lm::builder::__anon46::Callback
~Chain	HTKLVRec/kenlm/util/stream/chain.cc	/^Chain::~Chain() {$/;"	f	class:util::stream::Chain
~ChainConfigException	HTKLVRec/kenlm/util/stream/chain.cc	/^ChainConfigException::~ChainConfigException() throw() {}$/;"	f	class:util::stream::ChainConfigException
~Closer	HTKLVRec/kenlm/lm/trie_sort.cc	/^    ~Closer() {$/;"	f	class:lm::ngram::trie::__anon61::Closer
~CompressedException	HTKLVRec/kenlm/util/read_compressed.cc	/^CompressedException::~CompressedException() throw() {}$/;"	f	class:util::CompressedException
~ConditionCommon	HTKLVRec/kenlm/lm/filter/phrase.cc	/^ConditionCommon::~ConditionCommon() {}$/;"	f	class:lm::phrase::detail::ConditionCommon
~ConfigException	HTKLVRec/kenlm/lm/lm_exception.cc	/^ConfigException::~ConfigException() throw() {}$/;"	f	class:lm::ConfigException
~EndOfFileException	HTKLVRec/kenlm/util/file.cc	/^EndOfFileException::~EndOfFileException() throw() {}$/;"	f	class:util::EndOfFileException
~EnumerateVocab	HTKLVRec/kenlm/lm/enumerate_vocab.hh	/^    virtual ~EnumerateVocab() {}$/;"	f	class:lm::EnumerateVocab
~ErrnoException	HTKLVRec/kenlm/util/exception.cc	/^ErrnoException::~ErrnoException() throw() {}$/;"	f	class:util::ErrnoException
~ErsatzProgress	HTKLVRec/kenlm/util/ersatz_progress.cc	/^ErsatzProgress::~ErsatzProgress() {$/;"	f	class:util::ErsatzProgress
~Exception	HTKLVRec/kenlm/util/exception.cc	/^Exception::~Exception() throw() {}$/;"	f	class:util::Exception
~FDException	HTKLVRec/kenlm/util/file.cc	/^FDException::~FDException() throw() {}$/;"	f	class:util::FDException
~FakeOFStream	HTKLVRec/kenlm/util/fake_ofstream.hh	/^    ~FakeOFStream() {$/;"	f	class:util::FakeOFStream
~FileOpenException	HTKLVRec/kenlm/util/exception.hh	/^    ~FileOpenException() throw() {}$/;"	f	class:util::FileOpenException
~FilePiece	HTKLVRec/kenlm/util/file_piece.cc	/^FilePiece::~FilePiece() {}$/;"	f	class:util::FilePiece
~FixedArray	HTKLVRec/kenlm/util/fixed_array.hh	/^    ~FixedArray() { clear(); }$/;"	f	class:util::FixedArray
~FormatLoadException	HTKLVRec/kenlm/lm/lm_exception.cc	/^FormatLoadException::~FormatLoadException() throw() {}$/;"	f	class:lm::FormatLoadException
~GZException	HTKLVRec/kenlm/util/read_compressed.cc	/^GZException::~GZException() throw() {}$/;"	f	class:util::GZException
~GZip	HTKLVRec/kenlm/util/read_compressed.cc	/^    ~GZip() {$/;"	f	class:util::__anon79::GZip
~Link	HTKLVRec/kenlm/util/stream/chain.cc	/^Link::~Link() {$/;"	f	class:util::stream::Link
~LoadException	HTKLVRec/kenlm/lm/lm_exception.cc	/^LoadException::~LoadException() throw() {}$/;"	f	class:lm::LoadException
~LowerRestBuild	HTKLVRec/kenlm/lm/value_build.cc	/^template <class Model> LowerRestBuild<Model>::~LowerRestBuild() {$/;"	f	class:lm::ngram::LowerRestBuild
~MallocException	HTKLVRec/kenlm/util/scoped.cc	/^MallocException::~MallocException() throw() {}$/;"	f	class:util::MallocException
~Model	HTKLVRec/kenlm/lm/virtual_interface.cc	/^Model::~Model() {}$/;"	f	class:lm::base::Model
~Model	HTKLVRec/kenlm/lm/wrappers/nplm.cc	/^Model::~Model() {}$/;"	f	class:lm::np::Model
~ModelFacade	HTKLVRec/kenlm/lm/facade.hh	/^    virtual ~ModelFacade() {}$/;"	f	class:lm::base::ModelFacade
~MultiProgress	HTKLVRec/kenlm/util/stream/multi_progress.cc	/^MultiProgress::~MultiProgress() {$/;"	f	class:util::stream::MultiProgress
~OutOfTokens	HTKLVRec/kenlm/util/tokenize_piece.hh	/^    ~OutOfTokens() throw() {}$/;"	f	class:util::OutOfTokens
~OutputHook	HTKLVRec/kenlm/lm/builder/output.cc	/^OutputHook::~OutputHook() {}$/;"	f	class:lm::builder::OutputHook
~OverflowException	HTKLVRec/kenlm/util/exception.cc	/^OverflowException::~OverflowException() throw() {}$/;"	f	class:util::OverflowException
~ParseNumberException	HTKLVRec/kenlm/util/file_piece.hh	/^    ~ParseNumberException() throw() {}$/;"	f	class:util::ParseNumberException
~Pool	HTKLVRec/kenlm/util/pool.cc	/^Pool::~Pool() {$/;"	f	class:util::Pool
~ProbingSizeException	HTKLVRec/kenlm/util/probing_hash_table.hh	/^    ~ProbingSizeException() throw() {}$/;"	f	class:util::ProbingSizeException
~ReadBase	HTKLVRec/kenlm/util/read_compressed.cc	/^    virtual ~ReadBase() {}$/;"	f	class:util::ReadBase
~ReadCompressed	HTKLVRec/kenlm/util/read_compressed.cc	/^ReadCompressed::~ReadCompressed() {}$/;"	f	class:util::ReadCompressed
~ReadSizeException	HTKLVRec/kenlm/util/stream/io.cc	/^ReadSizeException::~ReadSizeException() throw() {}$/;"	f	class:util::stream::ReadSizeException
~Semaphore	HTKLVRec/kenlm/util/pcqueue.hh	/^    ~Semaphore() {$/;"	f	class:util::Semaphore
~SpecialWordMissingException	HTKLVRec/kenlm/lm/lm_exception.cc	/^SpecialWordMissingException::~SpecialWordMissingException() throw() {}$/;"	f	class:lm::SpecialWordMissingException
~StatCollector	HTKLVRec/kenlm/lm/builder/adjust_counts.cc	/^    ~StatCollector() {}$/;"	f	class:lm::builder::__anon42::StatCollector
~StringBuilder	HTKLVRec/kenlm/util/double-conversion/utils.h	/^  ~StringBuilder() { if (!is_finalized()) Finalize(); }$/;"	f	class:double_conversion::StringBuilder
~Thread	HTKLVRec/kenlm/util/stream/chain.cc	/^Thread::~Thread() {$/;"	f	class:util::stream::Thread
~ThreadPool	HTKLVRec/kenlm/util/thread_pool.hh	/^    ~ThreadPool() {$/;"	f	class:util::ThreadPool
~TrieSearch	HTKLVRec/kenlm/lm/search_trie.hh	/^    ~TrieSearch() { FreeMiddles(); }$/;"	f	class:lm::ngram::trie::TrieSearch
~VocabLoadException	HTKLVRec/kenlm/lm/lm_exception.cc	/^VocabLoadException::~VocabLoadException() throw() {}$/;"	f	class:lm::VocabLoadException
~Vocabulary	HTKLVRec/kenlm/lm/virtual_interface.cc	/^Vocabulary::~Vocabulary() {}$/;"	f	class:lm::base::Vocabulary
~Vocabulary	HTKLVRec/kenlm/lm/wrappers/nplm.cc	/^Vocabulary::~Vocabulary() {}$/;"	f	class:lm::np::Vocabulary
~WriteWordsWrapper	HTKLVRec/kenlm/lm/vocab.cc	/^WriteWordsWrapper::~WriteWordsWrapper() {}$/;"	f	class:lm::ngram::WriteWordsWrapper
~Writer	HTKLVRec/kenlm/lm/builder/corpus_count.cc	/^    ~Writer() {$/;"	f	class:lm::builder::__anon43::Writer
~XZException	HTKLVRec/kenlm/util/read_compressed.cc	/^XZException::~XZException() throw() {}$/;"	f	class:util::XZException
~XZip	HTKLVRec/kenlm/util/read_compressed.cc	/^    ~XZip() {$/;"	f	class:util::__anon79::XZip
~scoped_base	HTKLVRec/kenlm/util/scoped.hh	/^    ~scoped_base() { Closer::Close(p_); }$/;"	f	class:util::scoped_base
~scoped_fd	HTKLVRec/kenlm/util/file.cc	/^scoped_fd::~scoped_fd() {$/;"	f	class:util::scoped_fd
~scoped_memory	HTKLVRec/kenlm/util/mmap.hh	/^    ~scoped_memory() { reset(); }$/;"	f	class:util::scoped_memory
~scoped_mmap	HTKLVRec/kenlm/util/mmap.cc	/^scoped_mmap::~scoped_mmap() {$/;"	f	class:util::scoped_mmap
